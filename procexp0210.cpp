/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

MACRO_TPC_E __stdcall FakeCopyStringA(char *szFileName, unsigned int nLength, char *szPathInfo);
BOOL __stdcall GetHhctrlocxPath(CHAR *szFileName); // idb
int __stdcall HtmpHelpImpl(int a1, int a2, int a3, int a4);
int sub_11F1200();
int sub_11F1230();
int sub_11F1240();
int sub_11F1260();
int sub_11F1270();
HCURSOR sub_11F1280();
int sub_11F12A0();
int sub_11F12C0();
int sub_11F12E0();
int sub_11F1300();
int sub_11F1320();
HCURSOR sub_11F1340();
int sub_11F1360();
int sub_11F1380();
int sub_11F13A0();
int sub_11F1420();
int sub_11F1440();
int sub_11F1460();
int sub_11F1480();
int sub_11F14A0();
int sub_11F14B0();
int sub_11F14C0();
int sub_11F14D0();
int sub_11F14F0();
int sub_11F1510();
__int16 sub_11F1530();
ATOM sub_11F1550();
BOOL sub_11F1560();
int sub_11F1590();
FARPROC sub_11F15B0();
FARPROC sub_11F15E0();
FARPROC sub_11F1610();
FARPROC sub_11F1640();
CAtlStringMgr *sub_11F1670();
int sub_11F1680();
FARPROC sub_11F16A0();
int sub_11F16C0();
HANDLE sub_11F16E0();
DWORD InitSysColors();
FARPROC EnableThemeDialogTextureLoader();
int sub_11F1D10();
int sub_11F1D30();
int sub_11F1D50();
int sub_11F1DE0();
BOOL sub_11F1E00();
int sub_11F1E30();
bool sub_11F1E50();
int sub_11F1E60();
int sub_11F1EA0();
int sub_11F1EE0();
int sub_11F1F20();
int sub_11F1F40();
int sub_11F1F60();
int sub_11F1F90();
int sub_11F1FC0();
int sub_11F1FF0();
int sub_11F2070();
int sub_11F2090();
int sub_11F20B0();
int sub_11F20D0();
int sub_11F20F0();
int sub_11F20FC();
int sub_11F2112();
int sub_11F211E();
int sub_11F212A();
int sub_11F2136();
int ATL::_dynamic_initializer_for___AtlBaseModule__();
_DWORD *__thiscall sub_11F2170(_DWORD *this);
void __thiscall sub_11F21A0(void ***this);
void __thiscall sub_11F21F0(void **this);
void **__thiscall sub_11F2250(void **this, const wchar_t **a2);
void **__thiscall sub_11F2280(void **this, wchar_t *a2);
int __cdecl sub_11F22B0(int, int, wchar_t *); // idb
void *__thiscall sub_11F2300(unsigned __int16 **this, void *a2, int a3, int a4);
void __cdecl sub_11F23D0(int a1, void *a2, void *a3);
void *__cdecl sub_11F2480(int a1, void *a2, wchar_t *psz, void *a4);
void __stdcall sub_11F2BC0(void **a1, void **a2);
int __cdecl sub_11F2BF0(int a1, int a2);
void __thiscall sub_11F2C60(int *this);
void __cdecl sub_11F2CB0(int a1, void *a2, void *a3, LPCWSTR lpValueName);
void *__cdecl sub_11F2D60(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, void *a5);
int __cdecl sub_11F3440(int a1, int a2, int a3);
wchar_t **__cdecl sub_11F34F0(const wchar_t **a1, const wchar_t **a2, wchar_t **a3);
_DWORD *__thiscall sub_11F3530(void *this, void *a2);
wchar_t ***__thiscall sub_11F35A0(wchar_t ***this, const wchar_t ***a2);
BSTR *__thiscall ConcatenateBSTR(Data_t *pThis, _bstr_t *pbstr1, _bstr_t *pbstr2); // idb
void __thiscall sub_11F3750(void *); // idb
CComBSTR **__thiscall bstr_t::EqualAssign(_bstr_t *ppv, OLECHAR *psz);
int __thiscall sub_11F3820(int this);
void __thiscall sub_11F3850(void *); // idb
void __thiscall bstr_t::Data_t::Free(Data_t *pData); // idb
int *__thiscall sub_11F38F0(int *this, const wchar_t ***a2);
int *__thiscall sub_11F3A50(int *this, int *a2);
BSTR **__thiscall bstr_t::Assign(_bstr_t *this, OLECHAR *psz); // idb
int __thiscall sub_11F3B40(int **this);
int __cdecl sub_11F3B50(int, OLECHAR *psz, int); // idb
CComBSTR ***__thiscall CComBSTR::AppendTail(_bstr_t *this, _bstr_t *ppComBSTR1, CComBSTR **ppComBSTR2); // idb
BOOL __thiscall sub_11F3C30(BSTR **this, BSTR **a2);
OLECHAR ***__thiscall bstr_t::Append(_bstr_t *ppComBSTR1, _bstr_t *pbstr); // idb
char __cdecl sub_11F3D40(int a1, const wchar_t **a2, OLECHAR **a3, OLECHAR **a4, OLECHAR **a5, const wchar_t **a6, void **a7, _DWORD *a8);
int __cdecl sub_11F3FF0(int, int, void *, int, int, int, int); // idb
int __cdecl sub_11F4130(HWND hWindow);
char sub_11F4650();
int __thiscall sub_11F4730(BSTR *this, BSTR *a2);
errno_t __cdecl sub_11F47C0(wchar_t *Src, wchar_t *Dst, rsize_t SizeInWords);
BOOL __cdecl TmAdjustPrivilege(LPCWSTR lpName);
int __cdecl sub_11F4890(int, wchar_t *); // idb
int __cdecl sub_11F4AC0(int, wchar_t *psz); // idb
PSID __cdecl InitializeSidFromText(LPCTSTR lpszText); // idb
signed int sub_11F4ED0();
int __cdecl sub_11F4EE0(int a1, int a2, int a3, int a4);
int __cdecl sub_11F4F20(int, int, wchar_t *); // idb
wchar_t **__cdecl sub_11F4FB0(int a1, int a2, void *a3);
int __cdecl sub_11F52B0(int, wchar_t *psz); // idb
int __cdecl sub_11F5520(int, wchar_t *psz, int); // idb
wchar_t *UpadteSystemPathInfo();
char __cdecl sub_11F5860(wchar_t **a1, __int16 a2, const wchar_t **a3, char a4);
FARPROC sub_11F5BB0();
int __cdecl sub_11F5C70(int, wchar_t *); // idb
int __thiscall sub_11F5DE0(int **this, int a2, OLECHAR *psz);
char __cdecl sub_11F5FD0(wchar_t *a1, wchar_t *a2);
char __cdecl sub_11F6090(wchar_t *psz);
char __cdecl sub_11F63B0(wchar_t *a1);
int __thiscall sub_11F6440(CComBSTR *this, int a2, CComBSTR *a3, int a4, OLECHAR *psz); // idb
HANDLE __stdcall sub_11F6640(OLECHAR *psz, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
CRYPT_PROVIDER_SGNR *__cdecl sub_11F6700(OLECHAR *psz, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_11F67A0(HKEY hKey, OLECHAR *pszKeyName, int Reserved, int dwFlags, HKEY *phSubKey); // idb
int __cdecl AdjustPrivilegeToWINLOGON();
char __cdecl sub_11F6CC0(wchar_t *a1, int a2);
void __cdecl sub_11F6DD0(wchar_t *a1, int a2, int a3, int a4);
void __cdecl sub_11F7040(wchar_t *a1, int a2);
wchar_t **__cdecl sub_11F70E0(wchar_t **a1, int a2, int a3, void *a4);
int __thiscall sub_11F7AB0(int **this, int a2, OLECHAR *psz);
int __cdecl sub_11F7AE0(DWORD dwMessageId); // idb
unsigned __int16 **__cdecl sub_11F7BE0(void *a1, void *a2, int a3, int a4);
void __cdecl sub_11F7CC0(HWND a1, HWND a2);
int __cdecl sub_11F84A0(int, wchar_t *); // idb
_bstr_t *__cdecl sub_11F85A0(_bstr_t *this, WCHAR *psz, int nPos, _bstr_t *ppv); // idb
void __cdecl sub_11F86F0(int a1, void *a2, void *a3);
void *__cdecl sub_11F87A0(int a1, void *a2, wchar_t *psz, void *a4);
void __cdecl sub_11F9030(void *a1, int a2, void *a3, wchar_t *a4);
void __cdecl sub_11F91C0(int a1, int a2, void *a3);
void *__cdecl sub_11F9270(int a1, int a2, wchar_t *psz, void *a4);
void __cdecl sub_11F9AB0(int a1, void *a2, void *a3, char a4, char a5);
void *__cdecl sub_11F9B70(int a1, void *a2, wchar_t *psz, char a4, char a5, void *a6, char a7, char a8);
void __cdecl sub_11FAA30(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, int a5);
void *__cdecl sub_11FAB10(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, int a5, void *a6);
void __cdecl sub_11FB220(void *a1, LPCTSTR a2); // idb
void __cdecl sub_11FF2D0(int a1, void *a2, int a3, char a4, char a5);
char __cdecl sub_11FF610(HWND hWnd, int a2, int a3);
int __cdecl sub_11FF8D0(int, wchar_t *); // idb
char __thiscall sub_11FF930(_DWORD *this, unsigned int a2);
_DWORD *sub_11FF9A0();
int __thiscall sub_11FF9D0(int *this, unsigned int a2, int a3);
_DWORD __stdcall nullsub_1(_DWORD, _DWORD); // weak
void __stdcall sub_11FFB40(void *a1);
BOOL __thiscall sub_11FFC40(void *this, int a2, int a3);
int *__thiscall sub_11FFD00(int *this, unsigned int a2);
const wchar_t **__thiscall sub_11FFDF0(const wchar_t ***this, unsigned int a2);
int *__thiscall sub_11FFEE0(int *this, unsigned int a2);
unsigned int __thiscall sub_11FFF60(int this, unsigned int a2);
void *__stdcall sub_11FFFE0(unsigned int a1);
int __thiscall sub_1200010(int *this);
int __thiscall sub_1200050(_DWORD *this, int a2, void *a3, int a4);
int __thiscall sub_1200110(void *this, int a2, void *a3);
UINT __thiscall sub_1200440(BSTR **this);
const wchar_t **__thiscall sub_1200460(int *this, const wchar_t **a2);
unsigned int __thiscall sub_1200530(_DWORD *this, const wchar_t **a2);
void *__cdecl sub_12005A0(int a1, void *a2, OLECHAR *psz, LPCWSTR lpValueName);
void *__cdecl sub_1200790(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, void *a5);
LPWSTR *__cdecl GetEnvironmentPathInfo(LPWSTR *ppsz, LPCWSTR lpSrc); // idb
HANDLE __cdecl sub_1200FC0(OLECHAR *psz, LPWIN32_FIND_DATAW lpFindFileData);
DWORD __cdecl sub_1201040(OLECHAR *psz);
DWORD_PTR __cdecl sub_12010C0(OLECHAR *psz, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
bool __cdecl sub_1201150(int a1, wchar_t *a2, wchar_t *psz, int a4);
LSTATUS __cdecl sub_12013D0(HKEY hKey, DWORD dwIndex, int a3);
LSTATUS __cdecl sub_1201450(HKEY hKey, DWORD dwIndex, int a3, LPDWORD lpReserved, LPDWORD lpType, int a6);
LSTATUS __cdecl sub_1201520(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, int a5);
LSTATUS __cdecl sub_12015A0(HKEY hKey, LPCWSTR lpSubKey, int a3);
void *__cdecl sub_1201610(int a1, void *a2, wchar_t *psz);
void *__cdecl sub_1202060(int a1, int a2, int *a3);
void *__cdecl sub_1202090(int a1, int a2, int a3, void *a4, char a5);
unsigned __int16 **__cdecl sub_1203070(unsigned __int16 **a1, const wchar_t **a2, void **a3);
void __cdecl sub_12030B0(int a1, void *a2, void *a3);
void *__cdecl sub_1203160(int a1, void *a2, wchar_t *psz, void *a4);
void __cdecl sub_12039D0(int a1, void *a2, void *a3);
void *__cdecl sub_1203A80(int a1, void *a2, wchar_t *psz, void *a4);
void __cdecl sub_1204150(int a1, void *a2, void *a3);
void *__cdecl sub_1204200(int a1, void *a2, wchar_t *psz, void *a4);
void *__cdecl sub_1204E10(int a1, void *a2, OLECHAR *psz);
void *__cdecl sub_1204FF0(int a1, void *a2, wchar_t *psz, void *a4, char a5);
void *__cdecl sub_1205E10(int a1, void *a2, OLECHAR *psz);
void *__cdecl sub_1205FF0(int a1, void *a2, wchar_t *a3, void *a4, char a5);
void *__cdecl sub_1206A10(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, wchar_t *a5, int a6, void *a7);
void *__cdecl sub_1206E10(int a1, void *a2, OLECHAR *psz, LPCWSTR lpValueName);
void *__cdecl sub_1207000(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, int a5);
void __cdecl sub_1207710(int a1, void *a2, void *a3);
void *__cdecl sub_12077C0(int a1, void *a2, wchar_t *psz, void *a4);
void __cdecl sub_1207FE0(int a1, void *a2, LPCTSTR a3); // idb
void *__cdecl sub_1208050(int a1, void *a2, wchar_t *psz, void *a4);
void __cdecl sub_1208A90(int a1, void *a2, int a3, int a4);
void *__cdecl sub_1208C20(int a1, void *a2, wchar_t *psz, void *a4, char a5, int a6);
char __cdecl sub_12093C0(LPCWSTR lpServiceName, int a2);
void *__cdecl sub_1209580(int a1, void *a2, wchar_t *psz);
void __cdecl sub_120A070(int a1, void *a2, void *a3);
void *__cdecl sub_120A120(int a1, void *a2, wchar_t *psz, void *a4);
_DWORD *__stdcall sub_120AC50(_DWORD *a1, _DWORD *a2, int a3);
_DWORD *__thiscall sub_120AC80(_DWORD *this, int a2);
BSTR **__thiscall sub_120AD20(BSTR **this, VARIANTARG *pvarSrc);
BSTR **__thiscall CComBSTR::AssignA(BSTR **this, LPCSTR lpString);
void __thiscall sub_120AE80(_DWORD *this);
int *__thiscall sub_120B0D0(_DWORD *this, int a2);
char __cdecl sub_120B1A0(int **a1, void **a2);
void *__cdecl sub_120D790(HWND a1);
BSTR **__cdecl sub_120E1B0(BSTR **a1, int a2);
BSTR **__cdecl sub_120E210(BSTR **a1);
_DWORD *__stdcall sub_120E320(_DWORD *a1, _DWORD *a2);
void __thiscall sub_120E360(_DWORD *this);
void *__cdecl sub_120E3A0(int a1, void *a2, wchar_t *a3, void *a4, char a5);
void *__cdecl sub_120EFA0(int a1, int a2, OLECHAR *psz, LPCWSTR lpValueName);
void *__cdecl sub_120EFE0(int a1, int a2, OLECHAR *psz, LPCWSTR lpValueName, void *a5, char a6);
void *__cdecl sub_120F0E0(int a1, wchar_t *a2, wchar_t *a3, void *a4, char a5);
int __cdecl sub_120F210(int, wchar_t *, int); // idb
void __cdecl sub_120F260(int a1, int a2, wchar_t *a3, void *a4, int a5);
void __cdecl sub_1210760(int a1);
void __cdecl sub_1210EA0(int a1);
wchar_t *__cdecl sub_12111B0(wchar_t *a1, int a2, wchar_t *a3);
int __cdecl sub_1211290(wchar_t *, int); // idb
CSysProcItem *__thiscall sub_1211310(_DWORD *this, int *a2);
_DWORD *__thiscall sub_1211350(_DWORD *this);
void __thiscall sub_12113D0(_DWORD *this);
CSysProcItem *__thiscall sub_1211450(CSysProcItem *this);
bool __stdcall sub_12114B0(void *a1, void *a2);
void __cdecl sub_1211590(char a1, int a2, OLECHAR *a3, OLECHAR *a4, OLECHAR *psz, int a6);
CSysProcItem *__cdecl std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
CMapNode *__thiscall CMapNode::NewNode_0(CMapNode *this);
_DWORD *__thiscall sub_12117F0(int **this, _DWORD *a2);
void *__cdecl sub_1211840(int a1);
void *__cdecl sub_1211860(int a1, void *a2, char a3);
void __cdecl sub_1212060(int a1, void *a2, void *a3);
void *__cdecl sub_1212110(int a1, void *a2, wchar_t *psz, void *a4);
void __cdecl sub_12127D0(int a1, OLECHAR *psz);
void __cdecl sub_1213190(int a1, OLECHAR *psz);
_DWORD *__thiscall sub_1213B60(_DWORD *this, int a2, _DWORD **a3, int a4);
CSysProcItem *__thiscall sub_1213BA0(_DWORD *this, int a2, const wchar_t ***a3, int a4);
int __thiscall sub_1213BE0(_DWORD *this, int a2, char a3, int a4, int a5, void *a6);
int __thiscall sub_1213E00(_DWORD *this, int a2, char a3, int a4, int a5, void *a6);
int __thiscall sub_1214040(_DWORD *this, int a2, int a3, int a4, void *a5);
int __thiscall sub_1214270(_DWORD *this, int a2, int a3, int a4, void *a5);
int __thiscall sub_12144A0(_DWORD *this, int a2, int a3, int a4, void *a5);
int __thiscall sub_12145C0(_DWORD *this, int a2, int a3, int a4, void *a5);
void **__cdecl sub_1214700(const wchar_t **a1, const wchar_t **a2, void **a3);
void *__thiscall sub_1214740(void *this);
void *__thiscall sub_1214830(void *this);
_DWORD *__thiscall sub_1214920(_DWORD *this, int a2, OLECHAR *psz);
volatile LONG *__thiscall sub_1214A70(volatile LONG *this, volatile LONG a2);
void __thiscall sub_1214B00(void **this);
void **__thiscall sub_1214B60(void **this, void **a2);
_DWORD *__thiscall sub_1214BC0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_1214C50(_DWORD *this, _DWORD *a2);
CMapNode *__thiscall sub_1214CE0(CMapNode *this);
void *__thiscall sub_1214D30(void *this, char a2);
void sub_1214D60();
int __cdecl sub_1214DA0(int, LPVOID *ppv); // idb
int __thiscall sub_1214E20(LPVOID lpParameter, LPVOID *ppv); // idb
void *__cdecl sub_1214FE0(int a1, void *a2);
int __cdecl sub_1215120(int a1, int a2);
char __stdcall sub_1215350(int a1, void *a2, int a3);
bool __stdcall sub_1215440(int a1, void *a2, void *a3);
int __cdecl sub_12155B0(const wchar_t **a1);
char __thiscall sub_1215630(void *this, int a2, int a3, void **a4);
char __thiscall sub_12156B0(void *this, int a2, int a3, void **a4);
int __cdecl sub_1215730(LPVOID ppv, int, OLECHAR *psz, void *); // idb
int __cdecl sub_1215850(LPVOID ppv, wchar_t *psz, int); // idb
wchar_t **__stdcall sub_1215910(wchar_t **a1, int a2);
int __stdcall sub_1215940(int, void *); // idb
char __stdcall sub_1215A00(void *a1, int a2, int a3);
char __stdcall sub_1215AA0(int a1, int a2, int a3);
int __cdecl sub_1215AB0(int, int, OLECHAR *psz); // idb
int __cdecl sub_1215BE0(LPVOID *ppv, wchar_t *); // idb
bool __stdcall sub_1215C50(void *a1, int a2);
void __thiscall sub_1215CB0(void *this);
void __cdecl sub_1215D10(int a1);
CMapNode *__cdecl sub_1216830(int a1, int a2, LPVOID ppv, int a4, int a5);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
_DWORD *__thiscall sub_1216B70(_DWORD *this);
_DWORD *__thiscall sub_1216BB0(_DWORD *this, int a2, size_t a3);
void __stdcall sub_1216D00(void *a1);
void __stdcall sub_1216D40(void *a1);
void __stdcall sub_1216D60(void *a1);
void __stdcall sub_1216DC0(void *a1);
BOOL __thiscall sub_1216E00(void *this, size_t a2, int a3);
void *__stdcall sub_1216EC0(size_t a1);
_DWORD *__thiscall sub_1216F00(_DWORD *this, int a2, int a3, size_t a4);
_DWORD *__thiscall sub_1217030(int this, void *a2, size_t a3);
int *__stdcall sub_1217130(int *a1, int a2);
bool __thiscall sub_1217190(void *this, _DWORD *a2, int a3);
bool __thiscall sub_12171B0(void *this, int a2, _DWORD *a3);
int __thiscall sub_12171F0(_DWORD *this, int a2, void *a3, int a4);
int __thiscall sub_12172B0(void *this, int a2, void *a3);
int *__thiscall sub_1217560(int **this, int *a2, int **a3, int **a4);
_DWORD *__thiscall sub_1217620(int **this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_1217890(_DWORD *this, unsigned int a2, unsigned int a3);
int __stdcall sub_1217930(int a1, int a2);
int __stdcall sub_12179A0(int a1, int a2);
int __stdcall sub_12179F0(int a1, int a2);
const char *sub_1217A60();
const char *sub_1217A70();
const char *sub_1217A80();
_DWORD __stdcall nullsub_2(_DWORD); // weak
int stprintf(wchar_t *szLog, wchar_t *Format, ...); // idb
_DWORD *__thiscall sub_1217AC0(_DWORD *this, const __m128i *a2, __int16 a3, __int16 a4, char a5);
_DWORD **__cdecl sub_1217B60(int a1, OLECHAR *psz, int a3, int a4);
int *__thiscall sub_1217C40(_DWORD *this, _DWORD **a2);
LONG __cdecl sub_1217CE0(int a1);
int *__thiscall sub_1217D50(_DWORD *this, const __m128i *a2, unsigned __int16 a3, char a4, __int16 a5);
// signed int __usercall sub_1218250@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4);
int *__thiscall sub_1218730(_DWORD *this, const __m128i *a2, __int16 a3, __int16 a4, char a5);
int *__thiscall sub_1218970(_DWORD *this, int a2, const __m128i *a3, unsigned __int16 a4, char a5, __int16 a6);
int __cdecl sub_12192A0(wchar_t *Dst, size_t SizeInWords, int); // idb
HRESULT __cdecl sub_12192F0(IUnknown **a1);
_DWORD *__thiscall sub_1219380(_DWORD **this, _DWORD *a2);
_WORD *__thiscall sub_12193D0(_WORD *this, OLECHAR *psz);
// int __usercall sub_1219410@<eax>(int a1@<esi>, int a2, int a3, int a4);
// HRESULT __usercall sub_12194A0@<eax>(int a1@<esi>, int a2, int a3);
// int __usercall sub_1219580@<eax>(int a1@<esi>, OLECHAR *psz, LPCWSTR lpParameters, OLECHAR *a4);
_DWORD *__cdecl sub_1219700(_DWORD *a1, char a2, _DWORD *a3, unsigned int *a4, int a5, int a6);
CRYPT_PROVIDER_SGNR *__cdecl sub_1219930(void *a1, int a2, char a3, BYTE *a4, DWORD a5, void *a6, int a7, int a8);
CRYPT_PROVIDER_SGNR *__cdecl sub_1219A40(int a1, char a2, int a3, int a4, void *a5, int a6, int a7, int a8);
CRYPT_PROVIDER_SGNR *__cdecl sub_1219BB0(const WCHAR *a1, int a2, void **a3, char a4, _DWORD *a5, unsigned int *a6, int a7, int a8, int a9, int a10, int a11, wchar_t **a12, int a13);
bool LoadWintrust();
CTreeList *__thiscall CTreeList::CTreeList(CTreeList *this);
void *__thiscall sub_121A1F0(_DWORD *this);
void __thiscall sub_121A2C0(_DWORD *this);
BSTR **__thiscall sub_121A320(BSTR **this, LPCSTR lpString);
BOOL __thiscall sub_121A3E0(BSTR **this, BSTR **a2);
void *__thiscall sub_121A460(void *this, char a2);
HWND __cdecl CreateTreeListView(HWND hWndParent, HINSTANCE hInstance, HMENU hMenu, int dwStyle, LPRECT rc); // idb
HWND __stdcall CTreeList::CreateTooltip(HINSTANCE hInstance, HWND hWndParent);
int __cdecl CThemedWindow::GetWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT __thiscall sub_121A5C0(_DWORD *this, _DWORD *a2);
LRESULT __thiscall CTreeList::Close(CTreeList *pTreeList); // idb
bool __thiscall CTreeList::DeleteColumn(CTreeList *this, WPARAM wParam); // idb
void __thiscall sub_121A7D0(CTreeList *pTreeList, void *a2); // idb
signed int __thiscall sub_121A8E0(_DWORD *this);
void __thiscall CTreeList::DrawHeaderItem(CTreeList *pTreeList, int a2, HDC hDCInit, RECT rect); // idb
LRESULT __thiscall sub_121AE40(_DWORD *this, HWND hWnd, int a3, int a4, int a5, int a6, int a7);
void __thiscall sub_121AEC0(CTreeList *this, HDC *hdc, HRGN hRgn); // idb
HGDIOBJ __thiscall sub_121BC20(CTreeList *this, int a2, HDC hdc, char a4, LPRECT lprc); // idb
char __thiscall sub_121BDA0(CTreeList *this, char a2); // idb
void __thiscall CTreeList::RestoreScrollbars(CTreeList *this, char yyy); // idb
UINT __thiscall CTreeList::EnsureVisible(HWND *this, signed int a2);
char __thiscall sub_121BF00(int this, _DWORD *a2, char a3);
signed int __thiscall sub_121BFE0(CTreeList **this, CTreeList *a2); // idb
HANDLE __cdecl GetTreeListCtrl(HWND hWnd);
int __thiscall sub_121C080(_DWORD *this, int a2);
char __thiscall CTreeList::GetSubItemRect(CTreeList *pTreeList, int a2, int iItem, char a4, char a5, int a6, RECT *lprc); // idb
int __thiscall sub_121C420(_DWORD *this);
BOOL __thiscall CTreeList::GetItemWidth(CTreeList *this, WPARAM nItem, RECT *lprc); // idb
int __thiscall CTreeList::GetTooltipRightHeader(CTreeList *this); // idb
int __thiscall sub_121C4A0(_DWORD *this, _DWORD *a2, int *a3);
int __stdcall sub_121C530(int a1, int a2);
int __thiscall CTreeList::GetImageIcon(CTreeList *this); // idb
char __thiscall CTreeList::GetItemRect(CTreeList *pTreeList, int nPos, RECT *lprc); // idb
int __thiscall CTreeList::GetItemCount(CTreeList *this); // idb
int __thiscall CTreeList::GetScrollInfo(CTreeList *this, SCROLLINFO *pScrollInfo1, SCROLLINFO *pScrollInfo2); // idb
signed int __thiscall CTreeList::FindFirstSortableColumn(CTreeList *this, bool *Sortable); // idb
LPWSTR __thiscall sub_121C980(CListViewData *this, CTreeList **ppTreeList, int nColumn, TCHAR *szText, int *cbText); // idb
const wchar_t *__stdcall sub_121CA20(int a1, int a2, int a3, int a4);
const wchar_t *CTreeList::GetTitle();
int __thiscall CTreeList::GetTooltipTreeList(CTreeList *this); // idb
int __thiscall sub_121CA50(void *this);
int __thiscall sub_121CA60(_DWORD *this);
LRESULT __thiscall CTreeList::HeaderCtrlWndProc(CTreeList *this, HWND hWnd, UINT msg, WPARAM wParam, NMTTDISPINFOW *lParam); // idb
signed int __thiscall sub_121CDB0(CTreeList *this, LONG xx, LONG yy, POINT *pt1, POINT *pt2, _DWORD *a6); // idb
void __thiscall CTreeList::Scroll(CTreeList *this, HWND hWnd, int delta);
void __thiscall sub_121D2A0(_DWORD *this, HWND hwnd, int a3);
void __thiscall sub_121D310(void *this, int a2, int a3);
char __thiscall CTreeList::Init(CTreeList *pTreeList); // idb
CTreeData *__thiscall sub_121D640(void *this, CTreeList *pTreeList, CTreeListData *pTreeListData, BOOL fFlags, int uID); // idb
char __thiscall sub_121D750(void *this, int a2, int a3);
CTreeList *__thiscall sub_121D7E0(CTreeList *pTreeList, int a2, void *pTreeListData, BOOL fFlags, int uID);
void __thiscall sub_121D830(int this, int a2, int a3);
bool __thiscall sub_121D980(_DWORD *this, int a2);
_DWORD *__thiscall sub_121DA70(_DWORD *this, int a2);
int __thiscall CTreeList::GetHeaderHeight(CTreeList *this); // idb
int __cdecl sub_121DBA0(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_121DBC0(int a1, int a2, int (__stdcall *a3)(_DWORD, _DWORD, int), int a4);
HWND __thiscall CTreeList::HandleLVMessage(CTreeList *pTreeList, HWND hWnd, UINT Msg, WPARAM wParam, NMLISTVIEW *lParam); // idb
int __stdcall sub_121E5D0(void *pInfo); // idb
CTreeList *__thiscall sub_121E5E0(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_121E650(_DWORD *this);
int __thiscall sub_121E690(_DWORD *this, HWND hWnd, LPARAM a3);
BOOL __thiscall sub_121E900(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, const __m128i *a6);
char __stdcall sub_121E9C0(int a1, int a2, int a3, int a4, int a5);
int __thiscall sub_121E9D0(_DWORD *this);
LRESULT __thiscall sub_121EA10(HWND *this);
BOOL __thiscall sub_121EA60(HWND *this, int a2);
void __thiscall sub_121EAD0(_DWORD *this, _DWORD *a2);
void __thiscall CTreeList::RedrawItems(CTreeList *this, int a2, int a3); // idb
ATOM RegisterTreeListCtrl();
LRESULT __thiscall sub_121EC50(CTreeList *this); // idb
LRESULT __thiscall CTreeList::SetHeaderWidth(CTreeList *this, int width); // idb
void __thiscall sub_121EF00(CTreeList *this);
void __thiscall sub_121EFD0(int this);
void __thiscall sub_121F090(_DWORD *this, _DWORD *a2);
LRESULT __thiscall sub_121F110(HWND *this, int a2, int a3);
int __stdcall sub_121F160(int a1, char a2);
LRESULT __thiscall CTreeList::SetSortImgList(CTreeList *this, LPARAM hImg, int a3, int a4); // idb
char __thiscall CTreeList::SetImageList(CTreeList *this, int hImageList, char a3); // idb
int __thiscall sub_121F210(CTreeList *this, int Height); // idb
// void __thiscall CTreeList::SetSplitterCursor(CTreeList *this, void *a2); idb
int __thiscall sub_121F230(CTreeList *this, int a2); // idb
BOOL __thiscall sub_121F240(HWND *this, char a2);
bool __thiscall CTreeList::AutoSize(CTreeList *this, HWND hWndScrollbar, char bFlags1, char bFlags2); // idb
bool __thiscall sub_121F400(HWND *this, char a2, char a3);
unsigned int __cdecl sub_121F500(unsigned int *a1, unsigned int a2, int (__cdecl *a3)(_DWORD, _DWORD, int, int), int a4, int a5, int a6);
LRESULT __stdcall TreeListHeaderWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall TreeListTooltipWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int *__stdcall TreeListWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LVITEMUSERDATA2 *__thiscall sub_121F6C0(CTreeList *pTreeList); // idb
int __thiscall CTreeList::GetVertScrollPosition(CTreeList *this); // idb
bool __thiscall CTreeList::SetSortableColumn(CTreeList *this, HWND ProcessSortColumn, char bProcessSortDirection); // idb
LRESULT __thiscall sub_121F8F0(CTreeList *pTreeList, HWND hWnd, POINT *pt); // idb
unsigned int __thiscall CTreeList::VScroll(CTreeList *this, int Delta); // idb
unsigned int __thiscall CTreeList::VScrollToPos(CTreeList *this, int pos); // idb
int *__thiscall CTreeList::HandleMessage(CTreeList *pTreeList, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); // idb
CSysProcItem *__thiscall sub_12211F0(_DWORD *this, int *a2);
int __thiscall sub_1221240(int *this, int a2, int a3, int a4, void *a5);
int wsprintf(wchar_t *Dst, wchar_t *Format, ...);
void __thiscall sub_1221400(int **this);
void __thiscall sub_1221430(int *this);
int __cdecl sub_12214F0(int, LPCSTR lpString, int); // idb
int __stdcall CHttp::CHttp(HWND hWnd, OLECHAR *lpszCaption, char, char, LPCTSTR lpszDescription);
int __stdcall sub_12218A0(int, FILETIME *lpFileTime); // idb
int __stdcall sub_1221BC0(int, OLECHAR *psz); // idb
DWORD __thiscall sub_1221FC0(CHttp *this); // idb
CComBSTR *__thiscall sub_12237E0(_DWORD *this);
int __stdcall sub_1224320(int, DWORD dwMessageId); // idb
DWORD __stdcall sub_1224420(void *a1, int a2, int a3);
BSTR **__thiscall sub_1224530(void *this, int a2, OLECHAR psz, int a4);
int __stdcall sub_1224810(int, OLECHAR *psz, __int16); // idb
CComBSTR **__stdcall sub_1224950(int a1, int a2, void *a3);
DWORD __stdcall CHttp::ReadData(HINTERNET hRequest, CComBSTR *ppComBSTR);
int __stdcall CHttp::RequestHeader(HINTERNET hRequest, int, DWORD dwInfoLevel, int); // idb
int __stdcall sub_1224D50(void *); // idb
DWORD __thiscall CHttp::Open(CHttp *this, int a2, OLECHAR *psz, char a4, char a5, char a6); // idb
DWORD __thiscall sub_1224F00(HINTERNET *this, void *a2, void *a3, void *a4, int a5);
_DWORD *__thiscall sub_1225160(_DWORD *this, char a2);
char __thiscall LoadGlobalVariablesFromRegistry(CRegStr *bstrKey, GLOBALVAR *pGlobalVar);
// LSTATUS __userpurge CReyKey::ReadInts@<eax>(LPCTSTR szKeyName, int Size, LPBYTE lpData);
int __thiscall CReg::ReadWidth(CRegStr *this, LPCTSTR lpszName, BYTE *pnValue, int nDefValue);
int __stdcall CReg::ReadWidthArray(LPCWSTR lpSubKey, int Size, void *pBuffer);
DWORD __thiscall CHttp::Requery(CHttp *pMainHttp, CComBSTR **ppComBSTR2, CComBSTR *psz); // idb
LSTATUS __thiscall SaveGlobalVariable(CComBSTR *this, GLOBALVAR *pVariable); // idb
LSTATUS __thiscall SaveIntValueVectorToRegistry(HKEY *this, LPCWSTR lpSubKey, int a3, BYTE *lpData);
LSTATUS __thiscall sub_1226430(HKEY *this, LPCWSTR lpSubKey, int a3, int a4);
void __stdcall sub_1226500(void *a1);
int *__thiscall sub_1226540(int **this, int *a2, int **a3, int **a4);
_DWORD *__thiscall sub_1226600(int **this, _DWORD *a2, _DWORD *a3);
unsigned int __cdecl StrCpy(WCHAR *pBuffer, WCHAR *pszText); // idb
HBRUSH __stdcall UserProtocolDialogFunc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam_1); // idb
_BYTE *sub_1226A40();
BOOL __cdecl sub_1226AE0(HKEY hKey, LPCWSTR lpSubKey);
BOOL __cdecl sub_1226B60(int a1);
signed int sub_1226C00();
signed int OSIsNanoServer();
BOOL __cdecl sub_1226D40(HWND a1);
BOOL __cdecl sub_1226F60(TCHAR *strTitle, int *argc, TCHAR **argv); // idb
signed int sub_1227020();
void __noreturn sub_1227080();
BOOL __cdecl sub_12270B0(LPARAM dwInitParam, BYTE Data);
BOOL __cdecl sub_1227390(TCHAR *a1, _DWORD *a2, int a3); // idb
int __stdcall sub_1227910(int, void *, int, int); // idb
int __cdecl OnTreeListNotify7D2();
LRESULT __cdecl sub_1227960(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam);
int __cdecl EndDialogOK(HWND hDlg); // idb
HBRUSH __stdcall AboutOrSymbolConfigWarningProc(HWND hDlg, UINT Msg, WPARAM hdc, LPARAM lParam);
int __cdecl OnAbout(HWND hWndParent); // idb
char *__cdecl sub_1227DF0(char *a1, const unsigned __int16 *a2);
struct std::_Facet_base *__cdecl sub_1228150(int *a1);
_DWORD *__thiscall sub_1228270(_DWORD *this);
char *__thiscall sub_1228300(char *this, int a2, int a3);
struct std::_Locinfo *__thiscall sub_1228360(struct std::_Locinfo *this, char *a2);
std::exception *__thiscall sub_1228420(std::exception *this, int a2, int a3, int a4);
std::exception *__thiscall sub_12284F0(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_1228520(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_1228550(std::exception *this, struct exception *a2);
_DWORD *__thiscall sub_1228570(_DWORD *this, int a2);
std::exception *__thiscall sub_1228600(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_1228630(std::exception *this, int a2, int a3, void *a4);
int __thiscall sub_12287D0(_DWORD *this);
int __thiscall sub_1228880(std::_Lockit *this); // idb
// _DWORD __thiscall sub_1228940(std::locale *__hidden this); idb
void __thiscall sub_1228990(_DWORD *this);
void __fastcall sub_1228A1C(unsigned int a1, int a2, int a3);
void __fastcall sub_1228A24(unsigned int a1, int a2, int a3);
char *__thiscall sub_1228A2C(_DWORD *this, char a2);
void *__thiscall sub_1228B10(void *this, char a2);
_DWORD *__thiscall sub_1228B60(void *this, char a2);
_DWORD *__thiscall sub_1228BC0(struct std::ios_base *this, char a2);
void **__thiscall sub_1228C00(void *this, char a2);
void *__thiscall sub_1228C50(void *this, char a2);
struct std::ios_base *__thiscall sub_1228C80(struct std::ios_base *this, char a2);
void *__thiscall sub_1228CB0(void *this, char a2);
void __cdecl sub_1228CE0(int a1, int a2, wchar_t *a3);
int __cdecl sub_1229000(int a1, int a2, int a3, int a4);
volatile signed __int32 *__thiscall sub_1229070(volatile signed __int32 *this);
signed int __cdecl sub_1229090(char **a1, int *a2);
__int64 __thiscall sub_1229140(_DWORD **this);
signed __int32 __thiscall sub_1229160(volatile signed __int32 *this);
struct std::locale::_Locimp *__thiscall sub_1229170(_DWORD *this);
void *__cdecl sub_12291F0(void *a1, char a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __thiscall sub_12292D0(_DWORD *this);
__int64 __thiscall sub_1229400(_DWORD **this);
_DWORD *__thiscall sub_1229420(int this);
_DWORD *__thiscall sub_1229490(void *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_1229550(void *this, void *a2, size_t a3);
int *__thiscall sub_1229640(int *this, int *a2, unsigned int a3, unsigned int a4);
int *__thiscall sub_1229760(int *this, void *a2, int a3);
int __thiscall sub_1229860(_DWORD *this, char a2);
BOOL __stdcall sub_1229900(__int16 a1, WCHAR SrcStr);
char __thiscall sub_1229930(const _Cvtvec *this, wchar_t a2, int a3);
wchar_t *__thiscall sub_1229980(const _Cvtvec *this, wchar_t *a2, unsigned int a3, char a4, int a5);
unsigned __int16 *__thiscall sub_1229A20(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4);
unsigned __int16 *__thiscall sub_1229A60(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4);
int __thiscall sub_1229AA0(void *this, wchar_t Src);
wchar_t *__thiscall sub_1229AC0(char *this, wchar_t *a2, unsigned int a3);
int __thiscall sub_1229B10(void *this, wchar_t Src);
wchar_t *__thiscall sub_1229B30(char *this, wchar_t *a2, unsigned int a3);
wchar_t __thiscall sub_1229B80(const _Cvtvec *this, char a2);
char *__thiscall sub_1229BD0(const _Cvtvec *this, wchar_t a2, char a3, mbstate_t a4);
_DWORD *__thiscall sub_1229C60(_DWORD *this, unsigned int a2, unsigned int a3);
char *__thiscall sub_1229D10(char *this);
int *__thiscall sub_1229E40(_DWORD *this, int *a2);
void __thiscall sub_1229E70(struct std::ios_base *this, int a2, char a3);
int __thiscall sub_1229F90(_DWORD **this, int a2);
__int16 __thiscall sub_1229FC0(_DWORD *this, __int16 a2);
signed int __stdcall sub_122A1E0(int a1);
signed __int16 __thiscall sub_122A1F0(int this, __int16 a2);
_DWORD *__stdcall sub_122A260(_DWORD *a1, int a2, int a3, int a4, int a5);
signed int *__thiscall sub_122A290(int this, signed int *a2, __int64 a3, int a4, char a5);
_DWORD *__stdcall sub_122A480(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int *__thiscall sub_122A4B0(int this, signed int *a2, __int64 a3, __int64 a4, int a5, int a6, char a7);
void *__thiscall sub_122A600(void *this, int a2, int a3, int a4);
__int64 sub_122A610();
void *__thiscall sub_122A620(_DWORD *this, void *a2);
void *__thiscall sub_122A6E0(_DWORD *this, void *a2);
signed int __thiscall sub_122A700(_DWORD **this);
signed int sub_122A730();
signed __int16 __thiscall sub_122A740(int this);
unsigned int __thiscall sub_122A7B0(_DWORD **this, void *a2, int a3, int a4);
unsigned int __thiscall sub_122A8C0(_DWORD **this, void *a2, int a3, int a4);
void *__thiscall CObjSecurity::`scalar deleting destructor'(void *this, char a2);
int __cdecl sub_122AA10(int a1);
int __cdecl sub_122AA20(int, int, int, int, int);
int __stdcall sub_122AA90(int a1);
int __stdcall sub_122AAB0(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
int __stdcall sub_122ABB0(int a1, _DWORD *a2, _DWORD *a3);
int __stdcall sub_122ABD0(int, int);
int __stdcall sub_122AC00(CObjSecurity *a1, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, int a4); // idb
int __stdcall sub_122ACB0(CObjSecurity *a1, int a2, void *pServiceMgr, int a4, wchar_t *Src, int a6, int a7);
int __cdecl sub_122ACF0(int, wchar_t *Src); // idb
int __stdcall sub_122AD60(int, int, int, PDWORD AccessMask); // idb
int __stdcall sub_122ADD0(int a1, int a2, int a3, int a4);
int __stdcall sub_122ADE0(GUID *a1, int a2, int ppv);
int __stdcall sub_122AE60(_DWORD *a1);
int __stdcall sub_122AE80(int, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor); // idb
int __thiscall sub_122AEE0(_DWORD *this, int a2, char a3, int a4, int a5, void *a6);
int __thiscall sub_122B100(_DWORD *this, int a2, int a3, int a4, void *a5);
void **__thiscall sub_122B2D0(void **this, void *Src);
_DWORD *__thiscall sub_122B3A0(_DWORD *this);
void *__thiscall ATL::CAtlStringMgr::Clone(void *this);
volatile signed __int32 *__thiscall sub_122B3E0(_DWORD *this);
int __cdecl sub_122B460(int, int, void *); // idb
void *__thiscall ATL::CAtlStringMgr::`scalar deleting destructor'(void *this, char a2);
void *__thiscall ATL::CWin32Help::`scalar deleting destructor'(void *this, char a2);
_DWORD *__thiscall ATL::CAtlStringMgr::Allocate(int (__stdcall ****this)(_DWORD), int a2, unsigned int a3);
LPVOID __thiscall ATL::CWin32Heap::Allocate(HANDLE *this, SIZE_T dwBytes);
int __cdecl sub_122B650(int a1);
HMODULE __cdecl AtlGetStringResourceImage(int a1, WORD wLanguage);
void __cdecl __noreturn AtlThrow(int a1);
void __cdecl sub_122B780(HWND hWnd, LPWSTR lpCommandLine);
int sub_122B950();
volatile signed __int32 *__cdecl sub_122B970(volatile signed __int32 *a1);
void *__cdecl sub_122B9E0(int a1, void *Src, int a3, void *a4, int a5);
_WORD *__thiscall sub_122BA60(_DWORD *this);
volatile signed __int32 *__thiscall ATL::CSimpleStringT<wchar_t,0>::Fork(CString *this, int nLength); // idb
int __thiscall ATL::CAtlStringMgr::Free(_DWORD **this);
LPVOID __thiscall ATL::CWin32Heap::Free(HANDLE *this, LPVOID lpMem);
wchar_t *__cdecl sub_122BB70(wchar_t *a1, wchar_t *a2);
CAtlStringMgr *ATL::CAtlStringMgr::GetInstance();
volatile signed __int32 *__thiscall ATL::CAtlStringMgr::GetNilString(volatile signed __int32 *this);
SIZE_T __thiscall ATL::CWin32Heap::GetSize(HANDLE *this, LPCVOID lpMem);
int __thiscall sub_122BDC0(int *this, HMODULE hModule, int a3);
CStringData *__thiscall ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(CStringData **this, int nLength);
volatile signed __int32 *__cdecl sub_122BF00(OLECHAR *psz, OLECHAR *a2, OLECHAR *a3);
CStringData *__thiscall ATL::CSimpleStringT<wchar_t,0>::Reallocate(CString *this, int nLength); // idb
int __thiscall ATL::CAtlStringMgr::Reallocate(_DWORD **this, int a2, int a3, unsigned int a4);
LPVOID __thiscall ATL::CWin32Heap::Reallocate(HANDLE *this, LPVOID lpMem, SIZE_T dwBytes);
_WORD *__thiscall sub_122C620(void **this, void *Src, int a3);
HGLOBAL __cdecl AtlGetStringResourceImage(HMODULE hModule, HRSRC hResInfo, int a3);
void __stdcall sub_122C750(void *a1);
int *__thiscall sub_122C770(int *this, BSTR **a2);
int __cdecl sub_122C7E0(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD));
void *__cdecl sub_122C880(void *a1, int a2, int a3);
int __cdecl sub_122C930(int a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_122C9E0(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int));
int __cdecl sub_122CBC0(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD));
void *__cdecl sub_122CC30(void *a1, int a2, int a3, int a4);
signed int __cdecl sub_122CD10(_DWORD *a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD));
int **__cdecl sub_122CD70(int **a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int));
_DWORD *__cdecl sub_122CF50(_DWORD *a1, _WORD *a2, _WORD *a3, _WORD *a4);
void **__thiscall sub_122CF80(void **this, void *Src, int a3, int a4);
_DWORD *__thiscall sub_122D000(_DWORD *this, int a2, int a3);
void **__thiscall sub_122D080(void **this, int a2, int a3, void *a4, void *Src);
CResize *__thiscall CResize::CResize(CResize *this, HWND hWnd);
_DWORD *__thiscall sub_122D260(_DWORD *this);
_DWORD *__thiscall sub_122D2B0(_DWORD *this, int a2, __int16 a3);
volatile signed __int32 *__thiscall sub_122D3B0(_DWORD *this);
volatile signed __int32 *__thiscall sub_122D4B0(_DWORD *this);
void *__thiscall CResizer::~CResizer(_DWORD *this);
volatile signed __int32 *__thiscall sub_122D590(_DWORD *this);
volatile signed __int32 *__thiscall sub_122D670(_DWORD *this);
void **__thiscall sub_122D840(void **this, void **a2);
void *__thiscall sub_122D8B0(void *this, char a2);
void *__thiscall sub_122D8E0(void *this, char a2);
void *__thiscall sub_122D910(void *this, char a2);
void *__thiscall sub_122D940(void *this, char a2);
int __thiscall sub_122D970(_DWORD *this, _DWORD *a2);
int __cdecl sub_122DB10(wchar_t *Dst, rsize_t SizeInWords, int); // idb
CStringData *__thiscall sub_122DB40(int *this, wchar_t *Src);
CStringData *__thiscall sub_122DB80(int *this, wchar_t *Src, size_t MaxCount);
int __cdecl sub_122DC50(wchar_t *Dst, rsize_t SizeInWords, int); // idb
int __thiscall CResize::HookWindow(CResize *pThis, HWND hWnd); // idb
// ULONG __userpurge sub_122DD40@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// int __userpurge sub_122DE80@<eax>(int a1@<edi>, int *a2);
signed int __thiscall sub_122DEA0(void *this, int a2, DWORD ThreadId);
signed int __thiscall sub_122DF10(int *this);
int __stdcall ProcCLRWndProc(HWND hWnd, int, WPARAM, int); // idb
BOOL __cdecl sub_122E780(int a1, int a2);
bool __cdecl sub_122E7A0(int a1, int a2);
LRESULT __thiscall CResizer::HandleMessage(WNDPROC *this, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall EventCallback_0(int a1);
int __thiscall sub_122E810(_DWORD *this, int a2, int a3);
ResizeInfo *__thiscall CResize::InitResizeBuffer(CResize *pResize, HWND hWnd, int nCount);
int __cdecl sub_122E970(wchar_t *Dst, rsize_t SizeInWords, int, int, int); // idb
__int16 __thiscall sub_122E9F0(_WORD *this);
__int16 __thiscall sub_122EA10(_WORD *this);
__int16 __thiscall sub_122EA30(_WORD *this);
int __thiscall CTreeList::GetTooltipLeftHeader(CTreeList *this); // idb
WCHAR **sub_122EA80();
int __thiscall sub_122EA90(_WORD *this);
_WORD *__thiscall sub_122EAB0(_WORD *this);
_DWORD *__thiscall sub_122EAD0(_DWORD *this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_122EBA0(_DWORD *this, int a2, _DWORD *a3);
int __cdecl sub_122EC70(DWORD th32ProcessID, int); // idb
wchar_t *__thiscall sub_122EE50(_DWORD *this, int a2, int a3, wchar_t *Dst, int a5);
wchar_t *__thiscall sub_122EEA0(int this, int a2, int a3, wchar_t *Dst, int a5);
wchar_t *__thiscall sub_122EFF0(int this, int a2, int a3, wchar_t *Dst, int a5);
wchar_t *__stdcall sub_122F070(int a1, int a2, wchar_t *Dst, int a4);
const wchar_t *CResizer::GetName();
int __thiscall sub_122F0A0(_DWORD *this, int a2);
int __cdecl sub_122F690(WCHAR *a1); // idb
bool __cdecl sub_122F710(int a1, int a2, int a3);
bool __cdecl sub_122F730(int a1, int a2);
void **__thiscall sub_122F760(_DWORD *this, void **a2, int a3);
void **__thiscall sub_122F790(_DWORD *this, void **a2, int a3, int a4);
signed int __thiscall sub_122F840(char *this, WCHAR *a2);
BOOL __stdcall EnumFunc(HWND hWnd, CResize *pResizer); // idb
int __thiscall CResizer::Refresh(CResize *pResizerData); // idb
int __thiscall sub_122FE80(const wchar_t **this, wchar_t a2);
_WORD *__thiscall sub_122FEB0(void **this, void *Src);
_WORD *__thiscall sub_122FF00(void **this, void *Src);
_WORD *__thiscall sub_122FF50(void **this, void *Src);
_WORD *__thiscall sub_122FFA0(void **this, void *Src);
int __thiscall sub_122FFF0(void **this, void *Src);
_WORD *__thiscall sub_12300E0(void **this, void *Src);
int __thiscall sub_1230130(HWND *this);
void *__thiscall sub_12301B0(int this);
int __cdecl sub_12301D0(wchar_t *Dst, rsize_t SizeInWords, int); // idb
int __cdecl GUIDFromString(wchar_t *Src, GUID a2); // idb
LRESULT __stdcall CResizer::HookWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
char *__thiscall sub_1230650(const void **this, unsigned int a2);
char *__thiscall sub_12306D0(const void **this, unsigned int a2);
unsigned int __thiscall sub_1230750(int this, unsigned int a2);
unsigned int __thiscall sub_12307C0(int this, unsigned int a2);
int __thiscall sub_1230840(_DWORD *this, int a2, void *a3);
__int16 __thiscall sub_1230880(_DWORD *this, _WORD *a2);
CStringData *__thiscall sub_12308F0(void *this, SystemMenuData *pMenuData); // idb
bool __cdecl sub_1230960(#1077 *a1); // idb
int __cdecl sub_12309A0(wchar_t *Dst, int, __int64); // idb
int __cdecl sub_12309F0(wchar_t *Dst, int, __int64); // idb
errno_t __cdecl sub_1230A40(wchar_t *a1, int a2, __int64 a3);
int FormatTex(wchar_t *Dst, wchar_t *Format, ...);
int __thiscall sub_1230A90(_DWORD *this, int a2, int a3, int a4, int a5, unsigned int a6, int a7);
char __thiscall sub_1230CA0(void **this, LONG a2, signed int a3);
char __thiscall sub_1230D60(CBitmap *Bitmap, _DWORD *a2, unsigned int a3); // idb
int __cdecl sub_1230E00(wchar_t *Dst, size_t SizeInWords, int, __int64); // idb
char __thiscall sub_1230E50(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7);
char __thiscall sub_1230ED0(_DWORD *this, int a2, int a3, int a4, int a5, unsigned int a6, char a7);
void __cdecl UpdateText(ProcessorInfo *ProcessorsInfo, FILETIME TimeLastRefresh, __int64 dbMaxValue, __int64 dbMaxValue1, wchar_t *string);
ProcessorInfo *__cdecl InitProcessorScreenData(int dwProcessorNumber, int ProcessorCount, int fZero); // idb
void __cdecl sub_1231280(void *a1, int a2);
HWND __cdecl CreateGraphWindowInDlg(HWND hDlg, int uCtrlId, int lParam); // idb
HGDIOBJ __cdecl sub_1231470(LPCRITICAL_SECTION lpCriticalSection, int a2, int a3);
HICON __cdecl PEDrawIcon(ProcessorInfo *pInfo, HDC hdc, int *nValue128, COLORREF clrBack, int a5, double a6); // idb
char *__cdecl sub_1231FD0(float a1, HDC a2, int *a3, COLORREF a4);
int __cdecl GetPalletteInfo(CGraphData *pData, int *Red, int *Green); // idb
int __cdecl sub_1232200(char, wchar_t *, size_t SizeInWords, __int64, __int64, __int64); // idb
errno_t __cdecl sub_1232410(wchar_t *a1, rsize_t SizeInWords, int a3, __int64 a4);
void __cdecl sub_12324C0(int a1);
int __cdecl IsFocusWindow(HWND hWnd); // idb
LPBYTE __thiscall sub_1232AE0(LPBYTE lpData, HKEY phkResult);
void __thiscall sub_1232C80(void **this);
int __thiscall sub_1232CB0(_DWORD *this, LPCWSTR lpsz);
int __thiscall sub_1232D20(unsigned int *this, unsigned int a2);
LRESULT __cdecl MSGHANDLER::HandleCommand(MSGHANDLER *pMsgHandler, HWND hWnd, WPARAM wParam, LPARAM lParam);
LRESULT __cdecl MSGHANDLER::HandleMessage(MSGHANDLER *pMsgHandler, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
char __cdecl CDriver::LoadFromResource(LPCTSTR lpszResName, const TCHAR *lpszFileName); // idb
BOOL __cdecl CDriver::OpenEx(TCHAR *lpszName, TCHAR *lpszPathName, HANDLE *pHandles);
BOOL __cdecl CDriver::Open(TCHAR *ArgList, HANDLE *phHandle);
CList *__stdcall CList::Append(CList *pList, _DWORD *a2, _DWORD *a3);
char __cdecl sub_1233340(int a1, int a2, int a3, int a4, int a5, int a6, WPARAM wParam);
void __cdecl sub_12338F0(int a1, int a2, signed __int64 a3, int a4, int a5, int a6, int a7, int a8);
BOOL __cdecl InitializeD3DStatistics(DWORD64 *a1, DWORD64 *dwSegCommitLimit); // idb
CList *__stdcall sub_1234360(CList *a1, _DWORD *pNode); // idb
ProcessorInfo *__thiscall CSimpleGraphData::Init(CSimpleGraphData *P); // idb
signed __int64 __thiscall sub_1234400(_DWORD *this);
void __thiscall sub_12344A0(CSimpleGraphData *this, CDataInfo *pDataInfo); // idb
int __stdcall CDataInfo::Init(int a1, CDataInfo *a2);
int __cdecl CreateMainWindow(HINSTANCE hInstance, int nShowCmd); // idb
int VLogEntry(wchar_t *Dst, wchar_t *Format, ...);
int sub_1234BB0(wchar_t *Dst, wchar_t *Format, ...);
int __stdcall CString::LoadString(LPCSTR lpMultiByteStr);
CStringData **__thiscall AsciiToUNICODE(CString *str, LPCSTR lpMultiByteStr);
int __stdcall AutoEllipsisText(HDC hDC, LPCTSTR lpszText, UINT nLength, int nWidth);
signed int __cdecl sub_1234EF0(unsigned int *a1, _DWORD *a2);
int __cdecl sub_1234F50(WINDOWPLACEMENT *pWindowPlacement, WDPLSETTINGS *lpszSetting, int nLength);
BOOL __stdcall DrawItemText(HDC hDC, LPCTSTR lpszText, const RECT *lprc, int fRightAlign); // idb
char __cdecl sub_12356D0(char a1, int a2, WORD pwLuminance, HDC hDC, RECT *lprc);
errno_t __cdecl sub_1235AD0(int a1, int a2, int a3, int a4, int a5, wchar_t *Dst, rsize_t SizeInWords);
LPCWSTR __cdecl sub_1235BB0(wchar_t *Dst, __int64 a2);
char __cdecl GetListColor(HWND hLstCtrl, int *nIDs, int bFocused_1, DWORD *clrTex, DWORD *clrBack); // idb
BOOL __cdecl RedrawHeader(HWND hWnd, int iItem, int mode);
BOOL __stdcall EnumWindowsCallback2(HWND, LPARAM); // idb
char __cdecl IsColumnSortable(signed int uID); // idb
unsigned __int16 __cdecl sub_1236210(double a1, unsigned __int16 a2, unsigned __int16 a3);
BSTR **__cdecl sub_1236270(CTreeListItem *pTreeListItem, COLUMNTEXT *pData); // idb
void __cdecl SerializeColumnset(int a1, int ArgList, TCHAR *pBuffer); // idb
HANDLESANDDLLSLISTUSERPARAM *__cdecl AddRowToListCtrl(HWND hWnd, LVITEMUSERDATA2 *pUserData);
char __cdecl AutoLoadStringArrFromId(HWND hList, UINT uStringID, UINT *nStringIds, UINT nCount); // idb
int __cdecl VerifySignature(HWND hWnd, LVITEMUSERDATA *pUserData); // idb
DLLLISTITEMPARAM *__cdecl InsertRowToDllList(HWND hwnd, HANDLESANDDLLSLISTUSERPARAM *pUserParam);
int FindDlg::AppendToListToFind(HWND hWnd, ...);
#1077 *__cdecl sub_1237BC0(HWND hWnd, int a2);
HANDLESANDDLLSLISTUSERPARAM *__cdecl sub_1237DD0(HWND hWnd, char a2);
int __cdecl sub_1237E70(HWND hWnd, char a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
int __cdecl sub_1237F20(HWND hWnd, #1077 *a2); // idb
void __cdecl InitTreeListItemColor(TREELISTITEMPARAM *pTreeListItemData); // idb
struct _IMAGELIST *InitSortableImageList();
HWND __cdecl CreateListCtrl(HWND hWnd, DWORD dwStyle, __int16 *nWidths, int *nIDs, LONG dwColumnCount, HMENU uCtrlID);
void __cdecl RemoveTreeListItemParam(#1077 *ListItemData);
#1077 *__cdecl DeleteItemFromTreeList(HWND hWnd, #1077 *a2);
void __cdecl sub_1238600(LVITEMUSERDATA *lpAddend); // idb
void __cdecl DestroyTreeListItemData(#1077 *a1); // idb
char __cdecl FindDlg_DrawItem(DRAWITEMSTRUCT *lpdis); // idb
int __cdecl UpdateMenu(char bEnabled, int nPos); // idb
BOOL __cdecl sub_1238DA0(int a1);
char __cdecl sub_1238E30(int a1, HWND hWnd, int a3, int a4, int a5, wchar_t *Dst);
void InitDrawEngine();
BOOL __cdecl sub_1239980(HWND hWnd);
LRESULT __cdecl CThreadStackPage::InitListCtrl(HWND hWnd, LONG pStackInfo, int a3, int a4, char a5); // idb
char __cdecl IsIllegalID(int a1, int uId); // idb
int __stdcall PEListCtrlWndProc(HWND hWnd, UINT msg, int wParam, LPARAM lParam); // idb
void __cdecl GetListItemRect(HWND hWnd, WPARAM nItem, WPARAM nSubItem, LPRECT lprc); // idb
BOOL __cdecl InitTreeList(HWND hTreeList, WPARAM hFont); // idb
signed int __stdcall TreeListSort(int a1, int a2, int *a3);
int __stdcall InitListCtrl(HWND hWnd, int *uIDs, __int16 *nWidths, LONG dwCount);
int __cdecl OnTreeListClick(int a1, int a2);
int __cdecl OnTreeListColumnClick(HWND hWnd, tagNMLISTVIEW *pInfo, DWORD bMenu, LPARAM lParam);
int __cdecl CTreeList::DeleteItem(signed int uId, CTreeList *pTreeList); // idb
int __cdecl OnTreeListDblclks(int uId); // idb
int __cdecl OnFindItem(int a1);
// int __usercall CTreeList::OnGetDispInfo@<eax>(int esi0@<esi>, signed int a1, NMLVDISPINFOW *pnmhdr); idb
int __cdecl OnTreeListKeydown(int uID, NMLVKEYDOWN *pNMKeyDown); // idb
int __cdecl CTreeList::OnItemChanged(UINT nID); // idb
int __cdecl OnTreeListRClick(int a1, HWND *a2, POINT *a3); // idb
bool __cdecl InitTreeListSortableHeader(HWND hWnd, int item1, int item2, char Ascending);
LRESULT __cdecl sub_123FAA0(HWND hWnd);
BOOL __stdcall ColumnSetDlgProc(HWND, UINT, WPARAM, LPARAM); // idb
BOOL __cdecl AutoComputerSomeGraphColor(int nId, HDC hdc, int bkColor); // idb
HCURSOR __cdecl LoadHandCursor(int a1, int nId); // idb
char __cdecl ColumnIDIsIllegal(int a1, HWND hWnd, int uID, WPARAM wParam); // idb
// BOOL __userpurge ColumnSetSaveDlgProc@<eax>(double a1@<st0>, double a2@<st1>, double a3@<st3>, double a4@<st2>, double a5@<st4>, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int __cdecl CMainWnd::Reset(HWND hWnd, char fSave);
int __stdcall SelectColumnForProcDLLPageWndProc(HWND hDlg, int, int, int); // idb
int __stdcall SelectColumnForProcHandlePageWndProc(HWND hDlg, int, int, int); // idb
int __stdcall SelectColumnForDotNetProcPageWndProc(HWND hDlg, int, int, int); // idb
int __stdcall SelectColumnForProcessImagePageWndProc(HWND hWnd, UINT message, WPARAM wParam, _PSHNOTIFY *lParam);
int __cdecl sub_1241AF0(_DWORD *a1, _DWORD *a2);
signed int __cdecl OnTreeListNotify7D4(int a1, CTreeListItem *pTreeItem); // idb
signed int __cdecl OnTreeListNotify7D5(int a1, int a2);
BOOL RedrawTreeList();
int sub_1241D60(char *DstBuf, char *Format, ...);
int sub_1241D80(wchar_t *Dst, wchar_t *Format, ...);
int *__thiscall sub_1241DA0(int *this, void *a2);
_DWORD *__thiscall sub_1241E00(void *this, void *a2);
HRESULT __cdecl sub_1241E50(char a1, OLECHAR *a2);
void *__cdecl sub_12426B0(void *a1);
errno_t __cdecl FillDebuggerInfo(wchar_t *Dst, rsize_t SizeInWords);
char __cdecl sub_1242910(int a1, int a2, int a3, wchar_t *Dst, rsize_t SizeInWords);
WCHAR *__cdecl CReg::ReadEnvString(HKEY hKey, LPCWSTR lpValueName);
void __cdecl sub_1242A70(const __m128i *a1);
char __cdecl GetStringFromMemory(HWND hList, unsigned int dwSize, PUCHAR pBuffer, unsigned int dwLength);
int __cdecl IsTerminalServer(LPCWSTR szProduction); // idb
_DWORD *__thiscall sub_12430E0(void *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_12431B0(void *this, void *a2, int a3);
LPCWSTR __cdecl GetNumberTextFormat(LPCWSTR lpszText, rsize_t SizeInWords); // idb
void __cdecl sub_1243300(wchar_t *a1);
BOOL __cdecl UpdateSysIconInMenu(HMENU hMenu, UINT item); // idb
bool __cdecl sub_12436B0(int a1, unsigned int a2, char a3, char a4);
HWND __cdecl ResizeTab(HWND hWnd);
signed int __cdecl sub_12437B0(unsigned __int64 a1, unsigned __int64 a2);
BOOL __cdecl sub_12437F0(char a1);
LRESULT __cdecl InitToolTips(HWND hWnd);
BOOL __cdecl DrawWindowEx(HWND hWnd, int a2);
char __cdecl GetDependsFileName(LPCWSTR lpszFileName, wchar_t *pszSource, int nLen, wchar_t *pszResult); // idb
HWND __cdecl FindWindowByPid(int dwPid); // idb
int __cdecl sub_1243C40(wchar_t *, size_t SizeInWords, __int64); // idb
char __cdecl QuerySID(PSID Sid, LPWSTR Name, DWORD cchName, LPWSTR ReferencedDomainName, DWORD cchReferencedDomainName);
_DWORD *__cdecl sub_1243E70(PROCAFFINITY *a1, int a2, signed int a3, signed int *a4, _DWORD *a5); // idb
int __cdecl sub_1243F20(_DWORD *a1, unsigned int a2, int a3);
void __cdecl sub_1243F80(wchar_t *Str, int a2, int a3, int a4, int a5);
wchar_t *__cdecl sub_1244280(wchar_t *a1);
DWORD __cdecl GetImageVersionInfo(LPCWSTR lptstrFilename, wchar_t *szVersion, rsize_t SizeInWords, DWORD dwLen, WCHAR *szDesc);
char __cdecl sub_12444B0(int a1, char a2, int a3, u_long hostlong, int a5, wchar_t *Dst, size_t SizeInWords);
wchar_t *__cdecl sub_1244670(char a1, int port, char *proto, wchar_t *Dst, size_t SizeInWords);
wchar_t *__cdecl IsProcessComment(wchar_t *str); // idb
wchar_t *__cdecl sub_1244730(wchar_t *a1, int a2);
WCHAR *__cdecl GetSVCHostsFilePath(wchar_t *a1, LPCWSTR lpServiceName);
wchar_t *__cdecl sub_1244990(int a1);
BOOL __cdecl DrawWindow(HWND hWnd);
// bool __usercall MayRunAtLogon@<al>(int a1, _DWORD *a2);
bool sub_1245050();
char __cdecl sub_12450E0(wchar_t *a1);
BOOL __stdcall IsProcessorFeaturePresent_0(DWORD ProcessorFeature);
char TaskMgrIsDebugger();
int __cdecl IsWinServer();
BOOL __cdecl MainWnd_Hide(HWND hWnd);
// _DWORD __cdecl unknown_libname_2(char); weak
PROCAFFINITY *__cdecl sub_1245420(unsigned int *pdwLogicalProcessorInformationCount);
BOOL __cdecl SetPropSheetRect(HWND hWnd, int x, int y); // idb
char __cdecl sub_1245750(int a1, char a2, wchar_t *Src);
int __cdecl sub_1245A60(const void *, const void *); // idb
LSTATUS LoadHiddenProcsFromRegistry();
LSTATUS RetrieveProcessComments();
char __cdecl ReplaceTaskMgr(int a1, char bReportError); // idb
char __thiscall sub_1245E40(HKEY this);
DWORD __cdecl StartProcExp64(int bWait, WORD wShowMode);
DWORD __cdecl ExecuteProcess(const WCHAR *pParameters, int nShowCmd, char fWaiting); // idb
ULONG IsX64();
LSTATUS __cdecl sub_12462A0(int a1, wchar_t *a2);
char __cdecl sub_12464C0(HWND hWnd, LPCWSTR lpFileName);
HCURSOR __cdecl sub_1246620(HWND hList, HANDLE hProcess, LPCVOID lpBaseAddress, int dwBytesToRead); // idb
int __cdecl sub_1246710(int, HDC hdc); // idb
int __cdecl sub_1246750(HLOCAL *a1, int a2, _DWORD *a3, _DWORD *a4);
BOOL __cdecl AddShellIcon(int hWnd, int nID, void *pInfo, wchar_t *lpszTipText); // idb
BOOL __cdecl RemoveShellIcon(HWND hWnd, UINT uID); // idb
BOOL __cdecl UpdateTrayIcon(HWND hWnd, UINT uID, HICON hIcon, TCHAR *lpszTipText); // idb
BOOL __cdecl sub_12469D0(TREELISTITEMPARAM *a1); // idb
BOOL __cdecl CheckProcessWindowMenuItems(void *a1); // idb
bool __cdecl ShowMainWindow(HWND hWnd, int uMenuId, int dwPid); // idb
LSTATUS sub_1246C90();
HANDLE __cdecl sub_1246DB0(HANDLE TokenHandle);
BOOL __cdecl GetSidIndentityAuthInfo(wchar_t **szSidIndentityAuthInfo); // idb
BOOL __cdecl FormatSID(PSID pSid, wchar_t *szText, DWORD *pdwLength); // idb
char IsBuiltinAndAnministrative();
_DWORD *__cdecl sub_1247450(PSID AccountSid);
int sub_1247500(wchar_t *Dst, wchar_t *Format, ...);
_DWORD *__thiscall sub_1247520(_DWORD *this, int (__stdcall ***a2)(_DWORD, void *, _DWORD *));
_DWORD *__thiscall sub_1247560(_DWORD *this, int (__stdcall ***a2)(_DWORD, void *, _DWORD *));
#516 *__thiscall MixedModeStackWalker::MixedModeStackWalker(#516 *this);
int __thiscall sub_1247600(_DWORD *this, int a2);
_DWORD *__thiscall MixedModeStackWalker::`scalar deleting destructor'(void *this, char a2);
unsigned int __thiscall sub_12476F0(_DWORD *this, int *a2);
_DWORD *__thiscall sub_1247740(_DWORD *this, int *a2);
void __stdcall sub_12477E0(int *a1);
void __cdecl sub_12479A0(_DWORD *a1, int a2);
int __cdecl sub_12479D0(int a1, unsigned int a2);
int __cdecl sub_1247A00(HWND hWnd, int Pid, char a3); // idb
signed int __stdcall sub_1247DD0(int (__stdcall ***a1)(_DWORD, void *, int *));
int __cdecl sub_1247F10(int, LPCWSTR lpsz, int); // idb
int __thiscall sub_1247F60(_DWORD *this);
void __thiscall sub_1247F70(_DWORD *this);
signed int __stdcall sub_1247FF0(unsigned int a1, _DWORD *a2, unsigned int *a3);
signed int __stdcall sub_12480C0(int (__stdcall ***a1)(_DWORD, void *, int *), _DWORD *a2);
int __stdcall sub_12486C0(int a1, _DWORD *a2);
int *__cdecl sub_12486E0(wchar_t *a1, int a2);
int __cdecl sub_1248790(wchar_t *Src, wchar_t *Dst); // idb
int __stdcall sub_12487D0(int, DWORD dwThreadId, int, int, int); // idb
char __thiscall sub_12488A0(const void **this, unsigned int a2);
FARPROC __thiscall sub_1248940(_DWORD *this, _DWORD *a2);
int __thiscall sub_1248A30(_DWORD *this, int a2, int a3, int a4, int a5);
int __thiscall sub_1248A90(_DWORD *this, int a2, int a3, int a4, int a5);
void __thiscall sub_1248AE0(int *this, unsigned int a2, int *a3, unsigned int a4);
int (__stdcall ***__stdcall sub_1248C80(int (__stdcall ***a1)(_DWORD, void *, int *)))(_DWORD, void *, int *);
signed int __thiscall sub_1248D10(_DWORD *this, int a2);
BOOL __cdecl sub_1248DE0(int a1);
int __thiscall sub_1248E20(void *this, int a2, int a3, int *a4, _DWORD *a5, _DWORD *a6, int a7, unsigned int a8, unsigned int *a9);
signed int __thiscall sub_1249500(_DWORD *this, int a2, int a3, int a4);
signed int __stdcall sub_1249620(int a1, int a2, int a3, int a4, HMODULE *a5);
signed int __stdcall sub_1249780(int a1, _DWORD *a2, _DWORD *a3);
signed int __stdcall sub_1249800(int a1, _DWORD *a2, _DWORD *a3);
signed int __stdcall sub_1249880(int a1, _DWORD *a2, _DWORD *a3);
signed int __stdcall sub_12498D0(int a1, int a2, int a3);
int __stdcall sub_12498E0(int, LPCVOID lpBaseAddress, int, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); // idb
int __stdcall sub_1249910(void *); // idb
int __stdcall sub_1249940(_DWORD *a1);
int __stdcall sub_1249960(void *); // idb
int __stdcall sub_12499B0(void *); // idb
int __cdecl sub_1249A00(void *Dst, void *Src, int); // idb
_DWORD *__thiscall sub_1249A30(_DWORD *this);
_DWORD *__thiscall sub_1249AC0(int *this, _DWORD *a2);
int __stdcall sub_1249B40(DWORD dwThreadId); // idb
char __thiscall sub_1249B80(int this, unsigned int a2, int a3);
int __thiscall sub_1249C50(_DWORD *this, int a2, int a3, int a4);
signed int __stdcall sub_124A3A0(_WORD *a1, unsigned int a2, int a3);
signed int __stdcall sub_124A440(_WORD *a1, unsigned int a2, int a3, unsigned int a4);
signed int __stdcall sub_124A490(_WORD *a1, int a2, _DWORD *a3, int a4, int a5);
signed int __stdcall sub_124A500(_WORD *a1, unsigned int a2, _DWORD *a3, unsigned int a4);
HANDLE __thiscall sub_124A570(void *this, DWORD dwThreadId, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_124A870(int a1, WPARAM wParam);
int __thiscall sub_124B0A0(_DWORD *this, DWORD dwThreadId, int a3);
int __thiscall sub_124B680(_DWORD *this, DWORD dwThreadId, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
void sub_124B8A0();
void *__cdecl sub_124B9D0(int a1);
int __stdcall ProcNetWndProc(HWND hWnd, unsigned int a2, unsigned int wParam, int a4);
int sub_124C500();
char __cdecl sub_124C540(int a1, WPARAM wParam);
CMapNode *__thiscall CMapNode::NewNode(CMapNode *this, CMapPair *pair);
_DWORD *__thiscall sub_124C630(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, _DWORD *dwTid, int a6); // idb
int __thiscall sub_124C840(_DWORD *this, int a2, _DWORD *a3, ThreadInfo *pThreadInfo, int a6); // idb
signed int __stdcall BufferCallback(int a1);
HANDLE sub_124CA20();
signed int __thiscall RealTrace(PE_EVENT_TRACE_PROPERTIES *pParam); // idb
signed int __stdcall TraceEventThreadProc(char *a1);
unsigned __int64 __thiscall sub_124CBE0(_QWORD *this, __int64 a2);
unsigned __int8 *__cdecl sub_124CC70(int a1, int a2, int a3, wchar_t *Dst, rsize_t SizeInWords);
ULONG __thiscall FlushTrace(PEVENT_TRACE_PROPERTIES Properties);
int __cdecl sub_124D240(const unsigned __int16 *a1);
signed int __cdecl sub_124D2B0(unsigned int a1);
signed int __thiscall CEventTrace::Start(PE_EVENT_TRACE_PROPERTIES *pEventTraceProperties, char a2); // idb
void __cdecl sub_124D510(int a1, int a2);
void __stdcall EventCallback(int a1);
void __cdecl sub_124DB50(_DWORD *a1, const unsigned __int16 ***a2);
void __cdecl sub_124DCE0(_DWORD *a1, int a2);
CSysProcItem **__cdecl sub_124E310(int a1, int a2);
int __cdecl sub_124E4E0(int, PSID Sid); // idb
_DWORD *__thiscall sub_124E560(int *this, _DWORD *a2, unsigned int *a3);
void __stdcall sub_124E5E0(void *a1);
int __thiscall sub_124E620(_DWORD *this);
_DWORD *__thiscall sub_124E670(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
wchar_t **__thiscall sub_124E6A0(int **this, wchar_t *a2);
wchar_t **__thiscall sub_124E760(_DWORD **this, LPCWSTR lpsz);
wchar_t **__thiscall sub_124E830(int this);
wchar_t **__thiscall sub_124E840(int this);
int __thiscall sub_124E850(int *this, wchar_t *Dst, rsize_t SizeInWords);
// _DWORD __stdcall unknown_libname_3(_DWORD, _DWORD); weak
_DWORD *__thiscall sub_124E8B0(int **this, LPCWSTR lpsz);
char __cdecl OpenExeFromFile(LPCWSTR lpFileName, DWORD *pdwTime, HANDLE *hMapping, LPCVOID lpBaseAddress);
wchar_t **__thiscall sub_124EC40(wchar_t **this, wchar_t *a2, int a3, void *a4, unsigned int a5);
void __thiscall sub_124EC80(void **this);
signed int __thiscall sub_124ECA0(int this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_124ED40(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_124ED60(_DWORD *this);
_DWORD *__thiscall sub_124EE00(_DWORD *this);
_DWORD *__thiscall sub_124EEA0(_DWORD *this, int a2);
int __thiscall sub_124EEC0(_DWORD **this, LPCWSTR lpsz, wchar_t *Dst, int a4);
int __thiscall sub_124EF90(void *this);
int __thiscall sub_124EFA0(int *this);
int __thiscall sub_124EFB0(void **this, LPCWSTR lpMachineName, LPCWSTR lpsz);
int __cdecl sub_124F110(int a1, int a2, int a3, #1077 *a4); // idb
int __cdecl HandleDeviceChange(int a1, int a2, int a3, int a4);
int __cdecl sub_124F150(int a1, int a2, int a3, int a4);
int __cdecl OnDumpProcess(int a1, __int16 a2);
int OnRestartProcess();
int OnKillProcessTree();
int __cdecl OnExit(HWND hWnd); // idb
int OnShowProcessExplorer();
int OnThreadStackCopy();
int OnRefreshNow();
int __cdecl OnSelectColumn(int a1, signed __int16 uId); // idb
int __cdecl OnViewDlls(HWND hWnd); // idb
int __cdecl OnViewHandles(HWND hWnd); // idb
int __cdecl OnViewHandles2(HWND hWnd);
int __cdecl OnShowUnnamedHandlesAndMappings(HWND hWnd); // idb
int __cdecl OnHiliteRelocatedDlls(HWND hWnd); // idb
int __cdecl OnScrollToNewProcesses(HWND hWnd); // idb
int __cdecl OnHelp(int a1);
int __cdecl OnSearchOnline(int a1, __int16 a2);
int __cdecl OnFindHandlerOrDll(int a1, __int16 uId); // idb
int __cdecl OnDestroy(HWND hWnd); // idb
int sub_1250830();
int __cdecl OnSelectFont(HWND hWnd); // idb
int sub_12508E0();
int __cdecl sub_1250970(int a1, __int16 a2);
int OnConfirmKill();
int OnFormatIoBytes();
int sub_1250BC0();
int __cdecl OnHiliteDuration(HWND hWndParent); // idb
int OnFileSave();
int __cdecl OnCpuHistory_0(HWND hWndParent); // idb
int OnFileSaveas();
int OnKillProcess();
int OnSuspendProcess();
int __cdecl OnShowLowerPane(int a1);
int __cdecl OnShowProcessProperties(HWND hWnd, UINT uMenuId, BOOL bMenuMsg, LPARAM lParam);
int __cdecl OnRefreshTime(int a1, UINT a2);
int OnShowProcessTree();
// int __usercall OnProcessSetPriority@<eax>(int a1@<edi>, int a2, __int16 a3);
int OnOnlyOneInstanceCheck();
int __cdecl OnRunFileDlg(HWND hWndParent, int); // idb
int __cdecl OnRunDlg(HWND hWndParent, int); // idb
int __cdecl OnHideWhenMinimized(HWND hWnd); // idb
int __cdecl OnPacityShowMRU(HWND hWnd, int); // idb
int __cdecl OnShutdown(int a1, __int16 a2);
int __cdecl sub_1251F10(HWND hWnd); // idb
int __cdecl sub_1251F80(HWND hWndParent); // idb
int OnShowSystemInformation();
int __cdecl sub_1252020(HWND hWnd); // idb
int __cdecl OnChooseColor(HWND hWndParent); // idb
int OnTrimtProcessWorkingsetSize();
int __cdecl OnProcessWindowShow(int a1, int uMenuId);
int OnShowHeatmaps();
int __cdecl OnVerifyImageSignature(HWND hWnd); // idb
int __cdecl sub_1252390(HWND hWnd); // idb
int __cdecl sub_1252520(HWND hWnd); // idb
int OnCheckVirusTotalCom2();
int OnCheckVirusTotalCom();
int OnShowDetailsForalAllProcesses();
int __cdecl OnAlwaysOnTop(HWND hWnd); // idb
int __cdecl OnCpuHistory(HWND hWnd); // idb
int __cdecl OnIoHistory(HWND hWnd); // idb
int __cdecl sub_1252A20(HWND hWnd); // idb
int __cdecl sub_1252A80(HWND hWnd); // idb
int __cdecl sub_1252AE0(HWND hWnd); // idb
// int __usercall OnRunAtLogon@<eax>(_DWORD *a1@<edi>, HWND hWnd);
int __cdecl OnCommitHistory(HWND hWnd); // idb
int __cdecl OnPhysicalMemoryHistory(HWND hWnd); // idb
// signed int __usercall OnSelectColumnMRU@<eax>(double st7_0@<st0>, LPARAM ebx0@<ebx>, DWORD a3@<edi>, double a4@<st1>, double a5@<st3>, double a6@<st2>, double a7@<st4>, int a1, unsigned __int16 a2);
int sub_1252F00();
int sub_1252F10();
int __cdecl sub_1252F20(int a1, __int16 a2);
int sub_12531A0();
int __cdecl sub_1253330(HWND hWnd); // idb
int __cdecl OnSaveColumnSet(HWND hWndParent); // idb
int __cdecl OnOrganizeColumnset(HWND hWnd); // idb
LRESULT __cdecl HandleCommand(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam);
int __cdecl HandlePaint(HWND hWnd); // idb
int __cdecl HandleSize(HWND hWndMain, int a2, int wParam, LPARAM size); // idb
int __cdecl HandleGetMinmaxInfo(int a1, int a2, int a3, MINMAXINFO *pInfo); // idb
int __cdecl HandleLButtonDown(HWND hWnd, int, int, int); // idb
int __cdecl HandleLButtonUp(HWND hWnd, int, int, int); // idb
int __cdecl HandleMouseMove(HWND hWnd, UINT Flags, POINT pt);
BOOL __cdecl HandleMeasureItem(HWND hDlg, UINT uMsg, WPARAM wParam, MEASUREITEMSTRUCT *lpmis);
int __cdecl HandeNotify(HWND hWnd, int uMsg, HMENU wParam, NMLISTVIEW *pNMListView);
int __cdecl HandleCreate(HWND hWnd);
int __cdecl HandleClose(HWND hWnd);
int HandleEndSession();
int __cdecl HandleDestroy(HWND hWnd); // idb
int __cdecl HandleDrawItem(int a1, int a2, int a3, int a4);
MACRO_BOOL __cdecl HandleSetFocus(HWND a1);
LRESULT __cdecl HandleContextMenu(HWND hWnd, UINT msg, HWND hWndContext, LPARAM pt); // idb
int __cdecl OnMessage7EF(int, int, int, void *);
int __cdecl sub_1255A60(int a1, int a2, int a3, const wchar_t **a4);
int __cdecl sub_1255C10(int, int, int, HWND hWnd); // idb
HWND __stdcall GetFocus_0();
int __cdecl sub_1255C50(int a1, int a2, int a3, #1077 *TreeListItemData); // idb
#1077 *__cdecl sub_1255D40(int a1, int a2, int a3, int a4);
int __cdecl HandleInitMenuPopup(int a1, int a2, HMENU hMenu); // idb
LRESULT __cdecl HandleMenuCommand(HWND hWnd, int uMsg, WPARAM nPos, LPARAM hMenu); // idb
signed int __cdecl HandleCopyData(int a1, int a2, int hwnd, PCOPYDATASTRUCT lParam); // idb
int __cdecl sub_1256570(int a1, int a2, int a3, int a4);
int __cdecl OnMessage7E8(int a1, int a2, HWND uId); // idb
int __cdecl sub_1256660(HWND hWnd, int, int, int); // idb
LRESULT __cdecl HandleSysCommand(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __cdecl sub_1256830(int, int, WPARAM wParam, WPARAM); // idb
int sub_12568E0(wchar_t *Dst, wchar_t *Format, ...);
CStringData **__thiscall ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(CString *res, LPCSTR psz, int nLength); // idb
HBRUSH __stdcall ChooseColorDlgProc(HWND hDlg, UINT a2, WPARAM hdc, LPARAM hWnd);
// int __userpurge SelectColumnForStatusBarPageWndProc@<eax>(double a1@<st0>, double a2@<st1>, double st4_0@<st3>, double st5_0@<st2>, double st3_0@<st4>, HWND hDlg, int a3, int a4, int a5);
BOOL __stdcall DiffDurationDlgProc(HWND, UINT, WPARAM, LPARAM); // idb
void __cdecl sub_1257930(int a1);
HBRUSH __cdecl CreateBrush(COLORREF color, HBRUSH *phbrush); // idb
char __cdecl sub_12579E0(char a1);
BOOL __cdecl sub_1257A60(HWND hWnd);
int __cdecl SelectColor(HWND hWnd, COLORREF *pColor); // idb
// int __userpurge BackupUpdateThreadProc@<eax>(void *pInfo);
BOOL __stdcall RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wID, LPARAM hData); // idb
int __stdcall SendMessageDlgProc(HWND hDlg, int, int, int); // idb
BOOL __stdcall SymbolConfigDlgProc(HWND hDlg, UINT uMsg, WPARAM wID, LPARAM a4); // idb
bool __cdecl BrowseSymbolPath(HWND hWndOwner, LPTSTR pszPath); // idb
BOOL StartSystemInfoSheetThreadProc();
const wchar_t *__cdecl sub_1258D50(int a1);
BOOL __stdcall TsInfoDlgProc(HWND, UINT, WPARAM, LPARAM); // idb
BOOL __cdecl HandleShellIconMsg();
void __cdecl sub_12592A0(int a1);
int __cdecl FindProcessByWindow(HWND hWnd); // idb
LRESULT __stdcall PEMainWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL __cdecl DumpProcessToFile(HANDLE hFile, HANDLE Process, char a3);
int __cdecl sub_1259660(int, int, wchar_t *Dst); // idb
_DWORD *__thiscall sub_1259690(_DWORD *this, int a2);
int __thiscall map::_Insert_at(CSysProcItem *this, int a2, char a3, int a4, int a5, CSysProcItem *a6); // idb
_DWORD *__thiscall sub_12598E0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, int a6);
CMapNode *__thiscall std::_Tree<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Insert_at<std::pair<unsigned long const,void *> &,std::_Tree_node<std::pair<unsigned long const,void *>,void *> *>(CMap *this, CMapNode *a2, int flags, int dwPid, void *pnode); // idb
int __thiscall sub_1259C10(_DWORD *this, int a2, _DWORD *a3, _DWORD *a4, int a5);
int sub_1259D20(wchar_t *Dst, wchar_t *Format, ...);
int LogEntry(wchar_t *Dst, wchar_t *Format, ...);
int sub_1259D60(wchar_t *Dst, wchar_t *Format, ...);
int sub_1259D80(wchar_t *Dst, wchar_t *Format, ...);
int FormatULong64(wchar_t *Dst, wchar_t *Format, ...);
int sub_1259DC0(wchar_t *Dst, wchar_t *Format, ...);
int FormatString(wchar_t *Dst, wchar_t *Format, ...);
int *__thiscall sub_1259E00(_DWORD *this, LPCWSTR lpWideCharStr);
CString *__thiscall sub_1259EA0(int *this, LPCSTR lpMultiByteStr);
void __thiscall sub_1259F20(void **this);
void __thiscall sub_1259F70(void **this);
void __thiscall sub_1259FB0(int **this);
int *__thiscall sub_1259FE0(int *this, LPCWSTR lpWideCharStr);
HANDLESANDDLLSLISTUSERPARAM *__cdecl sub_125A070(HWND hWnd, char a2, int a3, int a4, int a5, int a6, int a7, u_long hostlong, int a9, int port, int a11, int a12, int a13, int a14);
int __thiscall sub_125A4A0(int *this, __int16 a2);
int __cdecl sub_125A500(int a1);
int __stdcall sub_125A580(int, int, DWORD pSIRequested, PSECURITY_DESCRIPTOR pSID, int, int, int, int); // idb
HBRUSH __stdcall DllInfoPropWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM dwNewLong); // idb
BOOL __stdcall DllPropDlgProc(HWND hDlg, UINT a2, WPARAM wParam, CPropSheetDlg *pPropSheetDlg); // idb
MACRO_BOOL CDriver::Load();
HCURSOR __cdecl sub_125B490(HWND hWnd, CPropSheetDlg *pPropSheet); // idb
_BYTE *__thiscall sub_125B8D0(_DWORD *this);
void __cdecl sub_125B930(HANDLE hProcess, LPCVOID lpBaseAddress, int a3, int a4, int a5);
int __stdcall SortInFindDlgCallback(int Data1, int Data2, int col); // idb
HANDLE __stdcall Real_FindExecutableImageExW(const WCHAR *a1, const WCHAR *a2, WCHAR *a3);
HANDLE __stdcall Proxy_FindExecutableImageExW(LPCWSTR a1, LPCWSTR a2, int a3);
// int __userpurge SearchThreadProc@<eax>(signed int a1@<ebx>, _BYTE *pbCancelFindInFindDlg); idb
HWND __cdecl sub_125BDA0(HWND hWndParent);
int *__thiscall sub_125BDF0(int *this, int a2);
HLOCAL __cdecl sub_125BE70(wchar_t *Dst, size_t SizeInWords);
int __cdecl sub_125BEC0(int, int, wchar_t *Dst, size_t SizeInWords); // idb
unsigned int __cdecl sub_125BEF0(int a1, int InBuffer);
int __stdcall BackQueryObjectThreadProc(void *pTheadParam);
int __stdcall sub_125C090(DWORD nLengthNeeded); // idb
LPVOID __cdecl GetImageDescription(LPCVOID pBlock, int a2, unsigned __int16 a3, int a4);
__int16 *__cdecl sub_125C270(int a1, rsize_t SizeInWords);
void __cdecl sub_125C350(LPCWSTR *a1);
int __stdcall QueryDBGInfoThreadProc(FILETIME *a1); // idb
char __cdecl sub_125C400(int *a1, LVITEMUSERDATA *pUserData); // idb
char __cdecl sub_125C4F0(LPVOID lpInBuffer, int a2, int a3, int a4);
void __cdecl sub_125C750(wchar_t *szType, int a2, wchar_t *szTargetName, rsize_t SizeInWords, _DWORD *a5); // idb
int __cdecl sub_125CE20(DWORD BytesReturned, LPVOID lpOutBuffer); // idb
char __cdecl sub_125CF30(HANDLE hProcess, int a2);
HICON __cdecl sub_125D050(LPCWSTR pszPath, int a2);
char __cdecl sub_125D0C0(HANDLE hProcess, LPARAM lParam);
int __cdecl VerifySignatureOK(#1077 *TreeListItemData, char a2); // idb
_DWORD *__cdecl sub_125D9D0(_DWORD *a1);
_DWORD *__cdecl GetTopSystemHandleInfo(PSYSTEM_HANDLE_INFORMATION SystemHandleInfo, int NumberOfHandles, PSYSTEM_HANDLE_TABLE_ENTRY_INFO HandleTableEntry); // idb
struct _FILETIME __cdecl GetAllProcesses(_SYSTEM_PROCESS_INFORMATION **ppBuffer, size_t *pdwSizeReturned); // idb
DWORD __cdecl LoadSystemInfo(_SYSTEM_PROCESS_INFORMATION **pSystemProcessInfo, int *pcbSize, SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *pSysProcessorPerfInfo, _SYSTEM_INTERRUPT_INFORMATION *pInterruptInfo, SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION *pProcessorCycleTimeInfo, void *pInfo, int InfoSize);
void GetAllServicesName();
void __cdecl sub_125DD60(char a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int *a8);
int __cdecl sub_125E420(HANDLE hObject); // idb
int __cdecl sub_125E4B0(CMap *map, _SYSTEM_PROCESS_INFORMATION *SystemProcessInfo, SYSTEM_PERFORMANCE_INFORMATION *perfinfo, unsigned int InfoSize); // idb
signed int sub_125E920();
LPVOID __cdecl GetDescInfo(LPCVOID VerInfo, int a2);
DWORD __cdecl sub_125EB20(void *a1, PVOID *a2, DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, DWORD *a7);
BOOL __stdcall SystemInfoGPUnodesDlgProc(HWND, UINT, WPARAM, LPARAM); // idb
signed int __cdecl sub_125F3E0(int ThreadId, int a2, int a3);
char __cdecl FindSystemHandleInfo(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *a1); // idb
int __cdecl sub_125F4D0(int, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, PSECURITY_DESCRIPTOR pSecurityDescriptor, int); // idb
int __stdcall sub_125F580(int a1, int a2, int a3);
int __stdcall sub_125F5C0(int a1, int a2, int a3, int a4);
char __cdecl sub_125F600(_DWORD *a1, int a2, int a3, int a4);
int __thiscall sub_125F660(int *this, HMODULE hModule, int a3);
char LoadSystemCalls();
char sub_12601B0();
void __cdecl sub_12602C0(HANDLE hProcess, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_12603E0(HANDLE hProcess, int a2, int a3, int a4, int a5);
// DWORD __usercall sub_12607B0@<eax>(DWORD edi0@<edi>, CHAR *a1);
char __cdecl sub_1260A90(HANDLE hProcess, int a2, int a3, int a4);
StrNode *__cdecl StrInList(wchar_t *str); // idb
void __cdecl sub_1260DD0(wchar_t *a1);
int __cdecl sub_1260EE0(wchar_t *Dst); // idb
char __cdecl ErrMsxBox(int ArgList);
signed int __stdcall HanldeInfoDlgProc(HWND hWnd, int a3, unsigned __int16 a4, int a5);
int __stdcall SecurityPageProc(HWND hWnd, DWORD nLengthNeeded, DWORD pSIRequested, int); // idb
HANDLE __cdecl DuplicateProcessHandle(DWORD dwProcessId, HANDLE hSourceHandle, DWORD dwDesiredAccess);
int *__thiscall sub_1262330(int *this, int a2);
int __stdcall PerfGraphPageWndProc(HWND hWnd, int uMsg, WPARAM wParam, LONG dwNewLong); // idb
int __stdcall ProcEnvWndProc(HWND hWnd, int, WPARAM wParam, int); // idb
HBRUSH __stdcall ProcInfoPageProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM dwNewLong); // idb
int __stdcall ProcJOBWndProc(HWND hWnd, int msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall ProcGPUWndProc(HWND hWnd, int, WPARAM wParam, LONG dwNewLong); // idb
signed int __stdcall PerfPageWndProc(HWND hWnd, unsigned int uMsg, HDC wParam, CProcPerfInfo *pPageData); // idb
int __stdcall ProcPerfETWWndProc(HWND hWnd, int, HDC hdc, int); // idb
BOOL __stdcall ProcessPropsheetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, CPropSheetDlg *pDlgProp); // idb
void __cdecl __noreturn ProcessPropSheetThreadProc(TREELISTITEMPARAM *pTreeListItemData); // idb
int __stdcall sub_1267440(volatile LONG *lpAddend); // idb
int __stdcall ProcSecurityWndProc(HWND hWnd, int, WPARAM, int); // idb
int __stdcall ProcServicesWndProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam); // idb
// int __userpurge ProcTcpUdpStackWndProc@<eax>(signed int a1@<ebx>, HWND hWnd, int message, WPARAM wParam, int lParam); idb
int __stdcall ProcThreadsWndProc(HWND hWnd, int message, WPARAM wParam, int lParam); // idb
int __stdcall sub_126C7F0(#1077 *a1);
int __stdcall sub_126D400(int a1);
BOOL __stdcall ProcWMIProvidersWndProc(HWND hDlg, int a2, WPARAM wParam, int a4);
char __cdecl sub_126DA70(void *a1, int a2, _DWORD *a3, int a4);
HANDLE __cdecl PEOpenProcess(DWORD dwDesiredAccess, int a2, DWORD dwProcessId);
BOOL __cdecl sub_126DC50(HWND a1, int a2);
int __thiscall sub_126DE20(int *this, int a2);
_PSAPI_WORKING_SET_INFORMATION *__cdecl GetProcessWorkingSet(DWORD dwProcessId);
// char __usercall sub_126DF20@<al>(signed int a1@<edx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, WPARAM wParam);
int __thiscall sub_126F7C0(CDataInfo *this); // idb
// char __usercall sub_126F870@<al>(int a1@<ebx>, int a2, int a3, int a4, DWORD dwProcessId, int a6, int a7, int a8);
BOOL __stdcall ServiceControlDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam); // idb
BOOL __cdecl SetDlgItemULong(HWND hDlg, int nIDDlgItem, int ArgList, int nValue); // idb
BOOL __cdecl SetDlgItemULong64(HWND hDlg, int nIDDlgItem, ULONG64 value);
BOOL (__stdcall *__thiscall sub_12704E0(_DWORD *this, int a2, int a3))(HWND hWnd, LPRECT lpRect);
void (__stdcall *__thiscall sub_1270510(_DWORD *this, int a2, int a3, int a4))(HWND hWnd, LPRECT lpRect);
BOOL __thiscall CResize::Update(CResize *this, int nWndCount, HWND *pHwnds);
BOOL __stdcall sub_1270640(int a1, int a2, DWORD BytesReturned, LPVOID lpOutBuffer, DWORD nOutBufferSize, int a6);
int __cdecl sub_12706C0(char a1, int a2, int a3);
int __stdcall Real_SymLoadModuleExW(int, int, int, int, __int64, int);
int __stdcall Proxy_SymLoadModule64(int hProcess, int hFile, LPCWSTR pszImageName, LPCWSTR pszModuleName, int BaseOfDll, int BaseOfDll_4, int SizeOfDll); // idb
int __stdcall SysInfoCPUPageWndProc(HWND hWnd, int, HDC hdc, int); // idb
int __stdcall SysInfoGPUPageWndProc(HWND hWnd, int, HDC hdc, int); // idb
int __stdcall SysInfoIOPageWndProc(HWND hDlg, int, HDC hdc, int); // idb
int __stdcall SysInfoMemoryPageWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
int __stdcall SysInfoSummaryPageWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
_DWORD *__cdecl sub_12739C0(_DWORD *a1, int a2);
BOOL __stdcall ThreadStackDlgProc1(HWND hWnd, UINT uMsg, WPARAM wParam, NMLISTVIEW *lParam); // idb
BOOL __stdcall ThreadStackDlgProc(HWND hWnd, UINT uMsg, WPARAM a3, LPARAM dwNewLong); // idb
void __noreturn ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
MACRO_BOOL __stdcall EnumWindowsCallback(HWND hWnd, LPARAM dwPid);
// signed int __usercall sub_1275140@<eax>(int a1@<ebx>, int a2, _BYTE *pnFlags); idb
errno_t __cdecl sub_1275230(wchar_t *Dst, rsize_t SizeInWords, int a3);
int __cdecl sub_1275250(int *a1);
int __cdecl sub_1275310(int *a1);
void __cdecl InsertNodeToTail(wchar_t *str1, StrNode *pNode, wchar_t *str2); // idb
_DWORD *sub_1275440();
_DWORD *__thiscall sub_1275470(_DWORD *this);
CMapNode *__thiscall sub_12754B0(CMapNode *this, CMapNode *pNode); // idb
CSysProcItem **__thiscall sub_1275510(CSysProcItem *this, CSysProcItem **a2, CSysProcItem *_Left, CSysProcItem *_Right); // idb
CMapNode *__thiscall sub_12755B0(CMapNode *this, CMapNode *a2, CMapNode *left);
_DWORD *__thiscall sub_1275820(int *this, _DWORD *a2, unsigned int *a3);
int __cdecl sub_1275870(int a1, int a2);
// char __usercall DeleteItemFromListCtrl@<al>(signed int a1@<ebx>, HWND hWnd, LVITEMW *pItem, LVITEMUSERDATA2 *pUserData, int ResultReturned); idb
BOOL __cdecl DeviceIoControl_0(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize);
int __stdcall CGraph::GraphWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); // idb
char __cdecl sub_1276020(int a1);
volatile signed __int32 *__cdecl ShowHandleProperties(HWND a1, void *a2); // idb
int __cdecl StartProcessPropSheet(TREELISTITEMPARAM *a1);
BOOL __cdecl LaunchDllPropDlg(HACCEL hAccTable);
LRESULT __stdcall CDriver::Close(HDRVR hDriver, LONG lParam1, LONG lParam2);
bool GetProcessDEPStatus();
BOOL __stdcall FindDialogDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, NMLISTVIEW *lParam); // idb
void __cdecl sub_1277400(signed __int64 a1, double *a2, __int64 *a3, _QWORD *a4);
int __cdecl sub_1277720(int, wchar_t *Dst, rsize_t SizeInWords); // idb
int __cdecl sub_1277790(int, wchar_t *Dst, size_t SizeInWords); // idb
void *__cdecl GetSystemHandlesInfo(int ReturnedLength); // idb
signed int InitDriver();
LRESULT __cdecl InsertJobToList(HWND hWnd, LPCTSTR lpszText, LPCTSTR lpszSubitemText); // idb
char __cdecl sub_1278030(int ArgList, DWORD dwProcessId);
void __cdecl sub_1278140(int ArgList, int a2);
int __cdecl sub_1278310(int, int, wchar_t *Dst, rsize_t SizeInWords); // idb
bool __cdecl QueryProcessUserInfo(HANDLE ProcessHandle, int dwPid, int a3, wchar_t *Buffer1, rsize_t BufferSize1, WCHAR *Buffer2, rsize_t BufferSize2, LPWSTR Name, rsize_t cchName, int a10, int a11); // idb
int sub_1278790();
char __cdecl sub_1278A20(HANDLESANDDLLSLISTUSERPARAM *pRowInfo); // idb
int __cdecl ErrMsgBox(LPCTSTR lpszFormat, HWND hWnd); // idb
int __stdcall ProcStringsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
// char __usercall SearchDlls@<al>(CHAR *ImageName@<ebx>, HWND hWnd, DWORD dwProcessId, BOOL *bCancelFindInFindDlg); idb
// char __usercall SearchHandles@<al>(signed int a1@<ebx>, HWND a2, int a3, _BYTE *a4);
// char __usercall CTreeList::Initialize@<al>(HWND hWndTreeList, char flags);
HCURSOR __cdecl sub_127E3B0(int a1);
HCURSOR __cdecl SaveStringToFile(HWND hWnd, int ArgList);
BOOL __stdcall CpuAffinityDlgProc(HWND, UINT, WPARAM, LPARAM); // idb
int __cdecl sub_127EF00(HMENU hmenu, int); // idb
int __cdecl sub_127EFB0(unsigned int a1);
_DWORD *__cdecl sub_127F0A0(unsigned __int8 a1, int a2, _DWORD *a3);
bool __cdecl LoadDbgHelp(LPCTSTR lpLibFileName);
BOOL __stdcall SysInfoPropWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
bool __cdecl sub_127F8F0(double a1, double *a2);
char __cdecl sub_127F920(int a1, int a2, _DWORD *a3);
void __cdecl VerifySignatureThreadProc(#1077 *lpAddend); // idb
int __thiscall ATL::CComCriticalSection::Init(LPCRITICAL_SECTION lpCriticalSection); // idb
int sub_127F9B0(wchar_t *DstBuf, size_t MaxCount, wchar_t *Format, ...);
LRESULT __cdecl InitStatusBar(HWND hWnd);
int __cdecl OnTooltipGetDipsInfoW(int a1, int a2);
void __cdecl sub_127FCA0(int a1, __int64 a2);
char __cdecl sub_127FD50(CGraphData *a1, double a2, int a3, double a4); // idb
BOOL __cdecl sub_1280010(int a1, int a2, __int64 a3, __int64 a4, __int64 a5);
ProcessorInfo *__cdecl sub_1280130(ProcessorInfo *pProcessorInfo, int a2, __int64 a3, __int64 a4, __int64 a5); // idb
BOOL __cdecl sub_1280250(int a1, int a2, __int64 a3, __int64 a4, __int64 a5);
void __cdecl sub_1280360(int a1, __int64 a2);
// double *__usercall UpdateStatusBar@<eax>(double a1@<st0>, double st6_0@<st1>, double st5_0@<st2>, double st4_0@<st3>, double st3_0@<st4>, HWND a2, int a3, double *a4, __int64 *a5);
HWND __cdecl CreateRebar(HWND hWndParent, UINT uId); // idb
LPARAM GetToolbarButtonHeight();
_DWORD *__stdcall sub_1281420(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_1281440(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int *a5, int a6);
int __thiscall sub_1281650(_DWORD *this, int a2, _DWORD *a3, int *a4, int a5);
char sub_12817E0();
char __cdecl sub_1281820(ResizeInfo *a1); // idb
BOOL __cdecl sub_1281840(LPCWSTR lpFileName, wchar_t *Dest, int a3);
int __cdecl sub_1281A50(int, wchar_t *Dest); // idb
void CHttp::Initialize();
char __cdecl sub_1281C10(CString *a1); // idb
void __cdecl sub_1281C30(int a1, char a2, int a3);
int __stdcall sub_1281EC0(int a1);
int __stdcall sub_1282230(int a1);
LRESULT __stdcall pfnSubclass(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData); // idb
char __cdecl sub_1282910(int a1);
int __stdcall sub_1282970(int); // weak
_DWORD *__stdcall sub_1282A70(_DWORD *a1, _DWORD *a2);
void __stdcall sub_1282AB0(void *a1);
int *__thiscall sub_1282B40(void *this, int a2);
_DWORD *__thiscall sub_1282BB0(void *this, _DWORD *a2);
int __stdcall sub_1282C10(int, int, int);
_DWORD *__thiscall sub_1282CD0(int **this, _DWORD *a2, _DWORD *a3);
int **__thiscall sub_1282F90(int **this, int **a2, volatile LONG **a3);
HANDLE DumpProcessThreadProc();
signed int Usage();
int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);
wchar_t *__cdecl sub_12836C0(wchar_t *Src);
int __cdecl sub_1283720(int, int, wchar_t *, int, int); // idb
int __cdecl sub_12837B0(int *a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_12838A0(wchar_t *, int, int, int, int); // idb
signed int __cdecl sub_12839A0(int *a1);
int __cdecl sub_1283A00(int ArgList, int a2);
signed int __cdecl sub_1283CB0(int a1, int a2, void **a3);
// DWORD __stdcall WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);
// BOOL __stdcall SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
// LRESULT __stdcall DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
// DWORD __stdcall GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle);
// BOOL __stdcall GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
// BOOL __stdcall VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL __stdcall Module32FirstW(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
// BOOL __stdcall Module32NextW(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
// BOOL __stdcall Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
// BOOL __stdcall Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
// NTSTATUS __stdcall LsaFreeMemory(PVOID Buffer);
// NTSTATUS __stdcall LsaClose(LSA_HANDLE ObjectHandle);
// NTSTATUS __stdcall LsaOpenPolicy(PLSA_UNICODE_STRING SystemName, PLSA_OBJECT_ATTRIBUTES ObjectAttributes, ACCESS_MASK DesiredAccess, PLSA_HANDLE PolicyHandle);
// NTSTATUS __stdcall LsaEnumerateAccountRights(LSA_HANDLE PolicyHandle, PSID AccountSid, PLSA_UNICODE_STRING *UserRights, PULONG CountOfRights);
// BOOL __stdcall ConvertSidToStringSidW(PSID Sid, LPWSTR *StringSid);
void __stdcall __noreturn com_error::throw(int a1);
_DWORD *__thiscall sub_1284190(_DWORD *this, int a2);
HLOCAL __thiscall sub_12841D0(_DWORD *this);
HLOCAL *__thiscall sub_1284200(void *this, char a2);
void __cdecl __noreturn sub_1284240(int, int);
CHAR *__stdcall UTFToAscii(LPCWSTR lpWideCharStr);
BSTR __stdcall AsciiToUTF(LPCSTR lpString);
std::exception *__thiscall sub_1284501(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_128451C(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_1284537(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_1284552(std::exception *this, struct exception *a2);
void __thiscall sub_128456D(std::exception *this);
void *__thiscall sub_1284585(void *this, char a2);
void *__thiscall sub_12845AA(void *this, char a2);
// void __noreturn std::bad_alloc::bad_alloc();
// void __cdecl __noreturn std::_Xlength_error(const char *); idb
// void __cdecl __noreturn std::_Xout_of_range(const char *); idb
// void *__cdecl operator new[](unsigned int); idb
int __cdecl sub_128465F(int a1);
int __cdecl sub_1284689(int a1);
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *this, int); idb
// int __thiscall unknown_libname_5(_DWORD); weak
// _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
bool __cdecl __uncaught_exception(); // idb
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// _Cvtvec __cdecl _Getcvt();
// int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *, const _Cvtvec *);
// int __cdecl _Mbrtowc(wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
// int __cdecl _Getwctype(WCHAR SrcStr); idb
// int __cdecl _Towlower(wchar_t Src, int); idb
// int __cdecl _Towupper(wchar_t Src, int); idb
// _DWORD __thiscall sub_1284B60(std::_Fac_tidy_reg_t *__hidden this); idb
// void __cdecl std::_Facet_Register(struct std::_Facet_base *); idb
int sub_1284C4A();
// struct std::locale::_Locimp *__cdecl std::locale::_Init(bool); idb
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *); idb
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
// void __cdecl std::ios_base::_Addstd(struct std::ios_base *); idb
// void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *); idb
// int __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); idb
void __cdecl sub_1284F3E(LPCRITICAL_SECTION lpCriticalSection);
void __cdecl sub_1284F4C(LPCRITICAL_SECTION lpCriticalSection);
// _DWORD __thiscall sub_1284F5A(_Init_atexit *__hidden this); idb
_DWORD *__thiscall ATL::CAtlBaseModule::CAtlBaseModule(_DWORD *this);
_DWORD *__thiscall ATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(_DWORD *this);
void __thiscall ATL::CAtlBaseModule::~CAtlBaseModule(ATL::CAtlBaseModule *this);
char *__thiscall sub_1285067(CSimpleArray *this, int a2);
HINSTANCE __thiscall CAtlBaseModule::GetHInstanceAt(_ATL_BASE_MODULE70 *this, int a2);
void __thiscall ATL::_ATL_BASE_MODULE70::~_ATL_BASE_MODULE70(void **this);
void __cdecl j__free(void *);
// void *__cdecl memmove(void *, const void *, size_t);
// wchar_t *__cdecl _wcsdup(const wchar_t *);
// void __cdecl free(void *);
// void *__cdecl malloc(size_t);
// void *__cdecl realloc(void *, size_t);
// _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *); weak
// void *__cdecl memmove_0(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// void *__cdecl operator new(size_t); idb
// int __cdecl atexit(void (__cdecl *)());
// int __report_rangecheckfailure(void); weak
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isspace(int);
// int __cdecl isxdigit(int);
// int __cdecl toupper(int);
// int __cdecl iswalpha(wint_t);
// int __cdecl iswspace(wint_t);
// errno_t __cdecl memcpy_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount);
// wchar_t *__cdecl wcschr(const wchar_t *, wchar_t);
// errno_t __cdecl tcscpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
// int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
// errno_t __cdecl wcsncpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src, rsize_t MaxCount);
// wchar_t *__cdecl wcsrchr(const wchar_t *, wchar_t);
// wchar_t *__cdecl wcsstr(const wchar_t *, const wchar_t *);
// int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
// int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
// wchar_t *__cdecl _wcslwr(wchar_t *);
// errno_t __cdecl _wcslwr_s(wchar_t *Str, size_t SizeInWords);
// wchar_t *__cdecl _wcsupr(wchar_t *);
// errno_t __cdecl _wcsupr_s(wchar_t *Str, size_t Size);
void **sub_1287B15();
// int __cdecl fputws(const wchar_t *, FILE *);
// int fwprintf(FILE *, const wchar_t *, ...);
// int wprintf(const wchar_t *, ...);
// int wprintf_s(const wchar_t *Format, ...);
// int _snwprintf_s(wchar_t *DstBuf, size_t SizeInWords, size_t MaxCount, const wchar_t *Format, ...);
// int _swprintf(wchar_t *Dest, const wchar_t *Format, ...);
// int swprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, ...);
// int __cdecl vscan_fn(wchar_t *, int, int); idb
// int __cdecl vscan_fn(int, wchar_t *, int, int, int); idb
// wint_t __cdecl _fputwc_nolock(wchar_t Ch, FILE *File);
void __cdecl j_j__free(void *);
// int __cdecl _ismbcprint(unsigned int);
// void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD); weak
// void *__cdecl calloc(size_t, size_t);
// int __cdecl _wtoi(const wchar_t *);
// size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
// int __cdecl _beginthreadex(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, int, int, DWORD dwCreationFlags, LPDWORD lpThreadId); idb
// wchar_t *__cdecl fgetws(wchar_t *, int, FILE *);
// FILE *__cdecl _wfopen(const wchar_t *, const wchar_t *);
// errno_t __cdecl _wfopen_s(FILE **File, const wchar_t *Filename, const wchar_t *Mode);
// int __cdecl fclose(FILE *);
int __thiscall sub_12889CE(_DWORD *this);
void *__thiscall sub_12889FA(void *this, char a2);
// int __cdecl _vsnwprintf_s(wchar_t *DstBuf, size_t SizeInWords, size_t MaxCount, const wchar_t *Format, va_list ArgList);
// int __cdecl vswprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, va_list ArgList);
// int __cdecl _stricmp(const char *, const char *);
// char *__cdecl strrchr(const char *, int);
// errno_t __cdecl wcscat_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
// wchar_t *__cdecl _getws_s(wchar_t *Str, size_t SizeInWords);
int sub_128918B();
// int __cdecl fflush(FILE *);
// _DWORD __cdecl flsall(_DWORD); weak
// void __cdecl __noreturn exit(int);
// int printf(const char *, ...);
// int __cdecl _getch();
// wchar_t *__cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
std::exception *__thiscall sub_1289CF7(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_1289D12(std::exception *this, char *a2);
// _DWORD __thiscall std::exception::exception(std::exception *this, const char *const *); idb
// _DWORD __thiscall std::exception::exception(std::exception *this, const char *const *, int); idb
// _DWORD __thiscall std::exception::exception(std::exception *this, const struct exception *); idb
void __thiscall sub_1289D91(std::exception *this);
void *__thiscall sub_1289DCF(void *this, char a2);
// void __thiscall std::exception::_Tidy(std::exception *__hidden this); idb
// errno_t __cdecl memmove_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount);
// int __cdecl wmemcpy_s(void *, int, void *, int); idb
// int __cdecl _beginthread(int, SIZE_T dwStackSize, int); idb
// int _endthread(void); weak
// size_t __cdecl wcsnlen(const wchar_t *Src, size_t MaxCount);
// size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
// void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *));
// errno_t __cdecl strcpy_s(char *Dst, rsize_t SizeInBytes, const char *Src);
// errno_t __cdecl _strlwr_s(char *Str, size_t Size);
// int __cdecl vsprintf_s(char *DstBuf, size_t SizeInBytes, const char *Format, va_list ArgList);
// errno_t __cdecl _wsplitpath_s(const wchar_t *FullPath, wchar_t *Drive, size_t DriveSize, wchar_t *Dir, size_t DirSize, wchar_t *Filename, size_t FilenameSize, wchar_t *Ext, size_t ExtSize);
// wchar_t *__cdecl wcstok_s(wchar_t *Str, const wchar_t *Delim, wchar_t **Context);
// wchar_t *__cdecl _wctime32(const __time32_t *Time);
// int *__cdecl _errno();
// errno_t __cdecl _get_errno(int *Value);
// errno_t __cdecl _set_errno(int Value);
// unsigned int __cdecl wcstoul(const wchar_t *, wchar_t **, int);
// size_t __cdecl strlen(const char *);
std::exception *__thiscall sub_128B822(std::exception *this, struct exception *a2);
void __thiscall sub_128B83D(std::exception *this);
void *__thiscall sub_128B848(void *this, char a2);
// int __cdecl _malloc_crt(size_t); idb
// int __crtIsPackagedApp(void); weak
// int __cdecl __crtSetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); idb
void __cdecl sub_128D342(DWORD dwMilliseconds);
// size_t __cdecl wcslen(const wchar_t *);
void *__cdecl sub_128F821(void *a1);
// int _invalid_parameter_noinfo(void); weak
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
void *__cdecl sub_128F8CF(void *a1);
// _DWORD __cdecl _GET_RTERRMSG(_DWORD); weak
// const wchar_t *__cdecl _NMSG_WRITE(int a1);
DWORD sub_128FAF6();
// int _getptd(void); weak
void sub_129007A();
// const wchar_t *__cdecl CPtoLocaleName(int); idb
// int __cdecl iswctype(wint_t, wctype_t);
// int __cdecl __check_float_string(int, int, int, void *, int); idb
// _DWORD __cdecl _hextodec(_DWORD); weak
// _DWORD __cdecl _un_inc(__int16); weak
// int __cdecl _whiteout(int, FILE *File); idb
// int __cdecl _winput_l(int, int, struct localeinfo_struct *, int); idb
// int __cdecl _fileno(FILE *);
// errno_t __cdecl wctomb_s(int *SizeConverted, char *MbCh, rsize_t SizeInBytes, wchar_t WCh);
// wint_t __cdecl _fgetwc_nolock(FILE *File);
void *__cdecl sub_129533B(void *a1);
// _DWORD __cdecl unknown_libname_8(_DWORD); weak
void sub_1297C9C();
void __cdecl sub_1297CBC(); // idb
PVOID sub_1297CDC();
int __cdecl sub_1297EFA(int a1);
HANDLE sub_1298B73();
// int __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_1299F90();
int __cdecl sub_129A2BD(int a1);
// int __cdecl _set_error_mode(int);
// errno_t __cdecl wcstombs_s(size_t *PtNumOfCharConverted, char *Dst, size_t DstSizeInBytes, const wchar_t *Src, size_t MaxCountInBytes);
int *sub_129B1A0();
int *sub_129B1A6();
int *sub_129B1AC();
void **sub_129B1B2();
signed int __cdecl sub_129B1B8(_DWORD *a1);
signed int __cdecl sub_129B1E2(_DWORD *a1);
signed int __cdecl sub_129B20C(_DWORD *a1);
int __cdecl sub_129B5FC(const WCHAR *a1, int a2, int a3);
// BOOL __stdcall LangCountryEnumProc(LPWSTR); idb
// _DWORD __cdecl LcidFromHexString(_DWORD); weak
// _DWORD __cdecl TestDefaultCountry_0(_DWORD); weak
// _DWORD __cdecl TestDefaultLanguage(_DWORD, _DWORD); weak
int OnTreeListNotify7D1();
signed int __cdecl sub_129FE30(unsigned __int16 *a1, int *a2);
signed int __cdecl sub_12A03A2(unsigned __int16 *a1, int *a2);
signed int __cdecl sub_12A1B17(_DWORD *a1);
HANDLE sub_12A1C0E();
// DWORD __stdcall GetModuleFileNameExW(HANDLE hProcess, HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
int __cdecl SEH_402480(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_402D60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_403440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4035A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4038F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4314F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_403D40(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_404130(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_404890(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_404AC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_404F20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_404FB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4052B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_405520(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_405C70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_406440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_406090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4067A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_406CC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_406DD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4070E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_407CC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4085A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4087A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_409270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_409B70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425730(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40AB10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40B220(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40F2D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40F610(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40F9D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40FD00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_40FDF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_410460(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_410790(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_411150(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_411610(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_412090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_413160(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_413A80(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_414200(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_414FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_415FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_416A10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_416E10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_417000(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4177C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_417FE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_418050(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_418A90(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_418C20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4193C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_419580(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41A120(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41AD20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45ED60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41B1A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41D790(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41E3A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41EFE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41F0E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_41F260(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_420760(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_420EA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4211B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4013A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_421590(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_421860(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_422060(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_422110(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4227D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_423190(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_424040(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_424270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4244A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4245C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_424740(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_424920(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_424FE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425120(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425350(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425850(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425940(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425AB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_425D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_426830(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4269A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_426BB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_427AC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45E760(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_428730(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_428970(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_429580(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_42A1F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_42FAF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_431240(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_431560(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4318A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_431BC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_431FC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4337E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_434530(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_434810(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_434AA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_434F00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4355A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_437DF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_438150(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_438360(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_438570(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_438630(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_438CE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_439090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4391F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4392D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_439D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_439E70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43B100(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43B460(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43B780(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43BF00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43D080(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43D1D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43D3B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43D590(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43D670(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43DF10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43E1A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43EAD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43EBA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43EEA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43F0A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_43FFF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_469E00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_445F60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_446270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_451E50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4526B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_457640(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_457740(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4577E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_457DD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4580C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_458AE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_458C80(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_458D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_458E20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_459500(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_459C50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45A570(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45B0A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45B680(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45B8A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45C840(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45EE00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45D510(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45DCE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45E4E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_45E8B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_466900(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_469AF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_469C10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_469EA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46A670(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46ADD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46B930(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46BC50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46C350(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46DAF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46DD60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_46EC30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4703E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4723A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_472810(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_472C20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_473C50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_474990(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4766A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_477710(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_478E00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_479A30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_47ACF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_47D5B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4808E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4809B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4818B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_482010(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_4825E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_483260(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_483AF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_483FC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_491650(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_401FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_491C30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_491EC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_492230(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl SEH_494270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl sub_12AA093(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
int __cdecl sub_12AA0AE(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4);
void __cdecl sub_12AA0D0(); // idb
void __thiscall sub_12AA0F0(void *this);
void __cdecl sub_12AA150(); // idb
void __cdecl sub_12AA160(); // idb
void __cdecl sub_12AA1C0(); // idb
void __cdecl sub_12AA220(); // idb
void __cdecl sub_12AA230(); // idb
void __cdecl sub_12AA240(); // idb
void __cdecl sub_12AA250(); // idb
void __cdecl sub_12AA2D0(); // idb
void __cdecl sub_12AA2E0(); // idb
void __cdecl sub_12AA2F0(); // idb
void __cdecl sub_12AA300(); // idb
void __cdecl sub_12AA310(); // idb
void __cdecl sub_12AA320(); // idb
void __cdecl sub_12AA3F0(); // idb
void __cdecl sub_12AA4C0(); // idb
void __cdecl sub_12AA590(); // idb
void __cdecl sub_12AA610(); // idb
void __cdecl sub_12AA620(); // idb
void __cdecl sub_12AA630(); // idb
void __cdecl sub_12AA640(); // idb
void __cdecl sub_12AA660(); // idb
void __cdecl sub_12AA680(); // idb
void __cdecl sub_12AA700(); // idb
void __cdecl sub_12AA720(); // idb
void __cdecl sub_12AA7F0(); // idb
void __cdecl sub_12AA820(); // idb
void __cdecl sub_12AA840(); // idb
void __cdecl sub_12AA910(); // idb
void __cdecl sub_12AA970(); // idb
void __cdecl sub_12AA9D0(); // idb
void __cdecl sub_12AA9E0(); // idb
void __cdecl sub_12AA9F0(); // idb
void __cdecl sub_12AAA50(); // idb
void __cdecl sub_12AAB20(); // idb
void __cdecl sub_12AABA0(); // idb
void __cdecl sub_12AAC00(); // idb
void __cdecl sub_12AAC60(); // idb
void __cdecl sub_12AACC0(); // idb
void __cdecl sub_12AAD40(); // idb
void __cdecl sub_12AADC0(); // idb
void __cdecl sub_12AADF0(); // idb
void __cdecl sub_12AAE00(); // idb
void __cdecl sub_12AAED0(); // idb
void __cdecl sub_12AAFA0(); // idb
void __cdecl sub_12AB070(); // idb
void __cdecl sub_12AB0F0(); // idb
void __cdecl sub_12AB0FC(); // idb
void __cdecl sub_12AB106(); // idb
void __cdecl sub_12AB110(); // idb
void __cdecl sub_12AB11A(); // idb
void __cdecl sub_12AB124(); // idb
void __cdecl ATL::_dynamic_atexit_destructor_for___AtlBaseModule__(); // idb
// LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// BOOL __stdcall LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName);
// BOOL __stdcall SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
// BOOL __stdcall IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor);
// BOOL __stdcall GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded);
// BOOL __stdcall CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// LSTATUS __stdcall RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult);
// ULONG __stdcall FlushTraceW(TRACEHANDLE TraceHandle, LPCWSTR InstanceName, PEVENT_TRACE_PROPERTIES Properties);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// DWORD __stdcall SetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// DWORD __stdcall GetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// BOOL __stdcall AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
// BOOL __stdcall GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce);
// BOOL __stdcall AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength);
// BOOL __stdcall InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// PUCHAR __stdcall GetSidSubAuthorityCount(PSID pSid);
// PDWORD __stdcall GetSidSubAuthority(PSID pSid, DWORD nSubAuthority);
// PSID_IDENTIFIER_AUTHORITY __stdcall GetSidIdentifierAuthority(PSID pSid);
// BOOL __stdcall IsValidSid(PSID pSid);
// BOOL __stdcall SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength);
// BOOL __stdcall QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// BOOL __stdcall CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid);
// BOOL __stdcall RevertToSelf();
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// BOOL __stdcall EqualSid(PSID pSid1, PSID pSid2);
// BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// DWORD __stdcall GetLengthSid(PSID pSid);
// ULONG __stdcall CloseTrace(TRACEHANDLE TraceHandle);
// ULONG __stdcall ProcessTrace(PTRACEHANDLE HandleArray, ULONG HandleCount, LPFILETIME StartTime, LPFILETIME EndTime);
// TRACEHANDLE __stdcall OpenTraceW(PEVENT_TRACE_LOGFILEW Logfile);
// ULONG __stdcall ControlTraceW(TRACEHANDLE TraceHandle, LPCWSTR InstanceName, PEVENT_TRACE_PROPERTIES Properties, ULONG ControlCode);
// ULONG __stdcall StartTraceW(PTRACEHANDLE TraceHandle, LPCWSTR InstanceName, PEVENT_TRACE_PROPERTIES Properties);
// BOOL __stdcall SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor);
// BOOL __stdcall QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// void __stdcall MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping);
// LSTATUS __stdcall RegCreateKey(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// BOOL __stdcall StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors);
// BOOL __stdcall QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
// PVOID __stdcall FreeSid(PSID pSid);
// BOOL __stdcall LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// BOOL __stdcall LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// BOOL __stdcall LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// BOOL __stdcall ImpersonateLoggedOnUser(HANDLE hToken);
// BOOL __stdcall DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken);
// LSTATUS __stdcall RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey);
// LSTATUS __stdcall RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName);
// LSTATUS __stdcall RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile);
// LSTATUS __stdcall RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// LSTATUS __stdcall RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
// LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey);
// LSTATUS __stdcall RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
// BOOL __stdcall CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// BOOL __stdcall CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptDestroyHash(HCRYPTHASH hHash);
// LSTATUS __stdcall RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName);
// BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject);
// SC_HANDLE __stdcall OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// SC_HANDLE __stdcall OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// BOOL __stdcall ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// HIMAGELIST __stdcall ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
// HWND __stdcall CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);
// HPROPSHEETPAGE __stdcall CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
// HWND __stdcall CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, UINT uStructSize);
// int __stdcall ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
// int __stdcall ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
// BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce);
// BOOL __stdcall ImageList_Destroy(HIMAGELIST himl);
// BOOL __stdcall ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
// void __stdcall InitCommonControls();
// INT_PTR __stdcall PropertySheetW(LPCPROPSHEETHEADERW);
// HWND __stdcall FindTextW(LPFINDREPLACEW);
// BOOL __stdcall ChooseColorW(LPCHOOSECOLORW);
// BOOL __stdcall GetSaveFileNameW(LPOPENFILENAMEW);
// BOOL __stdcall GetOpenFileNameW(LPOPENFILENAMEW);
// BOOL __stdcall PrintDlgW(LPPRINTDLGW pPD);
// BOOL __stdcall ChooseFontW(LPCHOOSEFONTW);
// PCCERT_CONTEXT __stdcall CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext);
// DWORD __stdcall CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString);
// int __stdcall StartDocW(HDC hdc, const DOCINFOW *lpdi);
// int __stdcall SetMapMode(HDC hdc, int iMode);
// COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color);
// int __stdcall SetBkMode(HDC hdc, int mode);
// COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
// BOOL __stdcall GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
// int __stdcall EndDoc(HDC hdc);
// int __stdcall StartPage(HDC hdc);
// int __stdcall EndPage(HDC hdc);
// HFONT __stdcall CreateFontIndirectW(const LOGFONTW *lplf);
// BOOL __stdcall GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// UINT __stdcall SetTextAlign(HDC hdc, UINT align);
// BOOL __stdcall Polyline(HDC hdc, const POINT *apt, int cpt);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// int __stdcall SetROP2(HDC hdc, int rop2);
// int __stdcall SaveDC(HDC hdc);
// BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC);
// BOOL __stdcall Rectangle(HDC hdc, int left, int top, int right, int bottom);
// BOOL __stdcall LineTo(HDC hdc, int x, int y);
// HBITMAP __stdcall CreateDIBSection(HDC hdc, const BITMAPINFO *lpbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
// HRGN __stdcall CreateRectRgn(int x1, int y1, int x2, int y2);
// HRGN __stdcall CreateRectRgnIndirect(const RECT *lprect);
// HBRUSH __stdcall CreateSolidBrush(COLORREF color);
// BOOL __stdcall DeleteDC(HDC hdc);
// COLORREF __stdcall GetBkColor(HDC hdc);
// int __stdcall GetBkMode(HDC hdc);
// int __stdcall GetDeviceCaps(HDC hdc, int index);
// HGDIOBJ __stdcall GetStockObject(int i);
// BOOL __stdcall RectInRegion(HRGN hrgn, const RECT *lprect);
// int __stdcall SelectClipRgn(HDC hdc, HRGN hrgn);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// BOOL __stdcall ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx);
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// SIZE_T __stdcall VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// DWORD __stdcall GetCurrentProcessId();
// DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// DWORD __stdcall SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// HANDLE __stdcall OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
// BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
// DWORD __stdcall SuspendThread(HANDLE hThread);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// BOOL __stdcall ResetEvent(HANDLE hEvent);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
// int __stdcall lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
// void __stdcall GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
// BOOL __stdcall SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// DWORD __stdcall GetProcessId(HANDLE Process);
// BOOL __stdcall PulseEvent(HANDLE hEvent);
// BOOL __stdcall SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);
// BOOL __stdcall GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize);
// BOOL __stdcall DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// UINT __stdcall GetDriveTypeW(LPCWSTR lpRootPathName);
// DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// PVOID __stdcall DecodePointer(PVOID Ptr);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// DWORD __stdcall ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall IsDebuggerPresent();
// PVOID __stdcall EncodePointer(PVOID Ptr);
// int __stdcall lstrlenA(LPCSTR lpString);
// int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
// BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// HANDLE __stdcall OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// void __stdcall SetLastError(DWORD dwErrCode);
// BOOL __stdcall IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax);
// BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// BOOL __stdcall GlobalUnlock(HGLOBAL hMem);
// LPVOID __stdcall GlobalLock(HGLOBAL hMem);
// HGLOBAL __stdcall GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// HRSRC __stdcall FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// HANDLE __stdcall GetProcessHeap();
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// LPWSTR __stdcall GetCommandLineW();
// DWORD __stdcall GetFileType(HANDLE hFile);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// ATOM __stdcall GlobalAddAtomW(LPCWSTR lpString);
// DWORD __stdcall GetTickCount();
// int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator);
// BOOL __stdcall GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// BOOL __stdcall GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// HANDLE __stdcall GetCurrentThread();
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// HMODULE __stdcall GetModuleHandle(LPCWSTR lpModuleName);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// DWORD __stdcall GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
// HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// DWORD __stdcall GetFileAttributesW(LPCWSTR lpFileName);
// int __stdcall GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
// int __stdcall GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// int __stdcall GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// HANDLE __stdcall CreateFile(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// UINT __stdcall GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
// void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);
// DWORD __stdcall ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// BOOL __stdcall SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);
// BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// DWORD __stdcall TlsAlloc();
// int __stdcall lstrlenW(LPCWSTR lpString);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// BOOL __stdcall FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// BOOL __stdcall FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// void __stdcall Sleep(DWORD dwMilliseconds);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// UINT __stdcall SetErrorMode(UINT uMode);
// DWORD __stdcall GetLastError();
// void __stdcall __noreturn ExitThread(DWORD dwExitCode);
// HANDLE __stdcall GetCurrentProcess();
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// DWORD __stdcall GetVersion();
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
// HRESULT __stdcall SafeArrayGetLBound(SAFEARRAY *psa, UINT nDim, LONG *plLbound);
// BSTR __stdcall SysAllocStringLen(const OLECHAR *strIn, UINT ui);
// HRESULT __stdcall SafeArrayGetElement(SAFEARRAY *psa, LONG *rgIndices, void *pv);
// HRESULT __stdcall SafeArrayUnaccessData(SAFEARRAY *psa);
// HRESULT __stdcall SafeArrayAccessData(SAFEARRAY *psa, void **ppvData);
// BSTR __stdcall SysAllocString(const OLECHAR *psz);
// void __stdcall SysFreeString(BSTR bstrString);
// UINT __stdcall SysStringLen(BSTR);
// BSTR __stdcall SysAllocStringByteLen(LPCSTR psz, UINT len);
// void __stdcall VariantInit(VARIANTARG *pvarg);
// HRESULT __stdcall VariantClear(VARIANTARG *pvarg);
// HRESULT __stdcall VariantChangeType(VARIANTARG *pvargDest, const VARIANTARG *pvarSrc, USHORT wFlags, VARTYPE vt);
// HRESULT __stdcall SafeArrayDestroy(SAFEARRAY *psa);
// HRESULT __stdcall SafeArrayGetUBound(SAFEARRAY *psa, UINT nDim, LONG *plUbound);
// HDEVINFO __stdcall SetupDiGetClassDevsW(const GUID *ClassGuid, PCWSTR Enumerator, HWND hwndParent, DWORD Flags);
// BOOL __stdcall SetupDiGetDeviceInterfaceDetailW(HDEVINFO DeviceInfoSet, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData, DWORD DeviceInterfaceDetailDataSize, PDWORD RequiredSize, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, const GUID *InterfaceClassGuid, DWORD MemberIndex, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData);
// BOOL __stdcall SetupDiDestroyDeviceInfoList(HDEVINFO DeviceInfoSet);
// BOOL __stdcall SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
// HRESULT __stdcall SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);
// LPITEMIDLIST __stdcall SHBrowseForFolderW(LPBROWSEINFOW lpbi);
// HRESULT __stdcall SHGetMalloc(IMalloc **ppMalloc);
// BOOL __stdcall Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
// BOOL __stdcall ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo);
// DWORD_PTR __stdcall SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
// HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// COLORREF __stdcall ColorHLSToRGB(WORD wHue, WORD wLuminance, WORD wSaturation);
// void __stdcall ColorRGBToHLS(COLORREF clrRGB, WORD *pwHue, WORD *pwLuminance, WORD *pwSaturation);
// HRESULT __stdcall IUnknown_QueryService(IUnknown *punk, const GUID *const guidService, const IID *const riid, void **ppvOut);
// HRESULT __stdcall UrlUnescapeW(LPWSTR pszUrl, LPWSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
// HWND __stdcall GetWindow(HWND hWnd, UINT uCmd);
// HWND __stdcall GetDesktopWindow();
// BOOL __stdcall KillTimer(HWND hWnd, UINT_PTR uIDEvent);
// DWORD __stdcall MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
// int __stdcall GetDlgCtrlID(HWND hWnd);
// BOOL __stdcall CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);
// LRESULT __stdcall SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);
// BOOL __stdcall PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// BOOL __stdcall GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded);
// BOOL __stdcall SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID);
// BOOL __stdcall IsDialogMessageW(HWND hDlg, LPMSG lpMsg);
// BOOL __stdcall DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
// BOOL __stdcall CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags);
// HWND __stdcall WindowFromPoint(POINT Point);
// BOOL __stdcall RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// BOOL __stdcall RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags);
// HMENU __stdcall CreateMenu();
// BOOL __stdcall DrawMenuBar(HWND hWnd);
// HMENU __stdcall LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
// int __stdcall TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// HACCEL __stdcall LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName);
// BOOL __stdcall IsWindowEnabled(HWND hWnd);
// UINT __stdcall GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);
// HWND __stdcall CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall IsWindow(HWND hWnd);
// void __stdcall PostQuitMessage(int nExitCode);
// BOOL __stdcall ExitWindowsEx(UINT uFlags, DWORD dwReason);
// LRESULT __stdcall DispatchMessageW(const MSG *lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// BOOL __stdcall GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);
// UINT __stdcall RegisterWindowMessageW(LPCWSTR lpString);
// HDC __stdcall GetWindowDC(HWND hWnd);
// BOOL __stdcall SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii);
// BOOL __stdcall IsIconic(HWND hWnd);
// BOOL __stdcall ShowWindowAsync(HWND hWnd, int nCmdShow);
// BOOL __stdcall SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// BOOL __stdcall EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);
// DWORD __stdcall SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);
// int __stdcall GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
// BOOL __stdcall InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
// BOOL __stdcall TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);
// BOOL __stdcall ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// BOOL __stdcall AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// int __stdcall GetMenuItemCount(HMENU hMenu);
// UINT __stdcall GetMenuItemID(HMENU hMenu, int nPos);
// BOOL __stdcall EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// HMENU __stdcall CreatePopupMenu();
// BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable);
// UINT __stdcall IsDlgButtonChecked(HWND hDlg, int nIDButton);
// BOOL __stdcall CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck);
// BOOL __stdcall GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
// HANDLE __stdcall LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);
// BOOL __stdcall SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl);
// ATOM __stdcall RegisterClassW(const WNDCLASSW *lpWndClass);
// LRESULT __stdcall DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
// LRESULT __stdcall DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
// HICON __stdcall CreateIconIndirect(PICONINFO piconinfo);
// int __stdcall FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint);
// BOOL __stdcall IsWindowVisible(HWND hWnd);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// int __stdcall GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
// BOOL __stdcall EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
// BOOL __stdcall PtInRect(const RECT *lprc, POINT pt);
// BOOL __stdcall UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// BOOL __stdcall CopyRect(LPRECT lprcDst, const RECT *lprcSrc);
// BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint);
// BOOL __stdcall EmptyClipboard();
// HANDLE __stdcall SetClipboardData(UINT uFormat, HANDLE hMem);
// BOOL __stdcall CloseClipboard();
// BOOL __stdcall OpenClipboard(HWND hWndNewOwner);
// BOOL __stdcall IsZoomed(HWND hWnd);
// BOOL __stdcall EndDeferWindowPos(HDWP hWinPosInfo);
// HDWP __stdcall DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags);
// HDWP __stdcall BeginDeferWindowPos(int nNumWindows);
// BOOL __stdcall DrawFrameControl(HDC, LPRECT, UINT, UINT);
// HWND __stdcall ChildWindowFromPoint(HWND hWndParent, POINT Point);
// BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
// INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// BOOL __stdcall SetWindowTextW(HWND hWnd, LPCWSTR lpString);
// HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem);
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// INT_PTR __stdcall DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi);
// int __stdcall SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// HWND __stdcall GetParent(HWND hWnd);
// DWORD __stdcall GetClassLongW(HWND hWnd, int nIndex);
// LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong);
// LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex);
// BOOL __stdcall OffsetRect(LPRECT lprc, int dx, int dy);
// BOOL __stdcall IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// BOOL __stdcall InflateRect(LPRECT lprc, int dx, int dy);
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// HBRUSH __stdcall GetSysColorBrush(int nIndex);
// DWORD __stdcall GetSysColor(int nIndex);
// int __stdcall MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
// BOOL __stdcall GetCursorPos(LPPOINT lpPoint);
// LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// DWORD __stdcall WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// HWND __stdcall SetFocus(HWND hWnd);
// HMENU __stdcall GetMenu(HWND hWnd);
// DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);
// HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos);
// BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// BOOL __stdcall DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// HANDLE __stdcall GetPropW(HWND hWnd, LPCWSTR lpString);
// BOOL __stdcall SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
// int __stdcall ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags);
// BOOL __stdcall ValidateRect(HWND hWnd, const RECT *lpRect);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// int __stdcall GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
// BOOL __stdcall GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// int __stdcall GetSystemMetrics(int nIndex);
// UINT_PTR __stdcall SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// BOOL __stdcall ReleaseCapture();
// BOOL __stdcall SetForegroundWindow(HWND hWnd);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// HCURSOR __stdcall SetCursor(HCURSOR hCursor);
// HWND __stdcall FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
// HWND __stdcall FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);
// DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId);
// HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
// HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
// BOOL __stdcall DestroyIcon(HICON hIcon);
// BOOL __stdcall EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode);
// HDC __stdcall GetDC(HWND hWnd);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// HWND __stdcall SetCapture(HWND hWnd);
// HWND __stdcall GetCapture();
// SHORT __stdcall GetKeyState(int nVirtKey);
// HWND __stdcall GetFocus();
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// ATOM __stdcall RegisterClassExW(const WNDCLASSEXW *);
// LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// LRESULT __stdcall DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
// HINTERNET __stdcall WinHttpOpenRequest(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR *ppwszAcceptTypes, DWORD dwFlags);
// BOOL __stdcall WinHttpSetOption(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength);
// BOOL __stdcall WinHttpQueryDataAvailable(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
// BOOL __stdcall WinHttpSendRequest(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
// BOOL __stdcall WinHttpReadData(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// HINTERNET __stdcall WinHttpConnect(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
// BOOL __stdcall WinHttpCloseHandle(HINTERNET hInternet);
// HINTERNET __stdcall WinHttpOpen(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
// BOOL __stdcall WinHttpReceiveResponse(HINTERNET hRequest, LPVOID lpReserved);
// BOOL __stdcall WinHttpQueryHeaders(HINTERNET hRequest, DWORD dwInfoLevel, LPCWSTR pwszName, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// BOOL __stdcall WinHttpGetProxyForUrl(HINTERNET hSession, LPCWSTR lpcwszUrl, WINHTTP_AUTOPROXY_OPTIONS *pAutoProxyOptions, WINHTTP_PROXY_INFO *pProxyInfo);
// BOOL __stdcall WinHttpWriteData(HINTERNET hRequest, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD lpdwNumberOfBytesWritten);
// u_long __stdcall ntohl(u_long netlong);
// u_long __stdcall htonl(u_long hostlong);
// u_short __stdcall htons(u_short hostshort);
// struct hostent *__stdcall gethostbyaddr(const char *addr, int len, int type);
// struct servent *__stdcall getservbyport(int port, const char *proto);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// u_short __stdcall ntohs(u_short netshort);
// int __stdcall CredUIPromptForCredentialsW(PCREDUI_INFO pUiInfo, PCTSTR pszTargetName, HANDLE Reserved, DWORD dwAuthError, PCTSTR pszUserName, ULONG ulUserNameMaxChars, PCTSTR pszPassword, ULONG ulPasswordMaxChars, PBOOL pfSave, DWORD dwFlags);
// HRESULT __stdcall CoGetInterfaceAndReleaseStream(LPSTREAM pStm, const IID *const iid, LPVOID *ppv);
// HRESULT __stdcall CoInitialize(LPVOID pvReserved);
// HRESULT __stdcall CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);
// HRESULT __stdcall CoCreateInstance(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// void __stdcall CoUninitialize();
// HRESULT __stdcall CoSetProxyBlanket(IUnknown *pProxy, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities);
// HRESULT __stdcall CoMarshalInterThreadInterfaceInStream(const IID *const riid, LPUNKNOWN pUnk, LPSTREAM *ppStm);
// void __stdcall CoTaskMemFree(LPVOID pv);
LSTATUS __stdcall RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
CRYPT_PROVIDER_SGNR *__stdcall WinVerifyTrust(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, BOOL fCounterSigner, DWORD idxCounterSigner);
CRYPT_PROVIDER_DATA *__stdcall WTHelperGetProvSignerFromChain(HANDLE hStateData);
BOOL __stdcall WTHelperProvDataFromStateData(HCATADMIN hCatAdmin, DWORD dwFlags);
BOOL __stdcall CryptCATAdminReleaseContext(HCATADMIN hCatAdmin, HCATINFO hCatInfo, DWORD dwFlags);
BOOL __stdcall CryptCATAdminReleaseCatalogContext(HCATINFO hCatInfo, CATALOG_INFO *psCatInfo, DWORD dwFlags);
BOOL __stdcall CryptCATCatalogInfoFromContext(HCATINFO hCatInfo, CATALOG_INFO *psCatInfo, DWORD dwFlags);
HCATINFO __stdcall CryptCATAdminEnumCatalogFromHash(HCATADMIN hCatAdmin, BYTE *pbHash, DWORD cbHash, DWORD dwFlags, HCATINFO *phPrevCatInfo);
BOOL __stdcall CryptCATAdminCalcHashFromFileHandle(HANDLE hFile, DWORD *pcbHash, BYTE *pbHash, DWORD dwFlags);
BOOL __stdcall CryptCATAdminAcquireContext(HCATADMIN *phCatAdmin, const GUID *pgSubsystem, DWORD dwFlags);
DWORD __stdcall CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz);
HCATINFO __stdcall CryptCATAdminAddCatalog(HCATADMIN hCatAdmin, PWSTR pwszCatalogFile, PWSTR pwszSelectBaseName, DWORD dwFlags);
BOOL __stdcall CryptCATAdminRemoveCatalog(HCATADMIN hCatAdmin, LPCWSTR pwszCatalogFile, DWORD dwFlags);
BOOL __stdcall IsCatalogFile(HANDLE hFile, WCHAR *pwszFileName);
BOOL __stdcall IsThemeActive();
HTHEME __stdcall OpenThemeData(HWND hwnd, LPCWSTR pszClassList);
HRESULT __stdcall DrawThemeBackground(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCRECT pRect, LPCRECT pClipRect);
HRESULT __stdcall CloseThemeData(HTHEME hTheme);
BOOL __stdcall gdwOpacity(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
HMONITOR __stdcall MonitorFromPoint(POINT pt, DWORD dwFlags);
BOOL __stdcall GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi);
BOOL __stdcall ConvertStringSidToSidA(LPCSTR StringSid, PSID *Sid);
BOOL __stdcall CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle);
BOOLEAN __stdcall SetSuspendState(BOOLEAN bHibernate, BOOLEAN bForce, BOOLEAN bWakeupEventsDisabled);
BOOL __stdcall LockWorkStation();
BOOLEAN __stdcall IsPwrHibernateAllowed();
BOOLEAN __stdcall IsPwrSuspendAllowed();
HPROPSHEETPAGE __stdcall CreateSecurityPage(LPSECURITYINFO psi);
DWORD __stdcall GetGuiResources(HANDLE hProcess, DWORD uiFlags);
DWORD __stdcall GetMappedFileNameW(HANDLE hProcess, LPVOID lpv, LPWSTR lpFilename, DWORD nSize);
DWORD __stdcall GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer);
BOOL __stdcall EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName);
BOOL __stdcall QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
BOOL __stdcall ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId);
BOOL __stdcall QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength);
BOOL __stdcall SymInitialize(HANDLE hProcess, LPSTR UserSearchPath, BOOL fInvadeProcess);
DWORD __stdcall SymGetOptions();
PVOID __stdcall SymFunctionTableAccess64(HANDLE hProcess, DWORD64 AddrBase);
BOOL __stdcall SymGetSymFromName(HANDLE hProcess, LPSTR Name, PIMAGEHLP_SYMBOL Symbol);
BOOL __stdcall SymFromAddrW(HANDLE hProcess, DWORD64 Address, PDWORD64 Displacement, PSYMBOL_INFOW Symbol);
BOOL __stdcall SymCleanup(HANDLE hProcess);
DWORD __stdcall SymSetOptions(DWORD SymOptions);
BOOL __stdcall StackWalk64(DWORD MachineType, HANDLE hProcess, HANDLE hThread, LPSTACKFRAME64 StackFrame, PVOID ContextRecord, PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine, PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine, PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine, PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress);
BOOL __stdcall QueryWorkingSet(HANDLE hProcess, PVOID pv, DWORD cb);
DWORD64 __stdcall SymLoadModuleExW(HANDLE hProcess, HANDLE hFile, PCWSTR ImageName, PCWSTR ModuleName, DWORD64 BaseOfDll, DWORD DllSize, PMODLOAD_DATA Data, DWORD Flags);
BOOL __stdcall SymUnloadModule64(HANDLE hProcess, DWORD64 BaseOfDll);
BOOL __stdcall SymGetModuleInfoW64(HANDLE hProcess, DWORD64 qwAddr, PIMAGEHLP_MODULEW64 ModuleInfo);
BOOL __stdcall EnumerateLoadedModulesW64(HANDLE hProcess, PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback, PVOID UserContext);
BOOL __stdcall EnumProcessModulesEx(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded, DWORD dwFilterFlag);
BOOL __stdcall SymRegisterCallback64(HANDLE hProcess, PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction, ULONG64 UserContext);
DWORD64 __stdcall SymGetModuleBase64(HANDLE hProcess, DWORD64 qwAddr);
PIMAGE_NT_HEADERS __stdcall ImageNtHeader(PVOID Base);
HANDLE __stdcall FindExecutableImage(LPSTR FileName, LPSTR SymbolPath, LPSTR ImageFilePath);
HANDLE __stdcall FindExecutableImageExW(PCWSTR FileName, PCWSTR SymbolPath, PWSTR ImageFilePath, PFIND_EXE_FILE_CALLBACKW Callback, PVOID CallerData);
BOOL __stdcall GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer);
BOOL __stdcall SetProcessAffinityMask(HANDLE hProcess, DWORD dwProcessAffinityMask);
DWORD __stdcall GetExtendedTcpTable(PVOID pTcpTable, PDWORD pdwSize, BOOL bOrder, ULONG ulAf, TCP_TABLE_CLASS TableClass, ULONG Reserved);
DWORD __stdcall GetExtendedUdpTable(PVOID pUdpTable, PDWORD pdwSize, BOOL bOrder, ULONG ulAf, UDP_TABLE_CLASS TableClass, ULONG Reserved);
ULONG __stdcall GetTcpTable(PMIB_TCPTABLE TcpTable, PULONG SizePointer, BOOL Order);
ULONG __stdcall GetUdpTable(PMIB_UDPTABLE UdpTable, PULONG SizePointer, BOOL Order);
BOOL __stdcall IsHungAppWindow(HWND hwnd);
DWORD __stdcall WTSGetActiveConsoleSessionId();
HANDLE __stdcall CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);
BOOL __stdcall MiniDumpWriteDump(HANDLE hProcess, DWORD ProcessId, HANDLE hFile, MINIDUMP_TYPE DumpType, PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
HANDLE __stdcall CreateToolhelp32Snapshot_0(DWORD dwFlags, DWORD th32ProcessID);
BOOL __stdcall Process32FirstW_0(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
BOOL __stdcall Process32NextW_0(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
BOOL __stdcall Thread32First_0(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL __stdcall Thread32Next_0(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL __stdcall Module32FirstW_0(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
BOOL __stdcall Module32NextW_0(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
BOOL __stdcall IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);
BOOL __stdcall GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);
BOOL __stdcall GetMenuInfo(HMENU, LPMENUINFO);
BOOL __stdcall SetMenuInfo(HMENU, LPCMENUINFO);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1228A40; // weak
_UNKNOWN loc_1228A70; // weak
char algn_1242FF0[16] = { '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '' }; // weak
char algn_126224B[5] = { '', '', '', '', '' }; // weak
_UNKNOWN loc_1285090; // weak
WCHAR gpszTargetName[2] = { 0u, 0u };
__int128 xmmword_12B28CC = 0x6D006100720067006F007200500025i64; // weak
double dbl_12B28DC =  1.056954221002778e-307; // weak
GUID CLSID_IShellItem2 = { 2124394707u, 37279u, 17159u, { 171u, 46u, 155u, 24u, 96u, 49u, 12u, 147u } }; // weak
GUID CLSID_ITask = { 344708388u, 41643u, 4558u, { 177u, 31u, 0u, 170u, 0u, 83u, 5u, 3u } }; // weak
IID CLSID_ITaskScheduler = { 344708391u, 41643u, 4558u, { 177u, 31u, 0u, 170u, 0u, 83u, 5u, 3u } }; // idb
IID CLSID_TaskServices = { 344708394u, 41643u, 4558u, { 177u, 31u, 0u, 170u, 0u, 83u, 5u, 3u } }; // idb
wchar_t aWinIni[9] = L"\\win.ini"; // weak
void *std::error_category::`vftable' = &sub_1214D30; // weak
IID CLSID_IWbemServices = { 2505497753u, 33420u, 4559u, { 163u, 126u, 0u, 170u, 0u, 50u, 64u, 199u } }; // idb
IID stru_12B2E34 = { 3692209799u, 29567u, 4559u, { 136u, 77u, 0u, 170u, 0u, 75u, 46u, 36u } }; // idb
void *EventConsumerDescBase::`vftable' = &_purecall; // weak
void *CommandLineEventConsumer::`vftable' = &sub_1215940; // weak
void *ActiveScriptEventConsumer::`vftable' = &sub_1215910; // weak
_UNKNOWN unk_12B362C; // weak
GUID CLSID_IDispatch = { 132096u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // weak
IID CLSID_IShellBrowser = { 136418u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
GUID CLSID_IShellFolderViewDual = { 3886133120u, 19862u, 4559u, { 150u, 12u, 0u, 128u, 199u, 244u, 238u, 133u } }; // weak
GUID CLSID_IShellView = { 136419u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // weak
IID stru_12B3910 = { 2244700416u, 19861u, 4559u, { 150u, 12u, 0u, 128u, 199u, 244u, 238u, 133u } }; // idb
GUID CLSID_IShellDispatch2 = { 2764474668u, 15273u, 4562u, { 157u, 234u, 0u, 192u, 79u, 177u, 97u, 98u } }; // weak
void *CThemedWindow::`vftable' = &_purecall; // weak
void *CTreeListData::`vftable' = &sub_121A460; // weak
void *CTreeList::`vftable' = &CTreeList::GetTitle; // weak
CHAR gszStatusBarText[4] = { '\0', '\0', '\0', '\0' }; // idb
void *CListViewData::`vftable' = &sub_121A460; // weak
__int128 xmmword_12B4280 = 0x1000000010000000100000001i64; // weak
__int128 xmmword_12B4290 = 0x1F4000001F40000000000000000i64; // weak
void *std::runtime_error::`vftable' = &sub_1228CB0; // weak
void *std::_Facet_base::`vftable' = &sub_1228C50; // weak
void *std::ctype<unsigned short>::`vftable' = &sub_1228C00; // weak
void *std::_System_error::`vftable' = &sub_1228CB0; // weak
_UNKNOWN unk_12BBEA4; // weak
void *std::system_error::`vftable' = &sub_1228CB0; // weak
void *std::ios_base::failure::`vftable' = &sub_1228CB0; // weak
void *std::ios_base::`vftable' = &sub_1228C80; // weak
void *std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable' = &sub_1228A2C; // weak
void *std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable' = &sub_1228B10; // weak
void *std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable' = &sub_1228A24; // weak
void *std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable' = &sub_1228A1C; // weak
void *std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable' = &sub_1228B60; // weak
void *std::basic_stringstream<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable' = &loc_1228A34; // weak
_UNKNOWN unk_12BBFB0; // weak
_DWORD dword_12BBFB8[2] = { 0, 88 }; // idb
GUID IID_IObjSecurity = { 2522858336u, 5887u, 4560u, { 145u, 203u, 0u, 170u, 0u, 187u, 183u, 35u } }; // weak
void *CObjSecurity::`vftable' = &sub_122ADE0; // weak
void *ATL::CWin32Heap::`vftable' = &ATL::CWin32Heap::Allocate; // weak
void *ATL::CAtlStringMgr::`vftable' = &ATL::CAtlStringMgr::Allocate; // weak
void *CResizer::`vftable' = &CResizer::GetName; // weak
void *Process::`vftable' = &sub_122D910; // weak
void *Runtime::`vftable' = &sub_122D940; // weak
void *Appdomain::`vftable' = &sub_122D8B0; // weak
void *Assembly::`vftable' = &sub_122D8E0; // weak
double doubleOnePointZero =  1.0; // weak
double doubleFourPointZero =  4.0; // weak
__m128d stru_12BCB40 = { {  0.0, ?flt } }; // weak
__m128d stru_12BCB50 = { { -1.0, -1.0 } };
double gdbMaxValue =  100.0; // weak
__int64 dbl_12BCDD8 = -4616189618054758400i64; // idb
GUID InterfaceClassGuid = { 480268672u, 42649u, 17674u, { 154u, 12u, 222u, 79u, 190u, 61u, 221u, 137u } }; // idb
COLORREF dword_12BD110[4] = { 0u, 0u, 0u, 1106247680u };
wchar_t aLight[] = L"-Light"; // idb
double dbl_12BE9C8 =  0.005; // weak
double dbl_12BE9E8 =  2.0; // weak
double dbl_12BE9F0 =  6.0; // weak
double dbl_12BE9F8 =  21.0; // weak
double dbl_12BEA00 =  200.0; // weak
double dbl_12BEA08 =  8213.0; // weak
double dbl_12BEA10 =  27856.0; // weak
double dbl_12BEA18 =  4605695.0; // weak
double dbl_12BEA20 =  4652870.0; // weak
double dbl_12BEA28 =  8388863.0; // weak
double dbl_12BEA30 =  8421504.0; // weak
double dbl_12BEA38 =  1.0551295e7; // weak
double dbl_12BEA40 =  4.294967295e9; // weak
__int128 xmmword_12BEA50 = 0x3000000020000000100000000i64; // weak
IID stru_12BF100 = { 260519583u, 42213u, 19708u, { 189u, 62u, 115u, 230u, 21u, 69u, 114u, 221u } }; // idb
IID stru_12BF110 = { 799777991u, 19881u, 16403u, { 150u, 151u, 32u, 204u, 63u, 212u, 15u, 133u } }; // idb
__int128 xmmword_12BF270 = 0xF0000000F0000000000000000i64; // weak
IID CLSID_CorpubPublish = { 75143744u, 25982u, 4563u, { 141u, 91u, 0u, 16u, 75u, 53u, 231u, 239u } }; // idb
IID IID_ICorPublish = { 2517868775u, 23144u, 4563u, { 143u, 132u, 0u, 160u, 201u, 180u, 213u, 12u } }; // idb
GUID stru_12BF3CC = { 2108457479u, 54190u, 19573u, { 155u, 103u, 146u, 128u, 26u, 73u, 125u, 68u } }; // weak
GUID stru_12BF3DC = { 3532602458u, 38452u, 16902u, { 165u, 9u, 71u, 117u, 82u, 238u, 251u, 16u } }; // weak
GUID stru_12BF3EC = { 3133953933u, 64477u, 18596u, { 150u, 159u, 2u, 217u, 50u, 183u, 70u, 52u } }; // weak
GUID stru_12BF3FC = { 827441293u, 19721u, 20379u, { 136u, 56u, 40u, 128u, 191u, 24u, 254u, 81u } }; // weak
GUID stru_12BF40C =
{
  3882671458u,
  18253u,
  17613u,
  { 186u, 105u, 55u, 183u, 149u, 119u, 37u, 173u }
}; // weak
void *SymbolInfo::`vftable' = &sub_12498D0; // weak
void *NativeFrame::`vftable' = &sub_12498D0; // weak
void *CCorDebugDataTarget::`vftable' = &sub_1249800; // weak
void *CCLRDebuggingLibraryProvider::`vftable' = &sub_1249780; // weak
void *MixedModeStackWalker::`vftable' = &sub_1249880; // weak
GUID stru_12BFB98 =
{
  4261862440u,
  18939u,
  17974u,
  { 164u, 163u, 232u, 13u, 180u, 174u, 17u, 108u }
}; // weak
GUID stru_12BFBA8 = { 1030709092u, 30008u, 4563u, { 141u, 91u, 0u, 16u, 75u, 53u, 231u, 239u } }; // weak
GUID stru_12BFBB8 = { 65168145u, 20342u, 4563u, { 136u, 198u, 0u, 96u, 151u, 148u, 84u, 24u } }; // weak
GUID stru_12BFBC8 = { 3106719735u, 40237u, 17860u, { 188u, 43u, 98u, 31u, 204u, 157u, 251u, 244u } }; // weak
GUID stru_12BFBD8 =
{
  2275191818u,
  19027u,
  18024u,
  { 184u, 227u, 203u, 132u, 115u, 203u, 24u, 127u }
}; // weak
GUID stru_12BFC40 = { 3229703132u, 53163u, 17534u, { 167u, 121u, 193u, 22u, 180u, 84u, 235u, 91u } }; // weak
GUID stru_12BFC50 = { 4166274755u, 24142u, 18119u, { 141u, 62u, 165u, 43u, 132u, 5u, 177u, 245u } }; // weak
GUID stru_12BFC60 = { 892903409u, 13956u, 19541u, { 162u, 238u, 33u, 15u, 38u, 198u, 14u, 94u } }; // weak
GUID stru_12BFD30 = { 65168148u, 20342u, 4563u, { 136u, 198u, 0u, 96u, 151u, 148u, 84u, 24u } }; // weak
__int128 xmmword_12C00E0 = 0x3969A8086000829A11D232049E814AADi64; // weak
wchar_t *off_12C00F0 = L"startime"; // weak
int dword_12C00F4[] = { 1 }; // weak
OLECHAR strIn = 0u; // idb
wchar_t *off_12C0410 = L"Send"; // weak
int dword_12C0414[] = { 2 }; // weak
wchar_t *off_12C06FC = L"Write"; // weak
int dword_12C0700[] = { 11 }; // weak
__int128 xmmword_12C6C30 = 0x16000000150000000400000003i64; // weak
__int128 xmmword_12C6C40 = 0x435000004440000041F00000434i64; // weak
__int128 xmmword_12C6C50 = 0x4A4000004A2000004A0000004A5i64; // weak
__int128 xmmword_12C6C60 = 0x53F000004440000041F00000434i64; // weak
__int128 xmmword_12C6C70 = 0x3FF00000000000003FF0000000000000i64; // weak
__int128 xmmword_12C7010 = 0x10000000100000000000000000i64; // weak
__int128 xmmword_12C7624 = 0x4500520041005700540046004F0053i64; // weak
__int128 xmmword_12C7634 = 0x730065007300730061006C0043005Ci64; // weak
__int128 xmmword_12C7644 = 0x5C004400490053004C0043005Ci64; // weak
IID IID_ITaskService = { 799777991u, 19881u, 16403u, { 150u, 151u, 32u, 204u, 63u, 212u, 15u, 133u } }; // idb
int dword_12C776C[44] =
{
  1926946360,
  1262418660,
  6157498,
  472641690,
  1968023323,
  1148535685,
  2186926493,
  1094122132,
  3562733927,
  1324324435,
  839339961,
  1374845642,
  3025618912,
  1115089831,
  3313838495,
  100675771,
  309091544,
  1104523912,
  2447687565,
  1557948996,
  1345911960,
  1131250431,
  312813703,
  3248323749,
  2546228977,
  1243245314,
  3206418076,
  2885686714,
  2010129827,
  1135251706,
  2781687477,
  1788123977,
  714880474,
  1106563927,
  2048967099,
  3421745601,
  1284500538,
  1309458968,
  2422357426,
  2727467812,
  3135588759,
  1287538865,
  3201721753,
  2763931174
}; // weak
int dword_12C781C[8] =
{
  1279091277,
  1235484011,
  3406411705,
  1206965052,
  1348378216,
  1186508681,
  374738851,
  936739626
}; // weak
_UNKNOWN unk_12C783C; // weak
IID CLSID_TaskScheduler = { 260519583u, 42213u, 19708u, { 189u, 62u, 115u, 230u, 21u, 69u, 114u, 221u } }; // idb
IID stru_12C79AC = { 3692209799u, 29567u, 4559u, { 136u, 77u, 0u, 170u, 0u, 75u, 46u, 36u } }; // idb
IID stru_12C7A7C = { 1167128593u, 7482u, 4560u, { 137u, 31u, 0u, 170u, 0u, 75u, 46u, 36u } }; // idb
IID CLSID_IShellLinkW = { 136441u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
GUID CLSID_SID_STopLevelBrowser = { 1284947520u, 37212u, 4559u, { 153u, 211u, 0u, 170u, 0u, 74u, 232u, 55u } }; // idb
GUID CLSID_IPersistFile = { 267u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // weak
GUID CLSID_IShellItemImageFactory = { 3166800761u, 47638u, 17455u, { 128u, 196u, 138u, 89u, 195u, 12u, 70u, 59u } }; // weak
IID RCSID_ShellLinkW = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
IID riid = { 691257217u, 31542u, 4562u, { 178u, 14u, 0u, 192u, 79u, 152u, 62u, 96u } }; // idb
IID stru_12C7B9C = { 2610977138u, 63144u, 4559u, { 164u, 66u, 0u, 160u, 201u, 10u, 143u, 57u } }; // idb
GUID CLSID_IUnknown = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // weak
int (__thiscall *std::_com_error::`vftable')(void *, char) = &sub_1284200; // weak
void *std::bad_alloc::`vftable' = &sub_1284585; // weak
void *std::logic_error::`vftable' = &sub_12845AA; // weak
void *std::length_error::`vftable' = &sub_12845AA; // weak
void *std::out_of_range::`vftable' = &sub_12845AA; // weak
_UNKNOWN unk_12C7C10; // weak
_UNKNOWN unk_12C7E68; // weak
GUID GUID_ATLVer110 =
{
  3544786984u,
  16696u,
  20436u,
  { 179u, 236u, 219u, 153u, 19u, 94u, 174u, 134u }
}; // weak
void *type_info::`vftable' = &sub_12889FA; // weak
void *std::exception::`vftable' = &sub_1289DCF; // weak
void *std::bad_cast::`vftable' = &sub_1289DCF; // weak
void *std::bad_exception::`vftable' = &sub_128B848; // weak
IID rclsid = { 4110913330u, 50513u, 4563u, { 137u, 185u, 0u, 0u, 248u, 31u, 226u, 33u } }; // idb
_UNKNOWN unk_12CF88C; // weak
_UNKNOWN unk_12CF894; // weak
int _TI2_AVruntime_error_std__ = 0; // weak
int _TI5_AVfailure_ios_base_std__ = 0; // weak
int _TI2_AVbad_cast_std__ = 0; // weak
int _TI1_AVCAtlException_ATL__ = 0; // weak
int _TI1J = 0; // weak
int _TI1_AV_com_error__ = 0; // weak
void *ghKLM = (void *)0x80000002; // idb
HKEY ghKCU = (HKEY)0x80000001; // idb
wchar_t *off_12DAA18 = L"Task Scheduler"; // idb
OLECHAR *off_12DAA1C = L"InprocServer32"; // idb
wchar_t *off_12DAA2C = L"Task Scheduler"; // idb
DWORD dwMilliseconds = 5000u; // idb
char byte_12DAA38 = '\x01'; // weak
int (__thiscall **off_12DAA3C[3])(void *, char) = { &off_12B2D90, &off_12B2DC4, &off_12B2E04 }; // weak
int (__thiscall **off_12DAA40[2])(void *, char) = { &off_12B2DC4, &off_12B2E04 }; // weak
int (__thiscall **off_12DAA44)(void *, char) = &off_12B2E04; // weak
GUID stru_12DC318 = { 11191659u, 52548u, 4560u, { 140u, 194u, 0u, 192u, 79u, 194u, 149u, 238u } }; // weak
GUID stru_12DC328 = { 11191659u, 52548u, 4560u, { 140u, 194u, 0u, 192u, 79u, 194u, 149u, 238u } }; // weak
wchar_t aYouMustAgreeTo[175] = L"You must agree to the VirusTotal Terms of Service and Privacy Policy before\ncontinuing. A browser window will open to:\n\n     https://www.virustotal.com/about/terms-of-service"; // weak
TextInfo gTextInfo[2] = { { 19612320, 1, 0, 19811760, "" }, { 0, 0, 0, 0, "" } };
char *off_12DC4C8[6] =
{
  "{\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033{\\fonttbl{\\f0\\fswiss\\fprq2\\fcharset0 Tahoma;}{\\f1\\fnil\\fcharset0 Calibri;}}",
  "{\\colortbl ;\\red0\\green0\\blue255;\\red0\\green0\\blue0;}",
  "{\\*\\generator Riched20 10.0.10240}\\viewkind4\\uc1 ",
  "\\pard\\brdrb\\brdrs\\brdrw10\\brsp20 \\sb120\\sa120\\b\\f0\\fs24 SYSINTERNALS SOFTWARE LICENSE TERMS\\fs28\\par",
  "\\pard\\sb120\\sa120\\b0\\fs19 These license terms are an agreement between Sysinternals (a wholly owned subsidiary of Microsoft Corporation) and you.  Please read them.  They apply to the software you are downloading from Systinternals.com, which includes the media on which you received it, if any.  The terms also apply to any Sysinternals\\par",
  "\\pard\\fi-363\\li720\\sb120\\sa120\\tx720\\'b7\\tab updates,\\par"
}; // weak
wchar_t *UserProtocal = L"SYSINTERNALS SOFTWARE LICENSE TERMS\nThese license terms are an agreement between Sysinternals(a wholly owned subsidiary of Microsoft Corporation) and you.Please read them.They apply to the software you are downloading from technet.microsoft.com / sysinternals, which includes the media on which you received it, if any.The terms also apply to any Sysinternals\n* updates,\n*supplements,\n*Internet - based services,\n*and support services\nfor this software, unless other terms accompany those items.If so, those terms apply.\nBY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.IF YOU DO NOT ACCEPT THEM, DO NOT USE THE SOFTWARE.\n\nIf you comply with these license terms, you have the rights below.\nINSTALLATION AND USER RIGHTS\nYou may install and use any number of copies of the software on your devices.\n\nSCOPE OF LICENSE\nThe software is licensed, not sold.This agreement only gives you some rights to use the software.Sysinternals reserves all other rights.Unless applicable law gives you more rights despite this limitation, you may use the software only as expressly permitted in this agreement.In doing so, you must comply with any technical limitations in the software that only allow you to use it in certain ways.You may not\n* work around any technical limitations in the software;\n*reverse engineer, decompile or disassemble the software, except and only to the extent that applicable law expressly permits, despite this limitation;\n*make more copies of the software than specified in this agreement or allowed by applicable law, despite this limitation;\n*publish the software for others to copy;\n*rent, lease or lend the software;\n*transfer the software or this agreement to any third party; or\n* use the software for commercial software hosting services.\n\nSENSITIVE INFORMATION\nPlease be aware that, similar to other debug tools that capture "; // idb
MSGHANDLER gpMsgHandlerEx = { 2, &dword_12DC590, NoWindow }; // idb
MSGHANDLER stru_12DC5BC = { 2, &dword_12DC5AC, NoWindow }; // idb
int gAccessMaskText = 131072; // weak
int *off_12DCB88 = &dword_12DC628; // weak
int dword_12DCB8C[] = { 11 }; // weak
wchar_t *off_12DCB90 = L"File"; // weak
GENERIC_MAPPING GenericMapping = { 1179785u, 1179926u, 1179808u, 2032127u }; // idb
GENERIC_MAPPING stru_12DCC38 = { 136208u, 132075u, 1179648u, 2035711u }; // idb
GENERIC_MAPPING stru_12DCC48 = { 133960u, 132274u, 1179648u, 2032639u }; // idb
GENERIC_MAPPING stru_12DCC58 = { 131213u, 131074u, 131440u, 983551u }; // idb
GUID *off_12DCC68 = &stru_12C7BAC; // weak
GUID *off_12DCCD8 = &stru_12C7BAC; // weak
GUID *off_12DCE08 = &stru_12C7BAC; // weak
GUID *off_12DCF18 = &stru_12C7BAC; // weak
GUID *off_12DD008 = &stru_12C7BAC; // weak
GUID *off_12DD098 = &stru_12C7BAC; // weak
GUID *off_12DD0E8 = &stru_12C7BAC; // weak
_UNKNOWN unk_12DD0F8; // weak
_UNKNOWN unk_12DD110; // weak
_UNKNOWN unk_12DD130; // weak
_UNKNOWN unk_12DD150; // weak
_UNKNOWN unk_12DD178; // weak
DWORD gdwNumberOfProcessColumn[12] =
{
  2622495u,
  5243940u,
  5243943u,
  2621444u,
  9830438u,
  9176073u,
  6553621u,
  29491222u,
  7208986u,
  11796522u,
  9176073u,
  19661911u
};
DWORD gdwNumberOfHandleColumnMap[] = { 6553621u, 29491222u };
DWORD gdwNumberODllColumnMap[] = { 7208986u, 11796522u, 9176073u, 19661911u };
WPARAM gdwProcessThreadSortColumnLast = 1u; // idb
char gbProcessSecurityUserListSortAscending = '\x01'; // weak
char gbProcessTcpDumpListAscending = '\x01'; // weak
char *proto[] = { "TCP" };
wchar_t *off_12DD238[13] =
{
  L"???",
  L"CLOSED",
  L"LISTENING",
  L"SYN_SENT",
  L"SYN_RCVD",
  L"ESTABLISHED",
  L"FIN_WAIT1",
  L"FIN_WAIT2",
  L"CLOSE_WAIT",
  L"CLOSING",
  L"LAST_ACK",
  L"TIME_WAIT",
  L"DELETE_TCB"
}; // weak
wchar_t aPsprotectedsig[448] =
{
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  78u,
  111u,
  110u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  65u,
  117u,
  116u,
  104u,
  101u,
  110u,
  116u,
  105u,
  99u,
  111u,
  100u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  67u,
  111u,
  100u,
  101u,
  71u,
  101u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  65u,
  110u,
  116u,
  105u,
  109u,
  97u,
  108u,
  119u,
  97u,
  114u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  76u,
  115u,
  97u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  87u,
  105u,
  110u,
  100u,
  111u,
  119u,
  115u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  115u,
  80u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  101u,
  100u,
  83u,
  105u,
  103u,
  110u,
  101u,
  114u,
  87u,
  105u,
  110u,
  84u,
  99u,
  98u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
int gdwStringIDVectorForProcessIageOfSelectCoumn[] =
{
  3,
  4,
  1055,
  1637,
  38,
  5,
  19,
  18,
  35,
  1087,
  7,
  1086,
  1059,
  1056,
  1060,
  1192,
  1114,
  1061,
  1032,
  1654,
  1033,
  25,
  1655,
  1656,
  1062,
  1063,
  1064,
  1065,
  1067,
  1066,
  1091,
  1092,
  1179,
  1068,
  1070,
  1072,
  1069,
  1071,
  1073,
  1326,
  1328,
  1335,
  1327,
  1329,
  1332,
  1333,
  1330,
  1609,
  1611,
  1613,
  1617,
  1618,
  1620,
  1610,
  1612,
  1614,
  1616,
  1619,
  1621,
  1622,
  1623,
  1625,
  1627,
  1630,
  1632,
  1634,
  1624,
  1626,
  1628,
  1631,
  1633,
  1635,
  1636,
  1650,
  1651,
  1652,
  1653,
  1181,
  1190,
  1196,
  1199,
  1667,
  1674,
  1673,
  1187,
  1670,
  1191,
  1193,
  1115,
  1116,
  1317,
  1118,
  1195,
  1200,
  1336,
  1338,
  40757,
  1180,
  1337,
  1339,
  1340,
  1341,
  1342,
  9,
  10,
  0
}; // idb
int dword_12DD798[] =
{
  1094,
  1095,
  1096,
  1097,
  1098,
  1099,
  1100,
  1101,
  1102,
  1103,
  1104,
  1105,
  1106,
  1107,
  1108,
  1109,
  1110
};
int dword_12DD7DC[] = { 20, 21, 39, 22, 1185, 1194, 1308 }; // idb
int dword_12DD7F8[] =
{
  23,
  24,
  40,
  42,
  25,
  30,
  1111,
  26,
  1033,
  1074,
  1115,
  1116,
  1317,
  1118,
  1187,
  1656,
  1190,
  1338,
  40757,
  1656,
  1670,
  0
}; // idb
GLOBALVAR *gGlobalVariables = &aWindowplacemen;
GLOBALVAR gColorGraphBkVar = { 19651260, 0, 0, 19831592, { { 0u, 0 } } }; // weak
GLOBALVAR gColorJobsVar[29] =
{
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } },
  { 0, 0, 0, 0, { { 0u, 0 } } }
};
wchar_t *off_12DE0BC[5] =
{
  L"SeShutdownPrivilege",
  L"SeChangeNotifyPrivilege",
  L"SeUndockPrivilege",
  L"SeIncreaseWorkingSetPrivilege",
  L"SeTimeZonePrivilege"
}; // weak
int dword_12DE0D0 = 32; // weak
int dword_12DE0D8 = 4294967295; // weak
int dword_12DE0DC = 1; // weak
wchar_t gszLocaleInfo = 46u; // idb
int dword_12DE100 = 4294967295; // weak
char gbFindHandlesOrDlls = '\x01'; // weak
int gnMenuLastColumnsetPosLast = 14; // idb
int gdwRefreshMenuId = 4294967295; // weak
MSGHANDLER gNormalWindowMsgHandler = { 34, &WindowMsgFunc, NormalWindow }; // idb
MSGHANDLER gNormalWindowCmdHandler = { 126, &gMenuMsgHandler2, NormalWindow }; // idb
int gnFileMenuPosLast = 5; // idb
wchar_t aActive[7] = L"Active"; // weak
char gbFINDDLGLISTAscending = '\x01'; // weak
wchar_t aExecutive[10] = L"Executive"; // weak
wchar_t aObject_0[7] = L"Object"; // weak
wchar_t aSpecialAccess[18] = L"Special Access..."; // weak
wchar_t *szHelpFileName = L"procexp.hlp"; // weak
int dword_12DFD10 = 2; // weak
_UNKNOWN unk_12DFED0; // weak
_UNKNOWN unk_12DFFB0; // weak
_UNKNOWN unk_12E0110; // weak
_UNKNOWN unk_12E01C0; // weak
_UNKNOWN unk_12E0280; // weak
_UNKNOWN unk_12E02F0; // weak
_UNKNOWN unk_12E0300; // weak
HANDLE theDriver = (HANDLE)0xFFFFFFFF; // idb
HANDLE ghSnapshot = (HANDLE)0xFFFFFFFF; // idb
DWORD g_dwProcessId = 4294967294u; // idb
REGUSERINFO gstrRegistryUser[6] =
{
  {
    {
      92u,
      82u,
      69u,
      71u,
      73u,
      83u,
      84u,
      82u,
      89u,
      92u,
      85u,
      83u,
      69u,
      82u,
      92u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    {
      72u,
      75u,
      67u,
      85u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    0u
  },
  {
    {
      72u,
      75u,
      85u,
      92u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    {
      72u,
      75u,
      67u,
      85u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    0u
  },
  {
    {
      92u,
      82u,
      69u,
      71u,
      73u,
      83u,
      84u,
      82u,
      89u,
      92u,
      85u,
      83u,
      69u,
      82u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    {
      72u,
      75u,
      85u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    0u
  },
  {
    {
      92u,
      82u,
      69u,
      71u,
      73u,
      83u,
      84u,
      82u,
      89u,
      92u,
      77u,
      65u,
      67u,
      72u,
      73u,
      78u,
      69u,
      92u,
      83u,
      89u,
      83u,
      84u,
      69u,
      77u,
      92u,
      67u,
      85u,
      82u,
      82u,
      69u,
      78u,
      84u,
      67u,
      79u,
      78u,
      84u,
      82u,
      79u,
      76u,
      83u,
      69u,
      84u,
      92u,
      72u,
      65u,
      82u,
      68u,
      87u,
      65u,
      82u,
      69u,
      32u,
      80u,
      82u,
      79u,
      70u,
      73u,
      76u,
      69u,
      83u,
      92u,
      67u,
      85u,
      82u,
      82u,
      69u,
      78u,
      84u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    {
      72u,
      75u,
      67u,
      67u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    0u
  },
  {
    {
      92u,
      82u,
      69u,
      71u,
      73u,
      83u,
      84u,
      82u,
      89u,
      92u,
      77u,
      65u,
      67u,
      72u,
      73u,
      78u,
      69u,
      92u,
      83u,
      79u,
      70u,
      84u,
      87u,
      65u,
      82u,
      69u,
      92u,
      67u,
      76u,
      65u,
      83u,
      83u,
      69u,
      83u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    {
      72u,
      75u,
      67u,
      82u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    0u
  },
  {
    {
      92u,
      82u,
      69u,
      71u,
      73u,
      83u,
      84u,
      82u,
      89u,
      92u,
      77u,
      65u,
      67u,
      72u,
      73u,
      78u,
      69u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    {
      72u,
      75u,
      76u,
      77u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u,
      0u
    },
    0u
  }
};
int dword_12E10B8 = 4294967294; // weak
int gdwProcessIdSearching = 4294967294; // weak
int gdwProcessIdOfSystemHandleInformation = 4294967295; // weak
size_t gdwSystemHandleInfoLength2 = 65536u; // idb
int dword_12E10C8 = 1; // weak
PSECURITY_DESCRIPTOR pSID = &dword_12EB208; // idb
PSECURITY_DESCRIPTOR off_12E10D0 = &dword_12ED208; // idb
int dword_12E10D4 = 4294967295; // weak
char gbResolveAddresses = '\x01'; // weak
int dword_12E10DC = 1; // weak
int dword_12E10E0 = 1; // weak
WPARAM gnItemSortedInFindDlg = 1u; // idb
int dword_12E10E8 = 4294967295; // weak
int dword_12E10EC = 4294967295; // weak
int dword_12E10F0 = 4294967295; // weak
int dword_12E10F4 = 4294967295; // weak
int dword_12E10F8 = 4294967295; // weak
int dword_12E10FC = 4294967295; // weak
int dword_12E1100 = 4294967295; // weak
int dword_12E1104 = 4294967295; // weak
double dbl_12E1108 = -1.0; // weak
double dbl_12E1110 = -1.0; // weak
double dbl_12E1118 = -1.0; // weak
double dbl_12E1120 = -1.0; // weak
double dbl_12E1128 = -1.0; // weak
double dbl_12E1130 = -1.0; // weak
CHAR szDescription[] =
{
  'Y',
  '\0',
  'o',
  '\0',
  'u',
  '\0',
  ' ',
  '\0',
  'm',
  '\0',
  'u',
  '\0',
  's',
  '\0',
  't',
  '\0',
  ' ',
  '\0',
  'a',
  '\0',
  'g',
  '\0',
  'r',
  '\0',
  'e',
  '\0',
  'e',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'o',
  '\0',
  ' ',
  '\0',
  'V',
  '\0',
  'i',
  '\0',
  'r',
  '\0',
  'u',
  '\0',
  's',
  '\0',
  'T',
  '\0',
  'o',
  '\0',
  't',
  '\0',
  'a',
  '\0',
  'l',
  '\0',
  '\'',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'e',
  '\0',
  'r',
  '\0',
  'm',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'o',
  '\0',
  'f',
  '\0',
  ' ',
  '\0',
  's',
  '\0',
  'e',
  '\0',
  'r',
  '\0',
  'v',
  '\0',
  'i',
  '\0',
  'c',
  '\0',
  'e',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'o',
  '\0',
  ' ',
  '\0',
  'u',
  '\0',
  's',
  '\0',
  'e',
  '\0',
  ' ',
  '\0',
  'V',
  '\0',
  'i',
  '\0',
  'r',
  '\0',
  'u',
  '\0',
  's',
  '\0',
  'T',
  '\0',
  'o',
  '\0',
  't',
  '\0',
  'a',
  '\0',
  'l',
  '\0',
  ' ',
  '\0',
  'f',
  '\0',
  'e',
  '\0',
  'a',
  '\0',
  't',
  '\0',
  'u',
  '\0',
  'r',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  '.',
  '\0',
  '\n',
  '\0',
  '\n',
  '\0',
  'W',
  '\0',
  'h',
  '\0',
  'e',
  '\0',
  'n',
  '\0',
  ' ',
  '\0',
  'y',
  '\0',
  'o',
  '\0',
  'u',
  '\0',
  ' ',
  '\0',
  'd',
  '\0',
  'o',
  '\0',
  ',',
  '\0',
  ' ',
  '\0',
  'P',
  '\0',
  'r',
  '\0',
  'o',
  '\0',
  'c',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'E',
  '\0',
  'x',
  '\0',
  'p',
  '\0',
  'l',
  '\0',
  'o',
  '\0',
  'r',
  '\0',
  'e',
  '\0',
  'r',
  '\0',
  ' ',
  '\0',
  'w',
  '\0',
  'i',
  '\0',
  'l',
  '\0',
  'l',
  '\0',
  ' ',
  '\0',
  's',
  '\0',
  'u',
  '\0',
  'b',
  '\0',
  'm',
  '\0',
  'i',
  '\0',
  't',
  '\0',
  ' ',
  '\0',
  'h',
  '\0',
  'a',
  '\0',
  's',
  '\0',
  'h',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'f',
  '\0',
  'o',
  '\0',
  'r',
  '\0',
  ' ',
  '\0',
  'f',
  '\0',
  'i',
  '\0',
  'l',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'l',
  '\0',
  'i',
  '\0',
  's',
  '\0',
  't',
  '\0',
  'e',
  '\0',
  'd',
  '\0',
  ' ',
  '\0',
  'i',
  '\0',
  'n',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'h',
  '\0',
  'e',
  '\0',
  ' ',
  '\0',
  'p',
  '\0',
  'r',
  '\0',
  'o',
  '\0',
  'c',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'a',
  '\0',
  'n',
  '\0',
  'd',
  '\0',
  ' ',
  '\0',
  'D',
  '\0',
  'L',
  '\0',
  'L',
  '\0',
  ' ',
  '\0',
  'v',
  '\0',
  'i',
  '\0',
  'e',
  '\0',
  'w',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'o',
  '\0',
  ' ',
  '\0',
  'V',
  '\0',
  'i',
  '\0',
  'r',
  '\0',
  'u',
  '\0',
  's',
  '\0',
  'T',
  '\0',
  'o',
  '\0',
  't',
  '\0',
  'a',
  '\0',
  'l',
  '\0',
  '.',
  '\0',
  'c',
  '\0',
  'o',
  '\0',
  'm',
  '\0',
  '.',
  '\0',
  ' ',
  '\0',
  'Y',
  '\0',
  'o',
  '\0',
  'u',
  '\0',
  ' ',
  '\0',
  'c',
  '\0',
  'a',
  '\0',
  'n',
  '\0',
  ' ',
  '\0',
  's',
  '\0',
  'u',
  '\0',
  'b',
  '\0',
  'm',
  '\0',
  'i',
  '\0',
  't',
  '\0',
  ' ',
  '\0',
  'a',
  '\0',
  ' ',
  '\0',
  'f',
  '\0',
  'i',
  '\0',
  'l',
  '\0',
  'e',
  '\0',
  '\'',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'c',
  '\0',
  'o',
  '\0',
  'n',
  '\0',
  't',
  '\0',
  'e',
  '\0',
  'n',
  '\0',
  't',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'b',
  '\0',
  'y',
  '\0',
  ' ',
  '\0',
  'u',
  '\0',
  's',
  '\0',
  'i',
  '\0',
  'n',
  '\0',
  'g',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'h',
  '\0',
  'e',
  '\0',
  ' ',
  '\0',
  'S',
  '\0',
  'u',
  '\0',
  'b',
  '\0',
  'm',
  '\0',
  'i',
  '\0',
  't',
  '\0',
  ' ',
  '\0',
  'b',
  '\0',
  'u',
  '\0',
  't',
  '\0',
  't',
  '\0',
  'o',
  '\0',
  'n',
  '\0',
  ' ',
  '\0',
  'o',
  '\0',
  'n',
  '\0',
  ' ',
  '\0',
  't',
  '\0',
  'h',
  '\0',
  'e',
  '\0',
  ' ',
  '\0',
  'p',
  '\0',
  'r',
  '\0',
  'o',
  '\0',
  'c',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'a',
  '\0',
  'n',
  '\0',
  'd',
  '\0',
  ' ',
  '\0',
  'D',
  '\0',
  'L',
  '\0',
  'L',
  '\0',
  ' ',
  '\0',
  'p',
  '\0',
  'r',
  '\0',
  'o',
  '\0',
  'p',
  '\0',
  'e',
  '\0',
  'r',
  '\0',
  't',
  '\0',
  'i',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  ' ',
  '\0',
  'd',
  '\0',
  'i',
  '\0',
  'a',
  '\0',
  'l',
  '\0',
  'o',
  '\0',
  'g',
  '\0',
  ' ',
  '\0',
  'b',
  '\0',
  'o',
  '\0',
  'x',
  '\0',
  'e',
  '\0',
  's',
  '\0',
  '.',
  '\0',
  '\0',
  '\0'
}; // idb
int (__cdecl *off_12E138C)(_DWORD, _DWORD) = &sub_1284240; // weak
VARIANTARG pvarg = { { { 10u, 0u, 0u, 0u, { ?flt } } } }; // idb
int __security_cookie = 3141592654; // weak
void *off_12E1568 = &gBuffer; // weak
DWORD dwTlsIndex = 4294967295u; // idb
HANDLE hObject = (HANDLE)0xFFFFFFFE; // idb
int dword_12E2430 = 28800; // weak
int dword_12E2434 = 1; // weak
int dword_12E2438 = 4294963696; // weak
void *off_12E24C0 = &unk_12E2440; // weak
int dword_12E2568 = 1024; // weak
int dword_12E256C = 4294966273; // weak
int dword_12E2570 = 53; // weak
int dword_12E2574 = 11; // weak
int dword_12E2578 = 64; // weak
int dword_12E257C = 1023; // weak
int dword_12E2580 = 128; // weak
int dword_12E2584 = 4294967169; // weak
int dword_12E2588 = 24; // weak
int dword_12E258C = 8; // weak
int dword_12E2590 = 32; // weak
int dword_12E2594 = 127; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFE; // idb
int dword_12E31C0 = 0; // weak
SystemMenuData *gpSysMenuData = NULL;
char byte_12E31C9 = '\0'; // weak
char byte_12E31CA = '\0'; // weak
DWORD gdwTlsIndex = 0u; // idb
int dword_12E31D8 = 0; // weak
int NtDeleteKey = 0; // weak
int (__stdcall *NtOpenKey)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *RtlNtStatusToDosError)(_DWORD) = NULL; // weak
int (__stdcall *NtCreateKey)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD) = NULL; // weak
__int16 gszSystemWinDirCopy[] = { 0, 0, 0, 0, 0,  }; // idb
struct _RTL_CRITICAL_SECTION stru_12E3400; // idb
wchar_t gszSystemWow64Directory; // idb
int (__stdcall *Wow64DisableWow64FsRedirection)(_DWORD); // weak
int (__stdcall *Wow64RevertWow64FsRedirection)(_DWORD); // weak
int dword_12E3628[140]; // weak
int dword_12E3858; // weak
char byte_12E3860[20]; // weak
HANDLE hToken; // idb
WCHAR gszSystemWinDir[];
WCHAR gszEnvValue[];
WCHAR gszProgrameFiles[];
int dword_12E48D4; // weak
int dword_12E48D8; // weak
wchar_t *gEnvPathName; // idb
void *dword_12E48E4; // idb
int ghCursorWait_0; // weak
int ghCursorHand_0; // weak
void *dword_12E48F0; // idb
void *dword_12E48F4; // idb
void *dword_12E48F8; // idb
void *dword_12E48FC; // idb
int dword_12E4900[200]; // weak
void *dword_12E4C20; // idb
int dword_12E4C24; // weak
int dword_12E4C28; // weak
void *gpszAutorunsDesc; // idb
void *dword_12E4C30; // idb
int dword_12E4C34; // weak
int (__stdcall *GetLongPathNameW_0)(_DWORD, _DWORD, _DWORD); // weak
int dword_12E4C40; // weak
void *dword_12E4C44; // idb
int dword_12E4C48; // weak
int RegLoadMUIStringW; // weak
void *dword_12E4C50; // idb
void *dword_12E4C54; // idb
char byte_12E4C58; // weak
int (__stdcall *QueryServiceConfig2W_0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_12E4C60; // weak
int (__stdcall *IsWow64Process)(_DWORD, _DWORD); // weak
int dword_12E4C68; // weak
int (__stdcall *GetSystemDefaultLocaleName)(_DWORD, _DWORD); // weak
int (__stdcall *GetUserDefaultLocaleName)(_DWORD, _DWORD); // weak
int (__stdcall *SHCreateItemFromParsingName)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_12E4C78; // weak
struct _RTL_CRITICAL_SECTION stru_12E4C80; // idb
struct _RTL_CRITICAL_SECTION stru_12E4C98; // idb
HANDLE dword_12E4CB8; // idb
HANDLE hEvent; // idb
char byte_12E4CCC; // weak
char byte_12E4CCD; // weak
int dword_12E4CD0; // weak
int dword_12E4CD8; // weak
int dword_12E4CE0; // weak
int dword_12E4CE4; // weak
void *stru_12E4CEC; // idb
void *dword_12E4CF4; // idb
int dword_12E4CF8; // weak
void *dword_12E4CFC; // idb
int dword_12E4D00; // weak
void *dword_12E4D04; // idb
int dword_12E4D08; // weak
void *dword_12E4D10; // idb
void *dword_12E4D14; // idb
int dword_12E4D1C; // weak
void *dword_12E4D20; // idb
void *dword_12E4D24; // idb
int dword_12E4D28; // weak
void *dword_12E4D2C; // idb
void *dword_12E4D30; // idb
int dword_12E4D34[5]; // weak
char byte_12E4D7C; // weak
HMODULE ghuxthemeModule; // idb
int gLogPixelsX; // idb
int gLogPixelsY; // idb
__int16 gAtomTreeListAtom; // weak
__int16 gAtomTreeListProperty;
HGDIOBJ ghPenDkShadow; // idb
int sbInited1; // weak
HGDIOBJ ghPenBlack; // idb
char byte_12E4DB0; // weak
int gnArgc; // weak
HWND ghButtonExplore; // idb
int dword_12E4DBC; // weak
int ghDefaultGUIFont; // weak
HGDIOBJ ghDefaultGUIFontUnderline; // idb
HCURSOR ghCursorHand; // idb
HCURSOR ghCursorArrow; // idb
int dword_12E4DD0; // weak
struct _RTL_CRITICAL_SECTION stru_12E4DD4; // idb
void *gList; // idb
int dword_12E4DF0; // weak
char byte_12E4DF4; // weak
CWin32Heap gWin32Heap;
int gbHeapInited; // weak
CAtlStringMgr `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr;
int (__cdecl *EnableTraceEx)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // idb
int gScreenWidth; // weak
int RtlNtStatusToDosError_0; // weak
int RtlInitUnicodeString; // weak
int (__stdcall *D3DKMTOpenAdapterFromDeviceName)(D3DKMT_OPENADAPTERFROMDEVICENAME *pName);
int D3DKMTCloseAdapter; // weak
int (__stdcall *D3DKMTQueryStatistics)(D3DKMT_QUERYSTATISTICS *);
int gdwAdapterRuntingTime; // idb
CList *gAdapterList;
HINSTANCE ghInstance; // idb
int gdwOsType; // weak
WCHAR PROCESSEXPLORER_WINDOWNAME[12];
WCHAR PROCESSEXPLORER_WINDOWNAME[40];
PE_EVENT_TRACE_PROPERTIES gEventTraceProperties; // idb
int dword_12E537C; // weak
int dword_12E5380; // weak
int dword_12E5390; // weak
#1077 *gpTreeListParamList;
FINDDLGLISTITEMPARAM *gpUserDataInFindDlg;
LVITEMUSERDATA *gpUserDataInVerifySignature;
WPARAM ghDefaultFont; // idb
HGDIOBJ ghDefaultFontUnderline; // idb
HFONT ghDefaultGuiFontUnderline;
WNDPROC OldListCtrlWndProc; // idb
int dword_12E53B4; // weak
WINDOWPLACEMENT gWindowPlacement[6];
LOGFONTW gDefaultLogFont;
double gdSavedDividerCopy; // idb
__int64 gdSavedDivider; // weak
DWORD gdwRefreshRateOfSearch; // idb
int gdwHighlightDuration; // weak
__int16 gszColumnsetName[260]; // weak
__int16 gwProcessImageColumnWidth; // weak
char gbShowProcessTree; // weak
WPARAM gdwProcessListColumnCount; // idb
__int16 gwProcessListColumnWidths[]; // idb
int gdwIDMapProcesListForSelectColumn[96];
WPARAM gdwProcessListSortColumnCount; // idb
char gbProcessSortDirection; // weak
int gdwStatusBarColumns; // weak
WPARAM gdwHandlesListColumnCount; // idb
__int16 gdwHandlesListColumnWidths[32]; // idb
int gdwIdMapForDllsListColumn[32];
HWND gdwDllsListlSortColumnCount; // idb
char DllSortDirection; // weak
WPARAM gdwDllsListColumnCount; // idb
__int16 DllColumns[32]; // idb
int gdwHandlesListColumnMap[32];
WPARAM gdwHandlesListSortColumnCount; // idb
char HandleSortDirection; // weak
int gdwNumColumnsets; // weak
wchar_t gstrMenuCulumnSet[10][762];
char gbHighlightJobs; // weak
char gbHighlightServices; // weak
char gbHighlightOwnProcesses; // weak
char gbHighlightNetProcess; // weak
char gbHighlightNewProc; // weak
char gbHighlightDelProc; // weak
char gbHighlightPacked; // weak
char gbHighlightImmersive; // weak
char gbHighlightSuspend; // weak
char gbHighlightProtected; // weak
char gbTrayCPUHistory; // weak
char gbShowCommitTray; // weak
char gbShowPhysTray; // weak
char gbShowIoTray; // weak
char gbShowNetTray; // weak
char gbShowDiskTray; // weak
char gbShowGpuTray; // weak
char gbShowCpuFractions; // weak
char gbShowUnnamedHandles; // weak
char gbShowDllView; // weak
char gbShowLowerpane; // weak
char gbHighlightRelocatedDlls; // weak
char gbShowColumnHeatmaps; // weak
char gbShowAllUsers; // weak
char gbHideWhenMinimized; // weak
char gbAlwaysOntop; // weak
char gbAllOneInstance; // weak
char gbConfirmKill; // weak
char gbFormatIoBytes; // weak
char byte_12E96D6; // weak
char gbVerifySignatures; // weak
char gbShowAllCpus; // weak
char gbShowAllGpus; // weak
char gbUseGoogle; // weak
char gbShowNewProcesses; // weak
int gdwGpuNodeUsageMask; // weak
char gbVirusTotalCheck; // weak
char gbVirusTotalSubmitUnknown; // weak
char gbETWstandardUserWarning; // weak
int gdwDefaultProcPropPage; // weak
int gdwDefaultDllPropPage; // weak
WPARAM gdwDefaultSysInfoPage; // idb
const WCHAR gstrDbgHelpPath[260];
char gbSymbolWarningShown; // weak
WCHAR gszSymbolPath[260];
int ColorOwn; // weak
int ColorServices; // weak
int ColorRelocatedDlls; // weak
int gColorJobs_0; // weak
int gColorNet; // weak
int gColorNewProc; // weak
int gColorDeleteObjects; // weak
int ColorPacked; // weak
COLORREF gColorGraphBackground; // idb
int ColorImmersive; // weak
int gColorSuspend; // weak
int gColorProtected; // weak
int gdwToolbarBands[]; // weak
int gGraphReBarCtrlIds[]; // weak
DWORD gdwSortableColumnVector[24];
HMENU hMenu; // idb
wchar_t gszProtocalName[260];
CComBSTR *gppComBSTR; // idb
int sbInited2; // weak
CComBSTR *gppComBSTR2; // idb
int dword_12E9E5C; // weak
int dword_12E9E60; // weak
int dword_12E9E64; // weak
int dword_12E9E68; // weak
int dword_12E9E6C; // weak
char byte_12E9E70; // weak
SIDDATA *gSIDDATA;
int dword_12E9E78; // weak
void *dword_12E9E7C; // idb
HICON ghShieldIcon;
WCHAR **gstrProcessComments;
int (__stdcall *EnableThemeDialogTexture)(_DWORD, _DWORD); // weak
int dword_12E9E8C; // weak
TCHAR g_strTrayIconTipText[256];
char sbInited; // weak
char gbHasBuiltinAndAnministrativePriviledge; // weak
char gbDotNetProcess; // weak
char byte_12EA099; // weak
char byte_12EA09A; // weak
struct _FILETIME SystemTimeAsFileTime; // idb
__int64 qword_12EA0A8; // weak
BYTE Data; // idb
int dword_12EA0C4; // weak
int Pid; // idb
struct _FILETIME gTimeStart; // idb
LARGE_INTEGER gPerformanceCountStart; // idb
LARGE_INTEGER gFrequencyStart; // idb
int dword_12EA0E8; // weak
void *dword_12EA0EC; // idb
int dword_12EA0F0; // weak
CComBSTR *ppComBSTR2; // idb
CSysProcItem Right; // idb
char byte_12EA100; // weak
int (__stdcall *StartTraceW_0)(_DWORD, _DWORD, _DWORD); // idb
int (__stdcall *ControlTraceW_0)(TRACEHANDLE SessionHandle, LPCTSTR SessionName, PEVENT_TRACE_PROPERTIES Properties, ULONG ControlCode);
int (__stdcall *OpenTraceW_0)(_DWORD); // idb
int (__stdcall *ProcessTrace_0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int gnCounter; // weak
wchar_t gszMainTitle; // idb
wchar_t *gstrSidIndentityInfo;
int gMSGCommdlg_FindReplace; // weak
HWND ghWndNewOwner; // idb
HWND ghWndTreeListView; // idb
int gdwTopLastTreeList; // weak
HWND ghWndHandlesListCtrl; // idb
HWND ghWndDllsListCtrl; // idb
HWND ghWndStatusBar; // idb
HWND ghWndToolbar; // idb
HWND ghSysinfoPropSheetDlg; // idb
HWND ghWndGraphCPUUsage; // idb
HWND ghWndGraphMemory; // idb
HWND ghWndGraphPhysicalMemory; // idb
HWND ghWndGPUGraphCtrl; // idb
HWND ghWndIOGraphCtrl; // idb
HWND ghWndNetworkGraphCtrl; // idb
HWND ghWndDiskGraphCtrl; // idb
HANDLE ghEventRefreshSearchResult; // idb
HANDLE ghStartToResumeProcessEvent; // idb
HANDLE ghRefreshEvent; // idb
HANDLE ghEvent5; // idb
HANDLE ghEvent6; // idb
int gdwTickCountLast; // weak
HMENU ghMenuPriority; // idb
char gbHide1; // weak
char gbProcessExplorerHide; // weak
char gbSessionValid; // weak
char gbIsFinding; // weak
WCHAR *gpszCommandLine;
char gbProcessDEPStatus; // weak
char gbWintrustInited; // weak
char gbLaunchDepends; // weak
char gbProcessExplorerShow; // weak
WCHAR **gpHiddenProcs;
HCURSOR ghCursorArrow_1; // idb
struct tagRECT gRectMainWnd; // idb
RECT gRectRedrawMainWnd; // idb
int guIdOfCpuTrayIcon; // weak
UINT guIdOfGpuTrayIcon; // idb
UINT guIdOfCommitTrayIcon; // idb
UINT guIdOfIoTrayIcon; // idb
struct _SYSTEM_INFO gSystemInfo; // idb
UINT guIdOfPhysTrayIcon; // idb
UINT guIdOfDiskTrayIcon; // idb
const WCHAR gszDependsFileName; // idb
UINT guIdOfNetTrayIcon; // idb
HINSTANCE ghArrowCursor; // idb
wchar_t gstrDefaultDebugger[260];
struct _RTL_CRITICAL_SECTION gLockForSysInfoProperties; // idb
struct _RTL_CRITICAL_SECTION gLock2; // idb
struct _RTL_CRITICAL_SECTION gLock3; // idb
struct _RTL_CRITICAL_SECTION gStrListLock; // idb
HANDLE ghSystemInfoSheetThreadEvent; // idb
HANDLE ghBackupUpdateThreadHandle; // idb
HANDLE ghEvent3; // idb
HCURSOR ghCursorFind; // idb
HWND ghWndPointLast; // idb
int gShellIconMsg; // weak
UINT_PTR ghMenuDllsMenu; // idb
UINT_PTR ghMenuHandlesMenu; // idb
HMENU ghMenuUsers; // idb
HWND ghWndFocus; // idb
COLORREF gColors[16];
int RunFileDlg; // weak
int (__stdcall *SetLayeredWindowAttributes)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *SHAutoComplete)(_DWORD, _DWORD); // weak
char gbTreeListSortable; // weak
int dword_12EA8FC; // idb
int gnToolbarHeight; // idb
HCURSOR ghCursorResizeVert; // idb
int ghCursorSplitter; // weak
int gdwTickLastUpdateGraph; // weak
DWORD SessionID; // idb
_DWORD dword_12EA914; // idb
WCHAR gszRunAsCommandLine[260];
HWND ghComboBoxRunDlg; // idb
COLORREF gColorOwnProcesses; // idb
COLORREF gColorServices; // idb
COLORREF gColorRelocatedDlls; // idb
COLORREF gColorJobs; // idb
COLORREF gColorNetProcesses; // idb
COLORREF gColorThreadId; // idb
HGDIOBJ ghbrOwnProcesses; // idb
HGDIOBJ ghbrServices; // idb
HGDIOBJ ghbrRelocatedDlls;
HGDIOBJ ghbrJobs; // idb
HGDIOBJ ghbrNetProcesses; // idb
HGDIOBJ ghbrThreadId; // idb
COLORREF gColorNewObjects; // idb
COLORREF gColorDeleteObects; // idb
COLORREF gColorPackedImages; // idb
COLORREF gColorGraphBackground; // idb
COLORREF gColorImmersiveProcess; // idb
COLORREF gColorKernelTime; // idb
HGDIOBJ ghbrNewObjects; // idb
HGDIOBJ ghbrDeletedObjects; // idb
HGDIOBJ ghbrPackedImage; // idb
HGDIOBJ ghbrGraphBackground; // idb
HGDIOBJ ghbrImmersiveProcess; // idb
HGDIOBJ ho; // idb
int dword_12EAB88; // weak
CObjectQueryThread theQueryObjectThread;
char gbServiceNotImplemented; // weak
WCHAR gszTextToFind[256];
WCHAR gszTextToFindCopy[256];
int dword_12EAFA8; // weak
int dword_12EAFAC; // weak
int dword_12EAFB0; // weak
HINSTANCE ghInstance2; // idb
int gdwProcessId; // weak
FILETIME gProcessorCreateTime; // weak
int (__stdcall *NtSetInformationProcess)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int gdwSomeFunctionVA; // weak
HWND ghDlgFindDialog; // idb
HWND ghWndThreadStack; // idb
HWND ghWndListCtrlInFindDialog; // idb
int gStrList; // weak
struct _RTL_CRITICAL_SECTION gEnumServiceLock; // idb
LPBYTE gstrServiceNameBuffer; // idb
DWORD gdwServiceNameBufferRealSize; // idb
int (__stdcall *I_QueryTagInformation)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtQuerySystemInformation)(DWORD dwType, void *pBuffer, DWORD cbSize, DWORD *pdwSizeReturned);
int (__stdcall *NtOpenSymbolicLinkObject)(_DWORD, _DWORD, _DWORD); // weak
int NtOpenDirectoryObject; // weak
LONG (__stdcall *NtQueryObject)(HANDLE Handle, ULONG ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
int (__stdcall *NtQuerySymbolicLinkObject)(_DWORD, _DWORD, _DWORD); // weak
int RtlTimeToTimeFields; // weak
int NtQueryDirectoryObject; // weak
int (__stdcall *NtQuerySemaphore)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtQuerySection)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtQueryEvent)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtQueryMutant)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS Type, void *pBuffer, ULONG BufferSize, ULONG *pulRet);
int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtQueryVirtualMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *NtSuspendThread)(_DWORD, _DWORD); // weak
int (__stdcall *NtResumeThread)(_DWORD, _DWORD); // weak
int (__stdcall *NtSuspendProcess)(_DWORD); // weak
int (__stdcall *NtResumeProcess)(_DWORD); // weak
int (__stdcall *NtOpenThread)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD); // weak
int (__stdcall *RtlCreateQueryDebugBuffer)(_DWORD, _DWORD); // weak
int (__stdcall *RtlQueryProcessDebugInformation)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD); // weak
int (__stdcall *SedDiscretionaryAclEditor)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *SedTakeOwnership)(HWND hWnd, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int (__stdcall *SedSystemAclEditor)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *Hook_SymLoadModuleExW)(HANDLE hProcess, HANDLE hFile, PCSTR ImageName, PCSTR ModuleName, DWORD64 BaseOfDll, DWORD SizeOfDll);
int (__stdcall *pfnSymLoadModule64)(HANDLE hProcess, HANDLE hFile, PCSTR ImageName, PCSTR ModuleName, DWORD64 BaseOfDll, DWORD SizeOfDll);
int (__stdcall *pfnFindExecutableImageExW)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *QueryProcessCycleTime)(_DWORD, _DWORD); // weak
bool (__stdcall *WinStationGetProcessSid)(void *PublicBinding, HANDLE TokenHandle, LARGE_INTEGER a3, PSID DestionationSid, UINT *cbSizeReturned);
BOOL (__stdcall *GetProcessorSystemCycleTime)(__int16, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, PDWORD);
int (__stdcall *AllocateAndGetTcpExTableFromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *AllocateAndGetUdpExTableFromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *AllocateAndGetUdpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *AllocateAndGetTcpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
BOOL (__stdcall *QueryThreadCycleTime)(HANDLE ThreadHandle, PULONG64 CycleTime);
int IsHungThread; // weak
BOOL (__stdcall *GetLogicalProcessorInformationEx)(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength);
int SetThreadGroupAffinity; // weak
int (__stdcall *WTSEnumerateSessionsW)(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFO *ppSessionInfo, DWORD *pCount);
int (__stdcall *WTSDisconnectSession)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *WinStationConnectW)(NTSTATUS Status, unsigned int SessionId, unsigned int a3, LPCWSTR lpString, unsigned __int8 a5);
int (__stdcall *WinStationShadow)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *WTSQuerySessionInformationW)(HANDLE hServer, DWORD SessionID, DWORD WTSInfoClass, LPTSTR *ppBuffer, DWORD *pdwBytesReturned);
int (__stdcall *WTSLogoffSession)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *WTSSendMessageW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *WTSFreeMemory)(_DWORD); // weak
int (__stdcall *QueryIdleProcessorCycleTime)(ULONG *puBufferLength, ULONG64 *ProcessorCycleTimes);
int (__stdcall *ChangeWindowMessageFilter)(_DWORD, _DWORD); // weak
int CpuGetContext; // weak
int (__stdcall *GetPackageFullName)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD); // weak
SYSTEM_PROCESS_INFORMATION *gpSysProcessInfo1;
int gdwSysProcessInfoSize1; // weak
FILETIME gTimeLastRefresh;
int (__stdcall *HungWindowFromGhostWindow)(_DWORD); // weak
SYSTEM_PROCESS_INFORMATION *gpSysProcessInfo;
size_t gdwSysProcessInfoSize; // idb
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *gpSysProcessorPerfInfo;
_SYSTEM_INTERRUPT_INFORMATION *gpInterruptInfo;
SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION *gpProcessorCycleTimeInfo; // idb
__int64 qword_12EF398; // weak
PSYSTEM_HANDLE_INFORMATION gpSystemHandleInformation; // idb
_SYSTEM_HANDLE_INFORMATION *gpSystemHandleInformation2;
PSYSTEM_HANDLE_INFORMATION gpSystemHandleInformation2Copy; // idb
DWORD gdwServiceNameBufferAllocSize; // idb
SC_HANDLE ghSCManager; // idb
wchar_t word_12F05D8[16384];
__int16 gszDeviceHarddi_0[]; // idb
__int16 gstrDriverSymLinkName[6425]; // idb
unsigned int gdwLogicalProcessorInformationCount; // idb
PROCAFFINITY *gLogicalProcessorInformation;
volatile LONG gnLock; // idb
ProcessorInfo **gpProcessorsInfo;
int dword_12FBA1C; // weak
CGraphData *gpGraphClassData[6];
FILETIME gTimeLastRefresh1; // idb
__int64 qword_12FBA40; // weak
int (__stdcall *IsImmersiveProcess)(_DWORD); // weak
int (__stdcall *SHGetStockIconInfo)(_DWORD, _DWORD, _DWORD); // weak
LPWSTR gszWindowNameFound; // idb
rsize_t gdwWindowNameFoundSize; // idb
char gbWindowFound; // weak
HWND ghWndFound; // idb
CSysProcItem dword_12FBA70; // idb
CSysProcItem dword_12FBA78; // idb
CDataInfo gDataInfo1; // idb
int dword_12FBA8C; // weak
int dword_12FBA90; // weak
int dword_12FBA94; // weak
CDataInfo gDataInfo2; // idb
CDataInfo gDataInfo3; // idb
CSimpleGraphData gptrIOGraphData__3UCSimpleGraphData__A;
CSimpleGraphData gptrNetGraphData;
CSimpleGraphData gptrDiskGraphData;
char byte_12FBC00; // weak
int GetProcessMitigationPolicy; // weak
int dword_12FBC08; // weak
_SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX gTopSystemHandleInfo;
int dword_12FBC28; // weak
__int64 qword_12FBC30; // weak
int dword_12FBC38[256]; // weak
int dword_12FC038; // weak
int dword_12FC03C; // weak
int dword_12FC040; // weak
int dword_12FC044; // weak
int dword_12FC048; // weak
int dword_12FC04C; // weak
int dword_12FC050; // weak
int dword_12FC054; // weak
int dword_12FC058; // weak
int dword_12FC05C; // weak
int dword_12FC060; // weak
int dword_12FC064; // weak
int dword_12FC068; // weak
int dword_12FC06C; // weak
int dword_12FC070; // weak
int dword_12FC074; // weak
int dword_12FC078; // weak
int dword_12FC07C; // weak
char byte_12FC080; // weak
char byte_12FC081; // weak
char byte_12FC082; // weak
char byte_12FC083; // weak
char byte_12FC084; // weak
char byte_12FC085; // weak
__int16 word_12FC088[1024]; // idb
wchar_t Dst; // idb
HANDLE hSourceProcessHandle; // idb
int gnTheadStackWindowWidth; // idb
int gnTheadStackWindowHeight; // idb
struct tagRECT gRectThreadStack; // idb
WORD word_12FD0A4[6];
int dword_12FD0B0; // weak
wchar_t gszStringToFind; // idb
struct tagFINDREPLACEW gOfnInProcStringPage; // idb
char byte_13010E0; // weak
wchar_t word_13010E8; // idb
int dword_13050E8; // weak
int dword_13050EC; // weak
HANDLE ghProcessToCheckCPUAffinity; // idb
__int16 gSystemPerfInfo[148]; // weak
int dword_1305220; // weak
void *gSystemInterruptInfo; // idb
int dword_1305234; // weak
int dword_1305238; // weak
void *gpSystemProcessorPerfInfo; // idb
SYSTEM_PERFORMANCE_INFORMATION gSystemPerfInforInitedFromMemoryPage; // weak
LARGE_INTEGER stru_1305378; // weak
LARGE_INTEGER stru_1305380; // weak
SYSTEM_PERFORMANCE_INFORMATION gSystemPerfInforInited;
COLUMNWIDTH gdwFindDlgListColumnWidths;
COLUMNWIDTH gdwFindDlgListColumDefnWidths;
int sbInited_0; // weak
HCURSOR hCursor; // idb
int gdwSelectedItemInFindDialog; // weak
int gdwRefreshRateOfSearchCopy; // weak
int gcxFindDlg; // idb
int gcyFindDlg; // idb
struct tagRECT gRectFindDialog; // idb
int ghIconMainOfFindDialg; // weak
char gbCancelFindInFindDlg; // weak
HANDLE ghSearchThreadHandle; // idb
int dword_13054FC; // weak
wchar_t word_1305500[260];
HINSTANCE ghWaitCursor; // idb
HINSTANCE ghCursorWait; // idb
char ATL::CAtlBaseModule::m_bInitFailed; // weak
HWND ghWndRebar; // idb
int gdwStatusBarCount; // weak
HGDIOBJ ghBitmapColor; // idb
int dword_1305728; // weak
int dword_130572C; // weak
HDC hdc; // idb
int dword_1305734; // weak
int dword_1305738; // weak
char byte_130573C; // weak
int dword_1305740; // weak
CHttpItem gItem;
char byte_1305774; // weak
char byte_1305775; // weak
HINTERNET gHttp; // idb
void *theStringMAP; // idb
void *theLIST1; // idb
CNode theLIST2;
void *theLIST; // idb
char gbHttpInited; // weak
int gpfnHtmlHelp; // weak
int gbInited; // weak
HMODULE ghHHCtrlModule; // idb
int dword_13057D8; // weak
int dword_1305840; // weak
bool dword_1305844; // idb
int dword_130585A; // weak
int dword_1305864; // weak
int dword_1305868; // idb
__int16 word_13058F0; // weak
_UNKNOWN unk_13058F3; // weak
_ATL_BASE_MODULE70 ATL::_AtlBaseModule; // idb
PVOID dword_1305EBC; // idb
PVOID dword_1305EC4; // idb
int dword_1305EC8; // weak
PVOID dword_1306628; // idb
PVOID dword_130663C; // idb
int dword_1306648; // weak
PVOID dword_130694C; // idb
PVOID dword_1306950; // idb
PVOID dword_1306954; // idb
PVOID dword_1306958; // idb
PVOID dword_130695C; // idb
int dword_13069A4; // weak
int dword_13069AC; // weak


//----- (011F1000) --------------------------------------------------------
// %SystemRoot%\System32\hhctrl.ocx
MACRO_TPC_E __stdcall FakeCopyStringA(char *szFileName, unsigned int nLength, char *szPathInfo)
{
  MACRO_TPC_E result; // eax
  char *psxFileName; // eax
  MACRO_TPC_E re; // ebx
  unsigned int len; // esi
  char chr; // cl

  result = 0;
  if ( !nLength || nLength > 0x7FFFFFFF )
    result = E_INVALIDARG;
  if ( (result & 0x80000000) == 0 )
  {
    psxFileName = szFileName;
    re = 0;
    len = nLength;
    if ( !nLength )
      goto LABEL_14;
    do
    {
      if ( !(0x7FFFFFFE - nLength + len) )
        break;
      chr = psxFileName[szPathInfo - szFileName];
      if ( !chr )
        break;
      *psxFileName++ = chr;
      --len;
    }
    while ( len );
    if ( !len )
    {
LABEL_14:
      --psxFileName;
      re = TPC_E_INSUFFICIENT_BUFFER;
    }
    *psxFileName = 0;
    result = re;
  }
  return result;
}

//----- (011F1063) --------------------------------------------------------
BOOL __stdcall GetHhctrlocxPath(CHAR *szFileName)
{
  BOOL v1; // esi
  DWORD cbData; // [esp+4h] [ebp-118h]
  DWORD dwType; // [esp+8h] [ebp-114h]
  LPSTR pszFileName; // [esp+Ch] [ebp-110h]
  HKEY hKey; // [esp+10h] [ebp-10Ch]
  CHAR szValue[260]; // [esp+14h] [ebp-108h]

  pszFileName = szFileName;
  v1 = 0;
  if ( RegOpenKeyExA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{ADB880A6-D8FF-11CF-9377-00AA003B7A11}\\InprocServer32",
         0,
         KEY_READ,
         &hKey) )
  {
    return 0;
  }
  cbData = _MAX_PATH;
  dwType = 1;
  // %SystemRoot%\System32\hhctrl.ocx
  if ( !RegQueryValueExA(hKey, 0, 0, &dwType, szValue, &cbData) )
  {
    szValue[259] = 0;
    if ( dwType == REG_EXPAND_SZ )
      v1 = ExpandEnvironmentStringsA(szValue, pszFileName, _MAX_PATH) - 1 <= 0x103;
    else
      v1 = (FakeCopyStringA(pszFileName, _MAX_PATH, szValue) & 0x80000000) == 0;
  }
  RegCloseKey(hKey);
  return v1;
}

//----- (011F1149) --------------------------------------------------------
int __stdcall HtmpHelpImpl(int a1, int a2, int a3, int a4)
{
  HMODULE v4; // ecx
  FARPROC HtmpHelp; // eax
  CHAR LibFileName; // [esp+Ch] [ebp-108h]

  v4 = ghHHCtrlModule;
  if ( ghHHCtrlModule || gbInited != ghHHCtrlModule )
    goto LABEL_13;
  if ( GetHhctrlocxPath(&LibFileName) )
    ghHHCtrlModule = LoadLibraryA(&LibFileName);
  v4 = ghHHCtrlModule;
  if ( ghHHCtrlModule || (v4 = LoadLibraryA("hhctrl.ocx"), (ghHHCtrlModule = v4) != 0) )
  {
LABEL_13:
    HtmpHelp = gpfnHtmlHelp;
    if ( gpfnHtmlHelp )
      return (HtmpHelp)(a1, a2, a3, a4);
    HtmpHelp = GetProcAddress(v4, 0xF);
    gpfnHtmlHelp = HtmpHelp;
    if ( HtmpHelp )
      return (HtmpHelp)(a1, a2, a3, a4);
  }
  gbInited = 1;
  return 0;
}
// 13057BC: using guessed type int gpfnHtmlHelp;
// 13057C0: using guessed type int gbInited;

//----- (011F1200) --------------------------------------------------------
int sub_11F1200()
{
  `eh vector constructor iterator'(dword_12E4900, 0x28u, 20, sub_11F3750, sub_11F3850);
  return atexit(sub_12AA0D0);
}
// 12E4900: using guessed type int dword_12E4900[200];

//----- (011F1230) --------------------------------------------------------
int sub_11F1230()
{
  return atexit(sub_12AA0F0);
}

//----- (011F1240) --------------------------------------------------------
int sub_11F1240()
{
  gpszAutorunsDesc = _wcsdup(L"Autoruns - Sysinternals: www.sysinternals.com");
  return atexit(sub_12AA150);
}

//----- (011F1260) --------------------------------------------------------
int sub_11F1260()
{
  return atexit(sub_12AA160);
}

//----- (011F1270) --------------------------------------------------------
int sub_11F1270()
{
  return atexit(sub_12AA1C0);
}

//----- (011F1280) --------------------------------------------------------
HCURSOR sub_11F1280()
{
  HCURSOR result; // eax

  result = LoadCursorW(0, IDC_HAND);
  ghCursorHand_0 = result;
  return result;
}
// 12E48EC: using guessed type int ghCursorHand_0;

//----- (011F12A0) --------------------------------------------------------
int sub_11F12A0()
{
  _WORD *v0; // eax

  v0 = malloc(2u);
  dword_12E48E4 = v0;
  *v0 = 0;
  return atexit(sub_12AA220);
}

//----- (011F12C0) --------------------------------------------------------
int sub_11F12C0()
{
  wchar_t *v0; // eax

  v0 = malloc(2u);
  gEnvPathName = v0;
  *v0 = 0;
  return atexit(sub_12AA230);
}

//----- (011F12E0) --------------------------------------------------------
int sub_11F12E0()
{
  _WORD *v0; // eax

  v0 = malloc(2u);
  dword_12E48FC = v0;
  *v0 = 0;
  return atexit(sub_12AA240);
}

//----- (011F1300) --------------------------------------------------------
int sub_11F1300()
{
  dword_12E4C30 = sub_11FF9A0();
  return atexit(sub_12AA250);
}

//----- (011F1320) --------------------------------------------------------
int sub_11F1320()
{
  _WORD *v0; // eax

  v0 = malloc(2u);
  dword_12E48F0 = v0;
  *v0 = 0;
  return atexit(sub_12AA2D0);
}

//----- (011F1340) --------------------------------------------------------
HCURSOR sub_11F1340()
{
  HCURSOR result; // eax

  result = LoadCursorW(0, IDC_WAIT);
  ghCursorWait_0 = result;
  return result;
}
// 12E48E8: using guessed type int ghCursorWait_0;

//----- (011F1360) --------------------------------------------------------
int sub_11F1360()
{
  _WORD *v0; // eax

  v0 = malloc(2u);
  dword_12E4C54 = v0;
  *v0 = 0;
  return atexit(sub_12AA2F0);
}

//----- (011F1380) --------------------------------------------------------
int sub_11F1380()
{
  _WORD *v0; // eax

  v0 = malloc(2u);
  dword_12E4C50 = v0;
  *v0 = 0;
  return atexit(sub_12AA300);
}

//----- (011F13A0) --------------------------------------------------------
int sub_11F13A0()
{
  dword_12E4CD8 = sub_1282A70(0, 0);
  dword_12E4CE0 = 0;
  dword_12E4CE4 = 0;
  dword_12E4CE0 = sub_1282A70(0, 0);
  return atexit(sub_12AA310);
}
// 12E4CD8: using guessed type int dword_12E4CD8;
// 12E4CE0: using guessed type int dword_12E4CE0;
// 12E4CE4: using guessed type int dword_12E4CE4;

//----- (011F1420) --------------------------------------------------------
int sub_11F1420()
{
  dword_12E4CFC = sub_1282A70(0, 0);
  return atexit(sub_12AA320);
}

//----- (011F1440) --------------------------------------------------------
int sub_11F1440()
{
  dword_12E4CF4 = sub_1282A70(0, 0);
  return atexit(sub_12AA3F0);
}

//----- (011F1460) --------------------------------------------------------
int sub_11F1460()
{
  dword_12E4D04 = sub_1282A70(0, 0);
  return atexit(sub_12AA4C0);
}

//----- (011F1480) --------------------------------------------------------
int sub_11F1480()
{
  stru_12E4CEC = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  return atexit(sub_12AA590);
}

//----- (011F14A0) --------------------------------------------------------
int sub_11F14A0()
{
  return atexit(sub_12AA610);
}

//----- (011F14B0) --------------------------------------------------------
int sub_11F14B0()
{
  return atexit(sub_12AA620);
}

//----- (011F14C0) --------------------------------------------------------
int sub_11F14C0()
{
  return atexit(sub_12AA630);
}

//----- (011F14D0) --------------------------------------------------------
int sub_11F14D0()
{
  sub_1214740(&dword_12E4D28);
  return atexit(sub_12AA640);
}
// 12E4D28: using guessed type int dword_12E4D28;

//----- (011F14F0) --------------------------------------------------------
int sub_11F14F0()
{
  sub_1214830(&dword_12E4D1C);
  return atexit(sub_12AA660);
}
// 12E4D1C: using guessed type int dword_12E4D1C;

//----- (011F1510) --------------------------------------------------------
int sub_11F1510()
{
  dword_12E4D14 = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  return atexit(sub_12AA680);
}

//----- (011F1530) --------------------------------------------------------
__int16 sub_11F1530()
{
  __int16 result; // ax

  result = GlobalAddAtomW(L"TreeListProperty");
  gAtomTreeListProperty = result;
  return result;
}

//----- (011F1550) --------------------------------------------------------
ATOM sub_11F1550()
{
  ATOM result; // ax

  result = RegisterTreeListCtrl();
  gAtomTreeListAtom = result;
  return result;
}
// 12E4D9C: using guessed type __int16 gAtomTreeListAtom;

//----- (011F1560) --------------------------------------------------------
BOOL sub_11F1560()
{
  HDC v0; // edi

  v0 = CreateCompatibleDC(0);
  gLogPixelsX = GetDeviceCaps(v0, LOGPIXELSX);
  gLogPixelsY = GetDeviceCaps(v0, LOGPIXELSY);
  return DeleteDC(v0);
}

//----- (011F1590) --------------------------------------------------------
int sub_11F1590()
{
  ghuxthemeModule = LoadLibraryW(L"uxtheme.dll");
  return atexit(sub_12AA700);
}

//----- (011F15B0) --------------------------------------------------------
FARPROC sub_11F15B0()
{
  FARPROC result; // eax

  result = ghuxthemeModule;
  if ( ghuxthemeModule )
  {
    result = GetProcAddress(ghuxthemeModule, "CloseThemeData");
    *CloseThemeData = result;
  }
  else
  {
    *CloseThemeData = 0;
  }
  return result;
}

//----- (011F15E0) --------------------------------------------------------
FARPROC sub_11F15E0()
{
  FARPROC result; // eax

  result = ghuxthemeModule;
  if ( ghuxthemeModule )
  {
    result = GetProcAddress(ghuxthemeModule, "DrawThemeBackground");
    *DrawThemeBackground = result;
  }
  else
  {
    *DrawThemeBackground = 0;
  }
  return result;
}

//----- (011F1610) --------------------------------------------------------
FARPROC sub_11F1610()
{
  FARPROC result; // eax

  result = ghuxthemeModule;
  if ( ghuxthemeModule )
  {
    result = GetProcAddress(ghuxthemeModule, "IsThemeActive");
    *IsThemeActive = result;
  }
  else
  {
    *IsThemeActive = 0;
  }
  return result;
}

//----- (011F1640) --------------------------------------------------------
FARPROC sub_11F1640()
{
  FARPROC result; // eax

  result = ghuxthemeModule;
  if ( ghuxthemeModule )
  {
    result = GetProcAddress(ghuxthemeModule, "OpenThemeData");
    *OpenThemeData = result;
  }
  else
  {
    *OpenThemeData = 0;
  }
  return result;
}

//----- (011F1670) --------------------------------------------------------
CAtlStringMgr *sub_11F1670()
{
  CAtlStringMgr *result; // eax

  result = ATL::CAtlStringMgr::GetInstance();
  byte_12E4DF4 = 1;
  return result;
}
// 12E4DF4: using guessed type char byte_12E4DF4;

//----- (011F1680) --------------------------------------------------------
int sub_11F1680()
{
  gList = sub_1282A70(0, 0);
  return atexit(sub_12AA720);
}

//----- (011F16A0) --------------------------------------------------------
FARPROC sub_11F16A0()
{
  HMODULE v0; // eax
  FARPROC result; // eax

  v0 = LoadLibraryW(L"Advapi32.dll");
  result = GetProcAddress(v0, "EnableTraceEx");
  EnableTraceEx = result;
  return result;
}

//----- (011F16C0) --------------------------------------------------------
int sub_11F16C0()
{
  gAdapterList = sub_1234360(0, 0);
  return atexit(sub_12AA840);
}

//----- (011F16E0) --------------------------------------------------------
HANDLE sub_11F16E0()
{
  HANDLE result; // eax

  result = CreateEventW(0, 1, 0, 0);
  dword_12E537C = result;
  dword_12E5380 = 0;
  return result;
}
// 12E537C: using guessed type int dword_12E537C;
// 12E5380: using guessed type int dword_12E5380;

//----- (011F1700) --------------------------------------------------------
DWORD InitSysColors()
{
  DWORD clrFace; // eax
  double v1; // xmm0_8
  DWORD result; // eax
  LARGE_INTEGER clr; // xmm0_8

  clrFace = GetSysColor(COLOR_BTNFACE);
  gColorJobsVar[0].Name = L"ColorJobs";
  gColorJobsVar[0].Type = 0;
  v1 = clrFace;
  result = clrFace >> 31;
  gColorJobsVar[0].Size = 0;
  gColorJobsVar[0].Value = &gColorJobs_0;
  gColorJobsVar[1].Name = L"ColorDelProc";
  gColorJobsVar[1].Type = 0;
  gColorJobsVar[1].Size = 0;
  *&clr.QuadPart = v1 + *&dword_12BD110[2 * result];
  gColorJobsVar[1].Value = &gColorDeleteObjects;
  gColorJobsVar[2].Name = L"ColorNewProc";
  gColorJobsVar[2].Type = 0;
  gColorJobsVar[2].Size = 0;
  gColorGraphBkVar.dDefaultValue = clr;
  *&gColorJobsVar[0].dDefaultValue.QuadPart = dbl_12BEA10;
  *&gColorJobsVar[1].dDefaultValue.QuadPart = dbl_12BEA18;
  *&gColorJobsVar[2].dDefaultValue.QuadPart = dbl_12BEA20;
  *&gColorJobsVar[3].dDefaultValue.QuadPart = dbl_12BEA38;
  *&gColorJobsVar[4].dDefaultValue.QuadPart = dbl_12BEA28;
  *&gColorJobsVar[6].dDefaultValue.QuadPart = dbl_12BEA30;
  *&gColorJobsVar[7].dDefaultValue.QuadPart = dbl_12BEA08;
  gColorJobsVar[2].Value = &gColorNewProc;
  gColorJobsVar[3].Name = L"ColorNet";
  gColorJobsVar[3].Type = 0;
  gColorJobsVar[3].Size = 0;
  gColorJobsVar[3].Value = &gColorNet;
  gColorJobsVar[4].Name = L"ColorProtected";
  gColorJobsVar[4].Type = 0;
  gColorJobsVar[4].Size = 0;
  gColorJobsVar[4].Value = &gColorProtected;
  gColorJobsVar[5].Name = L"ShowHeatmaps";
  gColorJobsVar[5].Type = 1;
  gColorJobsVar[5].Size = 0;
  gColorJobsVar[5].Value = &gbShowColumnHeatmaps;
  *&gColorJobsVar[5].dDefaultValue.QuadPart = doubleOnePointZero;
  gColorJobsVar[6].Name = L"ColorSuspend";
  gColorJobsVar[6].Type = 0;
  gColorJobsVar[6].Size = 0;
  gColorJobsVar[6].Value = &gColorSuspend;
  gColorJobsVar[7].Name = L"StatusBarColumns";
  gColorJobsVar[7].Type = 0;
  gColorJobsVar[7].Size = 0;
  gColorJobsVar[7].Value = &gdwStatusBarColumns;
  gColorJobsVar[8].Name = L"ShowAllCpus";
  gColorJobsVar[8].Type = 1;
  gColorJobsVar[8].Size = 0;
  gColorJobsVar[8].Value = &gbShowAllCpus;
  gColorJobsVar[8].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[9].Name = L"ShowAllGpus";
  gColorJobsVar[9].Type = 1;
  gColorJobsVar[9].Size = 0;
  gColorJobsVar[9].Value = &gbShowAllGpus;
  gColorJobsVar[9].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[10].Name = L"Opacity";
  gColorJobsVar[10].Type = 0;
  gColorJobsVar[10].Size = 0;
  gColorJobsVar[10].Value = gdwOpacity;
  *&gColorJobsVar[10].dDefaultValue.QuadPart = gdbMaxValue;
  gColorJobsVar[11].Name = L"GpuNodeUsageMask";
  gColorJobsVar[11].Type = 0;
  gColorJobsVar[11].Size = 0;
  gColorJobsVar[11].Value = &gdwGpuNodeUsageMask;
  *&gColorJobsVar[11].dDefaultValue.QuadPart = doubleOnePointZero;
  gColorJobsVar[12].Name = L"VerifySignatures";
  gColorJobsVar[12].Type = 1;
  gColorJobsVar[12].Size = 0;
  gColorJobsVar[12].Value = &gbVerifySignatures;
  gColorJobsVar[12].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[13].Name = L"VirusTotalCheck";
  gColorJobsVar[13].Type = 1;
  gColorJobsVar[13].Size = 0;
  gColorJobsVar[13].Value = &gbVirusTotalCheck;
  gColorJobsVar[13].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[14].Name = L"VirusTotalSubmitUnknown";
  gColorJobsVar[14].Type = 1;
  gColorJobsVar[14].Size = 0;
  gColorJobsVar[14].Value = &gbVirusTotalSubmitUnknown;
  gColorJobsVar[14].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[15].Name = L"ToolbarBands";
  gColorJobsVar[15].Type = 7;
  gColorJobsVar[15].Size = 96;
  gColorJobsVar[15].Value = gdwToolbarBands;
  gColorJobsVar[15].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[16].Name = L"UseGoogle";
  gColorJobsVar[16].Type = 1;
  gColorJobsVar[16].Size = 0;
  gColorJobsVar[16].Value = &gbUseGoogle;
  gColorJobsVar[16].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[17].Name = L"ShowNewProcesses";
  gColorJobsVar[17].Type = 1;
  gColorJobsVar[17].Size = 0;
  gColorJobsVar[17].Value = &gbShowNewProcesses;
  gColorJobsVar[17].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[18].Name = L"TrayCPUHistory";
  gColorJobsVar[18].Type = 1;
  gColorJobsVar[18].Size = 0;
  gColorJobsVar[18].Value = &gbTrayCPUHistory;
  *&gColorJobsVar[18].dDefaultValue.QuadPart = doubleOnePointZero;
  gColorJobsVar[19].Name = L"ShowIoTray";
  gColorJobsVar[19].Type = 1;
  gColorJobsVar[19].Size = 0;
  gColorJobsVar[19].Value = &gbShowIoTray;
  gColorJobsVar[19].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[20].Name = L"ShowNetTray";
  gColorJobsVar[20].Type = 1;
  gColorJobsVar[20].Size = 0;
  gColorJobsVar[20].Value = &gbShowNetTray;
  gColorJobsVar[20].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[21].Name = L"ShowDiskTray";
  gColorJobsVar[21].Type = 1;
  gColorJobsVar[21].Size = 0;
  gColorJobsVar[21].Value = &gbShowDiskTray;
  gColorJobsVar[21].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[22].Name = L"ShowPhysTray";
  gColorJobsVar[22].Type = 1;
  gColorJobsVar[22].Size = 0;
  gColorJobsVar[22].Value = &gbShowPhysTray;
  gColorJobsVar[22].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[23].Name = L"ShowCommitTray";
  gColorJobsVar[23].Type = 1;
  gColorJobsVar[23].Size = 0;
  gColorJobsVar[23].Value = &gbShowCommitTray;
  gColorJobsVar[23].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[24].Name = L"ShowGpuTray";
  gColorJobsVar[24].Type = 1;
  gColorJobsVar[24].Size = 0;
  gColorJobsVar[24].Value = &gbShowGpuTray;
  gColorJobsVar[24].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[25].Name = L"FormatIoBytes";
  gColorJobsVar[25].Type = 1;
  gColorJobsVar[25].Size = 0;
  gColorJobsVar[25].Value = &gbFormatIoBytes;
  *&gColorJobsVar[25].dDefaultValue.QuadPart = doubleOnePointZero;
  gColorJobsVar[26].Name = L"StackWindowPlacement";
  gColorJobsVar[26].Type = 7;
  gColorJobsVar[26].Size = 44;
  gColorJobsVar[0x1A].Value = &gWindowPlacement[StackWindowPlacement];
  gColorJobsVar[26].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[27].Name = L"ETWstandardUserWarning";
  gColorJobsVar[27].Type = 1;
  gColorJobsVar[27].Size = 0;
  gColorJobsVar[27].Value = &gbETWstandardUserWarning;
  gColorJobsVar[27].dDefaultValue.QuadPart = 0i64;
  gColorJobsVar[28].Name = 0;
  gColorJobsVar[28].Type = 0;
  gColorJobsVar[28].Size = 0;
  gColorJobsVar[28].Value = 0;
  gColorJobsVar[28].dDefaultValue.QuadPart = 0i64;
  return result;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCDC0: using guessed type double gdbMaxValue;
// 12BDAD8: using guessed type wchar_t aColorjobs[10];
// 12BDAEC: using guessed type wchar_t aColordelproc[13];
// 12BDB08: using guessed type wchar_t aColornewproc[13];
// 12BDB24: using guessed type wchar_t aColornet[9];
// 12BDB38: using guessed type wchar_t aColorprotected[15];
// 12BDB58: using guessed type wchar_t aShowheatmaps[13];
// 12BDB74: using guessed type wchar_t aColorsuspend[13];
// 12BDB90: using guessed type wchar_t aStatusbarcolum[17];
// 12BDBB4: using guessed type wchar_t aShowallcpus[12];
// 12BDBCC: using guessed type wchar_t aShowallgpus[12];
// 12BDBF4: using guessed type wchar_t aGpunodeusagema[17];
// 12BDC18: using guessed type wchar_t aVerifysignatur[17];
// 12BDC3C: using guessed type wchar_t aVirustotalchec[16];
// 12BDC5C: using guessed type wchar_t aVirustotalsubm[24];
// 12BDC8C: using guessed type wchar_t aToolbarbands[13];
// 12BDCA8: using guessed type wchar_t aUsegoogle[10];
// 12BDCBC: using guessed type wchar_t aShownewprocess[17];
// 12BDCE0: using guessed type wchar_t aTraycpuhistory[15];
// 12BDD00: using guessed type wchar_t aShowiotray[11];
// 12BDD18: using guessed type wchar_t aShownettray[12];
// 12BDD30: using guessed type wchar_t aShowdisktray[13];
// 12BDD4C: using guessed type wchar_t aShowphystray[13];
// 12BDD68: using guessed type wchar_t aShowcommittray[15];
// 12BDD88: using guessed type wchar_t aShowgputray[12];
// 12BDDA0: using guessed type wchar_t aFormatiobytes[14];
// 12BDDBC: using guessed type wchar_t aStackwindowpla[21];
// 12BDDE8: using guessed type wchar_t aEtwstandarduse[23];
// 12BEA08: using guessed type double dbl_12BEA08;
// 12BEA10: using guessed type double dbl_12BEA10;
// 12BEA18: using guessed type double dbl_12BEA18;
// 12BEA20: using guessed type double dbl_12BEA20;
// 12BEA28: using guessed type double dbl_12BEA28;
// 12BEA30: using guessed type double dbl_12BEA30;
// 12BEA38: using guessed type double dbl_12BEA38;
// 12DDDD8: using guessed type GLOBALVAR gColorGraphBkVar;
// 12E5990: using guessed type int gdwStatusBarColumns;
// 12E96C2: using guessed type char gbTrayCPUHistory;
// 12E96C3: using guessed type char gbShowCommitTray;
// 12E96C4: using guessed type char gbShowPhysTray;
// 12E96C5: using guessed type char gbShowIoTray;
// 12E96C6: using guessed type char gbShowNetTray;
// 12E96C7: using guessed type char gbShowDiskTray;
// 12E96C8: using guessed type char gbShowGpuTray;
// 12E96CF: using guessed type char gbShowColumnHeatmaps;
// 12E96D5: using guessed type char gbFormatIoBytes;
// 12E96D7: using guessed type char gbVerifySignatures;
// 12E96D8: using guessed type char gbShowAllCpus;
// 12E96D9: using guessed type char gbShowAllGpus;
// 12E96DA: using guessed type char gbUseGoogle;
// 12E96DB: using guessed type char gbShowNewProcesses;
// 12E96DC: using guessed type int gdwGpuNodeUsageMask;
// 12E96E0: using guessed type char gbVirusTotalCheck;
// 12E96E1: using guessed type char gbVirusTotalSubmitUnknown;
// 12E96E2: using guessed type char gbETWstandardUserWarning;
// 12E9B14: using guessed type int gColorJobs_0;
// 12E9B18: using guessed type int gColorNet;
// 12E9B1C: using guessed type int gColorNewProc;
// 12E9B20: using guessed type int gColorDeleteObjects;
// 12E9B30: using guessed type int gColorSuspend;
// 12E9B34: using guessed type int gColorProtected;
// 12E9B38: using guessed type int gdwToolbarBands[];

//----- (011F1CE0) --------------------------------------------------------
FARPROC EnableThemeDialogTextureLoader()
{
  FARPROC result; // eax

  result = ghuxthemeModule;
  if ( ghuxthemeModule )
  {
    result = GetProcAddress(ghuxthemeModule, "EnableThemeDialogTexture");
    EnableThemeDialogTexture = result;
  }
  else
  {
    EnableThemeDialogTexture = 0;
  }
  return result;
}
// 12E9E88: using guessed type int (__stdcall *EnableThemeDialogTexture)(_DWORD, _DWORD);

//----- (011F1D10) --------------------------------------------------------
int sub_11F1D10()
{
  sub_124EEA0(&dword_12EA0C4, &Data);
  return atexit(sub_12AA9D0);
}
// 12EA0C4: using guessed type int dword_12EA0C4;

//----- (011F1D30) --------------------------------------------------------
int sub_11F1D30()
{
  sub_1232AE0(&Data, 0);
  return atexit(sub_12AA9E0);
}

//----- (011F1D50) --------------------------------------------------------
int sub_11F1D50()
{
  BSTR v0; // esi
  CComBSTR *v1; // eax

  v0 = SysAllocStringLen(&strIn, 1u);
  v1 = operator new(0xCu);
  if ( v1 )
  {
    v1->hKey = 0;
    v1->Length = 1;
    v1->bstr = v0;
  }
  else
  {
    v1 = 0;
  }
  ppComBSTR2 = v1;
  if ( !v1 )
    com_error::throw(E_OUTOFMEMORY);
  return atexit(sub_12AA9F0);
}

//----- (011F1DE0) --------------------------------------------------------
int sub_11F1DE0()
{
  dword_12EA0EC = sub_1282A70(0, 0);
  return atexit(sub_12AAA50);
}

//----- (011F1E00) --------------------------------------------------------
BOOL sub_11F1E00()
{
  GetSystemTimeAsFileTime(&gTimeStart);
  QueryPerformanceCounter(&gPerformanceCountStart);
  return QueryPerformanceFrequency(&gFrequencyStart);
}

//----- (011F1E30) --------------------------------------------------------
int sub_11F1E30()
{
  Right._Left = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  return atexit(sub_12AAB20);
}

//----- (011F1E50) --------------------------------------------------------
bool sub_11F1E50()
{
  bool result; // al

  result = sub_1245050();
  gbTreeListSortable = result;
  return result;
}
// 12EA8F8: using guessed type char gbTreeListSortable;

//----- (011F1E60) --------------------------------------------------------
int sub_11F1E60()
{
  CComBSTR::AssignA(&gptrDiskGraphData, "Disk");
  gptrDiskGraphData.GraphData = 0;
  *&gptrDiskGraphData.field_8 = 0i64;
  HIDWORD(gptrDiskGraphData.ID) = 8;
  return atexit(sub_12AABA0);
}

//----- (011F1EA0) --------------------------------------------------------
int sub_11F1EA0()
{
  CComBSTR::AssignA(&gptrIOGraphData__3UCSimpleGraphData__A, "I/O");
  gptrIOGraphData__3UCSimpleGraphData__A.GraphData = 0;
  *&gptrIOGraphData__3UCSimpleGraphData__A.field_8 = 0i64;
  HIDWORD(gptrIOGraphData__3UCSimpleGraphData__A.ID) = 2;
  return atexit(sub_12AAC00);
}

//----- (011F1EE0) --------------------------------------------------------
int sub_11F1EE0()
{
  CComBSTR::AssignA(&gptrNetGraphData, "Network");
  gptrNetGraphData.GraphData = 0;
  *&gptrNetGraphData.field_8 = 0i64;
  HIDWORD(gptrNetGraphData.ID) = 9;
  return atexit(sub_12AAC60);
}

//----- (011F1F20) --------------------------------------------------------
int sub_11F1F20()
{
  dword_12FBA78._Left = sub_1275440();
  return atexit(sub_12AACC0);
}

//----- (011F1F40) --------------------------------------------------------
int sub_11F1F40()
{
  dword_12FBA70._Left = sub_1275440();
  return atexit(sub_12AAD40);
}

//----- (011F1F60) --------------------------------------------------------
int sub_11F1F60()
{
  int result; // eax

  result = sub_126F7C0(&gDataInfo3);
  gDataInfo3.field_14 = 0;
  gDataInfo3.field_10 = 0;
  gDataInfo3.field_C = 0;
  return result;
}

//----- (011F1F90) --------------------------------------------------------
int sub_11F1F90()
{
  int result; // eax

  result = sub_126F7C0(&gDataInfo1);
  dword_12FBA94 = 0;
  dword_12FBA90 = 0;
  dword_12FBA8C = 0;
  return result;
}
// 12FBA8C: using guessed type int dword_12FBA8C;
// 12FBA90: using guessed type int dword_12FBA90;
// 12FBA94: using guessed type int dword_12FBA94;

//----- (011F1FC0) --------------------------------------------------------
int sub_11F1FC0()
{
  int result; // eax

  result = sub_126F7C0(&gDataInfo2);
  gDataInfo2.field_14 = 0;
  gDataInfo2.field_10 = 0;
  gDataInfo2.field_C = 0;
  return result;
}

//----- (011F1FF0) --------------------------------------------------------
int sub_11F1FF0()
{
  *(&gHttp + 2) = sub_1282A70(0, 0);
  *(&gHttp + 2) = 0i64;
  *(&gHttp + 4) = sub_1282A70(0, 0);
  return atexit(sub_12AADF0);
}

//----- (011F2070) --------------------------------------------------------
int sub_11F2070()
{
  theLIST2.Next = sub_1282A70(0, 0);
  return atexit(sub_12AAE00);
}

//----- (011F2090) --------------------------------------------------------
int sub_11F2090()
{
  theLIST1 = sub_1282A70(0, 0);
  return atexit(sub_12AAED0);
}

//----- (011F20B0) --------------------------------------------------------
int sub_11F20B0()
{
  theLIST = sub_1282A70(0, 0);
  return atexit(sub_12AAFA0);
}

//----- (011F20D0) --------------------------------------------------------
int sub_11F20D0()
{
  theStringMAP = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  return atexit(sub_12AB070);
}

//----- (011F20F0) --------------------------------------------------------
int sub_11F20F0()
{
  return atexit(sub_12AB0F0);
}

//----- (011F20FC) --------------------------------------------------------
int sub_11F20FC()
{
  std::_Init_locks::_Init_locks(&dword_13057D8);
  return atexit(sub_12AB0FC);
}
// 13057D8: using guessed type int dword_13057D8;

//----- (011F2112) --------------------------------------------------------
int sub_11F2112()
{
  return atexit(sub_12AB106);
}

//----- (011F211E) --------------------------------------------------------
int sub_11F211E()
{
  return atexit(sub_12AB110);
}

//----- (011F212A) --------------------------------------------------------
int sub_11F212A()
{
  return atexit(sub_12AB11A);
}

//----- (011F2136) --------------------------------------------------------
int sub_11F2136()
{
  std::_Init_locks::_Init_locks(&word_13058F0);
  return atexit(sub_12AB124);
}
// 13058F0: using guessed type __int16 word_13058F0;

//----- (011F214C) --------------------------------------------------------
int ATL::_dynamic_initializer_for___AtlBaseModule__()
{
  ATL::CAtlBaseModule::CAtlBaseModule(&ATL::_AtlBaseModule);
  return atexit(ATL::_dynamic_atexit_destructor_for___AtlBaseModule__);
}

//----- (011F2170) --------------------------------------------------------
_DWORD *__thiscall sub_11F2170(_DWORD *this)
{
  _DWORD *v1; // esi
  _WORD *v2; // eax
  _DWORD *result; // eax

  v1 = this;
  v2 = malloc(2u);
  *v1 = v2;
  *v2 = 0;
  result = v1;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  return result;
}

//----- (011F21A0) --------------------------------------------------------
void __thiscall sub_11F21A0(void ***this)
{
  void ***v1; // edi
  void **v2; // esi
  void **i; // ebx

  v1 = this;
  v2 = *this;
  if ( *this )
  {
    for ( i = this[1]; v2 != i; ++v2 )
      free(*v2);
    j__free(*v1);
    *v1 = 0;
    v1[1] = 0;
    v1[2] = 0;
  }
}

//----- (011F21F0) --------------------------------------------------------
void __thiscall sub_11F21F0(void **this)
{
  void **v1; // edi
  void **v2; // esi
  void **i; // ebx

  v1 = this;
  v2 = this[1];
  if ( v2 )
  {
    for ( i = this[2]; v2 != i; ++v2 )
      free(*v2);
    j__free(v1[1]);
    v1[1] = 0;
    v1[2] = 0;
    v1[3] = 0;
  }
  free(*v1);
}

//----- (011F2250) --------------------------------------------------------
void **__thiscall sub_11F2250(void **this, const wchar_t **a2)
{
  void **v2; // edi
  void *v3; // esi

  v2 = this;
  v3 = *this;
  *this = _wcsdup(*a2);
  free(v3);
  return v2;
}

//----- (011F2280) --------------------------------------------------------
void **__thiscall sub_11F2280(void **this, wchar_t *a2)
{
  void **v2; // edi
  void *v3; // esi

  v2 = this;
  v3 = *this;
  *this = _wcsdup(a2);
  free(v3);
  return v2;
}

//----- (011F22B0) --------------------------------------------------------
int __cdecl sub_11F22B0(int a1, int a2, wchar_t *a3)
{
  WCHAR *v3; // ecx
  wchar_t *v4; // eax
  wchar_t *v5; // esi

  v3 = gpszTargetName;
  if ( a3 )
    v3 = a3;
  v4 = _wcsdup(v3);
  v5 = v4;
  a3 = v4;
  sub_1203070(a1, a2, &a3);
  free(v5);
  return a1;
}

//----- (011F2300) --------------------------------------------------------
void *__thiscall sub_11F2300(unsigned __int16 **this, void *a2, int a3, int a4)
{
  unsigned __int16 **v4; // eax
  unsigned __int16 *v5; // ecx
  unsigned int v6; // esi
  int v7; // ebx
  int v8; // edx
  unsigned int v9; // edi
  unsigned __int16 *v10; // eax
  unsigned __int16 **v11; // ecx
  unsigned __int16 **v13; // [esp+Ch] [ebp-4h]
  int v14; // [esp+1Ch] [ebp+Ch]

  v4 = this;
  v5 = *this;
  v13 = v4;
  v6 = wcslen(v5);
  v7 = a4;
  v8 = a3;
  if ( a3 > v6 )
    v8 = v6;
  v14 = v8;
  if ( v8 + a4 > v6 )
    v7 = v6 - v8;
  v9 = wcslen(a2);
  if ( (v9 - v7) <= 0 )
  {
    v11 = v13;
  }
  else
  {
    v10 = realloc(v5, 2 * (v6 + v9 - v7 + 2));
    v11 = v13;
    v8 = v14;
    *v13 = v10;
  }
  memmove(&(*v11)[v8 + v9], &(*v11)[v8 + v7], 2 * (v6 - v8 - v7) + 2);
  return memmove_0(&(*v13)[v14], a2, 2 * v9);
}

//----- (011F23D0) --------------------------------------------------------
void __cdecl sub_11F23D0(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_11F2480(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_11F2480(a1, a2, v7, v5);
  free(v7);
}

//----- (011F2480) --------------------------------------------------------
void *__cdecl sub_11F2480(int a1, void *a2, wchar_t *psz, void *a4)
{
  DWORD v4; // ebx
  HKEY v5; // esi
  WCHAR *v6; // eax
  WCHAR *v7; // eax
  unsigned __int16 **v8; // esi
  unsigned __int16 **v9; // eax
  unsigned int v10; // eax
  OLECHAR *v11; // esi
  unsigned int v12; // eax
  void *v13; // esi
  void *v14; // esi
  const wchar_t **v15; // eax
  void *v16; // esi
  WCHAR *v17; // ecx
  WCHAR *v18; // eax
  unsigned __int16 **v19; // esi
  unsigned __int16 **v20; // eax
  char v21; // bl
  WCHAR *v22; // eax
  WCHAR *v23; // eax
  void *v24; // ebx
  unsigned __int16 **v25; // esi
  unsigned __int16 **v26; // eax
  WCHAR *v27; // eax
  unsigned __int16 **v28; // eax
  int v30; // [esp+10h] [ebp-A4h]
  int v31; // [esp+14h] [ebp-A0h]
  int v32; // [esp+18h] [ebp-9Ch]
  int v33; // [esp+1Ch] [ebp-98h]
  void *v34; // [esp+20h] [ebp-94h]
  void *v35; // [esp+24h] [ebp-90h]
  void *v36; // [esp+28h] [ebp-8Ch]
  int v37; // [esp+2Ch] [ebp-88h]
  void *v38; // [esp+30h] [ebp-84h]
  int v39; // [esp+34h] [ebp-80h]
  void *v40; // [esp+38h] [ebp-7Ch]
  void *v41; // [esp+3Ch] [ebp-78h]
  DWORD v42; // [esp+40h] [ebp-74h]
  void *v43; // [esp+44h] [ebp-70h]
  void *v44; // [esp+48h] [ebp-6Ch]
  void *v45; // [esp+4Ch] [ebp-68h]
  void *v46; // [esp+50h] [ebp-64h]
  void *v47; // [esp+54h] [ebp-60h]
  HKEY hKey; // [esp+58h] [ebp-5Ch]
  void *v49; // [esp+5Ch] [ebp-58h]
  void *v50; // [esp+60h] [ebp-54h]
  void *v51; // [esp+64h] [ebp-50h]
  void *v52; // [esp+68h] [ebp-4Ch]
  HKEY v53; // [esp+6Ch] [ebp-48h]
  void *v54; // [esp+70h] [ebp-44h]
  void *v55; // [esp+74h] [ebp-40h]
  void *v56; // [esp+78h] [ebp-3Ch]
  void *v57; // [esp+7Ch] [ebp-38h]
  void *v58; // [esp+80h] [ebp-34h]
  void *v59; // [esp+84h] [ebp-30h]
  void *v60; // [esp+88h] [ebp-2Ch]
  void *v61; // [esp+8Ch] [ebp-28h]
  void *v62; // [esp+90h] [ebp-24h]
  void *v63; // [esp+94h] [ebp-20h]
  void *v64; // [esp+98h] [ebp-1Ch]
  void *v65; // [esp+9Ch] [ebp-18h]
  LPCWSTR lpSubKey; // [esp+A0h] [ebp-14h]
  wchar_t *v67; // [esp+A4h] [ebp-10h]
  int v68; // [esp+B0h] [ebp-4h]

  v4 = 0;
  v42 = 0;
  v67 = malloc(2u);
  *v67 = 0;
  v68 = 0;
  v64 = malloc(2u);
  *v64 = 0;
  lpSubKey = malloc(2u);
  *lpSubKey = 0;
  v65 = malloc(2u);
  *v65 = 0;
  v49 = malloc(2u);
  *v49 = 0;
  v46 = malloc(2u);
  *v46 = 0;
  v47 = malloc(2u);
  *v47 = 0;
  v51 = malloc(2u);
  *v51 = 0;
  v5 = a2;
  LOBYTE(v68) = 7;
  if ( a4 == -1 )
  {
    v62 = _wcsdup(gpszTargetName);
    v54 = _wcsdup(gpszTargetName);
    v63 = _wcsdup(gpszTargetName);
    v55 = _wcsdup(gpszTargetName);
    v59 = _wcsdup(gpszTargetName);
    v60 = _wcsdup(gpszTargetName);
    v61 = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( psz )
      v6 = psz;
    v58 = _wcsdup(v6);
    v56 = _wcsdup(gpszTargetName);
    v7 = gpszTargetName;
    if ( psz )
      v7 = psz;
    v57 = _wcsdup(v7);
    LOBYTE(v68) = 17;
    v8 = sub_11F7BE0(&v52, a2, &v58, &v61);
    LOBYTE(v68) = 18;
    v9 = sub_11F7BE0(&v50, a2, &v57, &v56);
    LOBYTE(v68) = 19;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v9, v8, &v60);
    free(v50);
    free(v52);
    free(v57);
    free(v56);
    free(v58);
    free(v61);
    free(v60);
    free(v59);
    free(v55);
    free(v63);
    free(v54);
    LOBYTE(v68) = 7;
    free(v62);
    v5 = a2;
  }
  v10 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(v5, psz, 0, v10 | 0x20019, &v53) )
  {
    if ( !sub_12013D0(v53, 0, &lpSubKey) )
    {
      do
      {
        v11 = lpSubKey;
        v12 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v53, v11, 0, v12 | 0x20019, &hKey) )
        {
          if ( !sub_12015A0(v53, lpSubKey, &v64) )
          {
            if ( (*v67 = 0, !sub_1201520(hKey, L"ShellComponent", 0, 0, &v67)) && *v67
              || (sub_1201520(hKey, L"StubPath", 0, 0, &v67), *v67) )
            {
              v13 = v64;
              if ( !*v64 )
              {
                v64 = _wcsdup(L"n/a");
                free(v13);
              }
              v30 = malloc(2u);
              *v30 = 0;
              v31 = 0;
              v32 = 0;
              v33 = 0;
              LOBYTE(v68) = 20;
              sub_11F6CC0(v67, &v30);
              v14 = v51;
              v51 = _wcsdup(v67);
              free(v14);
              v15 = sub_11F4EE0(&v38, a1, &v30, 0);
              v16 = v65;
              v65 = _wcsdup(*v15);
              free(v16);
              free(v38);
              v37 = sub_11F4ED0();
              v17 = gpszTargetName;
              if ( psz )
                v17 = psz;
              v63 = _wcsdup(v17);
              v54 = _wcsdup(gpszTargetName);
              v18 = gpszTargetName;
              if ( psz )
                v18 = psz;
              v62 = _wcsdup(v18);
              LOBYTE(v68) = 23;
              v19 = sub_11F7BE0(&v41, a2, &v63, &lpSubKey);
              LOBYTE(v68) = 24;
              v20 = sub_11F7BE0(&v36, a2, &v62, &v54);
              LOBYTE(v68) = 25;
              v21 = sub_11F3D40(a1, v20, v19, &v64, &v65, &v49, &v47, &v39);
              free(v36);
              free(v41);
              free(v62);
              free(v54);
              free(v63);
              if ( v21 )
              {
                if ( a4 == -1 )
                {
                  v44 = _wcsdup(gpszTargetName);
                  v43 = _wcsdup(gpszTargetName);
                  v45 = _wcsdup(gpszTargetName);
                  v57 = _wcsdup(gpszTargetName);
                  v56 = _wcsdup(gpszTargetName);
                  v58 = _wcsdup(gpszTargetName);
                  v61 = _wcsdup(gpszTargetName);
                  v22 = gpszTargetName;
                  if ( psz )
                    v22 = psz;
                  v60 = _wcsdup(v22);
                  v59 = _wcsdup(gpszTargetName);
                  v23 = gpszTargetName;
                  if ( psz )
                    v23 = psz;
                  v55 = _wcsdup(v23);
                  v24 = a2;
                  LOBYTE(v68) = 35;
                  v25 = sub_11F7BE0(&v40, a2, &v60, &v61);
                  LOBYTE(v68) = 36;
                  v26 = sub_11F7BE0(&v34, a2, &v55, &v59);
                  LOBYTE(v68) = 37;
                  a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v26, v25, &v58);
                  free(v34);
                  free(v40);
                  free(v55);
                  free(v59);
                  free(v60);
                  free(v61);
                  free(v58);
                  free(v56);
                  free(v57);
                  free(v45);
                  free(v43);
                  free(v44);
                }
                else
                {
                  v24 = a2;
                }
                v50 = _wcsdup(gpszTargetName);
                v27 = gpszTargetName;
                if ( psz )
                  v27 = psz;
                v52 = _wcsdup(v27);
                LOBYTE(v68) = 39;
                v28 = sub_11F7BE0(&v35, v24, &v52, &lpSubKey);
                LOBYTE(v68) = 40;
                sub_11F3FF0(a1, v37, a4, 3, &v64, v28, &v65);
                free(v35);
                free(v52);
                free(v50);
              }
              LOBYTE(v68) = 7;
              sub_11F21F0(&v30);
              v4 = v42;
            }
          }
          RegCloseKey(hKey);
        }
        v42 = ++v4;
      }
      while ( !sub_12013D0(v53, v4, &lpSubKey) );
    }
    RegCloseKey(v53);
  }
  free(v51);
  free(v47);
  free(v46);
  free(v49);
  free(v65);
  free(lpSubKey);
  free(v64);
  free(v67);
  return a4;
}

//----- (011F2BC0) --------------------------------------------------------
void __stdcall sub_11F2BC0(void **a1, void **a2)
{
  void **i; // esi

  for ( i = a1; i != a2; ++i )
    free(*i);
}

//----- (011F2BF0) --------------------------------------------------------
int __cdecl sub_11F2BF0(int a1, int a2)
{
  int v2; // edi
  void **v3; // esi
  void **i; // ebx
  int result; // eax

  if ( a1 != a2 )
  {
    v2 = a1 + 4;
    do
    {
      v3 = *v2;
      if ( *v2 )
      {
        for ( i = *(v2 + 4); v3 != i; ++v3 )
          free(*v3);
        j__free(*v2);
        *v2 = 0;
        *(v2 + 4) = 0;
        *(v2 + 8) = 0;
      }
      free(*(v2 - 4));
      v2 += 16;
      result = v2 - 4;
    }
    while ( v2 - 4 != a2 );
  }
  return result;
}

//----- (011F2C60) --------------------------------------------------------
void __thiscall sub_11F2C60(int *this)
{
  int *v1; // esi

  v1 = this;
  if ( *this )
  {
    sub_11F2BF0(*this, this[1]);
    j__free(*v1);
    *v1 = 0;
    v1[1] = 0;
    v1[2] = 0;
  }
}

//----- (011F2CB0) --------------------------------------------------------
void __cdecl sub_11F2CB0(int a1, void *a2, void *a3, LPCWSTR lpValueName)
{
  _WORD *v4; // ST58_4
  void *v5; // esi
  void *v6; // edi
  const wchar_t **v7; // eax
  wchar_t *v8; // ST5C_4

  v4 = malloc(2u);
  *v4 = 0;
  v5 = a3;
  v6 = sub_11F2D60(a1, a2, *a3, lpValueName, 0xFFFFFFFF);
  v7 = sub_11F22B0(&a3, v5, L"\\AutorunsDisabled");
  v8 = _wcsdup(*v7);
  free(v4);
  free(a3);
  sub_11F2D60(a1, a2, v8, lpValueName, v6);
  free(v8);
}

//----- (011F2D60) --------------------------------------------------------
void *__cdecl sub_11F2D60(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, void *a5)
{
  LPCWSTR v5; // ebx
  HKEY v6; // esi
  const wchar_t *v7; // eax
  WCHAR *v8; // eax
  const wchar_t *v9; // eax
  WCHAR *v10; // eax
  unsigned __int16 **v11; // esi
  unsigned __int16 **v12; // eax
  unsigned int v13; // eax
  int v14; // edx
  wchar_t *v15; // ecx
  unsigned int v16; // edi
  char *v17; // esi
  const wchar_t **v18; // eax
  void *v19; // esi
  WCHAR *v20; // ecx
  WCHAR *v21; // eax
  WCHAR *v22; // eax
  WCHAR *v23; // eax
  unsigned __int16 **v24; // esi
  unsigned __int16 **v25; // eax
  char v26; // bl
  const wchar_t *v27; // eax
  WCHAR *v28; // eax
  const wchar_t *v29; // eax
  WCHAR *v30; // eax
  unsigned __int16 **v31; // esi
  unsigned __int16 **v32; // eax
  WCHAR *v33; // eax
  WCHAR *v34; // eax
  unsigned __int16 **v35; // eax
  void *v37; // [esp+10h] [ebp-A4h]
  void *v38; // [esp+14h] [ebp-A0h]
  void *v39; // [esp+18h] [ebp-9Ch]
  void *v40; // [esp+1Ch] [ebp-98h]
  int v41; // [esp+20h] [ebp-94h]
  void *v42; // [esp+24h] [ebp-90h]
  int v43; // [esp+28h] [ebp-8Ch]
  void *v44; // [esp+2Ch] [ebp-88h]
  void *v45; // [esp+30h] [ebp-84h]
  void *v46; // [esp+34h] [ebp-80h]
  HKEY hKey; // [esp+38h] [ebp-7Ch]
  int v48; // [esp+3Ch] [ebp-78h]
  void *v49; // [esp+40h] [ebp-74h]
  void *v50; // [esp+44h] [ebp-70h]
  void *v51; // [esp+48h] [ebp-6Ch]
  wchar_t *v52; // [esp+4Ch] [ebp-68h]
  int v53; // [esp+50h] [ebp-64h]
  int v54; // [esp+54h] [ebp-60h]
  void *v55; // [esp+58h] [ebp-5Ch]
  void *v56; // [esp+5Ch] [ebp-58h]
  void *v57; // [esp+60h] [ebp-54h]
  wchar_t *v58; // [esp+64h] [ebp-50h]
  void *v59; // [esp+6Ch] [ebp-48h]
  void *v60; // [esp+70h] [ebp-44h]
  void *v61; // [esp+74h] [ebp-40h]
  void *v62; // [esp+78h] [ebp-3Ch]
  void *v63; // [esp+7Ch] [ebp-38h]
  void *v64; // [esp+80h] [ebp-34h]
  void *v65; // [esp+84h] [ebp-30h]
  void *v66; // [esp+88h] [ebp-2Ch]
  void *v67; // [esp+8Ch] [ebp-28h]
  void *v68; // [esp+90h] [ebp-24h]
  void *v69; // [esp+94h] [ebp-20h]
  void *v70; // [esp+98h] [ebp-1Ch]
  void *v71; // [esp+9Ch] [ebp-18h]
  void *v72; // [esp+A0h] [ebp-14h]
  void *v73; // [esp+A4h] [ebp-10h]
  int v74; // [esp+B0h] [ebp-4h]

  v58 = malloc(2u);
  *v58 = 0;
  v74 = 0;
  v73 = malloc(2u);
  *v73 = 0;
  v62 = malloc(2u);
  *v62 = 0;
  v57 = malloc(2u);
  *v57 = 0;
  v59 = malloc(2u);
  *v59 = 0;
  v5 = lpValueName;
  v6 = a2;
  LOBYTE(v74) = 4;
  if ( a5 == -1 )
  {
    v68 = _wcsdup(gpszTargetName);
    v63 = _wcsdup(gpszTargetName);
    v65 = _wcsdup(gpszTargetName);
    v67 = _wcsdup(gpszTargetName);
    v69 = _wcsdup(gpszTargetName);
    v70 = _wcsdup(gpszTargetName);
    v7 = gpszTargetName;
    if ( lpValueName )
      v7 = lpValueName;
    v71 = _wcsdup(v7);
    v8 = gpszTargetName;
    if ( psz )
      v8 = psz;
    v72 = _wcsdup(v8);
    v9 = gpszTargetName;
    if ( lpValueName )
      v9 = lpValueName;
    v66 = _wcsdup(v9);
    v10 = gpszTargetName;
    if ( psz )
      v10 = psz;
    v64 = _wcsdup(v10);
    LOBYTE(v74) = 14;
    v11 = sub_11F7BE0(&v61, a2, &v72, &v71);
    LOBYTE(v74) = 15;
    v12 = sub_11F7BE0(&v60, a2, &v64, &v66);
    LOBYTE(v74) = 16;
    a5 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v12, v11, &v70);
    free(v60);
    free(v61);
    free(v64);
    free(v66);
    free(v72);
    free(v71);
    free(v70);
    free(v69);
    free(v67);
    free(v65);
    free(v63);
    LOBYTE(v74) = 4;
    free(v68);
    v6 = a2;
  }
  v13 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(v6, psz, 0, v13 | 0x20019, &hKey) )
  {
    if ( !sub_1201520(hKey, lpValueName, 0, 0, &v58) )
    {
      v52 = 0;
      v53 = 0;
      v54 = 0;
      LOBYTE(v74) = 17;
      sub_11F6DD0(v58, 44, &v52, 32);
      v14 = v53;
      v15 = v52;
      v16 = 0;
      if ( (v53 - v52) >> 4 )
      {
        v17 = 0;
        v60 = 0;
        do
        {
          v48 = &v17[v15];
          v18 = sub_11F4EE0(&v44, a1, &v17[v15], 0);
          v19 = v73;
          v73 = _wcsdup(*v18);
          free(v19);
          free(v44);
          v41 = sub_11F4ED0();
          v20 = gpszTargetName;
          if ( v5 )
            v20 = v5;
          v67 = _wcsdup(v20);
          v21 = gpszTargetName;
          if ( psz )
            v21 = psz;
          v65 = _wcsdup(v21);
          v22 = gpszTargetName;
          if ( v5 )
            v22 = v5;
          v63 = _wcsdup(v22);
          v23 = gpszTargetName;
          if ( psz )
            v23 = psz;
          v68 = _wcsdup(v23);
          LOBYTE(v74) = 21;
          v24 = sub_11F7BE0(&v42, a2, &v65, &v67);
          LOBYTE(v74) = 22;
          v25 = sub_11F7BE0(&v37, a2, &v68, &v63);
          LOBYTE(v74) = 23;
          v26 = sub_11F3D40(a1, v25, v24, v48, &v73, &v62, &v59, &v43);
          free(v37);
          free(v42);
          free(v68);
          free(v63);
          free(v65);
          LOBYTE(v74) = 17;
          free(v67);
          if ( v26 )
          {
            if ( a5 == -1 )
            {
              v45 = _wcsdup(gpszTargetName);
              v49 = _wcsdup(gpszTargetName);
              v56 = _wcsdup(gpszTargetName);
              v51 = _wcsdup(gpszTargetName);
              v64 = _wcsdup(gpszTargetName);
              v66 = _wcsdup(gpszTargetName);
              v5 = lpValueName;
              v27 = gpszTargetName;
              if ( lpValueName )
                v27 = lpValueName;
              v72 = _wcsdup(v27);
              v28 = gpszTargetName;
              if ( psz )
                v28 = psz;
              v71 = _wcsdup(v28);
              v29 = gpszTargetName;
              if ( lpValueName )
                v29 = lpValueName;
              v70 = _wcsdup(v29);
              v30 = gpszTargetName;
              if ( psz )
                v30 = psz;
              v69 = _wcsdup(v30);
              LOBYTE(v74) = 33;
              v31 = sub_11F7BE0(&v40, a2, &v71, &v72);
              LOBYTE(v74) = 34;
              v32 = sub_11F7BE0(&v38, a2, &v69, &v70);
              LOBYTE(v74) = 35;
              a5 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v32, v31, &v66);
              free(v38);
              free(v40);
              free(v69);
              free(v70);
              free(v71);
              free(v72);
              free(v66);
              free(v64);
              free(v51);
              free(v56);
              free(v49);
              free(v45);
            }
            else
            {
              v5 = lpValueName;
            }
            v61 = _wcsdup(gpszTargetName);
            v55 = _wcsdup(gpszTargetName);
            v33 = gpszTargetName;
            if ( v5 )
              v33 = v5;
            v46 = _wcsdup(v33);
            v34 = gpszTargetName;
            if ( psz )
              v34 = psz;
            v50 = _wcsdup(v34);
            LOBYTE(v74) = 39;
            v35 = sub_11F7BE0(&v39, a2, &v50, &v46);
            LOBYTE(v74) = 40;
            sub_11F3FF0(a1, v41, a5, 5, v48, v35, &v73);
            free(v39);
            free(v50);
            free(v46);
            free(v55);
            LOBYTE(v74) = 17;
            free(v61);
          }
          else
          {
            v5 = lpValueName;
          }
          v14 = v53;
          ++v16;
          v15 = v52;
          v17 = v60 + 16;
          v60 = v60 + 16;
        }
        while ( v16 < (v53 - v52) >> 4 );
      }
      if ( v15 )
      {
        sub_11F2BF0(v15, v14);
        j__free(v52);
      }
    }
    RegCloseKey(hKey);
  }
  free(v59);
  free(v57);
  free(v62);
  free(v73);
  free(v58);
  return a5;
}

//----- (011F3440) --------------------------------------------------------
int __cdecl sub_11F3440(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edi
  int v6; // [esp+0h] [ebp-24h]
  int v7; // [esp+10h] [ebp-14h]
  int *v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+20h] [ebp-4h]

  v8 = &v6;
  v3 = a3;
  v4 = a1;
  v7 = a3;
  v9 = 0;
  while ( v4 != a2 )
  {
    if ( v3 )
    {
      *v3 = _wcsdup(*v4);
      LOBYTE(v9) = 2;
      sub_11F35A0((v3 + 4), (v4 + 4));
    }
    v3 += 16;
    LOBYTE(v9) = 0;
    v4 += 16;
  }
  return v3;
}

//----- (011F34F0) --------------------------------------------------------
wchar_t **__cdecl sub_11F34F0(const wchar_t **a1, const wchar_t **a2, wchar_t **a3)
{
  const wchar_t **v3; // esi
  wchar_t **v4; // edi

  v3 = a1;
  if ( a1 == a2 )
    return a3;
  v4 = a3;
  do
  {
    if ( v4 )
      *v4 = _wcsdup(*v3);
    ++v3;
    ++v4;
  }
  while ( v3 != a2 );
  return v4;
}

//----- (011F3530) --------------------------------------------------------
_DWORD *__thiscall sub_11F3530(void *this, void *a2)
{
  _DWORD *v2; // edi

  v2 = this;
  *(this + 5) = 7;
  *(this + 4) = 0;
  *this = 0;
  if ( *(a2 + 5) >= 8u )
  {
    *this = *a2;
    *a2 = 0;
  }
  else if ( *(a2 + 4) != -1 )
  {
    memmove(this, a2, 2 * (*(a2 + 4) + 1));
  }
  v2[4] = *(a2 + 4);
  v2[5] = *(a2 + 5);
  *(a2 + 5) = 7;
  *(a2 + 4) = 0;
  *a2 = 0;
  return v2;
}

//----- (011F35A0) --------------------------------------------------------
wchar_t ***__thiscall sub_11F35A0(wchar_t ***this, const wchar_t ***a2)
{
  wchar_t ***v2; // esi
  const wchar_t ***v3; // edi
  int v5; // [esp+0h] [ebp-24h]
  wchar_t ***v6; // [esp+10h] [ebp-14h]
  int *v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+20h] [ebp-4h]

  v7 = &v5;
  v2 = this;
  v6 = this;
  v3 = a2;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( sub_11FF930(this, v3[1] - *v3) )
  {
    v8 = 0;
    v2[1] = sub_11F34F0(*v3, v3[1], *v2);
  }
  return v2;
}

//----- (011F3650) --------------------------------------------------------
// _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2)
BSTR *__thiscall ConcatenateBSTR(Data_t *pThis, _bstr_t *pbstr1, _bstr_t *pbstr2)
{
  Data_t *this; // ebx
  WCHAR *bstr1; // eax
  UINT nLength1; // edi
  WCHAR *bstr2; // eax
  UINT nLength2; // esi
  unsigned int nLength; // ecx
  WCHAR *bstr; // edx
  Data_t *Data1; // eax
  _bstr_t *Data2; // eax
  int nTotalLength; // [esp+Ch] [ebp-8h]

  this = pThis;
  pThis->m_str = 0;
  pThis->m_RefCount = 1;
  if ( pbstr1->m_Data && (bstr1 = pbstr1->m_Data->m_wstr) != 0 )
    nLength1 = SysStringLen(bstr1);
  else
    nLength1 = 0;
  if ( pbstr2->m_Data && (bstr2 = pbstr2->m_Data->m_wstr) != 0 )
    nLength2 = SysStringLen(bstr2);
  else
    nLength2 = 0;
  nLength = nLength2 + nLength1;
  if ( nLength2 + nLength1 < nLength2 || !is_mul_ok(2u, nLength) || 2 * nLength > 0xFFFFFFFF )
__reporterror:
    com_error::throw(E_OUTOFMEMORY);
  nTotalLength = 2 * nLength;
  bstr = SysAllocStringByteLen(0, 2 * nLength);
  this->m_wstr = bstr;
  if ( bstr )
  {
    Data1 = pbstr1->m_Data;
    if ( pbstr1->m_Data && Data1->m_wstr )
      memcpy_s(bstr, nTotalLength + 2, Data1->m_wstr, 2 * nLength1 + 2);
    Data2 = pbstr2->m_Data;
    if ( pbstr2->m_Data && Data2->m_Data )
      memcpy_s(&this->m_wstr[nLength1], 2 * nLength2 + 2, Data2->m_Data, 2 * nLength2 + 2);
  }
  else if ( nLength2 + nLength1 )
  {
    goto __reporterror;
  }
  return this;
}

//----- (011F3750) --------------------------------------------------------
void __thiscall sub_11F3750(void *this)
{
  _DWORD *v1; // esi
  _WORD *v2; // eax

  v1 = this;
  v2 = malloc(2u);
  v1[4] = v2;
  *v2 = 0;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = 0;
}

//----- (011F3780) --------------------------------------------------------
// _bstr_t& _bstr_t::operator=(const wchar_t* s) 
CComBSTR **__thiscall bstr_t::EqualAssign(_bstr_t *ppv, OLECHAR *psz)
{
  _bstr_t *v2; // edi
  Data_t *pNewData; // eax
  Data_t *newData; // esi
  WCHAR *bstr; // eax

  v2 = ppv;
  pNewData = operator new(0xCu);
  newData = pNewData;
  if ( pNewData )
  {
    pNewData->m_str = 0;
    pNewData->m_RefCount = 1;
    bstr = SysAllocString(psz);
    newData->m_wstr = bstr;
    if ( !bstr && psz )
      com_error::throw(E_OUTOFMEMORY);
  }
  else
  {
    newData = 0;
  }
  v2->m_Data = newData;
  if ( !newData )
    com_error::throw(E_OUTOFMEMORY);
  return v2;
}

//----- (011F3820) --------------------------------------------------------
int __thiscall sub_11F3820(int this)
{
  int v1; // esi
  int result; // eax

  v1 = this;
  if ( *(this + 20) >= 8u )
    j__free(*this);
  *(v1 + 20) = 7;
  result = 0;
  *(v1 + 16) = 0;
  *v1 = 0;
  return result;
}

//----- (011F3850) --------------------------------------------------------
void __thiscall sub_11F3850(void *this)
{
  void *v1; // esi

  v1 = this;
  if ( *(this + 5) )
  {
    j__free(*(this + 5));
    *(v1 + 5) = 0;
    *(v1 + 6) = 0;
    *(v1 + 7) = 0;
  }
  free(*(v1 + 4));
}

//----- (011F3890) --------------------------------------------------------
void __thiscall bstr_t::Data_t::Free(Data_t *pData)
{
  Data_t *v1; // edi
  _bstr_t bstrThis; // esi

  v1 = pData;
  bstrThis.m_Data = pData->m_wstr;
  if ( pData->m_wstr )
  {
    if ( !InterlockedDecrement(&bstrThis.m_Data->m_RefCount) && bstrThis.m_Data )
    {
      if ( bstrThis.m_Data->m_wstr )
      {
        SysFreeString(bstrThis.m_Data->m_wstr);
        bstrThis.m_Data->m_wstr = 0;
      }
      if ( bstrThis.m_Data->m_str )
      {
        j_j__free(bstrThis.m_Data->m_str);
        bstrThis.m_Data->m_str = 0;
      }
      j__free(bstrThis.m_Data);
    }
    v1->m_wstr = 0;
  }
}

//----- (011F38F0) --------------------------------------------------------
int *__thiscall sub_11F38F0(int *this, const wchar_t ***a2)
{
  int *v2; // edi
  const wchar_t ***v3; // ebx
  const wchar_t **v4; // esi
  const wchar_t **v5; // eax
  void **v6; // ecx
  unsigned int v7; // edx
  void **v8; // esi
  void **v9; // ebx
  wchar_t **v10; // eax
  const wchar_t **v12; // esi
  int v13; // [esp+0h] [ebp-28h]
  int *v14; // [esp+10h] [ebp-18h]
  unsigned int v15; // [esp+14h] [ebp-14h]
  int *v16; // [esp+18h] [ebp-10h]
  int v17; // [esp+24h] [ebp-4h]

  v16 = &v13;
  v2 = this;
  v14 = this;
  v3 = a2;
  if ( this != a2 )
  {
    v4 = *a2;
    v5 = a2[1];
    if ( *a2 == v5 )
    {
      sub_1200010(this);
      return v2;
    }
    v6 = *this;
    v7 = v5 - v4;
    v15 = (v2[1] - *v2) >> 2;
    if ( v7 <= v15 )
    {
      v8 = sub_1214700(v4, a2[1], v6);
      if ( v8 != v2[1] )
      {
        v9 = v2[1];
        do
        {
          free(*v8);
          ++v8;
        }
        while ( v8 != v9 );
        v3 = a2;
      }
      v10 = (*v2 + 4 * (v3[1] - *v3));
      goto LABEL_10;
    }
    if ( v7 <= (v2[2] - v6) >> 2 )
    {
      v12 = &v4[v15];
      sub_1214700(*a2, v12, v6);
      v10 = sub_11F34F0(v12, v3[1], v2[1]);
LABEL_10:
      v2[1] = v10;
      return v2;
    }
    if ( v6 )
    {
      sub_11F2BC0(v6, v2[1]);
      j__free(*v2);
    }
    if ( sub_11FF930(v2, v3[1] - *v3) )
    {
      v17 = 0;
      v10 = sub_11F34F0(*v3, v3[1], *v2);
      goto LABEL_10;
    }
  }
  return v2;
}

//----- (011F3A50) --------------------------------------------------------
int *__thiscall sub_11F3A50(int *this, int *a2)
{
  int *v2; // esi
  int v3; // eax

  v2 = this;
  if ( this != a2 )
  {
    bstr_t::Data_t::Free(this);
    v3 = *a2;
    *v2 = *a2;
    if ( v3 )
      InterlockedIncrement((v3 + 8));
  }
  return v2;
}

//----- (011F3A80) --------------------------------------------------------
BSTR **__thiscall bstr_t::Assign(_bstr_t *this, OLECHAR *psz)
{
  _bstr_t *v2; // edi
  WCHAR *v3; // eax
  Data_t *newData; // eax
  Data_t *v5; // esi
  WCHAR *newBSTR; // eax

  v2 = this;
  if ( !psz || (!this->m_Data ? (v3 = 0) : (v3 = this->m_Data->m_wstr), v3 != psz) )
  {
    bstr_t::Data_t::Free(this);
    newData = operator new(0xCu);
    v5 = newData;
    if ( newData )
    {
      newData->m_str = 0;
      newData->m_RefCount = 1;
      newBSTR = SysAllocString(psz);
      v5->m_wstr = newBSTR;
      if ( !newBSTR && psz )
        com_error::throw(E_OUTOFMEMORY);
    }
    else
    {
      v5 = 0;
    }
    v2->m_Data = v5;
    if ( !v5 )
      com_error::throw(E_OUTOFMEMORY);
  }
  return v2;
}

//----- (011F3B40) --------------------------------------------------------
int __thiscall sub_11F3B40(int **this)
{
  int result; // eax

  if ( *this )
    result = **this;
  else
    result = 0;
  return result;
}

//----- (011F3B50) --------------------------------------------------------
int __cdecl sub_11F3B50(int ppv, OLECHAR *psz, int ppComBSTR2)
{
  bstr_t::EqualAssign(ppv, psz);
  bstr_t::Append(ppv, ppComBSTR2);
  return ppv;
}

//----- (011F3BC0) --------------------------------------------------------
// inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const 
CComBSTR ***__thiscall CComBSTR::AppendTail(_bstr_t *this, _bstr_t *ppComBSTR1, CComBSTR **ppComBSTR2)
{
  Data_t *pThis; // eax

  pThis = this->m_Data;
  ppComBSTR1->m_Data = this->m_Data;
  if ( pThis )
    //     _bstr_t b = *this;
    InterlockedIncrement(&pThis->m_RefCount);
  //     b += s;
  bstr_t::Append(ppComBSTR1, ppComBSTR2);
  return ppComBSTR1;
}

//----- (011F3C30) --------------------------------------------------------
BOOL __thiscall sub_11F3C30(BSTR **this, BSTR **a2)
{
  BSTR *v2; // ecx
  BSTR *v3; // eax
  OLECHAR *v5; // eax

  v2 = *this;
  v3 = *a2;
  if ( v2 == *a2 )
    return 0;
  if ( !v2 )
  {
    if ( v3 )
    {
      v5 = *v3;
      if ( v5 )
      {
        if ( SysStringLen(v5) )
          return 1;
      }
    }
    return 0;
  }
  if ( v3 )
    return sub_11F4730(v2, *a2) < 0;
  if ( !*v2 || !SysStringLen(*v2) )
    return 0;
  return 0;
}

//----- (011F3CB0) --------------------------------------------------------
//     _bstr_t& operator+=(const _bstr_t& s) ;
OLECHAR ***__thiscall bstr_t::Append(_bstr_t *ppComBSTR1, _bstr_t *pbstr)
{
  _bstr_t *this; // esi
  Data_t *NewData; // eax
  Data_t *res; // edi

  this = ppComBSTR1;
  NewData = operator new(0xCu);
  if ( NewData )
    res = ConcatenateBSTR(NewData, this, pbstr);
  else
    res = 0;
  if ( !res )
    com_error::throw(E_OUTOFMEMORY);
  bstr_t::Data_t::Free(this);
  this->m_Data = res;
  return this;
}

//----- (011F3D40) --------------------------------------------------------
char __cdecl sub_11F3D40(int a1, const wchar_t **a2, OLECHAR **a3, OLECHAR **a4, OLECHAR **a5, const wchar_t **a6, void **a7, _DWORD *a8)
{
  OLECHAR **v8; // esi
  void *v10; // esi
  wchar_t *v11; // eax
  wchar_t *v12; // edi
  WCHAR *v13; // eax
  wchar_t *v14; // eax
  int v15; // eax
  void *v16; // esi
  const wchar_t **v17; // eax
  WCHAR *v18; // edi
  WCHAR *v19; // ecx
  wchar_t *v20; // esi
  wchar_t *v21; // esi
  const wchar_t **v22; // eax
  wchar_t *v23; // ST14_4
  int v24; // ST10_4
  wchar_t *v25; // eax
  wchar_t *v26; // eax
  wchar_t *v27; // esi
  unsigned __int16 **v28; // eax
  int v29; // [esp+10h] [ebp-84h]
  OLECHAR **v30; // [esp+14h] [ebp-80h]
  int v31; // [esp+18h] [ebp-7Ch]
  OLECHAR **v32; // [esp+1Ch] [ebp-78h]
  wchar_t *v33; // [esp+20h] [ebp-74h]
  OLECHAR **v34; // [esp+24h] [ebp-70h]
  void *v35; // [esp+28h] [ebp-6Ch]
  int v36; // [esp+2Ch] [ebp-68h]
  void *v37; // [esp+30h] [ebp-64h]
  wchar_t *v38; // [esp+34h] [ebp-60h]
  int v39; // [esp+90h] [ebp-4h]

  v8 = a5;
  v30 = a3;
  v32 = a4;
  v34 = a5;
  v37 = a6;
  v31 = a8;
  *a8 = 0;
  v29 = 20;
  if ( byte_12E3860[0] )
    ExitThread(0);
  if ( !_wcsicmp(*a2, L"desktop.ini") )
    return 0;
  if ( dword_12E3858 )
  {
    v10 = *a7;
    *a7 = _wcsdup(*a6);
    free(v10);
    v11 = malloc(2u);
    v12 = v11;
    v33 = v11;
    *v11 = 0;
    v39 = 0;
    v13 = gpszTargetName;
    if ( *v34 )
      v13 = *v34;
    v14 = _wcsdup(v13);
    v15 = sub_1211290(v14, a7);
    if ( v15 != 2 )
    {
      if ( v15 )
      {
        if ( !**a7 )
          goto LABEL_24;
        v26 = _wcsdup(L"(Not Verified) ");
      }
      else
      {
        v26 = _wcsdup(L"(Verified) ");
      }
      v27 = v26;
      v36 = v26;
      v28 = sub_1203070(&v35, &v36, a7);
      sub_11F2250(a7, v28);
      free(v35);
      free(v27);
      goto LABEL_24;
    }
    v36 = sub_11F6700(*v34, 0, 0, &v38, &v29, 0);
    if ( v36 )
    {
      v16 = v37;
      if ( !**v37 )
      {
LABEL_18:
        v23 = _wcsdup(v12);
        v24 = v36;
        v25 = _wcsdup(*v34);
        sub_12111B0(v25, v24, v23);
LABEL_24:
        v39 = -1;
        free(v12);
        v8 = v34;
        goto LABEL_25;
      }
      sub_11F2250(&v33, v37);
      v17 = sub_120F210(&v37, L"(Not verified) ", v16);
      sub_11F2250(a7, v17);
      free(v37);
    }
    else
    {
      v18 = gpszTargetName;
      v19 = gpszTargetName;
      if ( v38 )
        v19 = v38;
      v20 = _wcsdup(v19);
      v37 = v20;
      sub_11F2250(&v33, &v37);
      free(v20);
      if ( v38 )
        v18 = v38;
      v21 = _wcsdup(v18);
      v37 = v21;
      v22 = sub_120F210(&v35, L"(Verified) ", &v37);
      sub_11F2250(a7, v22);
      free(v35);
      free(v21);
    }
    v12 = v33;
    goto LABEL_18;
  }
LABEL_25:
  if ( dword_12E48D4 )
  {
    if ( wcsncmp(*v8, L"File not found: ", 0x10u) )
      sub_1211590(1, v31, *v30, *v32, *v8, 0);
  }
  return 1;
}
// 12E3858: using guessed type int dword_12E3858;
// 12E48D4: using guessed type int dword_12E48D4;

//----- (011F3FF0) --------------------------------------------------------
int __cdecl sub_11F3FF0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7)
{
  _WORD *v7; // edi
  unsigned __int16 **v8; // eax
  OLECHAR *v9; // esi
  OLECHAR *v10; // ecx
  int result; // eax
  void *v12; // esi

  if ( !(dword_12E4C48 & 1) )
  {
    dword_12E4C48 |= 1u;
    dword_12E4C44 = malloc(2u);
    *dword_12E4C44 = 0;
    atexit(sub_12AA2E0);
  }
  if ( a3 == -1 )
  {
    v12 = dword_12E4C44;
    dword_12E4C44 = _wcsdup(*a5);
    free(v12);
    result = 0;
  }
  else
  {
    v7 = malloc(2u);
    *v7 = 0;
    if ( a4 == 9 )
    {
      v8 = sub_1203070(&a3, &dword_12E4C44, a5);
      v9 = _wcsdup(*v8);
      free(v7);
      free(a3);
    }
    else
    {
      v9 = _wcsdup(*a6);
      free(v7);
    }
    if ( dword_12E31C0 == 1 )
    {
      v10 = L"System";
    }
    else if ( gpSysMenuData )
    {
      v10 = gpSysMenuData->szMenuName;
    }
    else
    {
      v10 = L"Local System";
    }
    sub_122BF00(v10, *a7, v9);
    free(v9);
    result = 0;
  }
  return result;
}
// 12AD5D8: using guessed type wchar_t aLocalSystem[13];
// 12E31C0: using guessed type int dword_12E31C0;
// 12E4C48: using guessed type int dword_12E4C48;

//----- (011F4130) --------------------------------------------------------
int __cdecl sub_11F4130(HWND hWindow)
{
  HANDLE ProcessHandle; // eax
  HMENU hWindowMenu; // eax
  SystemMenuData *pBuffer; // eax
  OLECHAR *ppsz; // edx
  SystemMenuData *pSystemMenuData; // ebx
  __int16 *pBuffer_008H; // esi
  OLECHAR sz; // cx
  const wchar_t *pszDefault; // ecx
  int pBuffer_008H_copy; // edi
  wchar_t chDefault; // ax
  HWND hWnd_; // edi
  int nPos; // ST14_4
  HMENU hMainWnd; // eax
  HMENU ProcessMenu; // eax
  unsigned int dwTlsValue; // eax
  char *v16; // ebx
  LSTATUS (__stdcall *RegQueryValueExW)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // edi
  OLECHAR *v18; // esi
  unsigned int pTlsData; // eax
  PSID pSID; // ebx
  void *v21; // eax
  SystemMenuData *v22; // esi
  OLECHAR *v23; // ecx
  __int16 *v24; // edx
  OLECHAR v25; // ax
  UINT_PTR v26; // ST14_4
  HMENU v27; // eax
  HMENU v28; // eax
  int result; // eax
  int v30; // [esp+0h] [ebp-1468h]
  DWORD cchName; // [esp+10h] [ebp-1458h]
  DWORD ReturnLength; // [esp+14h] [ebp-1454h]
  BYTE Data; // [esp+18h] [ebp-1450h]
  enum _SID_NAME_USE peUse; // [esp+1Ch] [ebp-144Ch]
  DWORD cbSid; // [esp+20h] [ebp-1448h]
  HKEY hKey; // [esp+24h] [ebp-1444h]
  HANDLE TokenHandle; // [esp+28h] [ebp-1440h]
  DWORD cchReferencedDomainName; // [esp+2Ch] [ebp-143Ch]
  DWORD cbData; // [esp+30h] [ebp-1438h]
  SystemMenuData *SystemMenuData; // [esp+34h] [ebp-1434h]
  HWND hWnd; // [esp+38h] [ebp-1430h]
  HKEY hSubKey; // [esp+3Ch] [ebp-142Ch]
  PSID pSid; // [esp+40h] [ebp-1428h]
  OLECHAR *psz; // [esp+44h] [ebp-1424h]
  int TokenInformation[1024]; // [esp+48h] [ebp-1420h]
  __int16 Name[260]; // [esp+1048h] [ebp-420h]
  __int16 ReferencedDomainName[260]; // [esp+1250h] [ebp-218h]
  int v48; // [esp+1464h] [ebp-4h]

  hWnd = hWindow;
  psz = malloc(2u);
  *psz = 0;
  v48 = 0;
  ProcessHandle = GetCurrentProcess();
  if ( !OpenProcessToken(ProcessHandle, TOKEN_QUERY, &TokenHandle) )
  {
__Error:
    if ( hWindow )
    {
      hWindowMenu = GetMenu(hWindow);
__DeleteMenu:
      DeleteMenu(hWindowMenu, 3u, MF_BYPOSITION);
      goto __quit;
    }
    goto __quit;
  }
  ReturnLength = 4096;
  if ( !GetTokenInformation(TokenHandle, TokenUser, TokenInformation, 4096u, &ReturnLength) )
  {
    CloseHandle(TokenHandle);
    goto __Error;
  }
  CloseHandle(TokenHandle);
  cbSid = 0;
  LookupAccountNameW(0, L"System", 0, &cbSid, ReferencedDomainName, &cchReferencedDomainName, &peUse);
  pSid = malloc(cbSid);
  LookupAccountNameW(0, L"System", pSid, &cbSid, ReferencedDomainName, &cchReferencedDomainName, &peUse);
  pBuffer = malloc(1568u);
  ppsz = psz;
  pSystemMenuData = pBuffer;
  SystemMenuData = pBuffer;
  pBuffer_008H = pBuffer->strDefault;
  do
  {
    sz = *ppsz;
    ++ppsz;
    *pBuffer_008H = sz;
    ++pBuffer_008H;
  }
  while ( sz );
  pszDefault = L".Default";
  pBuffer_008H_copy = pBuffer->strDefault - L".Default";
  do
  {
    chDefault = *pszDefault;
    ++pszDefault;
    *(pszDefault + pBuffer_008H_copy - 2) = chDefault;
  }
  while ( chDefault );
  pSystemMenuData->nMenuPos = (dword_12E4C24 - dword_12E4C20) >> 2;
  _swprintf(pSystemMenuData->szMenuName, L"%s\\%s", L"NT AUTHORITY", L"SYSTEM");
  hWnd_ = hWnd;
  if ( hWnd )
  {
    nPos = pSystemMenuData->nMenuPos;
    hMainWnd = GetMenu(hWnd);
    ProcessMenu = GetSubMenu(hMainWnd, MENUINDEX_RPOCESS);
    InsertMenuW(ProcessMenu, -1u, MF_BYPOSITION, nPos, pSystemMenuData->szMenuName);
  }
  if ( EqualSid(pSid, TokenInformation[0]) )
  {
    pSystemMenuData->SystemAdministrative = 1;
    gpSysMenuData = pSystemMenuData;
  }
  else
  {
    pSystemMenuData->SystemAdministrative = 0;
  }
  _swprintf(pSystemMenuData->SystemWinDirectory, L"%s\\%s", &gszSystemWinDirCopy[1], L"Config", v30);
  sub_12308F0(&dword_12E4C20, &SystemMenuData);
  dwTlsValue = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(
          ghKLM,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
          0,
          dwTlsValue | KEY_READ,
          &hSubKey) )
  {
    v16 = 0;
    pSid = 0;
    if ( !sub_12013D0(hSubKey, 0, &psz) )
    {
      RegQueryValueExW = ::RegQueryValueExW;
      do
      {
        v18 = psz;
        pTlsData = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(hSubKey, v18, 0, pTlsData | KEY_READ, &hKey) )
        {
          cbData = 4;
          if ( !RegQueryValueExW(hKey, L"Flags", 0, 0, &Data, &cbData) && !(Data & 8) )
          {
            pSID = InitializeSidFromText(psz);
            if ( pSID )
            {
              cchName = 260;
              cchReferencedDomainName = 260;
              if ( LookupAccountSidW(0, pSID, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
              {
                v21 = malloc(1568u);
                cbData = 520;
                v22 = v21;
                SystemMenuData = v21;
                if ( RegQueryValueExW(hKey, L"ProfileImagePath", 0, 0, v21 + 0x418, &cbData) )
                {
                  free(v22);
                }
                else
                {
                  v23 = psz;
                  v24 = v22->strDefault;
                  do
                  {
                    v25 = *v23;
                    ++v23;
                    *v24 = v25;
                    ++v24;
                  }
                  while ( v25 );
                  v22->nMenuPos = (dword_12E4C24 - dword_12E4C20) >> 2;
                  _swprintf(v22->szMenuName, L"%s\\%s", ReferencedDomainName, Name);
                  if ( hWnd )
                  {
                    v26 = v22->nMenuPos;
                    v27 = GetMenu(hWnd);
                    v28 = GetSubMenu(v27, 3);
                    InsertMenuW(v28, 0xFFFFFFFF, 0x400u, v26, v22->szMenuName);
                  }
                  if ( EqualSid(pSID, TokenInformation[0]) )
                  {
                    v22->SystemAdministrative = 1;
                    gpSysMenuData = v22;
                  }
                  else
                  {
                    v22->SystemAdministrative = 0;
                  }
                  sub_12308F0(&dword_12E4C20, &SystemMenuData);
                  RegQueryValueExW = ::RegQueryValueExW;
                }
              }
              FreeSid(pSID);
            }
            v16 = pSid;
          }
          RegCloseKey(hKey);
        }
        pSid = ++v16;
      }
      while ( !sub_12013D0(hSubKey, v16, &psz) );
      hWnd_ = hWnd;
    }
    RegCloseKey(hSubKey);
  }
  if ( !TmAdjustPrivilege(L"SeRestorePrivilege") )
  {
    if ( hWnd_ )
    {
      hWindowMenu = GetMenu(hWnd_);
      goto __DeleteMenu;
    }
__quit:
    byte_12E31CA = 1;
  }
  free(psz);
  return result;
}
// 12ACA8C: using guessed type wchar_t aSystem_0[7];
// 12B1FCC: using guessed type wchar_t aDefault[9];
// 12B1FE0: using guessed type wchar_t aNtAuthority[13];
// 12B2008: using guessed type wchar_t aConfig[7];
// 12E31CA: using guessed type char byte_12E31CA;
// 12E4C24: using guessed type int dword_12E4C24;

//----- (011F4650) --------------------------------------------------------
char sub_11F4650()
{
  const wchar_t **strPath; // eax
  wchar_t *OldEnvPathName; // esi
  _DWORD *v2; // ecx
  unsigned int v3; // esi
  unsigned int v4; // eax
  TCHAR *pszPathInfo; // [esp+4h] [ebp-4h]

  sub_11F5BB0();
  gdwTlsIndex = TlsAlloc();
  TlsSetValue(gdwTlsIndex, 0);
  UpadteSystemPathInfo();
  strPath = GetEnvironmentPathInfo(&pszPathInfo, L"%PATH%");
  OldEnvPathName = gEnvPathName;
  gEnvPathName = _wcsdup(*strPath);
  free(OldEnvPathName);
  free(pszPathInfo);
  InitializeCriticalSection(&stru_12E3400);
  AdjustPrivilegeToWINLOGON();
  sub_11F4130(0);
  sub_11FB220(0xFFFFFFFF, 1);
  sub_11FB220(0xFFFFFFFF, 0);
  v2 = dword_12E4C20;
  v3 = 0;
  v4 = (dword_12E4C24 - dword_12E4C20) >> 2;
  if ( v4 )
  {
    do
    {
      LOBYTE(v4) = sub_11FF610(0, gpSysMenuData, *(v2[v3] + 4));
      if ( !v4 )
        break;
      sub_11FB220(0xFFFFFFFF, 0);
      ++v3;
      v2 = dword_12E4C20;
      v4 = (dword_12E4C24 - dword_12E4C20) >> 2;
    }
    while ( v3 < v4 );
  }
  return v4;
}
// 12E4C24: using guessed type int dword_12E4C24;

//----- (011F4730) --------------------------------------------------------
int __thiscall sub_11F4730(BSTR *this, BSTR *a2)
{
  BSTR *v2; // ebx
  UINT v3; // eax
  BSTR v4; // esi
  UINT v5; // edx
  UINT v6; // eax
  UINT v7; // ecx
  BSTR v8; // edi
  OLECHAR v9; // dx
  int result; // eax
  UINT v11; // [esp+Ch] [ebp-4h]
  UINT v12; // [esp+18h] [ebp+8h]

  v2 = this;
  v11 = SysStringLen(*this);
  v3 = SysStringLen(*a2);
  v4 = *v2;
  v5 = v3;
  v6 = v11;
  v7 = v11;
  v8 = *a2;
  v12 = v5;
  if ( v11 > v5 )
    v7 = v5;
  if ( v7 )
  {
    while ( 1 )
    {
      v9 = *v4;
      ++v8;
      ++v4;
      --v7;
      if ( v9 != *(v8 - 1) )
        break;
      if ( !v7 )
      {
        v5 = v12;
        v6 = v11;
        goto LABEL_7;
      }
    }
    result = *(v4 - 1) - *(v8 - 1);
  }
  else
  {
LABEL_7:
    if ( v6 >= v5 )
      result = v11 != v5;
    else
      result = -1;
  }
  return result;
}

//----- (011F47C0) --------------------------------------------------------
errno_t __cdecl sub_11F47C0(wchar_t *Src, wchar_t *Dst, rsize_t SizeInWords)
{
  return tcscpy_s(Dst, SizeInWords, Src);
}

//----- (011F47E0) --------------------------------------------------------
BOOL __cdecl TmAdjustPrivilege(LPCWSTR lpName)
{
  HANDLE hProcess; // eax
  BOOL bRet; // esi
  LUID Luid; // [esp+4h] [ebp-20h]
  HANDLE TokenHandle; // [esp+Ch] [ebp-18h]
  TOKEN_PRIVILEGES NewState; // [esp+10h] [ebp-14h]

  hProcess = GetCurrentProcess();
  if ( !OpenProcessToken(hProcess, 0x28u, &TokenHandle) || !LookupPrivilegeValueW(NULL, lpName, &Luid) )
    return 0;
  *&NewState.PrivilegeCount = Luid;
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  bRet = AdjustTokenPrivileges(TokenHandle, 0, &NewState, sizeof(_TOKEN_PRIVILEGES), 0, 0);
  if ( bRet )
  {
    if ( GetLastError() )
      bRet = FALSE;
  }
  CloseHandle(TokenHandle);
  return bRet;
}

//----- (011F4890) --------------------------------------------------------
int __cdecl sub_11F4890(int a1, wchar_t *a2)
{
  _WORD *v2; // esi
  _WORD *v3; // edi
  wchar_t *v4; // ebx
  wchar_t *v5; // esi
  int v6; // ecx
  wchar_t *v7; // ecx
  wchar_t v8; // ax
  const wchar_t **v9; // eax
  wchar_t *v10; // esi
  wchar_t *v11; // edi
  wchar_t *v12; // eax
  wchar_t *v13; // ST14_4
  LPWSTR v14; // eax
  signed __int16 v15; // cx
  wchar_t *v16; // ST14_4
  wchar_t *v17; // ebx
  DWORD v18; // eax
  wchar_t *v19; // eax
  WCHAR *v21; // [esp+14h] [ebp-18h]
  LPWSTR ppsz; // [esp+1Ch] [ebp-10h]
  int v23; // [esp+28h] [ebp-4h]

  v2 = malloc(2u);
  *v2 = 0;
  v23 = 0;
  v3 = malloc(2u);
  *v3 = 0;
  LOBYTE(v23) = 1;
  v4 = _wcsdup(a2);
  free(v2);
  if ( TlsGetValue(gdwTlsIndex) == 256 )
  {
    v5 = _wcsdup(v4);
    _wcsupr(v5);
    if ( wcsstr(v5, L"%PROGRAMFILES%") )
    {
      v6 = wcsstr(v5, L"%PROGRAMFILES%") - v5;
      _mm_storeu_si128(&v4[v6], _mm_loadu_si128(L"%ProgramW6432%"));
      _mm_storel_epi64(&v4[v6 + 8], _mm_loadl_epi64(L"W6432%"));
      *&v4[v6 + 12] = *L"2%";
      v7 = &v4[v6 + 14];
      do
      {
        v8 = *v7;
        ++v7;
        *(v7 - 1) = v8;
      }
      while ( v8 );
    }
    free(v5);
  }
  v9 = GetEnvironmentPathInfo(&ppsz, v4);
  v10 = _wcsdup(*v9);
  free(v3);
  free(ppsz);
  v11 = _wcsdup(v10);
  free(v4);
  if ( *v10 != 34 )
  {
    if ( sub_1201040(v10) != -1 )
      goto LABEL_20;
    ppsz = 0;
    v17 = wcsrchr(v10, 0x20u);
    if ( !v17 )
      goto LABEL_20;
    do
    {
      if ( ppsz )
        *ppsz = 32;
      *v17 = 0;
      v18 = sub_1201040(v10);
      if ( v18 != -1 && !(v18 & 0x10) )
      {
        v19 = _wcsdup(v10);
        goto LABEL_21;
      }
      ppsz = v17;
      v17 = wcsrchr(v10, 0x20u);
    }
    while ( v17 );
    v14 = ppsz;
    if ( !ppsz )
      goto LABEL_20;
    v15 = 32;
    goto LABEL_19;
  }
  v12 = wcschr(v10 + 1, 0x22u);
  v21 = v12;
  if ( v12 )
  {
    *v12 = 0;
    v13 = v11;
    v11 = _wcsdup(v10 + 1);
    free(v13);
    v14 = v21;
    v15 = 34;
LABEL_19:
    *v14 = v15;
    goto LABEL_20;
  }
  v16 = v11;
  v11 = _wcsdup(v10 + 1);
  free(v16);
LABEL_20:
  v19 = _wcsdup(v11);
LABEL_21:
  *a1 = v19;
  free(v10);
  free(v11);
  return a1;
}

//----- (011F4AC0) --------------------------------------------------------
int __cdecl sub_11F4AC0(int a1, wchar_t *psz)
{
  _WORD *v2; // edi
  wchar_t *v3; // esi
  wchar_t *v4; // ebx
  unsigned int v5; // kr04_4
  WCHAR *v6; // ecx
  wchar_t *v7; // esi
  const wchar_t **v8; // eax
  wchar_t *v9; // esi
  void *v11; // [esp+18h] [ebp-1Ch]
  void *v12; // [esp+1Ch] [ebp-18h]
  int v13; // [esp+20h] [ebp-14h]
  wchar_t *v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+30h] [ebp-4h]

  v15 = 0;
  v2 = malloc(2u);
  v13 = v2;
  *v2 = 0;
  v3 = _wcsdup(psz);
  v14 = v3;
  v4 = _wcsdup(gszProgrameFiles);
  LOBYTE(v15) = 3;
  _wcsupr(v4);
  _wcsupr(v3);
  if ( !wcsncmp(v3, v4, wcslen(v4)) && sub_1201040(psz) == -1 )
  {
    v5 = wcslen(gszProgrameFiles);
    v6 = gpszTargetName;
    if ( &psz[v5] )
      v6 = &psz[v5];
    v7 = _wcsdup(v6);
    v13 = v7;
    v8 = sub_120F210(&v11, gszEnvValue, &v13);
    v12 = v2;
    v2 = _wcsdup(*v8);
    v13 = v2;
    free(v12);
    free(v11);
    free(v7);
    if ( sub_1201040(v2) != -1 )
    {
      v9 = psz;
      psz = _wcsdup(v2);
      free(v9);
    }
    v3 = v14;
  }
  *a1 = _wcsdup(psz);
  free(v4);
  free(v3);
  free(v2);
  free(psz);
  return a1;
}

//----- (011F4C50) --------------------------------------------------------
PSID __cdecl InitializeSidFromText(LPCTSTR lpszText)
{
  LPCTSTR pszString; // ecx
  int count; // ebx
  __int16 chText; // ax
  LPCTSTR pszFound1; // eax
  LPCTSTR pszFound2; // eax
  LPCTSTR pszText2; // edi
  LPCTSTR pszFound3; // esi
  LPCTSTR pszText3; // eax
  LPCTSTR pszText; // esi
  UINT index; // edi
  LPCTSTR chText1; // eax
  int *nSubAuthority; // edi
  BOOL ret; // eax
  int nAuth; // [esp+4h] [ebp-838h]
  BYTE nSubAuthorityCount[4]; // [esp+8h] [ebp-834h]
  PSID pSid; // [esp+Ch] [ebp-830h]
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // [esp+10h] [ebp-82Ch]
  int nSubAuthority0[8]; // [esp+18h] [ebp-824h]
  TCHAR szBuffer[1024]; // [esp+38h] [ebp-804h]

  pszString = lpszText;
  pSid = NULL;
  LOBYTE(count) = 0;
  nSubAuthority0[0] = 0;
  nSubAuthorityCount[0] = 0;
  nSubAuthority0[1] = 0;
  nSubAuthority0[2] = 0;
  nSubAuthority0[3] = 0;
  nSubAuthority0[4] = 0;
  nSubAuthority0[5] = 0;
  nSubAuthority0[6] = 0;
  nSubAuthority0[7] = 0;
  *IdentifierAuthority.Value = 0;
  *&IdentifierAuthority.Value[4] = 0;
  // strcpy(szBuffer,strText)
  do
  {
    chText = *pszString;
    pszString += 2;
    *&pszString[szBuffer - lpszText - 2] = chText;// szBuffer[pszString-strText-2]=chText = *pszString; pszString++;
  }
  while ( chText );
  pszFound1 = wcschr(szBuffer, '-');
  if ( !pszFound1 )                             // -UserName?
    return pSid;
  pszFound2 = wcschr(pszFound1 + 1, '-');       // -Password
  if ( !pszFound2 )
    return pSid;
  pszText2 = pszFound2 + 2;
  pszFound3 = wcschr(pszFound2 + 1, '-');       // -Domain>
  if ( !pszFound3 )
    return pSid;
  *pszFound3 = 0;
  if ( *pszText2 != '0' || *(pszText2 + 1) != 'x' )
  {
    vscan_fn(pszText2, L"%lu", &nAuth);
    IdentifierAuthority.Value[4] = BYTE1(nAuth);
    IdentifierAuthority.Value[5] = nAuth;
    IdentifierAuthority.Value[2] = HIBYTE(nAuth);
    IdentifierAuthority.Value[3] = BYTE2(nAuth);
  }
  else
  {
    vscan_fn(pszText2, L"0x%02hx%02hx%02hx%02hx%02hx%02hx", &IdentifierAuthority);
  }
  *pszFound3 = '-';
  pszText3 = pszFound3;
  pszText = pszFound3 + 2;
  index = 0;
  do
  {
    chText1 = wcschr(pszText3, '-');
    if ( !chText1 )
      break;
    ++index;
    *chText1 = 0;
    LOBYTE(count) = count + 1;
    pszText3 = chText1 + 2;
  }
  while ( index < 8 );
  nSubAuthorityCount[0] = count;
  count = count;
  if ( count > 0 )
  {
    nSubAuthority = nSubAuthority0;
    do
    {
      vscan_fn(pszText, L"%lu", nSubAuthority);
      ++nSubAuthority;
      pszText += 2 * lstrlenW(pszText) + 2;
      --count;
    }
    while ( count );
  }
  ret = AllocateAndInitializeSid(
          &IdentifierAuthority,
          nSubAuthorityCount[0],
          nSubAuthority0[0],
          nSubAuthority0[1],
          nSubAuthority0[2],
          nSubAuthority0[3],
          nSubAuthority0[4],
          nSubAuthority0[5],
          nSubAuthority0[6],
          nSubAuthority0[7],
          &pSid);
  return (ret != FALSE ? pSid : 0);
}

//----- (011F4ED0) --------------------------------------------------------
signed int sub_11F4ED0()
{
  return -1;
}

//----- (011F4EE0) --------------------------------------------------------
int __cdecl sub_11F4EE0(int a1, int a2, int a3, int a4)
{
  wchar_t *v4; // ecx
  wchar_t *v6; // [esp-4h] [ebp-Ch]
  int v7; // [esp+4h] [ebp-4h]

  v6 = v4;
  v7 = 0;
  sub_11F70E0(&v6, a2, a3, a4);
  sub_11F84A0(a1, v6);
  return a1;
}

//----- (011F4F20) --------------------------------------------------------
int __cdecl sub_11F4F20(int a1, int a2, wchar_t *a3)
{
  _WORD *v3; // eax
  wchar_t *v5; // [esp-4h] [ebp-2Ch]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+24h] [ebp-4h]

  v10 = 0;
  v3 = malloc(2u);
  v6 = v3;
  v7 = 0;
  v8 = 0;
  *v3 = 0;
  v9 = 0;
  v11 = 0;
  sub_11F7040(a3, &v6);
  sub_11F70E0(&v5, a2, &v6, 0);
  sub_11F84A0(a1, v5);
  sub_11F21F0(&v6);
  return a1;
}

//----- (011F4FB0) --------------------------------------------------------
wchar_t **__cdecl sub_11F4FB0(int a1, int a2, void *a3)
{
  wchar_t **v3; // ebx
  wchar_t *v4; // esi
  _WORD *v5; // edi
  wchar_t *v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // ebx
  wchar_t *v9; // eax
  const wchar_t **v10; // eax
  void *v11; // ebx
  _WORD *v12; // eax
  wchar_t **v13; // eax
  void *v15; // [esp+14h] [ebp-28Ch]
  char v16; // [esp+18h] [ebp-288h]
  int v17; // [esp+24h] [ebp-27Ch]
  int v18; // [esp+28h] [ebp-278h]
  wchar_t **v19; // [esp+2Ch] [ebp-274h]
  _WORD *v20; // [esp+30h] [ebp-270h]
  LPVOID ppv; // [esp+34h] [ebp-26Ch]
  void *v22; // [esp+38h] [ebp-268h]
  wchar_t *v23; // [esp+3Ch] [ebp-264h]
  char v24; // [esp+40h] [ebp-260h]
  int v25; // [esp+29Ch] [ebp-4h]

  v3 = a1;
  v18 = a2;
  v19 = a1;
  v22 = a3;
  v4 = malloc(2u);
  v23 = v4;
  *v4 = 0;
  v25 = 0;
  v5 = malloc(2u);
  v20 = v5;
  *v5 = 0;
  LOBYTE(v25) = 1;
  CoInitializeEx(0, 0);
  if ( CoCreateInstance(&RCSID_ShellLinkW, 0, 1u, &CLSID_IShellLinkW, &ppv) >= 0 )
  {
    if ( (**ppv)(ppv, &CLSID_IPersistFile, &v17) >= 0 )
    {
      if ( (*(*v17 + 20))(v17, v22, 0) >= 0 && (*(*ppv + 76))(ppv, v18, 3) >= 0 )
      {
        v7 = realloc(v4, 0x7D2u);
        v8 = v7;
        v23 = v7;
        if ( v7 )
          memset(v7, 0, 0x7D2u);
        if ( (*(*ppv + 12))(ppv, v8, 1000, &v24, 1) >= 0 )
        {
          sub_11F2170(&v15);
          LOBYTE(v25) = 2;
          v9 = _wcsdup(v8);
          v10 = sub_11F4AC0(&v22, v9);
          sub_11F2250(&v23, v10);
          free(v22);
          v4 = v23;
          v11 = v15;
          v15 = _wcsdup(v23);
          free(v11);
          v12 = realloc(v5, 0x7D2u);
          v5 = v12;
          v20 = v12;
          if ( v12 )
            memset(v12, 0, 0x7D2u);
          if ( (*(*ppv + 40))(ppv, v5, 1000) >= 0 )
          {
            sub_11F2300(&v15, v5, 0x7FFFFFFF, 0);
            sub_1200530(&v16, &v23);
            sub_1200530(&v16, &v20);
            v13 = sub_11F70E0(&v22, v18, &v15, 0);
            sub_11F2250(&v23, v13);
            free(v22);
            v4 = v23;
            v5 = v20;
          }
          LOBYTE(v25) = 1;
          sub_11F21F0(&v15);
        }
        else
        {
          v4 = _wcsdup(gpszTargetName);
          v23 = v4;
          free(v8);
        }
        v3 = v19;
      }
      (*(*v17 + 8))(v17);
    }
    (*(*ppv + 8))(ppv);
    v6 = _wcsdup(v4);
  }
  else
  {
    v6 = _wcsdup(gpszTargetName);
  }
  *v3 = v6;
  free(v5);
  free(v4);
  return v3;
}
// 12C7B5C: using guessed type GUID CLSID_IPersistFile;

//----- (011F52B0) --------------------------------------------------------
int __cdecl sub_11F52B0(int a1, wchar_t *psz)
{
  HMODULE v2; // eax
  FARPROC v3; // eax
  WCHAR *v4; // ecx
  CComBSTR *v6; // edi
  BSTR v7; // eax
  _WORD *v8; // esi
  BSTR v9; // eax
  const unsigned __int16 *v10; // eax
  int v11; // eax
  const unsigned __int16 *v12; // eax
  int v13; // eax
  wchar_t **v14; // eax
  wchar_t *v15; // eax
  wchar_t *v16; // eax
  WCHAR *v17; // eax
  WCHAR *v18; // eax
  _WORD *v19; // [esp+14h] [ebp-18h]
  CComBSTR *ppComBSTR; // [esp+18h] [ebp-14h]
  CComBSTR *v21; // [esp+1Ch] [ebp-10h]
  int v22; // [esp+28h] [ebp-4h]

  if ( dword_12E4C40 & 1 )
  {
    v3 = GetLongPathNameW_0;
  }
  else
  {
    dword_12E4C40 |= 1u;
    v2 = LoadLibraryW(L"kernel32.dll");
    v3 = GetProcAddress(v2, "GetLongPathNameW");
    GetLongPathNameW_0 = v3;
  }
  if ( !v3 )
  {
    v4 = gpszTargetName;
    if ( psz )
      v4 = psz;
    *a1 = _wcsdup(v4);
    return a1;
  }
  sub_11F7AB0(&dword_12E4C30, &v21, psz);
  v22 = 0;
  if ( !byte_12E3860[0] )
  {
    v6 = v21;
    if ( v21 )
      v7 = v21->bstr;
    else
      v7 = 0;
    ppComBSTR = GetLongPathNameW_0(v7, 0, 0);
    v8 = malloc(2u);
    *v8 = 0;
    LOBYTE(v22) = 1;
    if ( !byte_12E3860[0] )
    {
      v8 = realloc(v8, 2 * ppComBSTR + 2);
      v19 = v8;
      if ( v8 )
        memset(v8, 0, 2 * ppComBSTR + 2);
      v9 = v6 ? v6->bstr : 0;
      if ( GetLongPathNameW_0(v9, v8, ppComBSTR) )
      {
        if ( v6 )
          v10 = v6->bstr;
        else
          v10 = 0;
        v11 = wcscmp(v8, v10);
        if ( v11 )
          v11 = -(v11 < 0) | 1;
        if ( v11 )
        {
          if ( v6 )
            v12 = v6->bstr;
          else
            v12 = 0;
          v13 = wcscmp(psz, v12);
          if ( v13 )
            v13 = -(v13 < 0) | 1;
          if ( v13 )
          {
            v14 = *sub_11F5DE0(&dword_12E4C30, &ppComBSTR, v8);
            if ( v14 )
              v15 = *v14;
            else
              v15 = 0;
            sub_11F2280(&v19, v15);
            bstr_t::Data_t::Free(&ppComBSTR);
            v8 = v19;
          }
          v16 = _wcsdup(v8);
        }
        else
        {
          v17 = gpszTargetName;
          if ( psz )
            v17 = psz;
          v16 = _wcsdup(v17);
        }
        *a1 = v16;
        free(v8);
        bstr_t::Data_t::Free(&v21);
        return a1;
      }
    }
    free(v8);
  }
  v18 = gpszTargetName;
  if ( psz )
    v18 = psz;
  *a1 = _wcsdup(v18);
  bstr_t::Data_t::Free(&v21);
  return a1;
}
// 12E4C3C: using guessed type int (__stdcall *GetLongPathNameW_0)(_DWORD, _DWORD, _DWORD);
// 12E4C40: using guessed type int dword_12E4C40;

//----- (011F5520) --------------------------------------------------------
int __cdecl sub_11F5520(int a1, wchar_t *psz, int a3)
{
  wchar_t *v3; // esi
  wchar_t *v4; // eax
  unsigned int v5; // ecx
  _WORD *v6; // eax
  wchar_t *v7; // ST0C_4
  wchar_t *v8; // eax
  wchar_t *v10; // eax
  wchar_t *v11; // edi
  wchar_t *v12; // eax
  int v13; // [esp+18h] [ebp-14h]
  signed int v14; // [esp+1Ch] [ebp-10h]

  v3 = _wcsdup(psz);
  _wcsupr(v3);
  v4 = _wcsdup(v3);
  if ( !sub_11F6090(v4) || (v5 = 1, v14 = 1, ((*(a3 + 8) - *(a3 + 4)) >> 2) <= 1) )
  {
LABEL_9:
    *a1 = _wcsdup(gpszTargetName);
    free(v3);
    free(psz);
    return a1;
  }
  while ( 1 )
  {
    v13 = 4 * v5;
    v6 = *(4 * v5 + *(a3 + 4));
    if ( *v6 == 47 || *v6 == 45 )
      goto LABEL_8;
    v7 = _wcsdup(L"CMD");
    v8 = _wcsdup(v3);
    if ( !sub_11F5FD0(v8, v7) || _wcsicmp(*(v13 + *(a3 + 4)), L"start") )
      break;
    v5 = v14;
LABEL_8:
    v14 = ++v5;
    if ( v5 >= (*(a3 + 8) - *(a3 + 4)) >> 2 )
      goto LABEL_9;
  }
  v10 = _wcsdup(*(*(a3 + 4) + 4 * v14));
  v11 = v10;
  if ( *v10 != 34 )
  {
    v12 = wcschr(v10, 0x2Cu);
    if ( v12 )
      *v12 = 0;
  }
  *a1 = _wcsdup(v11);
  free(v11);
  free(v3);
  free(psz);
  return a1;
}

//----- (011F56C0) --------------------------------------------------------
wchar_t *UpadteSystemPathInfo()
{
  HMODULE v0; // eax
  void (__stdcall *GetSystemWindowsDirectoryW)(LPTSTR, UINT); // eax
  int idx; // ecx
  __int16 chText; // ax
  __int16 *pszSystemWinDirCopy; // ecx
  __int16 chText2; // ax
  HMODULE Kernel32Handle; // eax
  int (__stdcall *GetSystemWow64DirectoryW)(LPTSTR, UINT); // eax
  int v8; // ecx
  __int16 v9; // ax
  int nCom; // eax
  wchar_t *result; // eax

  v0 = LoadLibraryW(L"Kernel32.dll");
  GetSystemWindowsDirectoryW = GetProcAddress(v0, "GetSystemWindowsDirectoryW");
  if ( GetSystemWindowsDirectoryW )
    (GetSystemWindowsDirectoryW)();
  else
    GetWindowsDirectoryW(gszSystemWinDir, _MAX_PATH);
  idx = 0;
  do
  {
    chText = gszSystemWinDir[idx];
    ++idx;
    gszSystemWinDirCopy[idx] = chText;
  }
  while ( chText );
  pszSystemWinDirCopy = gszSystemWinDirCopy;
  do
  {
    chText2 = pszSystemWinDirCopy[1];
    ++pszSystemWinDirCopy;
  }
  while ( chText2 );
  *pszSystemWinDirCopy = *L"\\System32";
  *(pszSystemWinDirCopy + 1) = *L"ystem32";
  *(pszSystemWinDirCopy + 2) = *L"tem32";
  *(pszSystemWinDirCopy + 3) = *L"m32";
  *(pszSystemWinDirCopy + 4) = *L"2";
  Kernel32Handle = LoadLibraryW(L"Kernel32.dll");
  GetSystemWow64DirectoryW = GetProcAddress(Kernel32Handle, "GetSystemWow64DirectoryW");
  if ( GetSystemWow64DirectoryW && !(GetSystemWow64DirectoryW)() )
  {
    v8 = 0;
    do
    {
      v9 = gszSystemWinDirCopy[v8 + 1];
      ++v8;
      *(&stru_12E3400.SpinCount + v8 * 2 + 2) = v9;
    }
    while ( v9 );
  }
  ExpandEnvironmentStringsW(L"%ProgramW6432%", gszEnvValue, _MAX_PATH);
  nCom = wcscmp(L"%ProgramW6432%", gszEnvValue);
  if ( nCom )
    nCom = -(nCom < 0) | 1;
  if ( !nCom )
  {
    ExpandEnvironmentStringsW(L"%ProgramFiles%", gszEnvValue, _MAX_PATH);
    SetEnvironmentVariableW(L"ProgramW6432", gszEnvValue);
  }
  ExpandEnvironmentStringsW(L"%PROGRAMFILES(X86)%", gszProgrameFiles, _MAX_PATH);
  result = wcsstr(gszEnvValue, L" (x86)");
  if ( result )
  {
    *wcsstr(gszEnvValue, L" (x86)") = 0;
    result = SetEnvironmentVariableW(L"PROGRAMFILES(X86)", gszEnvValue);
  }
  return result;
}
// 12ACEA8: using guessed type wchar_t aSystem32[10];

//----- (011F5860) --------------------------------------------------------
char __cdecl sub_11F5860(wchar_t **a1, __int16 a2, const wchar_t **a3, char a4)
{
  wchar_t *v4; // esi
  wchar_t v5; // ax
  __int16 j; // bx
  char result; // al
  int v8; // eax
  wchar_t v9; // ax
  wchar_t *v10; // edi
  wchar_t *v11; // eax
  wchar_t *v12; // eax
  wchar_t i; // ax
  int v14; // eax
  wchar_t *v15; // ebx
  wchar_t *v16; // esi
  wchar_t *v17; // esi
  wchar_t *v18; // eax
  const wchar_t *v19; // ecx
  int v20; // edx
  const wchar_t *v21; // edx
  int v22; // ecx
  wchar_t v23; // ax
  const wchar_t **v24; // eax
  wchar_t *v25; // ebx
  DWORD v26; // eax
  const wchar_t **v27; // eax
  wchar_t *v28; // ebx
  DWORD v29; // eax
  wchar_t v30; // ax
  wchar_t *v31; // ebx
  wchar_t *v32; // esi
  void *v33; // [esp+14h] [ebp-18h]
  LPWSTR ppsz; // [esp+18h] [ebp-14h]
  wchar_t *v35; // [esp+1Ch] [ebp-10h]
  int v36; // [esp+28h] [ebp-4h]

  v4 = *a1;
  v35 = v4;
  v5 = *v4;
  if ( !*v4 )
    goto LABEL_5;
  while ( 1 )
  {
    if ( !isspace(v5) )
    {
      j = a2;
      if ( *v4 != a2 )
        break;
    }
    v5 = v4[1];
    ++v4;
    v35 = v4;
    if ( !v5 )
      goto LABEL_5;
  }
  v8 = *v4;
  if ( v8 && v8 != a2 )
  {
    if ( v8 == 34 )
    {
      v9 = v4[1];
      v35 = v4 + 1;
      v10 = v4 + 1;
      if ( v9 )
      {
        while ( v9 != 34 )
        {
          v9 = v10[1];
          ++v10;
          if ( !v9 )
            goto LABEL_14;
        }
      }
      v11 = v10 + 1;
      if ( !*v10 )
LABEL_14:
        v11 = v10;
      *a1 = v11;
      if ( a2 && *v11 )
      {
        do
        {
          if ( **a1 == a2 )
            break;
          v12 = *a1 + 1;
          *a1 = v12;
        }
        while ( *v12 );
      }
LABEL_45:
      v31 = v35;
      v32 = *a3;
      *a3 = _wcsdup(v35);
      free(v32);
      (*a3)[v10 - v31] = 0;
      result = 1;
    }
    else
    {
      v10 = v4;
      while ( 1 )
      {
        for ( i = *v10; i; ++v10 )
        {
          if ( i == j )
            break;
          if ( i == 32 )
            break;
          i = v10[1];
        }
        if ( !a4 )
          goto LABEL_44;
        v14 = *v4;
        if ( v14 != 37 && v14 != 92 && v4[1] != 58 )
          goto LABEL_44;
        v15 = v35;
        v16 = *a3;
        *a3 = _wcsdup(v35);
        free(v16);
        (*a3)[v10 - v15] = 0;
        v17 = _wcsdup(*a3);
        v36 = 0;
        _wcsupr(v17);
        if ( TlsGetValue(gdwTlsIndex) == 256 && wcsstr(v17, L"%PROGRAMFILES%") )
        {
          v18 = wcsstr(v17, L"%PROGRAMFILES%");
          v19 = *a3;
          v20 = v18 - v17;
          _mm_storeu_si128(&(*a3)[v20], _mm_loadu_si128(L"%ProgramW6432%"));
          _mm_storel_epi64(&v19[v20 + 8], _mm_loadl_epi64(L"W6432%"));
          *&v19[v20 + 12] = *L"2%";
          v21 = &(*a3)[v20 + 14];
          v22 = *a3 - *a3;
          do
          {
            v23 = *v21;
            ++v21;
            *(v21 + v22 - 2) = v23;
          }
          while ( v23 );
        }
        v24 = GetEnvironmentPathInfo(&ppsz, *a3);
        v25 = *a3;
        *a3 = _wcsdup(*v24);
        free(v25);
        free(ppsz);
        v26 = sub_1201040(*a3);
        if ( v26 != -1 && !(v26 & 0x10)
          || (v27 = sub_11F22B0(&v33, a3, L".exe"),
              v28 = *a3,
              *a3 = _wcsdup(*v27),
              free(v28),
              free(v33),
              v29 = sub_1201040(*a3),
              v29 != -1)
          && !(v29 & 0x10) )
        {
          free(v17);
LABEL_44:
          *a1 = v10;
          goto LABEL_45;
        }
        v30 = *v10;
        for ( j = a2; v30 != a2; ++v10 )
        {
          if ( !isspace(v30) )
            break;
          v30 = v10[1];
        }
        if ( !*v10 || *v10 == a2 )
          break;
        v36 = -1;
        free(v17);
        v4 = v35;
      }
      free(v17);
      result = 1;
    }
  }
  else
  {
LABEL_5:
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (011F5BB0) --------------------------------------------------------
FARPROC sub_11F5BB0()
{
  HMODULE v0; // eax
  HMODULE v1; // eax
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  HMODULE v5; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  FARPROC result; // eax

  v0 = LoadLibraryW(L"Kernel32.dll");
  Wow64EnableWow64FsRedirection = GetProcAddress(v0, "Wow64EnableWow64FsRedirection");
  v1 = LoadLibraryW(L"Kernel32.dll");
  Wow64DisableWow64FsRedirection = GetProcAddress(v1, "Wow64DisableWow64FsRedirection");
  v2 = LoadLibraryW(L"Kernel32.dll");
  Wow64RevertWow64FsRedirection = GetProcAddress(v2, "Wow64RevertWow64FsRedirection");
  v3 = LoadLibraryW(L"advapi32.dll");
  *RegDeleteKeyExW = GetProcAddress(v3, "RegDeleteKeyExW");
  v4 = LoadLibraryW(L"ntdll.dll");
  NtDeleteKey = GetProcAddress(v4, "NtDeleteKey");
  v5 = LoadLibraryW(L"ntdll.dll");
  NtOpenKey = GetProcAddress(v5, "NtOpenKey");
  v6 = LoadLibraryW(L"ntdll.dll");
  NtCreateKey = GetProcAddress(v6, "NtCreateKey");
  v7 = LoadLibraryW(L"ntdll.dll");
  result = GetProcAddress(v7, "RtlNtStatusToDosError");
  RtlNtStatusToDosError = result;
  return result;
}
// 12E31DC: using guessed type int NtDeleteKey;
// 12E31E0: using guessed type int (__stdcall *NtOpenKey)(_DWORD, _DWORD, _DWORD);
// 12E31E4: using guessed type int (__stdcall *RtlNtStatusToDosError)(_DWORD);
// 12E31E8: using guessed type int (__stdcall *NtCreateKey)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);
// 12E3620: using guessed type int (__stdcall *Wow64DisableWow64FsRedirection)(_DWORD);
// 12E3624: using guessed type int (__stdcall *Wow64RevertWow64FsRedirection)(_DWORD);

//----- (011F5C70) --------------------------------------------------------
int __cdecl sub_11F5C70(int a1, wchar_t *a2)
{
  wchar_t *v2; // eax
  wchar_t *v3; // esi
  unsigned int v4; // kr04_4
  wchar_t *v5; // esi
  const wchar_t **v6; // eax
  void *v7; // edi
  void *v9; // [esp+10h] [ebp-20h]
  void *v10; // [esp+14h] [ebp-1Ch]
  int v11; // [esp+18h] [ebp-18h]
  int v12; // [esp+1Ch] [ebp-14h]
  int v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v14 = 1;
  *a1 = _wcsdup(a2);
  v2 = a2;
  v12 = 1;
  if ( *a2 && Wow64DisableWow64FsRedirection )
  {
    v3 = _wcsdup(L"\\");
    v11 = v3;
    sub_120F210(&v9, gszEnvValue, &v11);
    LOBYTE(v14) = 2;
    free(v3);
    Wow64DisableWow64FsRedirection(&v13);
    if ( !v13 && !_wcsnicmp(a2, &gszSystemWinDirCopy[1], wcslen(&gszSystemWinDirCopy[1])) )
    {
      v4 = wcslen(&gszSystemWinDirCopy[1]);
      v5 = _wcsdup(&gszSystemWow64Directory);
      v11 = v5;
      v6 = sub_11F22B0(&v10, &v11, &a2[v4]);
      v7 = *a1;
      *a1 = _wcsdup(*v6);
      free(v7);
      free(v10);
      free(v5);
    }
    Wow64RevertWow64FsRedirection(v13);
    free(v9);
    v2 = a2;
  }
  free(v2);
  return a1;
}
// 12E3620: using guessed type int (__stdcall *Wow64DisableWow64FsRedirection)(_DWORD);
// 12E3624: using guessed type int (__stdcall *Wow64RevertWow64FsRedirection)(_DWORD);

//----- (011F5DE0) --------------------------------------------------------
int __thiscall sub_11F5DE0(int **this, int a2, OLECHAR *psz)
{
  OLECHAR *v3; // ebx
  int v4; // esi
  OLECHAR **v5; // eax
  OLECHAR *v6; // eax
  UINT v7; // edi
  _DWORD *v8; // eax
  const wchar_t *v9; // eax
  int v10; // eax
  int v11; // eax
  int j; // eax
  int i; // eax
  BSTR *v14; // eax
  BSTR *v15; // esi
  BSTR v16; // eax
  OLECHAR *v17; // eax
  OLECHAR *v18; // esi
  int result; // eax
  int **v20; // [esp+14h] [ebp-10h]

  v20 = this;
  v3 = psz;
  v4 = **this;
  if ( **this == *this )
  {
LABEL_23:
    v14 = operator new(0xCu);
    v15 = v14;
    psz = v14;
    if ( v14 )
    {
      v14[1] = 0;
      v14[2] = 1;
      v16 = SysAllocString(v3);
      *v15 = v16;
      if ( !v16 && v3 )
        com_error::throw(-2147024882);
    }
    else
    {
      v15 = 0;
    }
    result = a2;
    *a2 = v15;
    if ( !v15 )
      com_error::throw(-2147024882);
    return result;
  }
  while ( 1 )
  {
    if ( *(v4 + 24) )
      goto LABEL_13;
    v5 = *(v4 + 28);
    if ( !v5 )
      break;
    v6 = *v5;
    if ( !v6 )
      break;
    v7 = SysStringLen(v6);
    if ( !v7 )
      goto LABEL_28;
    v8 = *(v4 + 28);
    v9 = (v8 ? *v8 : 0);
    if ( !_wcsnicmp(v3, v9, v7) )
    {
      v10 = v3[v7];
      if ( !v10 || v10 == 92 )
        goto LABEL_28;
    }
    this = v20;
LABEL_13:
    if ( !*(v4 + 13) )
    {
      v11 = *(v4 + 8);
      if ( *(v11 + 13) )
      {
        for ( i = *(v4 + 4); !*(i + 13); i = *(i + 4) )
        {
          if ( v4 != *(i + 8) )
            break;
          v4 = i;
        }
        v4 = i;
      }
      else
      {
        v4 = *(v4 + 8);
        for ( j = *v11; !*(j + 13); j = *j )
          v4 = j;
      }
    }
    if ( v4 == *this )
      goto LABEL_23;
  }
  v7 = 0;
LABEL_28:
  sub_11F85A0(&psz, v3, v7, (v4 + 20));
  v17 = psz;
  *a2 = psz;
  if ( v17 )
  {
    InterlockedIncrement(v17 + 2);
    v18 = psz;
    if ( psz )
    {
      if ( !InterlockedDecrement(psz + 2) && v18 )
      {
        if ( *v18 )
        {
          SysFreeString(*v18);
          *v18 = 0;
        }
        if ( *(v18 + 1) )
        {
          j_j__free(*(v18 + 1));
          *(v18 + 1) = 0;
        }
        j__free(v18);
      }
    }
  }
  return a2;
}

//----- (011F5FD0) --------------------------------------------------------
char __cdecl sub_11F5FD0(wchar_t *a1, wchar_t *a2)
{
  wchar_t *v2; // esi
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  wchar_t *v5; // eax
  int v6; // ecx
  int v7; // ecx
  char v8; // bl

  if ( !wcsstr(a1, a2) )
  {
    v5 = a1;
LABEL_16:
    v8 = 0;
    goto LABEL_17;
  }
  v2 = a1;
  v3 = a2;
  do
  {
    v4 = wcsstr(v2, a2);
    if ( !v4 )
      break;
    v3 = v4;
    v2 = v4 + 1;
    if ( v4 == -2 )
      break;
  }
  while ( wcsstr(v2, a2) );
  v5 = a1;
  if ( v3 != a1 )
  {
    v6 = *(v3 - 1);
    if ( v6 != 92 && v6 != 34 && v6 != 32 )
      goto LABEL_16;
  }
  v7 = v3[wcslen(a2)];
  if ( v7 )
  {
    if ( v7 != 34 && v7 != 32 && v7 != 46 )
      goto LABEL_16;
  }
  v8 = 1;
LABEL_17:
  free(v5);
  free(a2);
  return v8;
}

//----- (011F6090) --------------------------------------------------------
char __cdecl sub_11F6090(wchar_t *psz)
{
  wchar_t *v1; // ST14_4
  wchar_t *v2; // eax
  wchar_t *v3; // ST14_4
  wchar_t *v4; // eax
  wchar_t *v5; // ST14_4
  wchar_t *v6; // eax
  wchar_t *v7; // ST14_4
  wchar_t *v8; // eax
  wchar_t *v9; // ST14_4
  wchar_t *v10; // eax
  wchar_t *v11; // ST14_4
  wchar_t *v12; // eax
  wchar_t *v13; // ST14_4
  wchar_t *v14; // eax
  _WORD *v15; // eax
  void *v16; // ebx
  wchar_t *v17; // eax
  wchar_t *v18; // eax
  wchar_t *v19; // edi
  WCHAR *v20; // eax
  wchar_t *v21; // eax
  wchar_t *v22; // esi
  wchar_t *v23; // esi
  WCHAR *v24; // ecx
  wchar_t *v25; // esi
  wchar_t *v26; // ST14_4
  int v27; // ST10_4
  wchar_t *v28; // eax
  char v29; // bl
  int v31; // [esp+18h] [ebp-70h]
  void *v32; // [esp+1Ch] [ebp-6Ch]
  wchar_t *v33; // [esp+20h] [ebp-68h]
  int v34; // [esp+24h] [ebp-64h]
  wchar_t *v35; // [esp+28h] [ebp-60h]
  int v36; // [esp+84h] [ebp-4h]

  v36 = 0;
  if ( wcsstr(psz, L"POWERSHELL") )
    OutputDebugStringW(L"here");
  v1 = _wcsdup(L"RUNDLL32");
  v2 = _wcsdup(psz);
  if ( !sub_11F5FD0(v2, v1) )
  {
    v3 = _wcsdup(L"RUNDLL");
    v4 = _wcsdup(psz);
    if ( !sub_11F5FD0(v4, v3) )
    {
      v5 = _wcsdup(L"CSCRIPT");
      v6 = _wcsdup(psz);
      if ( !sub_11F5FD0(v6, v5) )
      {
        v7 = _wcsdup(L"WSCRIPT");
        v8 = _wcsdup(psz);
        if ( !sub_11F5FD0(v8, v7) )
        {
          v9 = _wcsdup(L"REGSVR32");
          v10 = _wcsdup(psz);
          if ( !sub_11F5FD0(v10, v9) )
          {
            v11 = _wcsdup(L"POWERSHELL");
            v12 = _wcsdup(psz);
            if ( !sub_11F5FD0(v12, v11) )
            {
              v13 = _wcsdup(L"CMD");
              v14 = _wcsdup(psz);
              if ( !sub_11F5FD0(v14, v13) )
                goto LABEL_24;
            }
          }
        }
      }
    }
  }
  v15 = malloc(2u);
  v16 = v15;
  *v15 = 0;
  v17 = malloc(2u);
  v33 = v17;
  *v17 = 0;
  v18 = malloc(2u);
  v19 = v18;
  *v18 = 0;
  LOBYTE(v36) = 3;
  v20 = gpszTargetName;
  v31 = 20;
  if ( psz )
    v20 = psz;
  v21 = _wcsdup(v20);
  v22 = sub_1211290(v21, &v33);
  if ( v22 == 2 )
  {
    v34 = sub_11F6700(psz, 0, 0, &v35, &v31, 0);
    if ( v34 )
    {
      if ( *v19 )
      {
        v23 = v33;
        v33 = _wcsdup(v19);
        free(v23);
      }
    }
    else
    {
      v24 = gpszTargetName;
      if ( v35 )
        v24 = v35;
      v25 = _wcsdup(v24);
      v32 = v33;
      v33 = _wcsdup(v25);
      free(v32);
      free(v25);
    }
    v26 = _wcsdup(v33);
    v27 = v34;
    v28 = _wcsdup(psz);
    v22 = sub_12111B0(v28, v27, v26);
  }
  _wcsupr(v33);
  if ( v22 || !wcsstr(v33, L"WINDOWS") )
  {
    free(v19);
    free(v33);
    free(v16);
LABEL_24:
    v29 = 0;
    goto LABEL_25;
  }
  free(v19);
  free(v33);
  free(v16);
  v29 = 1;
LABEL_25:
  free(psz);
  return v29;
}

//----- (011F63B0) --------------------------------------------------------
char __cdecl sub_11F63B0(wchar_t *a1)
{
  wchar_t *v1; // ecx
  wchar_t v2; // ax
  int v3; // eax
  char result; // al

  v1 = a1;
  v2 = *a1;
  if ( !*a1 )
    goto LABEL_14;
  do
  {
    if ( v2 != 32 && v2 != 44 )
      break;
    v2 = v1[1];
    ++v1;
  }
  while ( v2 );
  if ( !*v1 || !_wcsicmp(a1, L"desktop.ini") )
    goto LABEL_14;
  v3 = wcscmp(a1, L"%1");
  if ( v3 )
    v3 = -(v3 < 0) | 1;
  if ( v3 )
    result = 1;
  else
LABEL_14:
    result = 0;
  return result;
}

//----- (011F6440) --------------------------------------------------------
int __thiscall sub_11F6440(CComBSTR *this, int a2, CComBSTR *a3, int a4, OLECHAR *psz)
{
  OLECHAR *strSource; // ebx
  int *v6; // esi
  OLECHAR **v7; // eax
  OLECHAR *v8; // eax
  UINT v9; // edi
  _DWORD *v10; // eax
  const wchar_t *v11; // eax
  int v12; // eax
  int **v13; // eax
  int *j; // eax
  int *i; // eax
  CComBSTR *v16; // eax
  CComBSTR *pbstr; // esi
  BSTR bstr; // eax
  CComBSTR *v19; // eax
  CComBSTR *v20; // esi
  int result; // eax
  CComBSTR *v22; // [esp+14h] [ebp-10h]

  v22 = this;
  strSource = psz;
  v6 = *this->bstr;
  if ( *this->bstr == this->bstr )
  {
LABEL_23:
    a3->bstr = a4;
    v16 = operator new(0xCu);
    pbstr = v16;
    a3 = v16;
    if ( v16 )
    {
      v16->hKey = 0;
      v16->Length = 1;
      bstr = SysAllocString(strSource);
      pbstr->bstr = bstr;
      if ( !bstr && strSource )
        com_error::throw(E_OUTOFMEMORY);
    }
    else
    {
      pbstr = 0;
    }
    result = a2;
    *a2 = pbstr;
    if ( !pbstr )
      com_error::throw(E_OUTOFMEMORY);
    return result;
  }
  while ( 1 )
  {
    if ( v6[4] != a4 )
      goto LABEL_13;
    v7 = v6[5];
    if ( !v7 )
      break;
    v8 = *v7;
    if ( !v8 )
      break;
    v9 = SysStringLen(v8);
    if ( !v9 )
      goto LABEL_28;
    v10 = v6[5];
    v11 = (v10 ? *v10 : 0);
    if ( !_wcsnicmp(strSource, v11, v9) )
    {
      v12 = strSource[v9];
      if ( !v12 || v12 == 92 )
        goto LABEL_28;
    }
    this = v22;
LABEL_13:
    if ( !*(v6 + 13) )
    {
      v13 = v6[2];
      if ( *(v13 + 13) )
      {
        for ( i = v6[1]; !*(i + 13); i = i[1] )
        {
          if ( v6 != i[2] )
            break;
          v6 = i;
        }
        v6 = i;
      }
      else
      {
        v6 = v6[2];
        for ( j = *v13; !*(j + 13); j = *j )
          v6 = j;
      }
    }
    if ( v6 == this->bstr )
      goto LABEL_23;
  }
  v9 = 0;
LABEL_28:
  a3->bstr = v6[6];
  sub_11F85A0(&a3, strSource, v9, v6 + 7);
  v19 = a3;
  *a2 = a3;
  if ( v19 )
  {
    InterlockedIncrement(&v19->Length);
    v20 = a3;
    if ( a3 )
    {
      if ( !InterlockedDecrement(&a3->Length) && v20 )
      {
        if ( v20->bstr )
        {
          SysFreeString(v20->bstr);
          v20->bstr = 0;
        }
        if ( v20->hKey )
        {
          j_j__free(v20->hKey);
          v20->hKey = 0;
        }
        j__free(v20);
      }
    }
  }
  return a2;
}

//----- (011F6640) --------------------------------------------------------
HANDLE __stdcall sub_11F6640(OLECHAR *psz, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
  OLECHAR *v7; // esi
  const WCHAR *v8; // ebx
  HANDLE v9; // edi

  sub_11F7AB0(&dword_12E4C30, &psz, psz);
  v7 = psz;
  if ( psz )
    v8 = *psz;
  else
    v8 = 0;
  v9 = CreateFile(
         v8,
         dwDesiredAccess,
         dwShareMode,
         lpSecurityAttributes,
         dwCreationDisposition,
         dwFlagsAndAttributes,
         hTemplateFile);
  if ( v9 == -1 )
  {
    ImpersonateLoggedOnUser(hToken);
    v9 = CreateFile(
           v8,
           dwDesiredAccess,
           dwShareMode,
           lpSecurityAttributes,
           dwCreationDisposition,
           dwFlagsAndAttributes,
           hTemplateFile);
    RevertToSelf();
  }
  if ( v7 && !InterlockedDecrement(v7 + 2) )
  {
    if ( *v7 )
    {
      SysFreeString(*v7);
      *v7 = 0;
    }
    if ( *(v7 + 1) )
    {
      j_j__free(*(v7 + 1));
      *(v7 + 1) = 0;
    }
    j__free(v7);
  }
  return v9;
}

//----- (011F6700) --------------------------------------------------------
CRYPT_PROVIDER_SGNR *__cdecl sub_11F6700(OLECHAR *psz, int a2, int a3, int a4, int a5, int a6)
{
  void *v6; // esi
  const WCHAR *v7; // eax
  CRYPT_PROVIDER_SGNR *v8; // edi
  void *v10; // [esp+8h] [ebp-4h]

  sub_11F7AB0(&dword_12E4C30, &v10, psz);
  v6 = v10;
  if ( v10 )
    v7 = *v10;
  else
    v7 = 0;
  v8 = sub_1219BB0(v7, a2, 0, 0, a3, a5, a4, 0, 0, 0, 0, a6, -1);
  if ( v6 && !InterlockedDecrement(v6 + 2) )
  {
    if ( *v6 )
    {
      SysFreeString(*v6);
      *v6 = 0;
    }
    if ( *(v6 + 1) )
    {
      j_j__free(*(v6 + 1));
      *(v6 + 1) = 0;
    }
    j__free(v6);
  }
  return v8;
}

//----- (011F67A0) --------------------------------------------------------
int __cdecl sub_11F67A0(HKEY hKey, OLECHAR *pszKeyName, int Reserved, int dwFlags, HKEY *phSubKey)
{
  CComBSTR *v5; // esi
  HKEY v6; // ebx
  OLECHAR *v7; // edi
  CComBSTR **v8; // ebx
  int v9; // edx
  CComBSTR **v10; // eax
  _bstr_t *v11; // eax
  _bstr_t *v12; // eax
  CComBSTR **v13; // ebx
  CComBSTR **v14; // ebx
  CComBSTR **v15; // ebx
  char *v16; // ecx
  __int16 v17; // ax
  int v18; // ecx
  int v19; // eax
  int v20; // ebx
  int v21; // eax
  int v22; // eax
  LONG (__stdcall *v23)(volatile LONG *); // ecx
  int v25; // [esp+10h] [ebp-44h]
  HKEY v26; // [esp+14h] [ebp-40h]
  __int16 *v27; // [esp+18h] [ebp-3Ch]
  int v28; // [esp+1Ch] [ebp-38h]
  int v29; // [esp+20h] [ebp-34h]
  int v30; // [esp+24h] [ebp-30h]
  __int16 v31; // [esp+28h] [ebp-2Ch]
  __int16 v32; // [esp+2Ah] [ebp-2Ah]
  int v33; // [esp+2Ch] [ebp-28h]
  int v34; // [esp+30h] [ebp-24h]
  BSTR *v35; // [esp+34h] [ebp-20h]
  CComBSTR *v36; // [esp+38h] [ebp-1Ch]
  OLECHAR **v37; // [esp+3Ch] [ebp-18h]
  OLECHAR **v38; // [esp+40h] [ebp-14h]
  CComBSTR *ppComBSTR; // [esp+44h] [ebp-10h]
  int v40; // [esp+50h] [ebp-4h]

  v5 = 0;
  ppComBSTR = 0;
  v40 = 0;
  sub_11F6440(&dword_12E4C30, &pszKeyName, &hKey, hKey, pszKeyName);
  v6 = hKey;
  v7 = pszKeyName;
  LOBYTE(v40) = 1;
  if ( hKey != HKEY_LOCAL_MACHINE )
  {
    if ( hKey == HKEY_CURRENT_USER )
    {
      bstr_t::EqualAssign(&hKey, L"\\");
      LOBYTE(v40) = 2;
      v10 = bstr_t::EqualAssign(&v35, gpSysMenuData->strDefault);
      LOBYTE(v40) = 3;
      v11 = sub_11F3B50(&v36, L"\\Registry\\User\\", v10);
      LOBYTE(v40) = 4;
      v12 = CComBSTR::AppendTail(v11, &v37, &hKey);
      LOBYTE(v40) = 5;
      v13 = CComBSTR::AppendTail(v12, &v38, &pszKeyName);
      if ( &ppComBSTR != v13 )
      {
        bstr_t::Data_t::Free(&ppComBSTR);
        v5 = *v13;
        ppComBSTR = v5;
        if ( v5 )
          InterlockedIncrement(&v5->Length);
      }
      bstr_t::Data_t::Free(&v38);
      bstr_t::Data_t::Free(&v37);
      bstr_t::Data_t::Free(&v36);
      bstr_t::Data_t::Free(&v35);
      LOBYTE(v40) = 1;
      bstr_t::Data_t::Free(&hKey);
      v6 = 0;
      if ( v5 )
      {
        v9 = v5->bstr;
        goto LABEL_28;
      }
    }
    else if ( hKey == HKEY_CLASSES_ROOT )
    {
      v14 = sub_11F3B50(&hKey, L"\\Registry\\Machine\\Software\\Classes\\", &pszKeyName);
      if ( &ppComBSTR != v14 )
      {
        bstr_t::Data_t::Free(&ppComBSTR);
        v5 = *v14;
        ppComBSTR = v5;
        if ( v5 )
          InterlockedIncrement(&v5->Length);
      }
      bstr_t::Data_t::Free(&hKey);
      v6 = 0;
      if ( v5 )
      {
        v9 = v5->bstr;
        goto LABEL_28;
      }
    }
    else if ( hKey == HKEY_USERS )
    {
      v15 = sub_11F3B50(&hKey, L"\\Registry\\User\\", &pszKeyName);
      if ( &ppComBSTR != v15 )
      {
        bstr_t::Data_t::Free(&ppComBSTR);
        v5 = *v15;
        ppComBSTR = v5;
        if ( v5 )
          InterlockedIncrement(&v5->Length);
      }
      bstr_t::Data_t::Free(&hKey);
      v6 = 0;
      if ( v5 )
      {
        v9 = v5->bstr;
        goto LABEL_28;
      }
    }
    else if ( pszKeyName )
    {
      v9 = *pszKeyName;
      goto LABEL_28;
    }
LABEL_27:
    v9 = 0;
    goto LABEL_28;
  }
  v8 = sub_11F3B50(&hKey, L"\\Registry\\Machine\\", &pszKeyName);
  if ( &ppComBSTR != v8 )
  {
    bstr_t::Data_t::Free(&ppComBSTR);
    v5 = *v8;
    ppComBSTR = v5;
    if ( v5 )
      InterlockedIncrement(&v5->Length);
  }
  bstr_t::Data_t::Free(&hKey);
  v6 = 0;
  if ( !v5 )
    goto LABEL_27;
  v9 = v5->bstr;
LABEL_28:
  v16 = v9;
  hKey = (v9 + 2);
  do
  {
    v17 = *v16;
    v16 += 2;
  }
  while ( v17 );
  v18 = (v16 - hKey) >> 1;
  v33 = v9;
  v25 = 24;
  v26 = v6;
  v28 = 64;
  v32 = 2 * v18;
  v31 = 2 * v18;
  v27 = &v31;
  v29 = 0;
  v30 = 0;
  v19 = NtOpenKey(phSubKey, dwFlags, &v25);
  v20 = RtlNtStatusToDosError(v19);
  if ( v20 == 5 )
  {
    v21 = NtCreateKey(phSubKey, dwFlags, &v25, 0, 0, Reserved | 4, &v34);
    v20 = RtlNtStatusToDosError(v21);
    if ( v20 == 5 )
    {
      if ( hToken )
      {
        ImpersonateLoggedOnUser(hToken);
        v22 = NtOpenKey(phSubKey, dwFlags, &v25);
        v20 = RtlNtStatusToDosError(v22);
        RevertToSelf();
      }
    }
  }
  v23 = InterlockedDecrement;
  if ( v7 )
  {
    if ( !InterlockedDecrement(v7 + 2) )
    {
      if ( *v7 )
      {
        SysFreeString(*v7);
        *v7 = 0;
      }
      if ( *(v7 + 1) )
      {
        j_j__free(*(v7 + 1));
        *(v7 + 1) = 0;
      }
      j__free(v7);
    }
    v23 = InterlockedDecrement;
  }
  if ( v5 && !v23(&v5->Length) )
  {
    if ( v5->bstr )
    {
      SysFreeString(v5->bstr);
      v5->bstr = 0;
    }
    if ( v5->hKey )
    {
      j_j__free(v5->hKey);
      v5->hKey = 0;
    }
    j__free(v5);
  }
  return v20;
}
// 12E31E0: using guessed type int (__stdcall *NtOpenKey)(_DWORD, _DWORD, _DWORD);
// 12E31E4: using guessed type int (__stdcall *RtlNtStatusToDosError)(_DWORD);
// 12E31E8: using guessed type int (__stdcall *NtCreateKey)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (011F6B30) --------------------------------------------------------
int __cdecl AdjustPrivilegeToWINLOGON()
{
  int result; // eax
  void *hSnap; // edi
  const wchar_t *szExeFile; // esi
  wchar_t *psz; // eax
  HANDLE hProcess; // esi
  HANDLE phNewToken; // [esp+0h] [ebp-238h]
  HANDLE TokenHandle; // [esp+4h] [ebp-234h]
  PROCESSENTRY32W pe; // [esp+8h] [ebp-230h]

  result = TmAdjustPrivilege(L"SeDebugPrivilege");
  if ( result )
  {
    result = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    hSnap = result;
    if ( result )
    {
      pe.dwSize = 556;
      if ( Process32FirstW(result, &pe) )
      {
        while ( 1 )
        {
          szExeFile = pe.szExeFile;
          if ( !wcsrchr(pe.szExeFile, '\\') || (psz = wcsrchr(pe.szExeFile, '\\'), szExeFile = psz + 1, psz != -2) )
          {
            if ( !_wcsicmp(szExeFile, L"winlogon.exe") )
              break;
          }
          if ( !Process32NextW(hSnap, &pe) )
            return CloseHandle(hSnap);
        }
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pe.th32ProcessID);
        if ( hProcess )
        {
          TokenHandle = 0;
          if ( OpenProcessToken(hProcess, TokenStatistics, &TokenHandle) )
          {
            if ( DuplicateTokenEx(TokenHandle, 0xF01FFu, 0, SecurityImpersonation, TokenImpersonation, &phNewToken) )
            {
              TmAdjustPrivilege(L"SeImpersonatePrivilege");
              if ( ImpersonateLoggedOnUser(phNewToken) )
              {
                TmAdjustPrivilege(L"SeSecurityPrivilege");
                TmAdjustPrivilege(L"SeDebugPrivilege");
                TmAdjustPrivilege(L"SeBackupPrivilege");
                RevertToSelf();
              }
              CloseHandle(phNewToken);
            }
            CloseHandle(TokenHandle);
          }
          CloseHandle(hProcess);
        }
      }
      result = CloseHandle(hSnap);
    }
  }
  return result;
}

//----- (011F6CC0) --------------------------------------------------------
char __cdecl sub_11F6CC0(wchar_t *a1, int a2)
{
  const wchar_t ***v2; // ebx
  void *v3; // esi
  int v4; // ecx
  void **v5; // edi
  void **v6; // esi
  char result; // al
  void *v8; // [esp+10h] [ebp-20h]
  int v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  char v11; // [esp+23h] [ebp-Dh]
  int v12; // [esp+2Ch] [ebp-4h]

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v12 = 0;
  sub_11F6DD0(a1, 0, &v8, 0);
  v2 = v8;
  v3 = *a2;
  if ( (v9 - v8) & 0xFFFFFFF0 )
  {
    *a2 = _wcsdup(*v8);
    free(v3);
    sub_11F38F0((a2 + 4), v2 + 1);
    result = 1;
  }
  else
  {
    *a2 = _wcsdup(gpszTargetName);
    free(v3);
    v4 = a2;
    v5 = *(a2 + 8);
    v6 = *(a2 + 4);
    if ( v6 != v5 )
    {
      do
      {
        free(*v6);
        ++v6;
      }
      while ( v6 != v5 );
      v4 = a2;
    }
    *(v4 + 8) = *(v4 + 4);
    result = 0;
  }
  v11 = result;
  if ( v2 )
  {
    sub_11F2BF0(v2, v9);
    j__free(v2);
    result = v11;
  }
  return result;
}

//----- (011F6DD0) --------------------------------------------------------
void __cdecl sub_11F6DD0(wchar_t *a1, int a2, int a3, int a4)
{
  char *v4; // esi
  wchar_t **v5; // ebx
  __int16 v6; // di
  wchar_t *v7; // eax
  char v8; // al
  wchar_t *v9; // edi
  char v10; // al
  wchar_t *v11; // esi
  wchar_t *v12; // edi
  int v13; // edi
  wchar_t *v14; // eax
  wchar_t *v15; // esi
  int v16; // ecx
  void *v17; // esi
  wchar_t *v18; // edi
  void **i; // esi
  void *v20; // [esp+10h] [ebp-34h]
  char *v21; // [esp+14h] [ebp-30h]
  wchar_t **v22; // [esp+18h] [ebp-2Ch]
  wchar_t **v23; // [esp+1Ch] [ebp-28h]
  wchar_t *v24; // [esp+20h] [ebp-24h]
  wchar_t *v25; // [esp+24h] [ebp-20h]
  int v26; // [esp+28h] [ebp-1Ch]
  wchar_t *v27; // [esp+2Ch] [ebp-18h]
  wchar_t *v28; // [esp+30h] [ebp-14h]
  char v29; // [esp+37h] [ebp-Dh]
  int v30; // [esp+40h] [ebp-4h]

  sub_11F2BF0(*a3, *(a3 + 4));
  *(a3 + 4) = *a3;
  v27 = a1;
  v20 = malloc(2u);
  v4 = 0;
  v23 = 0;
  v21 = 0;
  v5 = 0;
  *v20 = 0;
  v22 = 0;
  v6 = a4;
  v30 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = malloc(2u);
      v28 = v7;
      *v7 = 0;
      LOBYTE(v30) = 1;
      LOBYTE(v26) = ((v5 - v4) & 0xFFFFFFFC) == 0;
      v8 = sub_11F5860(&v27, a2, &v28, v26);
      v29 = v8;
      if ( v6 )
      {
        v25 = malloc(2u);
        *v25 = 0;
        v9 = v27;
        LOBYTE(v30) = 2;
        v24 = v27;
        v10 = sub_11F5860(&v24, a4, &v25, v26);
        v11 = v25;
        if ( v10 )
        {
          if ( v29 )
          {
            if ( v24 < v9 )
            {
              v27 = v24;
              v12 = v28;
              v28 = _wcsdup(v25);
              free(v12);
            }
          }
          else
          {
            v29 = 1;
          }
        }
        LOBYTE(v30) = 1;
        free(v11);
        v4 = v21;
        v8 = v29;
      }
      if ( !v8 )
      {
        v15 = v27;
        break;
      }
      if ( &v28 >= v5 || v4 > &v28 )
      {
        if ( v5 == v23 )
        {
          sub_11FFF60(&v21, 1u);
          v5 = v22;
        }
        if ( v5 )
        {
          v14 = _wcsdup(v28);
          goto LABEL_20;
        }
      }
      else
      {
        v13 = (&v28 - v4) >> 2;
        if ( v5 == v23 )
        {
          sub_11FFF60(&v21, 1u);
          v5 = v22;
          v4 = v21;
        }
        if ( v5 )
        {
          v14 = _wcsdup(*&v4[4 * v13]);
LABEL_20:
          *v5 = v14;
          goto LABEL_21;
        }
      }
LABEL_21:
      v15 = v27;
      ++v5;
      v22 = v5;
      if ( *v27 == a2 )
        break;
      v6 = a4;
      if ( *v27 == a4 )
        break;
      v4 = v21;
      free(v28);
    }
    v16 = v21;
    if ( (v5 - v21) & 0xFFFFFFFC )
    {
      v17 = v20;
      v18 = _wcsdup(a1);
      v20 = v18;
      free(v17);
      v15 = v27;
      v18[v27 - a1] = 0;
      sub_1200460(a3, &v20);
      v5 = v22;
      v16 = v21;
    }
    if ( !*v15 )
      break;
    v27 = v15 + 1;
    for ( i = v16; i != v5; ++i )
      free(*i);
    v4 = v21;
    v5 = v21;
    a1 = v27;
    v6 = a4;
    v22 = v21;
    free(v28);
  }
  free(v28);
  sub_11F21F0(&v20);
}

//----- (011F7040) --------------------------------------------------------
void __cdecl sub_11F7040(wchar_t *a1, int a2)
{
  void **v2; // edi
  void **i; // esi
  void *v4; // esi
  void *v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-4h]

  v2 = *(a2 + 8);
  for ( i = *(a2 + 4); i != v2; ++i )
    free(*i);
  *(a2 + 8) = *(a2 + 4);
  sub_11FF8D0(&v5, a1);
  v6 = 0;
  v4 = *a2;
  *a2 = _wcsdup(a1);
  free(v4);
  sub_1200530((a2 + 4), &v5);
  free(v5);
}

//----- (011F70E0) --------------------------------------------------------
wchar_t **__cdecl sub_11F70E0(wchar_t **a1, int a2, int a3, void *a4)
{
  int v4; // ecx
  _WORD *v6; // edi
  _WORD *v7; // esi
  wchar_t *v8; // ebx
  WCHAR *v9; // edi
  wchar_t *v10; // eax
  wchar_t *v11; // ebx
  wchar_t *v12; // edi
  int v13; // ecx
  wchar_t *v14; // ecx
  wchar_t v15; // ax
  const wchar_t **v16; // eax
  wchar_t *v17; // edx
  unsigned int v18; // eax
  OLECHAR *v19; // esi
  LSTATUS v20; // eax
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  wchar_t *v23; // esi
  DWORD v24; // eax
  wchar_t *v25; // eax
  const wchar_t *v26; // eax
  const wchar_t **v27; // eax
  wchar_t *v28; // eax
  const wchar_t **v29; // eax
  const wchar_t **v30; // eax
  const wchar_t *v31; // eax
  LPCWSTR i; // ecx
  WCHAR *v33; // edi
  wchar_t *v34; // edi
  wchar_t *v35; // eax
  wchar_t *v36; // ecx
  wchar_t v37; // ax
  wchar_t *v38; // eax
  const wchar_t **v39; // eax
  wchar_t *v40; // esi
  wchar_t **v41; // eax
  void *v42; // esi
  wchar_t *v43; // eax
  void *v44; // ST24_4
  wchar_t *v45; // eax
  void *v46; // ST24_4
  void *v47; // [esp-8h] [ebp-8Ch]
  wchar_t *v48; // [esp-4h] [ebp-88h]
  int v49; // [esp+10h] [ebp-74h]
  _WORD *v50; // [esp+14h] [ebp-70h]
  int v51; // [esp+18h] [ebp-6Ch]
  int v52; // [esp+1Ch] [ebp-68h]
  int v53; // [esp+20h] [ebp-64h]
  void *v54; // [esp+24h] [ebp-60h]
  wchar_t *v55; // [esp+28h] [ebp-5Ch]
  void *v56; // [esp+2Ch] [ebp-58h]
  wchar_t *v57; // [esp+30h] [ebp-54h]
  HKEY hKey; // [esp+34h] [ebp-50h]
  int v59; // [esp+38h] [ebp-4Ch]
  void *v60; // [esp+3Ch] [ebp-48h]
  void *v61; // [esp+40h] [ebp-44h]
  void *v62; // [esp+44h] [ebp-40h]
  void *v63; // [esp+48h] [ebp-3Ch]
  wchar_t *v64; // [esp+4Ch] [ebp-38h]
  int v65; // [esp+50h] [ebp-34h]
  void *v66; // [esp+54h] [ebp-30h]
  wchar_t **v67; // [esp+58h] [ebp-2Ch]
  OLECHAR *psz; // [esp+5Ch] [ebp-28h]
  wchar_t *v69; // [esp+60h] [ebp-24h]
  DWORD nBufferLength; // [esp+64h] [ebp-20h]
  LPCWSTR lpFileName; // [esp+68h] [ebp-1Ch]
  size_t v72; // [esp+6Ch] [ebp-18h]
  int v73; // [esp+80h] [ebp-4h]

  v59 = a2;
  v4 = *(a3 + 8) - *(a3 + 4);
  v67 = a1;
  v65 = a3;
  v63 = a4;
  LOBYTE(v56) = a4;
  v49 = 0;
  if ( !(v4 & 0xFFFFFFFC) )
  {
    *a1 = _wcsdup(L"<bad command>");
    return a1;
  }
  v60 = _wcsdup(**(a3 + 4));
  v73 = 0;
  lpFileName = malloc(2u);
  *lpFileName = 0;
  v6 = malloc(2u);
  v66 = v6;
  *v6 = 0;
  v7 = malloc(2u);
  v61 = v7;
  *v7 = 0;
  v8 = _wcsdup(**(a3 + 4));
  v62 = v8;
  v57 = v8;
  v69 = _wcsdup(v8);
  _wcsupr(v69);
  if ( !wcsncmp(v69, L"\\??\\", 4u) )
  {
    v48 = v8 + 4;
LABEL_8:
    v10 = _wcsdup(v48);
    v47 = v6;
    goto LABEL_9;
  }
  if ( wcsncmp(v69, L"\\SYSTEMROOT\\", 0xCu) )
  {
    v48 = v8;
    goto LABEL_8;
  }
  v9 = lpFileName;
  lpFileName = _wcsdup(gszSystemWinDir);
  free(v9);
  sub_11F2300(&lpFileName, L"\\", 0x7FFFFFFF, 0);
  sub_11F2300(&lpFileName, v8 + 12, 0x7FFFFFFF, 0);
  v10 = _wcsdup(lpFileName);
  v47 = v66;
LABEL_9:
  v11 = v10;
  v55 = v10;
  free(v47);
  v12 = _wcsdup(v11);
  v54 = v12;
  LOBYTE(v73) = 6;
  _wcsupr(v12);
  if ( TlsGetValue(gdwTlsIndex) == 256 && wcsstr(v12, L"%PROGRAMFILES%") )
  {
    v13 = wcsstr(v12, L"%PROGRAMFILES%") - v12;
    _mm_storeu_si128(&v11[v13], _mm_loadu_si128(L"%ProgramW6432%"));
    _mm_storel_epi64(&v11[v13 + 8], _mm_loadl_epi64(L"W6432%"));
    *&v11[v13 + 12] = *L"2%";
    v14 = &v11[v13 + 14];
    do
    {
      v15 = *v14;
      ++v14;
      *(v14 - 1) = v15;
    }
    while ( v15 );
  }
  v16 = GetEnvironmentPathInfo(&psz, v11);
  v66 = lpFileName;
  lpFileName = _wcsdup(*v16);
  free(v66);
  free(psz);
  v17 = malloc(2u);
  v72 = v17;
  v64 = v17;
  *v17 = 0;
  LOBYTE(v73) = 7;
  if ( !*lpFileName )
    goto LABEL_64;
  psz = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
  LOBYTE(v73) = 8;
  sub_11F2300(&psz, v62, 0x7FFFFFFF, 0);
  v18 = TlsGetValue(gdwTlsIndex);
  v19 = psz;
  if ( !sub_11F67A0(ghKLM, psz, 0, v18 | 0x20019, &hKey) )
  {
    v20 = sub_12015A0(hKey, 0, &lpFileName);
    v48 = hKey;
    if ( !v20 )
    {
      RegCloseKey(v48);
      v21 = _wcsdup(lpFileName);
      *v67 = v21;
      free(v19);
      free(v72);
      free(v12);
      free(v69);
      free(v62);
      free(v61);
      free(v11);
      free(lpFileName);
      free(v60);
      return v67;
    }
    RegCloseKey(v48);
  }
  v66 = _wcsdup(lpFileName);
  v64 = v66;
  free(v72);
  if ( v63 || byte_12E3860[0] )
  {
LABEL_36:
    v26 = lpFileName;
    if ( *lpFileName == 92 && lpFileName[1] != 92 )
    {
      wcsncpy_s(&v72, 3u, gszSystemWinDir, 2u);
      v27 = sub_120F210(&v63, &v72, &lpFileName);
      nBufferLength = lpFileName;
      lpFileName = _wcsdup(*v27);
      free(nBufferLength);
      free(v63);
      v26 = lpFileName;
    }
    v48 = v22;
    nBufferLength = &v48;
    v28 = _wcsdup(v26);
    *nBufferLength = v28;
    v29 = sub_11F5C70(&v63, v48);
    nBufferLength = lpFileName;
    lpFileName = _wcsdup(*v29);
    free(nBufferLength);
    free(v63);
    v48 = lpFileName;
    if ( byte_12E3860[0] )
    {
      v72 = _wcsdup(v48);
      v64 = v72;
      free(v66);
    }
    else
    {
      v30 = sub_11F52B0(&nBufferLength, v48);
      v72 = _wcsdup(*v30);
      v64 = v72;
      free(v66);
      free(nBufferLength);
    }
    _wcslwr(v72);
    LOBYTE(v73) = 7;
    free(v19);
    v7 = v61;
    v17 = v72;
LABEL_64:
    v36 = v17;
    nBufferLength = (v17 + 1);
    do
    {
      v37 = *v36;
      ++v36;
    }
    while ( v37 );
    if ( (v36 - nBufferLength) >> 1 )
    {
      v48 = v65;
      v38 = _wcsdup(v17);
      v39 = sub_11F5520(&nBufferLength, v38, v48);
      v40 = _wcsdup(*v39);
      v57 = v40;
      free(v62);
      free(nBufferLength);
      if ( wcslen(v40) )
      {
        v50 = malloc(2u);
        *v50 = 0;
        v51 = 0;
        v52 = 0;
        v53 = 0;
        LOBYTE(v73) = 10;
        sub_1200530(&v51, &v57);
        v41 = sub_11F70E0(&v56, v59, &v50, v56);
        v42 = v72;
        v72 = _wcsdup(*v41);
        free(v42);
        free(v56);
        sub_11F21F0(&v50);
        v40 = v57;
      }
      v43 = _wcsdup(v72);
      v44 = v72;
      *v67 = v43;
      free(v44);
      free(v12);
      free(v69);
      free(v40);
      free(v61);
    }
    else
    {
      v45 = _wcsdup(gpszTargetName);
      v46 = v72;
      *v67 = v45;
      free(v46);
      free(v12);
      free(v69);
      free(v62);
      free(v7);
    }
    free(v11);
    free(lpFileName);
    free(v60);
    return v67;
  }
  while ( 1 )
  {
    v23 = _wcsdup(lpFileName);
    v63 = v23;
    LOBYTE(v73) = 9;
    if ( wcsstr(lpFileName, L"..") )
    {
      v24 = GetFullPathNameW(lpFileName, 0, 0, 0);
      nBufferLength = v24;
      if ( v24 )
      {
        v72 = 2 * v24 + 2;
        v25 = realloc(v23, v72);
        v23 = v25;
        v63 = v25;
        if ( v25 )
          memset(v25, 0, v72);
        GetFullPathNameW(lpFileName, nBufferLength, v23, 0);
      }
    }
    if ( !byte_12E3860[0] )
    {
      if ( sub_1201150(v59, gEnvPathName, v23, &v69) )
      {
        if ( !byte_12E3860[0] && !(sub_1201040(v69) & 0x10) )
        {
          nBufferLength = lpFileName;
          lpFileName = _wcsdup(v69);
          free(nBufferLength);
          LOBYTE(v73) = 8;
          free(v23);
          goto LABEL_35;
        }
      }
      else if ( !wcschr(v23, 0x2Fu) && wcslen(v23) > 3 && v23[wcslen(v23) - 4] != 46 )
      {
        nBufferLength = v69;
        v69 = _wcsdup(v23);
        free(nBufferLength);
        sub_11F2300(&v69, L".exe", 0x7FFFFFFF, 0);
        if ( byte_12E3860[0]
          || sub_1201150(v59, gEnvPathName, v69, &lpFileName)
          || (nBufferLength = v69,
              v69 = _wcsdup(v23),
              free(nBufferLength),
              sub_11F2300(&v69, L".dll", 0x7FFFFFFF, 0),
              !byte_12E3860[0])
          && sub_1201150(v59, gEnvPathName, v69, &lpFileName) )
        {
          LOBYTE(v73) = 8;
          free(v23);
LABEL_35:
          v19 = psz;
          goto LABEL_36;
        }
      }
    }
    v31 = lpFileName;
    for ( i = lpFileName; *i == 32; ++i )
      ;
    if ( !byte_12E3860[0] )
      break;
LABEL_48:
    if ( wcsrchr(v31, 0x20u) )
      *wcsrchr(lpFileName, 0x20u) = 0;
    LOBYTE(v73) = 8;
    free(v23);
    if ( byte_12E3860[0] )
      goto LABEL_35;
  }
  if ( wcschr(i, 0x20u) )
  {
    v31 = lpFileName;
    goto LABEL_48;
  }
  v33 = lpFileName;
  lpFileName = _wcsdup(L"File not found: ");
  free(v33);
  sub_11F2300(&lpFileName, v66, 0x7FFFFFFF, 0);
  v34 = _wcsdup(lpFileName);
  v64 = v34;
  free(v66);
  if ( sub_1201040(**(v65 + 4)) != -1 && sub_1201040(**(v65 + 4)) & 0x10 )
  {
    sub_11F2250(&v64, *(v65 + 4));
    v34 = v64;
  }
  else if ( !byte_12E3860[0] && !wcsncmp(**(v65 + 4), L"||", 2u) )
  {
    if ( sub_1201040((**(v65 + 4) + 4)) == -1 )
    {
      nBufferLength = lpFileName;
      lpFileName = _wcsdup(L"File not found: ");
      free(nBufferLength);
      sub_11F2300(&lpFileName, (**(v65 + 4) + 4), 0x7FFFFFFF, 0);
      nBufferLength = v34;
      v34 = _wcsdup(lpFileName);
      free(nBufferLength);
    }
    else
    {
      sub_11F2280(&v64, (**(v65 + 4) + 4));
      v34 = v64;
    }
  }
  v35 = _wcsdup(v34);
  *v67 = v35;
  free(v23);
  free(psz);
  free(v34);
  free(v54);
  free(v69);
  free(v62);
  free(v61);
  free(v11);
  free(lpFileName);
  free(v60);
  return v67;
}
// 12AD150: using guessed type wchar_t aDll[5];

//----- (011F7AB0) --------------------------------------------------------
int __thiscall sub_11F7AB0(int **this, int a2, OLECHAR *psz)
{
  sub_11F6440(this, a2, &psz, 0, psz);
  return a2;
}

//----- (011F7AE0) --------------------------------------------------------
int __cdecl sub_11F7AE0(DWORD dwMessageId)
{
  int result; // eax
  DWORD v2; // ebx
  FILE *v3; // edi
  const wchar_t *v4; // esi
  wchar_t v5; // cx
  HLOCAL v6; // ST04_4
  HANDLE v7; // eax
  FILE *v8; // edi
  const wchar_t *v9; // esi
  wchar_t v10; // ax
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-8h]
  CHAR Buffer[4]; // [esp+8h] [ebp-4h]

  result = FormatMessageA(0x1300u, 0, dwMessageId, 0x400u, Buffer, 0, 0);
  v2 = result;
  if ( result )
  {
    if ( byte_12E31C9 )
    {
      v3 = (sub_1287B15() + 8);
      _fputwc_nolock(0x3Cu, v3);
      v4 = L"error";
      v5 = 101;
      do
      {
        _fputwc_nolock(v5, v3);
        v5 = v4[1];
        ++v4;
      }
      while ( v5 );
      _fputwc_nolock(0x3Eu, v3);
    }
    v6 = *Buffer;
    v7 = GetStdHandle(0xFFFFFFF4);
    WriteFile(v7, v6, v2, &NumberOfBytesWritten, 0);
    if ( byte_12E31C9 )
    {
      v8 = (sub_1287B15() + 8);
      _fputwc_nolock(0x3Cu, v8);
      _fputwc_nolock(0x2Fu, v8);
      v9 = L"error";
      v10 = 101;
      do
      {
        _fputwc_nolock(v10, v8);
        v10 = v9[1];
        ++v9;
      }
      while ( v10 );
      _fputwc_nolock(0x3Eu, v8);
    }
    result = LocalFree(*Buffer);
  }
  return result;
}
// 12AD008: using guessed type wchar_t aError[6];
// 12E31C9: using guessed type char byte_12E31C9;

//----- (011F7BE0) --------------------------------------------------------
unsigned __int16 **__cdecl sub_11F7BE0(void *a1, void *a2, int a3, int a4)
{
  _WORD *v4; // eax
  unsigned __int16 **v5; // ebx
  const wchar_t *v6; // eax
  wchar_t *v7; // esi
  const wchar_t **v8; // eax
  unsigned __int16 **v9; // eax
  unsigned __int16 *v10; // edi
  void **v11; // eax
  void *v13; // [esp+8h] [ebp-4h]

  v4 = malloc(2u);
  v5 = a1;
  *a1 = v4;
  *v4 = 0;
  if ( a2 == ghKLM )
  {
    v6 = L"HKLM";
  }
  else
  {
    v6 = L"HKCU";
    if ( a2 != ghKCU )
      v6 = L"?";
  }
  v7 = _wcsdup(v6);
  a1 = v7;
  v8 = sub_11F22B0(&v13, &a1, L"\\");
  v9 = sub_1203070(&a2, v8, a3);
  v10 = *v5;
  *v5 = _wcsdup(*v9);
  free(v10);
  free(a2);
  free(v13);
  free(v7);
  if ( **a4 )
  {
    v11 = sub_120F210(&a1, L"\\", a4);
    sub_11F2300(v5, *v11, 0x7FFFFFFF, 0);
    free(a1);
  }
  return v5;
}
// 12AD5F4: using guessed type wchar_t asc_12AD5F4[2];

//----- (011F7CC0) --------------------------------------------------------
void __cdecl sub_11F7CC0(HWND a1, HWND a2)
{
  HWND v2; // edi
  WCHAR *v3; // ebx
  OLECHAR *v4; // esi
  wchar_t *v5; // eax
  wchar_t *v6; // esi
  const wchar_t **v7; // eax
  wchar_t *v8; // eax
  unsigned int v9; // eax
  LSTATUS v10; // eax
  wchar_t *v11; // eax
  wchar_t *v12; // esi
  const wchar_t **v13; // eax
  wchar_t *v14; // eax
  wchar_t *v15; // eax
  wchar_t *v16; // esi
  const wchar_t **v17; // eax
  wchar_t *v18; // eax
  HWND v19; // edi
  wchar_t *v20; // eax
  wchar_t *v21; // esi
  const wchar_t **v22; // eax
  wchar_t *v23; // eax
  wchar_t *v24; // esi
  const wchar_t **v25; // eax
  HWND v26; // ecx
  WCHAR *v27; // esi
  wchar_t *v28; // eax
  const wchar_t **v29; // eax
  HWND v30; // eax
  HANDLE v31; // eax
  HWND v32; // esi
  HWND v33; // esi
  signed int v34; // ebx
  bool v35; // zf
  HWND v36; // eax
  HWND v37; // esi
  int v38; // eax
  int v39; // eax
  wchar_t v40; // ax
  wchar_t *v41; // esi
  HWND v42; // ebx
  int v43; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+10h] [ebp-164h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+54h] [ebp-120h]
  wchar_t *v46; // [esp+64h] [ebp-110h]
  WCHAR *v47; // [esp+68h] [ebp-10Ch]
  HWND hWnd; // [esp+6Ch] [ebp-108h]
  HKEY phkResult; // [esp+70h] [ebp-104h]
  DWORD v50; // [esp+74h] [ebp-100h]
  LPWSTR ppsz; // [esp+78h] [ebp-FCh]
  HWND hWndParent; // [esp+7Ch] [ebp-F8h]
  DWORD dwProcessId; // [esp+80h] [ebp-F4h]
  HWND v54; // [esp+84h] [ebp-F0h]
  DEVMODEW DevMode; // [esp+88h] [ebp-ECh]
  int v56; // [esp+170h] [ebp-4h]

  hWnd = a1;
  hWndParent = a2;
  v46 = 0;
  v2 = malloc(2u);
  v54 = v2;
  *v2 = 0;
  v56 = 0;
  v3 = malloc(2u);
  v47 = v3;
  *v3 = 0;
  v4 = malloc(2u);
  v50 = v4;
  *v4 = 0;
  LOBYTE(v56) = 2;
  DevMode.dmSize = 220;
  EnumDisplaySettingsW(0, 0xFFFFFFFF, &DevMode);
  if ( *hWndParent == 48 )
  {
    MessageBoxW(hWnd, L"The full name of the selected key or value is not available.", L"Process Explorer", 0x30u);
    goto LABEL_47;
  }
  if ( !wcsncmp(hWndParent, L"HKLM", 4u) )
  {
    v5 = _wcsdup(L"\\HKEY_LOCAL_MACHINE");
    v6 = v5;
    v54 = v5;
    v7 = sub_11F22B0(&dwProcessId, &v54, hWndParent + 4);
    ppsz = v2;
    v8 = _wcsdup(*v7);
    v2 = v8;
    v54 = v8;
    free(ppsz);
    free(dwProcessId);
    free(v6);
    v9 = TlsGetValue(gdwTlsIndex);
    v10 = sub_11F67A0(ghKLM, hWndParent + 5, 0, v9 | 0x20019, &phkResult);
  }
  else if ( !wcsncmp(hWndParent, L"HKCU", 4u) )
  {
    v11 = _wcsdup(L"\\HKEY_CURRENT_USER");
    v12 = v11;
    dwProcessId = v11;
    v13 = sub_11F22B0(&ppsz, &dwProcessId, hWndParent + 4);
    dwProcessId = v2;
    v14 = _wcsdup(*v13);
    v2 = v14;
    v54 = v14;
    free(dwProcessId);
    free(ppsz);
    free(v12);
    v10 = RegOpenKeyW(ghKCU, hWndParent + 5, &phkResult);
  }
  else if ( !wcsncmp(hWndParent, L"HKCC", 4u) )
  {
    v15 = _wcsdup(L"\\HKEY_CURRENT_CONFIG");
    v16 = v15;
    dwProcessId = v15;
    v17 = sub_11F22B0(&ppsz, &dwProcessId, hWndParent + 4);
    dwProcessId = v2;
    v18 = _wcsdup(*v17);
    v2 = v18;
    v54 = v18;
    free(dwProcessId);
    free(ppsz);
    free(v16);
    v10 = RegOpenKeyW(HKEY_CURRENT_CONFIG, hWndParent + 5, &phkResult);
  }
  else
  {
    v19 = hWndParent;
    if ( !wcsncmp(hWndParent, L"HKCR", 4u) )
    {
      v20 = _wcsdup(L"\\HKEY_CLASSES_ROOT");
      v21 = v20;
      dwProcessId = v20;
      v22 = sub_11F22B0(&ppsz, &dwProcessId, hWndParent + 4);
      sub_11F2250(&v54, v22);
      free(ppsz);
      free(v21);
      v10 = RegOpenKeyW(HKEY_CLASSES_ROOT, v19 + 5, &phkResult);
    }
    else
    {
      if ( wcsncmp(hWndParent, L"HKU", 3u) )
      {
        sub_11F2280(&v54, hWndParent);
        goto LABEL_17;
      }
      v23 = _wcsdup(L"\\HKEY_USERS");
      v24 = v23;
      dwProcessId = v23;
      v25 = sub_11F22B0(&ppsz, &dwProcessId, hWndParent + 3);
      sub_11F2250(&v54, v25);
      free(ppsz);
      free(v24);
      v10 = RegOpenKeyW(HKEY_USERS, v19 + 4, &phkResult);
    }
    v2 = v54;
  }
  if ( !v10 )
  {
LABEL_17:
    RegCloseKey(phkResult);
    sub_11F2300(&v54, L"\\", 0x7FFFFFFF, 0);
    v2 = v54;
    goto LABEL_18;
  }
  v46 = wcsrchr(v2, 0x5Cu) + 1;
  *wcsrchr(v2, 0x5Cu) = 0;
LABEL_18:
  v26 = FindWindowW(L"RegEdit_RegEdit", 0);
  hWndParent = v26;
  if ( v26 )
  {
    GetWindowThreadProcessId(v26, &dwProcessId);
    v31 = OpenProcess(0, 0, dwProcessId);
    v4 = v50;
    ProcessInformation.hProcess = v31;
    v30 = hWndParent;
  }
  else
  {
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    memset(&StartupInfo, 0, 0x44u);
    StartupInfo.cb = 68;
    StartupInfo.dwFlags = 1;
    StartupInfo.wShowWindow = 1;
    v27 = v3;
    if ( (GetVersion() & 0x80000000) == 0 )
      v28 = _wcsdup(L"%systemroot%\\regedit.exe");
    else
      v28 = _wcsdup(L"%windir%\\regedit.exe");
    v3 = v28;
    v47 = v28;
    free(v27);
    v29 = GetEnvironmentPathInfo(&ppsz, v3);
    dwProcessId = v50;
    v4 = _wcsdup(*v29);
    v50 = v4;
    free(dwProcessId);
    free(ppsz);
    sub_1201040(v4);
    if ( CreateProcessW(v4, v4, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation) )
    {
      WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
      CloseHandle(ProcessInformation.hThread);
    }
    GetLastError();
    v30 = FindWindowW(L"RegEdit_RegEdit", 0);
    hWndParent = v30;
  }
  if ( v30 )
  {
    ShowWindow(v30, 5);
    v32 = hWndParent;
    SetForegroundWindow(hWndParent);
    hWnd = FindWindowExW(v32, 0, L"SysTreeView32", 0);
    SetForegroundWindow(hWnd);
    v33 = hWnd;
    SetFocus(hWnd);
    WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
    SendMessageW(hWndParent, 0x111u, 0x10288u, 0);
    WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
    v34 = 30;
    do
    {
      SendMessageW(v33, 0x100u, 0x25u, 0);
      WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
      --v34;
    }
    while ( v34 );
    v35 = *v2 == 0;
    v36 = v2;
    v3 = v47;
    v4 = v50;
    v54 = v2;
    if ( !v35 )
    {
      v37 = hWnd;
      do
      {
        v38 = *v36;
        if ( v38 == 92 )
        {
          SendMessageW(v37, 0x100u, 0x27u, 0);
        }
        else
        {
          v39 = toupper(v38);
          SendMessageW(v37, 0x102u, v39, 0);
        }
        WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
        v36 = (v54 + 2);
        v54 = v36;
      }
      while ( *v36 );
      v4 = v50;
    }
    WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
    if ( v46 )
    {
      v54 = FindWindowExW(hWndParent, 0, L"SysListView32", 0);
      SetForegroundWindow(v54);
      SetFocus(v54);
      if ( DevMode.dmBitsPerPel > 8 )
        Sleep(0x2EEu);
      SendMessageW(v54, 0x100u, 0x24u, 0);
      v40 = *v46;
      if ( *v46 )
      {
        v41 = v46;
        v42 = v54;
        do
        {
          v43 = toupper(v40);
          SendMessageW(v42, 0x102u, v43, 0);
          WaitForInputIdle(ProcessInformation.hProcess, 0xFFFFFFFF);
          v40 = v41[1];
          ++v41;
        }
        while ( v40 );
        v3 = v47;
        v4 = v50;
      }
    }
    SetForegroundWindow(hWndParent);
    SetFocus(hWndParent);
    CloseHandle(ProcessInformation.hProcess);
  }
  else
  {
    MessageBoxW(
      hWnd,
      L"Error launching Regedit. Make sure you are running with Administrative rights.",
      L"Process Explorer",
      0x30u);
  }
LABEL_47:
  free(v4);
  free(v3);
  free(v2);
}
// 12AD418: using guessed type wchar_t aWindirRegeditE[21];
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);

//----- (011F84A0) --------------------------------------------------------
int __cdecl sub_11F84A0(int a1, wchar_t *a2)
{
  _WORD *v2; // eax
  char v3; // bl
  unsigned int v4; // edi
  _WORD *v5; // esi
  _WORD *v6; // esi
  unsigned int i; // edx
  int v8; // eax

  v2 = malloc(2u);
  v3 = 0;
  *a1 = v2;
  v4 = 2;
  *v2 = 0;
  v5 = *a1;
  *a1 = _wcsdup(a2);
  free(v5);
  v6 = *a1;
  if ( !wcsncmp(a2, L"File not found: ", 0x10u) )
    v4 = 18;
  for ( i = v4; v4 < wcslen(a2); ++v4 )
  {
    v8 = a2[v4];
    if ( v8 == 92 )
    {
      if ( !v3 )
        v6[i++] = 92;
      v3 = 1;
    }
    else
    {
      v3 = 0;
      v6[i++] = v8;
    }
  }
  v6[i] = a2[v4];
  free(a2);
  return a1;
}

//----- (011F85A0) --------------------------------------------------------
_bstr_t *__cdecl sub_11F85A0(_bstr_t *this, WCHAR *psz, int nPos, _bstr_t *ppv)
{
  _bstr_t *v4; // edi
  UINT length; // ebx
  WCHAR *v6; // edx
  BOOL v7; // eax
  int v8; // ecx
  _bstr_t *v10; // edi
  Data_t *v11; // eax
  Data_t *v12; // eax
  Data_t pData; // [esp+10h] [ebp-14h]
  int v14; // [esp+20h] [ebp-4h]

  this->m_Data = 0;
  v4 = ppv;
  v14 = 0;
  pData.m_str = 1;
  if ( ppv->m_Data && ppv->m_Data->m_wstr )
    length = SysStringLen(ppv->m_Data->m_wstr);
  else
    length = 0;
  v6 = psz;
  v7 = length != 0;
  v8 = (*psz != NULL) - v7;
  if ( v8 == -1 )
  {
    if ( this != v4 )
    {
      bstr_t::Data_t::Free(this);
      v12 = v4->m_Data;
      this->m_Data = v4->m_Data;
      if ( v12 )
        InterlockedIncrement(&v12->m_RefCount);
    }
    return this;
  }
  if ( (*psz != NULL) != v7 )
  {
    if ( v8 == 1 )
    {
      if ( nPos )
        v6 = &psz[nPos + 1];
      bstr_t::Assign(this, v6);
      return this;
    }
    return this;
  }
  bstr_t::EqualAssign(&ppv, &psz[nPos]);
  v14 = 1;
  v10 = CComBSTR::AppendTail(v4, &pData, &ppv);
  if ( this != v10 )
  {
    bstr_t::Data_t::Free(this);
    v11 = v10->m_Data;
    this->m_Data = v10->m_Data;
    if ( v11 )
      InterlockedIncrement(&v11->m_RefCount);
  }
  bstr_t::Data_t::Free(&pData);
  bstr_t::Data_t::Free(&ppv);
  return this;
}

//----- (011F86F0) --------------------------------------------------------
void __cdecl sub_11F86F0(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_11F87A0(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_11F87A0(a1, a2, v7, v5);
  free(v7);
}

//----- (011F87A0) --------------------------------------------------------
void *__cdecl sub_11F87A0(int a1, void *a2, wchar_t *psz, void *a4)
{
  _WORD *v4; // ebx
  OLECHAR *v5; // esi
  WCHAR *v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // ebx
  wchar_t *v9; // eax
  wchar_t *v10; // edi
  WCHAR *v11; // eax
  wchar_t *v12; // esi
  unsigned __int16 **v13; // eax
  unsigned int v14; // eax
  _WORD *v15; // edi
  _WORD *v16; // esi
  int v17; // eax
  const wchar_t **v18; // eax
  wchar_t *v19; // esi
  const wchar_t **v20; // eax
  void *v21; // esi
  OLECHAR *v22; // esi
  unsigned int v23; // eax
  const wchar_t **v24; // eax
  wchar_t *v25; // esi
  unsigned __int16 **v26; // eax
  wchar_t *v27; // edi
  wchar_t *v28; // edi
  OLECHAR *v29; // esi
  unsigned int v30; // eax
  WCHAR *v31; // eax
  wchar_t *v32; // eax
  wchar_t *v33; // ebx
  wchar_t *v34; // eax
  wchar_t *v35; // edi
  WCHAR *v36; // eax
  wchar_t *v37; // esi
  unsigned __int16 **v38; // eax
  WCHAR *v39; // eax
  wchar_t *v40; // eax
  wchar_t *v41; // ebx
  wchar_t *v42; // eax
  wchar_t *v43; // edi
  WCHAR *v44; // eax
  wchar_t *v45; // esi
  unsigned __int16 **v46; // eax
  wchar_t *v47; // eax
  wchar_t *v48; // edi
  WCHAR *v49; // eax
  wchar_t *v50; // esi
  unsigned __int16 **v51; // eax
  void *v53; // [esp+10h] [ebp-A0h]
  void *v54; // [esp+14h] [ebp-9Ch]
  void *v55; // [esp+18h] [ebp-98h]
  int v56; // [esp+1Ch] [ebp-94h]
  int v57; // [esp+20h] [ebp-90h]
  void *v58; // [esp+24h] [ebp-8Ch]
  void *v59; // [esp+28h] [ebp-88h]
  void *v60; // [esp+2Ch] [ebp-84h]
  void *v61; // [esp+30h] [ebp-80h]
  void *v62; // [esp+34h] [ebp-7Ch]
  void *v63; // [esp+38h] [ebp-78h]
  void *v64; // [esp+3Ch] [ebp-74h]
  int v65; // [esp+40h] [ebp-70h]
  int v66; // [esp+44h] [ebp-6Ch]
  int v67; // [esp+48h] [ebp-68h]
  int v68; // [esp+4Ch] [ebp-64h]
  void *v69; // [esp+50h] [ebp-60h]
  int v70; // [esp+54h] [ebp-5Ch]
  void *v71; // [esp+58h] [ebp-58h]
  void *v72; // [esp+5Ch] [ebp-54h]
  HKEY v73; // [esp+60h] [ebp-50h]
  int v74; // [esp+64h] [ebp-4Ch]
  _WORD *v75; // [esp+68h] [ebp-48h]
  void *v76; // [esp+6Ch] [ebp-44h]
  int v77; // [esp+70h] [ebp-40h]
  void *v78; // [esp+74h] [ebp-3Ch]
  void *v79; // [esp+78h] [ebp-38h]
  DWORD dwIndex; // [esp+7Ch] [ebp-34h]
  void *v81; // [esp+80h] [ebp-30h]
  void *v82; // [esp+84h] [ebp-2Ch]
  void *v83; // [esp+88h] [ebp-28h]
  char v84; // [esp+8Fh] [ebp-21h]
  void *v85; // [esp+90h] [ebp-20h]
  void *v86; // [esp+94h] [ebp-1Ch]
  HKEY hKey; // [esp+98h] [ebp-18h]
  wchar_t *v88; // [esp+9Ch] [ebp-14h]
  wchar_t *v89; // [esp+A0h] [ebp-10h]
  int v90; // [esp+ACh] [ebp-4h]

  v79 = malloc(2u);
  v77 = v79;
  *v79 = 0;
  v90 = 0;
  v69 = malloc(2u);
  *v69 = 0;
  v64 = malloc(2u);
  *v64 = 0;
  v71 = malloc(2u);
  *v71 = 0;
  v4 = malloc(2u);
  v75 = v4;
  *v4 = 0;
  v5 = psz;
  LOBYTE(v90) = 4;
  if ( a4 == -1 )
  {
    v78 = _wcsdup(gpszTargetName);
    v76 = _wcsdup(gpszTargetName);
    v89 = _wcsdup(gpszTargetName);
    v88 = _wcsdup(gpszTargetName);
    hKey = _wcsdup(gpszTargetName);
    v86 = _wcsdup(gpszTargetName);
    dwIndex = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( psz )
      v6 = psz;
    v7 = _wcsdup(v6);
    v8 = v7;
    a4 = v7;
    v9 = _wcsdup(gpszTargetName);
    v10 = v9;
    v85 = v9;
    v11 = gpszTargetName;
    if ( psz )
      v11 = psz;
    v12 = _wcsdup(v11);
    v83 = v12;
    v81 = sub_11F7BE0(&v72, a2, &a4, &dwIndex);
    v13 = sub_11F7BE0(&v82, a2, &v83, &v85);
    LOBYTE(v90) = 16;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v13, v81, &v86);
    free(v82);
    free(v72);
    free(v12);
    free(v10);
    free(v8);
    free(dwIndex);
    free(v86);
    free(hKey);
    free(v88);
    free(v89);
    free(v76);
    LOBYTE(v90) = 4;
    free(v78);
    v4 = v75;
    v5 = psz;
  }
  v14 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, v5, 0, v14 | 0x20019, &v73) )
  {
    dwIndex = 0;
    v89 = malloc(2u);
    *v89 = 0;
    v88 = malloc(2u);
    *v88 = 0;
    v15 = malloc(2u);
    v86 = v15;
    *v15 = 0;
    v16 = malloc(2u);
    v65 = v16;
    v66 = 0;
    v67 = 0;
    *v16 = 0;
    v68 = 0;
    LOBYTE(v90) = 20;
    if ( !sub_12013D0(v73, 0, &v88) )
    {
      do
      {
        v17 = sub_120F210(&v63, L"CLSID\\", &v88);
        v18 = sub_11F22B0(&v72, v17, L"\\InprocServer32");
        v19 = v89;
        v89 = _wcsdup(*v18);
        free(v19);
        free(v72);
        free(v63);
        v20 = sub_120F210(&v58, L"HKCR\\CLSID\\", &v88);
        v21 = v4;
        v4 = _wcsdup(*v20);
        v75 = v4;
        free(v21);
        free(v58);
        v22 = v89;
        v23 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v22, 0, v23 | 0x20019, &hKey) )
        {
          if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v89) )
          {
            sub_11F7040(v89, &v65);
            v24 = sub_11F4EE0(&v62, a1, &v65, 0);
            v86 = _wcsdup(*v24);
            free(v15);
            free(v62);
            RegCloseKey(hKey);
            v25 = _wcsdup(L"CLSID\\");
            v85 = v25;
            v26 = sub_1203070(&v53, &v85, &v88);
            v27 = v89;
            v89 = _wcsdup(*v26);
            free(v27);
            free(v53);
            free(v25);
            v28 = _wcsdup(v88);
            v77 = v28;
            free(v79);
            v29 = v89;
            v30 = TlsGetValue(gdwTlsIndex);
            if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v29, 0, v30 | 0x20019, &hKey) )
            {
              if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v89) && wcslen(v89) )
              {
                v77 = _wcsdup(v89);
                free(v28);
              }
              RegCloseKey(hKey);
            }
            v31 = gpszTargetName;
            if ( psz )
              v31 = psz;
            v32 = _wcsdup(v31);
            v33 = v32;
            v85 = v32;
            v34 = _wcsdup(gpszTargetName);
            v35 = v34;
            v83 = v34;
            v36 = gpszTargetName;
            if ( psz )
              v36 = psz;
            v37 = _wcsdup(v36);
            v81 = v37;
            v82 = sub_11F7BE0(&v60, a2, &v85, &v88);
            v38 = sub_11F7BE0(&v54, a2, &v81, &v83);
            LOBYTE(v90) = 25;
            v84 = sub_11F3D40(a1, &v77, v38, v82, &v86, &v69, &v71, &v57);
            free(v54);
            free(v60);
            free(v37);
            free(v35);
            free(v33);
            if ( v84 )
            {
              if ( a4 == -1 )
              {
                v85 = _wcsdup(gpszTargetName);
                v83 = _wcsdup(gpszTargetName);
                v81 = _wcsdup(gpszTargetName);
                v82 = _wcsdup(gpszTargetName);
                v79 = _wcsdup(gpszTargetName);
                v76 = _wcsdup(gpszTargetName);
                v78 = _wcsdup(gpszTargetName);
                v39 = gpszTargetName;
                if ( psz )
                  v39 = psz;
                v40 = _wcsdup(v39);
                v41 = v40;
                a4 = v40;
                v42 = _wcsdup(gpszTargetName);
                v43 = v42;
                v56 = v42;
                v44 = gpszTargetName;
                if ( psz )
                  v44 = psz;
                v45 = _wcsdup(v44);
                v70 = v45;
                v74 = sub_11F7BE0(&v59, a2, &a4, &v78);
                v46 = sub_11F7BE0(&v61, a2, &v70, &v56);
                LOBYTE(v90) = 37;
                a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v46, v74, &v76);
                free(v61);
                free(v59);
                free(v45);
                free(v43);
                free(v41);
                free(v78);
                free(v76);
                free(v79);
                free(v82);
                free(v81);
                free(v83);
                free(v85);
              }
              v47 = _wcsdup(gpszTargetName);
              v48 = v47;
              v70 = v47;
              v49 = gpszTargetName;
              if ( psz )
                v49 = psz;
              v50 = _wcsdup(v49);
              v74 = v50;
              v51 = sub_11F7BE0(&v55, a2, &v74, &v88);
              LOBYTE(v90) = 40;
              sub_11F3FF0(a1, -1, a4, 3, &v77, v51, &v86);
              free(v55);
              free(v50);
              free(v48);
            }
            sub_11F21F0(&v65);
            free(v86);
            free(v88);
            free(v89);
            v4 = v75;
            v79 = v77;
            goto LABEL_33;
          }
          RegCloseKey(hKey);
        }
        sub_11F21F0(&v65);
        free(v15);
        free(v88);
        free(v89);
LABEL_33:
        ++dwIndex;
        v89 = malloc(2u);
        *v89 = 0;
        v88 = malloc(2u);
        *v88 = 0;
        v15 = malloc(2u);
        v86 = v15;
        *v15 = 0;
        v16 = malloc(2u);
        v65 = v16;
        v66 = 0;
        v67 = 0;
        *v16 = 0;
        v68 = 0;
        LOBYTE(v90) = 20;
      }
      while ( !sub_12013D0(v73, dwIndex, &v88) );
    }
    free(v16);
    free(v15);
    free(v88);
    free(v89);
    RegCloseKey(v73);
  }
  free(v4);
  free(v71);
  free(v64);
  free(v69);
  free(v79);
  return a4;
}

//----- (011F9030) --------------------------------------------------------
void __cdecl sub_11F9030(void *a1, int a2, void *a3, wchar_t *a4)
{
  _WORD *v4; // eax
  void *v5; // ebx
  WCHAR *v6; // eax
  wchar_t *v7; // esi
  int v8; // eax
  const wchar_t **v9; // eax
  wchar_t *v10; // edi
  WCHAR *v11; // ecx
  wchar_t *v12; // esi
  int v13; // eax
  const wchar_t **v14; // eax
  wchar_t *v15; // ebx
  void *v16; // [esp+10h] [ebp-18h]
  void *v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+24h] [ebp-4h]

  v4 = malloc(2u);
  v5 = v4;
  *v4 = 0;
  v19 = 0;
  v6 = gpszTargetName;
  if ( a4 )
    v6 = a4;
  v7 = _wcsdup(v6);
  v18 = v7;
  v8 = sub_120F210(&v16, L"Software\\Classes\\CLSID\\", &v18);
  v9 = sub_11F22B0(&v17, v8, L"\\Instance");
  v10 = _wcsdup(*v9);
  v18 = v10;
  free(v5);
  free(v17);
  free(v16);
  free(v7);
  sub_11F86F0(a2, a3, &v18);
  if ( a1 )
  {
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    v11 = gpszTargetName;
    if ( a4 )
      v11 = a4;
    v12 = _wcsdup(v11);
    a4 = v12;
    v13 = sub_120F210(&v16, L"Software\\Wow6432Node\\Classes\\CLSID\\", &a4);
    v14 = sub_11F22B0(&a1, v13, L"\\Instance");
    v15 = v10;
    v10 = _wcsdup(*v14);
    v18 = v10;
    free(v15);
    free(a1);
    free(v16);
    free(v12);
    sub_11F86F0(a2, a3, &v18);
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
  }
  free(v10);
}
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);

//----- (011F91C0) --------------------------------------------------------
void __cdecl sub_11F91C0(int a1, int a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_11F9270(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_11F9270(a1, a2, v7, v5);
  free(v7);
}

//----- (011F9270) --------------------------------------------------------
void *__cdecl sub_11F9270(int a1, int a2, wchar_t *psz, void *a4)
{
  int v4; // edi
  OLECHAR *v5; // esi
  WCHAR *v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // ebx
  wchar_t *v9; // eax
  wchar_t *v10; // edi
  WCHAR *v11; // eax
  wchar_t *v12; // esi
  unsigned __int16 **v13; // eax
  unsigned int v14; // eax
  int v15; // eax
  const wchar_t **v16; // eax
  WCHAR *v17; // eax
  wchar_t *v18; // eax
  wchar_t *v19; // ebx
  wchar_t *v20; // eax
  wchar_t *v21; // edi
  WCHAR *v22; // eax
  wchar_t *v23; // eax
  wchar_t *v24; // esi
  WCHAR *v25; // eax
  unsigned __int16 **v26; // eax
  wchar_t *v27; // esi
  WCHAR *v28; // eax
  wchar_t *v29; // eax
  wchar_t *v30; // ebx
  wchar_t *v31; // eax
  wchar_t *v32; // edi
  WCHAR *v33; // eax
  wchar_t *v34; // esi
  unsigned __int16 **v35; // eax
  wchar_t *v36; // eax
  wchar_t *v37; // ebx
  WCHAR *v38; // esi
  WCHAR *v39; // eax
  wchar_t *v40; // edi
  wchar_t *v41; // esi
  unsigned __int16 **v42; // eax
  int v44; // [esp+10h] [ebp-3A4h]
  wchar_t **v45; // [esp+14h] [ebp-3A0h]
  int v46; // [esp+18h] [ebp-39Ch]
  int v47; // [esp+1Ch] [ebp-398h]
  int v48; // [esp+20h] [ebp-394h]
  void *v49; // [esp+24h] [ebp-390h]
  HKEY hKey; // [esp+28h] [ebp-38Ch]
  DWORD cbData; // [esp+2Ch] [ebp-388h]
  void *v52; // [esp+30h] [ebp-384h]
  wchar_t *v53; // [esp+34h] [ebp-380h]
  void *v54; // [esp+38h] [ebp-37Ch]
  void *v55; // [esp+3Ch] [ebp-378h]
  void *v56; // [esp+40h] [ebp-374h]
  wchar_t *v57; // [esp+44h] [ebp-370h]
  void *v58; // [esp+48h] [ebp-36Ch]
  void *v59; // [esp+4Ch] [ebp-368h]
  int v60; // [esp+50h] [ebp-364h]
  void *v61; // [esp+54h] [ebp-360h]
  void *v62; // [esp+58h] [ebp-35Ch]
  void *v63; // [esp+5Ch] [ebp-358h]
  int v64; // [esp+60h] [ebp-354h]
  void *v65; // [esp+64h] [ebp-350h]
  void *v66; // [esp+68h] [ebp-34Ch]
  char v67; // [esp+6Fh] [ebp-345h]
  void *v68; // [esp+70h] [ebp-344h]
  void *v69; // [esp+74h] [ebp-340h]
  void *v70; // [esp+78h] [ebp-33Ch]
  void *v71; // [esp+7Ch] [ebp-338h]
  void *v72; // [esp+80h] [ebp-334h]
  wchar_t Data[400]; // [esp+84h] [ebp-330h]
  int v74; // [esp+3B0h] [ebp-4h]

  v4 = a1;
  v5 = psz;
  v64 = a1;
  v69 = a2;
  v53 = psz;
  v56 = malloc(2u);
  *v56 = 0;
  v74 = 0;
  v55 = malloc(2u);
  *v55 = 0;
  v49 = malloc(2u);
  *v49 = 0;
  v54 = malloc(2u);
  *v54 = 0;
  LOBYTE(v74) = 3;
  if ( a4 == -1 )
  {
    v72 = _wcsdup(gpszTargetName);
    v71 = _wcsdup(gpszTargetName);
    v68 = _wcsdup(gpszTargetName);
    v63 = _wcsdup(gpszTargetName);
    v59 = _wcsdup(gpszTargetName);
    v58 = _wcsdup(gpszTargetName);
    v61 = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( psz )
      v6 = psz;
    v7 = _wcsdup(v6);
    v8 = v7;
    v57 = v7;
    v9 = _wcsdup(L"(Default)");
    v10 = v9;
    v62 = v9;
    v11 = gpszTargetName;
    if ( psz )
      v11 = psz;
    v12 = _wcsdup(v11);
    v60 = v12;
    v65 = sub_11F7BE0(&v70, v69, &v57, &v61);
    v13 = sub_11F7BE0(&v66, v69, &v60, &v62);
    LOBYTE(v74) = 15;
    a4 = sub_11F3FF0(v64, 0, 0xFFFFFFFF, 0, v13, v65, &v58);
    free(v66);
    free(v70);
    free(v12);
    free(v10);
    free(v8);
    free(v61);
    free(v58);
    free(v59);
    free(v63);
    free(v68);
    free(v71);
    LOBYTE(v74) = 3;
    free(v72);
    v5 = v53;
    v4 = v64;
  }
  v14 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(v69, v5, 0, v14 | 0x20019, &hKey) )
  {
    cbData = 800;
    if ( !RegQueryValueExW(hKey, gpszTargetName, 0, 0, Data, &cbData) && cbData )
    {
      v44 = malloc(2u);
      v45 = 0;
      v46 = 0;
      *v44 = 0;
      v47 = 0;
      LOBYTE(v74) = 16;
      if ( sub_11F6CC0(Data, &v44) )
      {
        v57 = *v45;
        v15 = wcscmp(v57, L"%1");
        if ( v15 )
          v15 = -(v15 < 0) | 1;
        if ( v15 )
        {
          v16 = sub_11F4EE0(&v70, v4, &v44, 0);
          sub_11F2250(&v56, v16);
          free(v70);
          v71 = _wcsdup(L"(Default)");
          v17 = gpszTargetName;
          if ( v5 )
            v17 = v5;
          v18 = _wcsdup(v17);
          v19 = v18;
          v70 = v18;
          v20 = _wcsdup(gpszTargetName);
          v21 = v20;
          v66 = v20;
          v22 = gpszTargetName;
          if ( v5 )
            v22 = v5;
          v23 = _wcsdup(v22);
          v24 = v23;
          v65 = v23;
          v25 = gpszTargetName;
          if ( v57 )
            v25 = v57;
          v72 = _wcsdup(v25);
          v60 = sub_11F7BE0(&v68, v69, &v70, &v71);
          v26 = sub_11F7BE0(&v62, v69, &v65, &v66);
          LOBYTE(v74) = 23;
          v67 = sub_11F3D40(v64, &v72, v26, v60, &v56, &v55, &v54, &v48);
          free(v62);
          free(v68);
          free(v72);
          free(v24);
          free(v21);
          free(v19);
          LOBYTE(v74) = 16;
          free(v71);
          if ( v67 )
          {
            if ( a4 == -1 )
            {
              v61 = _wcsdup(gpszTargetName);
              v58 = _wcsdup(gpszTargetName);
              v59 = _wcsdup(gpszTargetName);
              v63 = _wcsdup(gpszTargetName);
              v68 = _wcsdup(gpszTargetName);
              v71 = _wcsdup(gpszTargetName);
              v72 = _wcsdup(gpszTargetName);
              v27 = v53;
              v28 = gpszTargetName;
              if ( v53 )
                v28 = v53;
              v29 = _wcsdup(v28);
              v30 = v29;
              v70 = v29;
              v31 = _wcsdup(L"(Default)");
              v32 = v31;
              v66 = v31;
              v33 = gpszTargetName;
              if ( v27 )
                v33 = v27;
              v34 = _wcsdup(v33);
              v65 = v34;
              v60 = sub_11F7BE0(&v52, v69, &v70, &v72);
              v35 = sub_11F7BE0(&v62, v69, &v65, &v66);
              LOBYTE(v74) = 35;
              a4 = sub_11F3FF0(v64, 0, 0xFFFFFFFF, 0, v35, v60, &v71);
              free(v62);
              free(v52);
              free(v34);
              free(v32);
              free(v30);
              free(v72);
              free(v71);
              free(v68);
              free(v63);
              free(v59);
              free(v58);
              free(v61);
            }
            v71 = _wcsdup(gpszTargetName);
            v72 = _wcsdup(gpszTargetName);
            v36 = _wcsdup(L"(Default)");
            v37 = v36;
            v52 = v36;
            v38 = gpszTargetName;
            v39 = gpszTargetName;
            if ( v53 )
              v39 = v53;
            v40 = _wcsdup(v39);
            v70 = v40;
            if ( v57 )
              v38 = v57;
            v41 = _wcsdup(v38);
            v66 = v41;
            v42 = sub_11F7BE0(&v65, v69, &v70, &v52);
            LOBYTE(v74) = 41;
            sub_11F3FF0(v64, -1, a4, 12, &v66, v42, &v56);
            free(v65);
            free(v41);
            free(v40);
            free(v37);
            free(v72);
            free(v71);
          }
        }
      }
      sub_11F21F0(&v44);
    }
    RegCloseKey(hKey);
  }
  free(v54);
  free(v49);
  free(v55);
  free(v56);
  return a4;
}

//----- (011F9AB0) --------------------------------------------------------
void __cdecl sub_11F9AB0(int a1, void *a2, void *a3, char a4, char a5)
{
  _WORD *v5; // ST68_4
  void *v6; // esi
  void *v7; // edi
  const wchar_t **v8; // eax
  wchar_t *v9; // ST6C_4

  v5 = malloc(2u);
  *v5 = 0;
  v6 = a3;
  v7 = sub_11F9B70(a1, a2, *a3, a4, a5, 0xFFFFFFFF, 1, 1);
  v8 = sub_11F22B0(&a3, v6, L"\\AutorunsDisabled");
  v9 = _wcsdup(*v8);
  free(v5);
  free(a3);
  sub_11F9B70(a1, a2, v9, a4, a5, v7, 0, 1);
  free(v9);
}

//----- (011F9B70) --------------------------------------------------------
void *__cdecl sub_11F9B70(int a1, void *a2, wchar_t *psz, char a4, char a5, void *a6, char a7, char a8)
{
  wchar_t *v8; // edi
  OLECHAR *v9; // esi
  WCHAR *v10; // eax
  wchar_t *v11; // eax
  wchar_t *v12; // ebx
  wchar_t *v13; // eax
  wchar_t *v14; // edi
  WCHAR *v15; // eax
  wchar_t *v16; // esi
  unsigned __int16 **v17; // eax
  unsigned int v18; // eax
  _WORD *v19; // ebx
  _WORD *v20; // esi
  wchar_t *v21; // edx
  wchar_t *v22; // ecx
  wchar_t v23; // ax
  wchar_t *v24; // esi
  int v25; // eax
  const wchar_t **v26; // eax
  OLECHAR *v27; // esi
  const wchar_t **v28; // eax
  wchar_t *v29; // esi
  OLECHAR *v30; // edi
  unsigned int v31; // eax
  OLECHAR *v32; // esi
  void (__stdcall *v33)(HKEY); // edi
  int v34; // eax
  const wchar_t **v35; // eax
  OLECHAR *v36; // edi
  const wchar_t **v37; // eax
  OLECHAR *v38; // esi
  unsigned int v39; // eax
  int v40; // eax
  OLECHAR *v41; // esi
  OLECHAR *v42; // esi
  unsigned int v43; // eax
  int v44; // eax
  void *v45; // esi
  void *v46; // ebx
  const wchar_t **v47; // eax
  OLECHAR *v48; // esi
  const wchar_t **v49; // eax
  wchar_t *v50; // esi
  int v51; // eax
  const wchar_t **v52; // eax
  OLECHAR *v53; // esi
  const wchar_t **v54; // eax
  wchar_t *v55; // esi
  OLECHAR *v56; // esi
  unsigned int v57; // eax
  const wchar_t **v58; // eax
  const wchar_t **v59; // eax
  unsigned __int16 **v60; // eax
  wchar_t *v61; // esi
  const wchar_t **v62; // eax
  const wchar_t **v63; // eax
  void *v64; // esi
  const wchar_t **v65; // eax
  wchar_t *v66; // eax
  WCHAR *v67; // eax
  wchar_t *v68; // eax
  wchar_t *v69; // ebx
  wchar_t *v70; // eax
  wchar_t *v71; // edi
  WCHAR *v72; // eax
  wchar_t *v73; // esi
  unsigned __int16 **v74; // eax
  WCHAR *v75; // eax
  wchar_t *v76; // eax
  wchar_t *v77; // ebx
  wchar_t *v78; // eax
  wchar_t *v79; // edi
  WCHAR *v80; // eax
  wchar_t *v81; // esi
  unsigned __int16 **v82; // eax
  WCHAR *v83; // eax
  wchar_t *v84; // esi
  unsigned __int16 **v85; // eax
  int v87; // [esp+10h] [ebp-108h]
  int v88; // [esp+14h] [ebp-104h]
  int v89; // [esp+18h] [ebp-100h]
  int v90; // [esp+1Ch] [ebp-FCh]
  void *v91; // [esp+20h] [ebp-F8h]
  int v92; // [esp+24h] [ebp-F4h]
  int v93; // [esp+28h] [ebp-F0h]
  int v94; // [esp+2Ch] [ebp-ECh]
  int v95; // [esp+30h] [ebp-E8h]
  void *v96; // [esp+34h] [ebp-E4h]
  void *v97; // [esp+38h] [ebp-E0h]
  void *v98; // [esp+3Ch] [ebp-DCh]
  void *v99; // [esp+40h] [ebp-D8h]
  void *v100; // [esp+44h] [ebp-D4h]
  int v101; // [esp+48h] [ebp-D0h]
  void *v102; // [esp+4Ch] [ebp-CCh]
  void *v103; // [esp+50h] [ebp-C8h]
  void *v104; // [esp+54h] [ebp-C4h]
  void *v105; // [esp+58h] [ebp-C0h]
  void *v106; // [esp+5Ch] [ebp-BCh]
  void *v107; // [esp+60h] [ebp-B8h]
  void *v108; // [esp+64h] [ebp-B4h]
  int v109; // [esp+68h] [ebp-B0h]
  void *v110; // [esp+6Ch] [ebp-ACh]
  int v111; // [esp+70h] [ebp-A8h]
  void *v112; // [esp+74h] [ebp-A4h]
  void *v113; // [esp+78h] [ebp-A0h]
  void *v114; // [esp+7Ch] [ebp-9Ch]
  void *v115; // [esp+80h] [ebp-98h]
  void *v116; // [esp+84h] [ebp-94h]
  void *v117; // [esp+88h] [ebp-90h]
  void *v118; // [esp+8Ch] [ebp-8Ch]
  void *v119; // [esp+90h] [ebp-88h]
  void *v120; // [esp+94h] [ebp-84h]
  int v121; // [esp+98h] [ebp-80h]
  int v122; // [esp+9Ch] [ebp-7Ch]
  int v123; // [esp+A0h] [ebp-78h]
  int v124; // [esp+A4h] [ebp-74h]
  void *v125; // [esp+A8h] [ebp-70h]
  void *v126; // [esp+ACh] [ebp-6Ch]
  void *v127; // [esp+B0h] [ebp-68h]
  void *v128; // [esp+B4h] [ebp-64h]
  HKEY v129; // [esp+B8h] [ebp-60h]
  DWORD Type; // [esp+BCh] [ebp-5Ch]
  unsigned int v131; // [esp+C0h] [ebp-58h]
  void *v132; // [esp+C4h] [ebp-54h]
  DWORD dwIndex; // [esp+C8h] [ebp-50h]
  void *v134; // [esp+CCh] [ebp-4Ch]
  int v135; // [esp+D0h] [ebp-48h]
  void *v136; // [esp+D4h] [ebp-44h]
  void *v137; // [esp+D8h] [ebp-40h]
  wchar_t *v138; // [esp+DCh] [ebp-3Ch]
  void *v139; // [esp+E0h] [ebp-38h]
  void *v140; // [esp+E4h] [ebp-34h]
  void *v141; // [esp+E8h] [ebp-30h]
  HKEY hKey; // [esp+ECh] [ebp-2Ch]
  void *v143; // [esp+F0h] [ebp-28h]
  void *v144; // [esp+F4h] [ebp-24h]
  void *v145; // [esp+F8h] [ebp-20h]
  char v146; // [esp+FFh] [ebp-19h]
  wchar_t *v147; // [esp+100h] [ebp-18h]
  wchar_t *v148; // [esp+104h] [ebp-14h]
  OLECHAR *v149; // [esp+108h] [ebp-10h]
  int v150; // [esp+114h] [ebp-4h]

  v131 = 0;
  v139 = 0;
  v126 = malloc(2u);
  *v126 = 0;
  v150 = 0;
  v128 = malloc(2u);
  *v128 = 0;
  v125 = malloc(2u);
  *v125 = 0;
  v127 = malloc(2u);
  *v127 = 0;
  v8 = malloc(2u);
  v138 = v8;
  *v8 = 0;
  v9 = psz;
  LOBYTE(v150) = 4;
  if ( a6 == -1 )
  {
    v145 = _wcsdup(gpszTargetName);
    v143 = _wcsdup(gpszTargetName);
    v144 = _wcsdup(gpszTargetName);
    v140 = _wcsdup(gpszTargetName);
    v141 = _wcsdup(gpszTargetName);
    v136 = _wcsdup(gpszTargetName);
    dwIndex = _wcsdup(gpszTargetName);
    v10 = gpszTargetName;
    if ( psz )
      v10 = psz;
    v11 = _wcsdup(v10);
    v12 = v11;
    a6 = v11;
    v13 = _wcsdup(gpszTargetName);
    v14 = v13;
    Type = v13;
    v15 = gpszTargetName;
    if ( psz )
      v15 = psz;
    v16 = _wcsdup(v15);
    v139 = v16;
    v137 = sub_11F7BE0(&v132, a2, &a6, &dwIndex);
    v17 = sub_11F7BE0(&v134, a2, &v139, &Type);
    LOBYTE(v150) = 16;
    a6 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v17, v137, &v136);
    free(v134);
    free(v132);
    free(v16);
    free(v14);
    free(v12);
    free(dwIndex);
    free(v136);
    free(v141);
    free(v140);
    free(v144);
    free(v143);
    LOBYTE(v150) = 4;
    free(v145);
    v8 = v138;
    v9 = psz;
  }
  v18 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, v9, 0, v18 | 0x20019, &v129) )
  {
    dwIndex = 0;
    v148 = malloc(2u);
    *v148 = 0;
    v141 = malloc(2u);
    v143 = v141;
    *v141 = 0;
    v147 = malloc(2u);
    *v147 = 0;
    v149 = malloc(2u);
    *v149 = 0;
    v19 = malloc(2u);
    v136 = v19;
    *v19 = 0;
    v20 = malloc(2u);
    v145 = v20;
    v140 = v20;
    *v20 = 0;
    LOBYTE(v150) = 22;
    if ( !sub_1201450(v129, 0, &v148, 0, &Type, &v147) )
    {
      while ( Type == 1 || Type == 2 || Type == 7 || Type == 3 )
      {
        v21 = v148;
        v22 = v148;
        v137 = v148;
        v139 = v148 + 1;
        do
        {
          v23 = *v22;
          ++v22;
        }
        while ( v23 );
        if ( !((v22 - v139) >> 1) )
        {
          if ( !a8 )
            break;
          v148 = _wcsdup(L"(Default)");
          free(v137);
          v21 = v148;
        }
        v24 = _wcsdup(v21);
        v144 = v24;
        v143 = v24;
        free(v141);
        if ( a5 )
        {
          v25 = sub_120F210(&v107, L"CLSID\\", &v148);
          v26 = sub_11F22B0(&v97, v25, L"\\InprocServer32");
          v27 = v149;
          v149 = _wcsdup(*v26);
          free(v27);
          free(v97);
          free(v107);
          v28 = sub_120F210(&v120, L"HKCR\\CLSID\\", &v148);
          v29 = _wcsdup(*v28);
          v138 = v29;
          free(v8);
          free(v120);
          v30 = v149;
          v31 = TlsGetValue(gdwTlsIndex);
          if ( sub_11F67A0(HKEY_CLASSES_ROOT, v30, 0, v31 | 0x20019, &hKey) )
          {
            v34 = sub_120F210(&v96, L"CLSID\\", &v148);
            v35 = sub_11F22B0(&v118, v34, L"\\Shell\\Open\\Command");
            v36 = v149;
            v149 = _wcsdup(*v35);
            free(v36);
            free(v118);
            free(v96);
            v37 = sub_120F210(&v116, L"HKCR\\CLSID\\", &v148);
            v138 = _wcsdup(*v37);
            free(v29);
            free(v116);
            v38 = v149;
            v39 = TlsGetValue(gdwTlsIndex);
            v40 = sub_11F67A0(HKEY_CLASSES_ROOT, v38, 0, v39 | 0x20019, &hKey);
            v41 = v149;
            if ( v40 )
            {
              v149 = _wcsdup(gpszTargetName);
              free(v41);
              v33 = RegCloseKey;
            }
            else
            {
              v149 = _wcsdup(gpszTargetName);
              free(v41);
              sub_1201520(hKey, gpszTargetName, 0, 0, &v149);
              v33 = RegCloseKey;
              RegCloseKey(hKey);
            }
          }
          else
          {
            v32 = v149;
            v149 = _wcsdup(gpszTargetName);
            free(v32);
            sub_1201520(hKey, gpszTargetName, 0, 0, &v149);
            v33 = RegCloseKey;
            RegCloseKey(hKey);
          }
          if ( wcslen(v147)
            || (v42 = *sub_120F210(&v104, L"CLSID\\", &v148),
                LOBYTE(v150) = 23,
                v131 |= 1u,
                v139 = v131,
                v43 = TlsGetValue(gdwTlsIndex),
                v44 = sub_11F67A0(HKEY_CLASSES_ROOT, v42, 0, v43 | 0x20019, &hKey),
                v146 = 1,
                v44) )
          {
            v146 = 0;
          }
          v150 = 22;
          if ( v131 & 1 )
          {
            v131 &= 0xFFFFFFFE;
            free(v104);
          }
          if ( v146 )
          {
            sub_1201520(hKey, gpszTargetName, 0, 0, &v147);
            v33(hKey);
          }
          v92 = malloc(2u);
          v93 = 0;
          v94 = 0;
          *v92 = 0;
          v95 = 0;
          LOBYTE(v150) = 24;
          if ( sub_11F6CC0(v149, &v92) )
          {
            v45 = v144;
            v46 = _wcsdup(v147);
            v143 = v46;
            free(v45);
            v47 = sub_11F4890(&v114, v149);
            v48 = v149;
            v149 = _wcsdup(*v47);
            free(v48);
            free(v114);
            v49 = sub_11F4EE0(&v98, a1, &v92, 0);
            v50 = _wcsdup(*v49);
            v140 = v50;
            free(v145);
            free(v98);
            sub_11F21F0(&v92);
            goto LABEL_46;
          }
          sub_11F21F0(&v92);
          free(v145);
          free(v19);
          free(v149);
          free(v147);
          free(v144);
LABEL_66:
          free(v148);
          v8 = v138;
          goto LABEL_67;
        }
        if ( a4 )
        {
          v87 = malloc(2u);
          v88 = 0;
          v89 = 0;
          *v87 = 0;
          v90 = 0;
          LOBYTE(v150) = 26;
          if ( sub_11F6CC0(v147, &v87) )
          {
            v138 = _wcsdup(v147);
            free(v8);
            v63 = sub_11F4890(&v119, v147);
            v64 = v126;
            v126 = _wcsdup(*v63);
            free(v64);
            free(v119);
            v65 = sub_11F4EE0(&v117, a1, &v87, 0);
            v50 = _wcsdup(*v65);
            v140 = v50;
            free(v145);
            free(v117);
            sub_11F21F0(&v87);
LABEL_45:
            v46 = v144;
LABEL_46:
            if ( !wcslen(v46) && wcslen(v50) )
            {
              if ( wcsrchr(v50, 0x5Cu) )
              {
                v66 = wcsrchr(v50, 0x5Cu);
                v143 = _wcsdup(v66 + 1);
                free(v46);
              }
              else
              {
                v143 = _wcsdup(v50);
                free(v46);
              }
            }
            v67 = gpszTargetName;
            if ( psz )
              v67 = psz;
            v68 = _wcsdup(v67);
            v69 = v68;
            v139 = v68;
            v70 = _wcsdup(gpszTargetName);
            v71 = v70;
            v137 = v70;
            v72 = gpszTargetName;
            if ( psz )
              v72 = psz;
            v73 = _wcsdup(v72);
            v134 = v73;
            v132 = sub_11F7BE0(&v113, a2, &v139, &v148);
            v74 = sub_11F7BE0(&v115, a2, &v134, &v137);
            LOBYTE(v150) = 31;
            v146 = sub_11F3D40(a1, &v143, v74, v132, &v140, &v128, &v127, &v101);
            free(v115);
            free(v113);
            free(v73);
            free(v71);
            free(v69);
            if ( v146 )
            {
              if ( a6 == -1 )
              {
                v139 = _wcsdup(gpszTargetName);
                v137 = _wcsdup(gpszTargetName);
                v134 = _wcsdup(gpszTargetName);
                v132 = _wcsdup(gpszTargetName);
                v145 = _wcsdup(gpszTargetName);
                v144 = _wcsdup(gpszTargetName);
                v141 = _wcsdup(gpszTargetName);
                v75 = gpszTargetName;
                if ( psz )
                  v75 = psz;
                v76 = _wcsdup(v75);
                v77 = v76;
                a6 = v76;
                v78 = _wcsdup(gpszTargetName);
                v79 = v78;
                v111 = v78;
                v80 = gpszTargetName;
                if ( psz )
                  v80 = psz;
                v81 = _wcsdup(v80);
                v109 = v81;
                v135 = sub_11F7BE0(&v103, a2, &a6, &v141);
                v82 = sub_11F7BE0(&v105, a2, &v109, &v111);
                LOBYTE(v150) = 43;
                a6 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v82, v135, &v144);
                free(v105);
                free(v103);
                free(v81);
                free(v79);
                free(v77);
                free(v141);
                free(v144);
                free(v145);
                free(v132);
                free(v134);
                free(v137);
                free(v139);
              }
              v83 = gpszTargetName;
              if ( psz )
                v83 = psz;
              v84 = _wcsdup(v83);
              v135 = v84;
              v85 = sub_11F7BE0(&v99, a2, &v135, &v148);
              LOBYTE(v150) = 45;
              sub_11F3FF0(a1, -1, a6, 1, &v143, v85, &v140);
              free(v99);
              free(v84);
            }
            free(v140);
            free(v136);
            free(v149);
            free(v147);
            free(v143);
            goto LABEL_66;
          }
          sub_11F21F0(&v87);
          free(v145);
          free(v19);
          free(v149);
          free(v147);
          free(v24);
          free(v148);
        }
        else
        {
          v51 = sub_120F210(&v102, L"CLSID\\", &v147);
          v52 = sub_11F22B0(&v112, v51, L"\\InprocServer32");
          v53 = v149;
          v149 = _wcsdup(*v52);
          free(v53);
          free(v112);
          free(v102);
          v54 = sub_120F210(&v110, L"HKCR\\CLSID\\", &v147);
          v55 = v8;
          v8 = _wcsdup(*v54);
          v138 = v8;
          free(v55);
          free(v110);
          v56 = v149;
          v57 = TlsGetValue(gdwTlsIndex);
          if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v56, 0, v57 | 0x20019, &hKey)
            && !sub_1201520(hKey, gpszTargetName, 0, 0, &v149) )
          {
            v121 = malloc(2u);
            v122 = 0;
            v123 = 0;
            *v121 = 0;
            v124 = 0;
            LOBYTE(v150) = 25;
            if ( sub_11F6CC0(v149, &v121) )
            {
              v58 = sub_11F4EE0(&v91, a1, &v121, 0);
              v136 = _wcsdup(*v58);
              free(v19);
              free(v91);
              v59 = sub_11F22B0(&v100, &v148, L" -> ");
              v60 = sub_1203070(&v108, v59, &v136);
              v61 = v147;
              v147 = _wcsdup(*v60);
              free(v61);
              free(v108);
              free(v100);
              v62 = sub_11F4EE0(&v106, a1, &v121, 0);
              v50 = _wcsdup(*v62);
              v140 = v50;
              free(v145);
              free(v106);
              sub_11F21F0(&v121);
              RegCloseKey(hKey);
              goto LABEL_45;
            }
            sub_11F21F0(&v121);
          }
          free(v145);
          free(v19);
          free(v149);
          free(v147);
          free(v144);
          free(v148);
        }
LABEL_67:
        ++dwIndex;
        v148 = malloc(2u);
        *v148 = 0;
        v141 = malloc(2u);
        v143 = v141;
        *v141 = 0;
        v147 = malloc(2u);
        *v147 = 0;
        v149 = malloc(2u);
        *v149 = 0;
        v19 = malloc(2u);
        v136 = v19;
        *v19 = 0;
        v20 = malloc(2u);
        v145 = v20;
        v140 = v20;
        *v20 = 0;
        LOBYTE(v150) = 22;
        if ( sub_1201450(v129, dwIndex, &v148, 0, &Type, &v147) )
          goto LABEL_68;
      }
      free(v20);
      free(v19);
      free(v149);
      free(v147);
      free(v141);
      free(v148);
      goto LABEL_67;
    }
LABEL_68:
    free(v20);
    free(v19);
    free(v149);
    free(v147);
    free(v141);
    free(v148);
    RegCloseKey(v129);
  }
  free(v8);
  free(v127);
  free(v125);
  free(v128);
  free(v126);
  return a6;
}

//----- (011FAA30) --------------------------------------------------------
void __cdecl sub_11FAA30(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, int a5)
{
  wchar_t *v5; // esi
  void *v6; // eax
  WCHAR *v7; // ecx
  void *v8; // ebx
  wchar_t *v9; // edi
  const wchar_t **v10; // eax
  wchar_t *v11; // esi
  void *v12; // [esp+10h] [ebp-18h]
  void *v13; // [esp+14h] [ebp-14h]
  void *v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+24h] [ebp-4h]

  v13 = malloc(2u);
  v14 = v13;
  *v13 = 0;
  v5 = psz;
  v15 = 0;
  v6 = sub_11FAB10(a1, a2, psz, lpValueName, a5, 0xFFFFFFFF);
  v7 = gpszTargetName;
  v8 = v6;
  if ( v5 )
    v7 = v5;
  v9 = _wcsdup(v7);
  psz = v9;
  v10 = sub_11F22B0(&v12, &psz, L"\\AutorunsDisabled");
  v11 = _wcsdup(*v10);
  v14 = v11;
  free(v13);
  free(v12);
  free(v9);
  sub_11FAB10(a1, a2, v11, lpValueName, a5, v8);
  free(v11);
}

//----- (011FAB10) --------------------------------------------------------
void *__cdecl sub_11FAB10(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, int a5, void *a6)
{
  _WORD *v6; // edi
  const WCHAR *v7; // esi
  OLECHAR *v8; // ebx
  WCHAR *v9; // eax
  wchar_t *v10; // eax
  wchar_t *v11; // ebx
  const wchar_t *v12; // eax
  wchar_t *v13; // eax
  wchar_t *v14; // edi
  WCHAR *v15; // eax
  wchar_t *v16; // esi
  unsigned __int16 **v17; // eax
  unsigned int v18; // eax
  wchar_t *v19; // edx
  wchar_t v20; // cx
  int v21; // edx
  void *v22; // ecx
  const wchar_t ***v23; // edi
  _WORD *v24; // eax
  const wchar_t **v25; // eax
  const wchar_t **v26; // eax
  WCHAR *v27; // eax
  WCHAR *v28; // eax
  wchar_t *v29; // eax
  wchar_t *v30; // ebx
  WCHAR *v31; // eax
  wchar_t *v32; // eax
  wchar_t *v33; // edi
  WCHAR *v34; // eax
  wchar_t *v35; // esi
  unsigned __int16 **v36; // eax
  WCHAR *v37; // eax
  wchar_t *v38; // eax
  wchar_t *v39; // ebx
  const wchar_t *v40; // eax
  wchar_t *v41; // eax
  wchar_t *v42; // edi
  WCHAR *v43; // eax
  wchar_t *v44; // esi
  unsigned __int16 **v45; // eax
  const wchar_t *v46; // eax
  wchar_t *v47; // eax
  wchar_t *v48; // ebx
  const wchar_t *v49; // eax
  wchar_t *v50; // eax
  wchar_t *v51; // edi
  WCHAR *v52; // eax
  wchar_t *v53; // esi
  unsigned __int16 **v54; // eax
  bool v55; // zf
  int v57; // [esp+10h] [ebp-94h]
  int v58; // [esp+14h] [ebp-90h]
  int v59; // [esp+18h] [ebp-8Ch]
  int v60; // [esp+1Ch] [ebp-88h]
  int v61; // [esp+20h] [ebp-84h]
  void *v62; // [esp+24h] [ebp-80h]
  void *v63; // [esp+28h] [ebp-7Ch]
  void *v64; // [esp+2Ch] [ebp-78h]
  void *v65; // [esp+30h] [ebp-74h]
  void *v66; // [esp+34h] [ebp-70h]
  void *v67; // [esp+38h] [ebp-6Ch]
  int v68; // [esp+3Ch] [ebp-68h]
  int v69; // [esp+40h] [ebp-64h]
  HKEY hKey; // [esp+44h] [ebp-60h]
  void *v71; // [esp+48h] [ebp-5Ch]
  void *v72; // [esp+4Ch] [ebp-58h]
  void *v73; // [esp+50h] [ebp-54h]
  int v74; // [esp+54h] [ebp-50h]
  int v75; // [esp+58h] [ebp-4Ch]
  void *v76; // [esp+5Ch] [ebp-48h]
  void *v77; // [esp+60h] [ebp-44h]
  int v78; // [esp+64h] [ebp-40h]
  void *v79; // [esp+68h] [ebp-3Ch]
  void *v80; // [esp+6Ch] [ebp-38h]
  void *v81; // [esp+70h] [ebp-34h]
  int v82; // [esp+74h] [ebp-30h]
  void *v83; // [esp+78h] [ebp-2Ch]
  wchar_t *v84; // [esp+7Ch] [ebp-28h]
  int v85; // [esp+80h] [ebp-24h]
  void *v86; // [esp+84h] [ebp-20h]
  void *v87; // [esp+88h] [ebp-1Ch]
  void *v88; // [esp+8Ch] [ebp-18h]
  void *v89; // [esp+90h] [ebp-14h]
  char v90; // [esp+97h] [ebp-Dh]
  int v91; // [esp+A0h] [ebp-4h]

  v83 = malloc(2u);
  v78 = v83;
  *v83 = 0;
  v91 = 0;
  v6 = malloc(2u);
  v81 = v6;
  v82 = v6;
  *v6 = 0;
  v72 = malloc(2u);
  *v72 = 0;
  v71 = malloc(2u);
  *v71 = 0;
  v73 = malloc(2u);
  *v73 = 0;
  v7 = lpValueName;
  v8 = psz;
  LOBYTE(v91) = 4;
  if ( a6 == -1 )
  {
    v89 = _wcsdup(gpszTargetName);
    v86 = _wcsdup(gpszTargetName);
    v88 = _wcsdup(gpszTargetName);
    v79 = _wcsdup(gpszTargetName);
    v80 = _wcsdup(gpszTargetName);
    v76 = _wcsdup(gpszTargetName);
    v84 = _wcsdup(gpszTargetName);
    v9 = gpszTargetName;
    if ( psz )
      v9 = psz;
    v10 = _wcsdup(v9);
    v11 = v10;
    a6 = v10;
    v12 = gpszTargetName;
    if ( lpValueName )
      v12 = lpValueName;
    v13 = _wcsdup(v12);
    v14 = v13;
    v74 = v13;
    v15 = gpszTargetName;
    if ( psz )
      v15 = psz;
    v16 = _wcsdup(v15);
    v75 = v16;
    v85 = sub_11F7BE0(&v77, a2, &a6, &v84);
    v17 = sub_11F7BE0(&v87, a2, &v75, &v74);
    LOBYTE(v91) = 16;
    a6 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v17, v85, &v76);
    free(v87);
    free(v77);
    free(v16);
    free(v14);
    free(v11);
    free(v84);
    free(v76);
    free(v80);
    free(v79);
    free(v88);
    free(v86);
    LOBYTE(v91) = 4;
    free(v89);
    v7 = lpValueName;
    v8 = psz;
    v6 = v81;
  }
  v18 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, v8, 0, v18 | 0x20019, &hKey) )
  {
    v84 = malloc(2u);
    *v84 = 0;
    LOBYTE(v91) = 17;
    if ( !sub_1201520(hKey, v7, 0, 0, &v84) )
    {
      v19 = v84;
      v77 = v84 + 1;
      do
      {
        v20 = *v19;
        ++v19;
      }
      while ( v20 );
      if ( (v19 - v77) >> 1 )
      {
        v67 = 0;
        v68 = 0;
        v69 = 0;
        LOBYTE(v91) = 18;
        sub_11F6DD0(v84, a5, &v67, 0);
        v21 = v68;
        v22 = v67;
        v74 = (v68 - v67) >> 4;
        if ( v74 )
        {
          v23 = (v67 + 4);
          v75 = v67 + 4;
          while ( 1 )
          {
            v82 = _wcsdup(**v23);
            free(v81);
            v24 = malloc(2u);
            v57 = v24;
            v58 = 0;
            v59 = 0;
            *v24 = 0;
            v60 = 0;
            v25 = *v23;
            LOBYTE(v91) = 19;
            sub_11F6CC0(*v25, &v57);
            v26 = sub_11F4EE0(&v77, a1, &v57, 0);
            v78 = _wcsdup(*v26);
            free(v83);
            free(v77);
            v27 = gpszTargetName;
            if ( v7 )
              v27 = v7;
            v89 = _wcsdup(v27);
            v28 = gpszTargetName;
            if ( v8 )
              v28 = v8;
            v29 = _wcsdup(v28);
            v30 = v29;
            v87 = v29;
            v31 = gpszTargetName;
            if ( v7 )
              v31 = v7;
            v32 = _wcsdup(v31);
            v33 = v32;
            v85 = v32;
            v34 = gpszTargetName;
            if ( psz )
              v34 = psz;
            v35 = _wcsdup(v34);
            v86 = v35;
            v88 = sub_11F7BE0(&v65, a2, &v87, &v89);
            v36 = sub_11F7BE0(&v64, a2, &v86, &v85);
            LOBYTE(v91) = 25;
            v90 = sub_11F3D40(a1, v36, v88, &v82, &v78, &v72, &v73, &v61);
            free(v64);
            free(v65);
            free(v35);
            free(v33);
            free(v30);
            free(v89);
            if ( v90 )
            {
              if ( a6 == -1 )
              {
                v81 = _wcsdup(gpszTargetName);
                v76 = _wcsdup(gpszTargetName);
                v80 = _wcsdup(gpszTargetName);
                v79 = _wcsdup(gpszTargetName);
                v88 = _wcsdup(gpszTargetName);
                v86 = _wcsdup(gpszTargetName);
                v89 = _wcsdup(gpszTargetName);
                v37 = gpszTargetName;
                if ( psz )
                  v37 = psz;
                v38 = _wcsdup(v37);
                v39 = v38;
                a6 = v38;
                v40 = gpszTargetName;
                if ( lpValueName )
                  v40 = lpValueName;
                v41 = _wcsdup(v40);
                v42 = v41;
                v87 = v41;
                v43 = gpszTargetName;
                if ( psz )
                  v43 = psz;
                v44 = _wcsdup(v43);
                v85 = v44;
                v83 = sub_11F7BE0(&v63, a2, &a6, &v89);
                v45 = sub_11F7BE0(&v62, a2, &v85, &v87);
                LOBYTE(v91) = 37;
                a6 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v45, v83, &v86);
                free(v62);
                free(v63);
                free(v44);
                free(v42);
                free(v39);
                free(v89);
                free(v86);
                free(v88);
                free(v79);
                free(v80);
                free(v76);
                free(v81);
              }
              v46 = gpszTargetName;
              if ( lpValueName )
                v46 = lpValueName;
              v47 = _wcsdup(v46);
              v48 = v47;
              v89 = v47;
              v49 = gpszTargetName;
              if ( lpValueName )
                v49 = lpValueName;
              v50 = _wcsdup(v49);
              v51 = v50;
              v87 = v50;
              v52 = gpszTargetName;
              if ( psz )
                v52 = psz;
              v53 = _wcsdup(v52);
              v85 = v53;
              v54 = sub_11F7BE0(&v66, a2, &v85, &v87);
              LOBYTE(v91) = 41;
              sub_11F3FF0(a1, -1, a6, 1, &v82, v54, &v78);
              free(v66);
              free(v53);
              free(v51);
              free(v48);
            }
            LOBYTE(v91) = 18;
            sub_11F21F0(&v57);
            v23 = (v75 + 16);
            v55 = v74-- == 1;
            v75 += 16;
            v83 = v78;
            if ( v55 )
              break;
            v7 = lpValueName;
            v8 = psz;
            v81 = v82;
          }
          v6 = v82;
          v22 = v67;
          v21 = v68;
        }
        if ( v22 )
        {
          sub_11F2BF0(v22, v21);
          j__free(v67);
        }
      }
    }
    RegCloseKey(hKey);
    free(v84);
  }
  free(v73);
  free(v71);
  free(v72);
  free(v6);
  free(v83);
  return a6;
}

//----- (011FB220) --------------------------------------------------------
void __cdecl sub_11FB220(void *a1, LPCTSTR a2)
{
  LPCTSTR v2; // edi
  unsigned __int8 (__stdcall *v3)(); // esi
  DWORD v4; // eax
  unsigned int v5; // eax
  wchar_t *v6; // esi
  wchar_t *v7; // esi
  wchar_t *v8; // esi
  wchar_t *v9; // esi
  char v10; // al
  wchar_t *v11; // esi
  wchar_t *v12; // esi
  wchar_t *v13; // esi
  wchar_t *v14; // esi
  unsigned int v15; // esi
  OLECHAR *v16; // eax
  OLECHAR *v17; // eax
  OLECHAR *v18; // eax
  OLECHAR *v19; // eax
  const CHAR *v20; // esi
  wchar_t *v21; // esi
  wchar_t *v22; // esi
  wchar_t *v23; // esi
  wchar_t *v24; // esi
  wchar_t *v25; // esi
  wchar_t *v26; // esi
  wchar_t *v27; // esi
  wchar_t *v28; // esi
  wchar_t *v29; // esi
  wchar_t *v30; // esi
  wchar_t *v31; // esi
  wchar_t *v32; // esi
  wchar_t *v33; // esi
  wchar_t *v34; // esi
  wchar_t *v35; // esi
  wchar_t *v36; // esi
  wchar_t *v37; // esi
  wchar_t *v38; // esi
  wchar_t *v39; // esi
  wchar_t *v40; // esi
  wchar_t *v41; // esi
  wchar_t *v42; // esi
  wchar_t *v43; // esi
  wchar_t *v44; // esi
  wchar_t *v45; // esi
  wchar_t *v46; // esi
  wchar_t *v47; // esi
  wchar_t *v48; // esi
  wchar_t *v49; // esi
  wchar_t *v50; // esi
  wchar_t *v51; // esi
  wchar_t *v52; // esi
  wchar_t *v53; // esi
  wchar_t *v54; // esi
  wchar_t *v55; // esi
  wchar_t *v56; // esi
  wchar_t *v57; // esi
  wchar_t *v58; // esi
  wchar_t *v59; // esi
  char v60; // al
  wchar_t *v61; // esi
  wchar_t *v62; // esi
  wchar_t *v63; // esi
  wchar_t *v64; // esi
  wchar_t *v65; // esi
  wchar_t *v66; // esi
  wchar_t *v67; // esi
  wchar_t *v68; // esi
  wchar_t *v69; // esi
  wchar_t *v70; // esi
  wchar_t *v71; // esi
  wchar_t *v72; // esi
  wchar_t *v73; // esi
  wchar_t *v74; // esi
  wchar_t *v75; // esi
  wchar_t *v76; // esi
  wchar_t *v77; // esi
  wchar_t *v78; // esi
  wchar_t *v79; // esi
  wchar_t *v80; // esi
  BYTE Data[4]; // [esp+10h] [ebp-1Ch]
  DWORD cbData; // [esp+14h] [ebp-18h]
  HKEY hKey; // [esp+18h] [ebp-14h]
  DWORD Type; // [esp+1Ch] [ebp-10h]
  int v85; // [esp+28h] [ebp-4h]

  v2 = a2;
  dword_12E31C0 = a2;
  SetErrorMode(1u);
  if ( Wow64EnableWow64FsRedirection )
  {
    Wow64EnableWow64FsRedirection(0);
    TlsSetValue(gdwTlsIndex, 0x100);
  }
  v3 = GetVersion;
  if ( a1 & 0x100 )
  {
    dword_12E48D8 = 256;
    if ( v2 == 2 || v2 == 1 )
      sub_12005A0(0, ghKLM, L"System\\CurrentControlSet\\Control\\Session Manager", L"BootExecute");
    if ( v2 == 2 || v2 == 1 )
      sub_12005A0(0, ghKLM, L"System\\CurrentControlSet\\Control\\Session Manager", L"SetupExecute");
    if ( v2 == 2 || v2 == 1 )
      sub_12005A0(0, ghKLM, L"System\\CurrentControlSet\\Control\\Session Manager", L"Execute");
    if ( v2 == 2 || v2 == 1 )
      sub_12005A0(0, ghKLM, L"System\\CurrentControlSet\\Control\\Session Manager", L"S0InitialCommand");
    if ( GetVersion() >= 6u )
    {
      v4 = GetVersion();
      if ( BYTE1(v4) >= 1u && (v2 == 2 || v2 == 1) )
        sub_11FAA30(0, ghKLM, L"System\\CurrentControlSet\\Control", L"ServiceControlManagerExtension", 32);
    }
  }
  v5 = a1;
  if ( a1 & 0x40000 )
  {
    dword_12E48D8 = 0x40000;
    sub_120D790(0);
    v5 = a1;
  }
  if ( v5 & 0x80000 )
  {
    dword_12E48D8 = 0x80000;
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Outlook\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Outlook\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Outlook\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Outlook\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Excel\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Excel\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Excel\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Excel\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\PowerPoint\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\PowerPoint\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\PowerPoint\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\PowerPoint\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Word\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Word\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Word\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Word\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Access\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Microsoft\\Office\\Access\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Access\\Addins");
      sub_1207FE0(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
    if ( v2 == 2 || !v2 )
    {
      a2 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Office\\Access\\Addins");
      sub_1207FE0(0, ghKCU, &a2);
      v85 = -1;
      free(a2);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    LOWORD(v5) = a1;
  }
  if ( v5 & 0x200 )
  {
    dword_12E48D8 = 512;
    if ( v2 == 2 || v2 == 1 )
      sub_1204E10(0, ghKLM, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_1204E10(
        0,
        ghKLM,
        L"Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"Software\\Microsoft\\Command Processor", L"Autorun", 44);
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"Software\\Wow6432Node\\Microsoft\\Command Processor", L"Autorun", 44);
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"Software\\Microsoft\\Command Processor", L"Autorun", 44);
    if ( v2 == 2 || !v2 )
    {
      v6 = _wcsdup(L"SOFTWARE\\Classes\\Exefile\\Shell\\Open\\Command");
      a2 = v6;
      sub_11F91C0(0, ghKCU, &a2);
      v85 = -1;
      free(v6);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v7 = _wcsdup(L"SOFTWARE\\Classes\\Exefile\\Shell\\Open\\Command");
      a2 = v7;
      sub_11F91C0(0, ghKLM, &a2);
      v85 = -1;
      free(v7);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_1205E10(0, ghKLM, L"Software\\Classes\\.exe");
    if ( v2 == 2 || !v2 )
      sub_1205E10(0, ghKCU, L"Software\\Classes\\.exe");
    if ( v2 == 2 || v2 == 1 )
      sub_1205E10(0, ghKLM, L"Software\\Classes\\.cmd");
    if ( v2 == 2 || !v2 )
      sub_1205E10(0, ghKCU, L"Software\\Classes\\.cmd");
    if ( v2 == 2 || !v2 )
    {
      v8 = _wcsdup(L"SOFTWARE\\Classes\\Htmlfile\\Shell\\Open\\Command");
      a2 = v8;
      sub_11F91C0(0, ghKCU, &a2);
      v85 = -1;
      free(v8);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v9 = _wcsdup(L"SOFTWARE\\Classes\\Htmlfile\\Shell\\Open\\Command");
      a2 = v9;
      sub_11F91C0(0, ghKLM, &a2);
      v85 = -1;
      free(v9);
    }
    LOWORD(v5) = a1;
    v3 = GetVersion;
  }
  cbData = v5 & 0x1000;
  if ( v5 & 0x1000 )
  {
    dword_12E48D8 = 4096;
    if ( v3() < 6u )
    {
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(
          0,
          ghKLM,
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
          L"ServiceControllerStart",
          32);
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"LsaStart", 32);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SYSTEM\\Setup", L"CmdLine", 44);
  }
  v10 = a1;
  if ( a1 & 0x20000 )
  {
    dword_12E48D8 = 0x20000;
    if ( v2 == 2 || v2 == 1 )
    {
      sub_1215D10(0);
      v10 = a1;
    }
  }
  if ( v10 & 0x20 )
  {
    dword_12E48D8 = 32;
    if ( v2 == 2 || v2 == 1 )
    {
      sub_1209580(0, ghKLM, L"System\\CurrentControlSet\\Services");
      v10 = a1;
    }
  }
  if ( v10 & 0x40 )
  {
    dword_12E48D8 = 64;
    if ( v2 == 2 || v2 == 1 )
      sub_1201610(0, ghKLM, L"System\\CurrentControlSet\\Services");
    if ( v2 == 2 || v2 == 1 )
    {
      v11 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Font Drivers");
      a2 = v11;
      sub_11F9AB0(0, ghKLM, &a2, 1, 0);
      v85 = -1;
      free(v11);
    }
  }
  if ( cbData )
  {
    dword_12E48D8 = 4096;
    if ( GetVersion() < 6u )
    {
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"GinaDLL", 44);
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"UIHost", 44);
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"System", 44);
      if ( v2 == 2 || v2 == 1 )
      {
        a2 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify");
        sub_1212060(0, ghKLM, &a2);
        v85 = -1;
        free(a2);
      }
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"SaveDumpStart", 32);
    }
    else
    {
      if ( v2 == 2 || v2 == 1 )
      {
        v12 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\Credential Providers");
        a2 = v12;
        sub_11F86F0(0, ghKLM, &a2);
        v85 = -1;
        free(v12);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v13 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\Credential Provider Filters");
        a2 = v13;
        sub_11F86F0(0, ghKLM, &a2);
        v85 = -1;
        free(v13);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v14 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\PLAP Providers");
        a2 = v14;
        sub_11F86F0(0, ghKLM, &a2);
        v85 = -1;
        free(v14);
      }
    }
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"Taskman", 32);
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"SOFTWARE\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop", L"Scrnsave.exe", 44);
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"Control Panel\\Desktop", L"Scrnsave.exe", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"System\\CurrentControlSet\\Control\\BootVerificationProgram", L"ImagePath", 44);
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GpExtensions");
      sub_1212060(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
  }
  v15 = a1;
  if ( a1 & 0x4000 )
  {
    dword_12E48D8 = 0x4000;
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors");
      sub_1208A90(0, ghKLM, &a2, 1);
      v85 = -1;
      free(a2);
    }
  }
  if ( v15 & 0x8000 )
  {
    dword_12E48D8 = 0x8000;
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\SecurityProviders", L"SecurityProviders", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_1206E10(0, ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\Lsa", L"Authentication Packages");
    if ( v2 == 2 || v2 == 1 )
      sub_1206E10(0, ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\Lsa", L"Notification Packages");
    if ( v2 == 2 || v2 == 1 )
      sub_1206E10(0, ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\Lsa", L"Security Packages");
    if ( v2 == 2 || v2 == 1 )
      sub_1206E10(0, ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig", L"Security Packages");
  }
  if ( v15 & 0x10000 )
  {
    dword_12E48D8 = 0x10000;
    if ( v2 == 2 || v2 == 1 )
    {
      a2 = _wcsdup(L"SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
      sub_1207710(0, ghKLM, &a2);
      v85 = -1;
      free(a2);
    }
  }
  if ( v15 & 0x2000 )
  {
    dword_12E48D8 = 0x10000;
    if ( v2 == 2 || v2 == 1 )
    {
      v16 = _wcsdup(L"System\\CurrentControlSet\\Services\\WinSock2\\Parameters\\Protocol_Catalog9\\Catalog_Entries");
      sub_1213190(0, v16);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v17 = _wcsdup(L"System\\CurrentControlSet\\Services\\WinSock2\\Parameters\\NameSpace_Catalog5\\Catalog_Entries");
      sub_12127D0(0, v17);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v18 = _wcsdup(L"System\\CurrentControlSet\\Services\\WinSock2\\Parameters\\Protocol_Catalog9\\Catalog_Entries64");
      sub_1213190(0, v18);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v19 = _wcsdup(L"System\\CurrentControlSet\\Services\\WinSock2\\Parameters\\NameSpace_Catalog5\\Catalog_Entries64");
      sub_12127D0(0, v19);
    }
    LOBYTE(v15) = a1;
  }
  v20 = (v15 & 2);
  a2 = v20;
  if ( v20 && IsWinServer() )
  {
    dword_12E48D8 = 2;
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"System\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd", L"StartupPrograms", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"AppSetup", 44);
  }
  if ( v20 )
  {
    dword_12E48D8 = 2;
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Startup");
      v85 = 32;
      sub_1202060(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || !v2 )
    {
      Type = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logon");
      v85 = 33;
      sub_1202060(0, ghKCU, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logon");
      v85 = 34;
      sub_1202060(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"Userinit", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"VmApplet", 0);
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Shutdown");
      v85 = 35;
      sub_1202060(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || !v2 )
    {
      Type = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logoff");
      v85 = 36;
      sub_1202060(0, ghKCU, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logoff");
      v85 = 37;
      sub_1202060(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup");
      v85 = 38;
      sub_1202060(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Shutdown");
      v85 = 39;
      sub_1202060(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
  }
  if ( a1 & 0x400 )
  {
    dword_12E48D8 = 1024;
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows");
      v85 = 40;
      sub_11F2CB0(0, ghKLM, &Type, L"Appinit_Dlls");
      v85 = -1;
      free(Type);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows");
      v85 = 41;
      sub_11F2CB0(0, ghKLM, &Type, L"Appinit_Dlls");
      v85 = -1;
      free(Type);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v21 = _wcsdup(L"System\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls");
      cbData = v21;
      v85 = 42;
      sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v21);
      v20 = a2;
    }
  }
  if ( v20 )
  {
    dword_12E48D8 = 2;
    if ( (GetVersion() & 0x80000000) != 0 )
    {
      if ( v2 == 2 || v2 == 1 )
      {
        v22 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices");
        cbData = v22;
        v85 = 43;
        sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
        v85 = -1;
        free(v22);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v23 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce");
        cbData = v23;
        v85 = 44;
        sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
        v85 = -1;
        free(v23);
      }
      if ( v2 == 2 || !v2 )
      {
        v24 = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServices");
        cbData = v24;
        v85 = 45;
        sub_11F9AB0(0, ghKCU, &cbData, 1, 0);
        v85 = -1;
        free(v24);
      }
      if ( v2 == 2 || !v2 )
      {
        v25 = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce");
        cbData = v25;
        v85 = 46;
        sub_11F9AB0(0, ghKCU, &cbData, 1, 0);
        v85 = -1;
        free(v25);
      }
    }
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", L"Shell", 44);
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"Shell", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", L"Shell", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"Shell", 44);
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"Taskman", 32);
    if ( !sub_11F67A0(ghKLM, L"System\\CurrentControlSet\\Control\\SafeBoot\\Option", 0, 131097, &hKey) )
    {
      cbData = 4;
      Type = 4;
      if ( !RegQueryValueExW(hKey, L"UseAlternateShell", 0, &Type, Data, &cbData) && (v2 == 2 || v2 == 1) )
        sub_11FAA30(0, ghKLM, L"System\\CurrentControlSet\\Control\\SafeBoot", L"AlternateShell", 44);
      RegCloseKey(hKey);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v26 = _wcsdup(L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AlternateShells\\AvailableShells");
      cbData = v26;
      v85 = 47;
      sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v26);
    }
    if ( IsWinServer() )
    {
      if ( v2 == 2 || v2 == 1 )
      {
        v27 = _wcsdup(
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Microsoft\\Windows\\"
                 "CurrentVersion\\Runonce");
        cbData = v27;
        v85 = 48;
        sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
        v85 = -1;
        free(v27);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v28 = _wcsdup(
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Microsoft\\Windows\\"
                 "CurrentVersion\\RunonceEx");
        cbData = v28;
        v85 = 49;
        sub_11FF2D0(0, ghKLM, &cbData, 1, 0);
        v85 = -1;
        free(v28);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v29 = _wcsdup(
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Microsoft\\Windows\\"
                 "CurrentVersion\\Run");
        cbData = v29;
        v85 = 50;
        sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
        v85 = -1;
        free(v29);
      }
      if ( v2 == 2 || v2 == 1 )
        sub_11FAA30(
          0,
          ghKLM,
          L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp",
          L"InitialProgram",
          44);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v30 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
      cbData = v30;
      v85 = 51;
      sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v30);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v31 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run");
      cbData = v31;
      v85 = 52;
      sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v31);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      v32 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
      cbData = v32;
      v85 = 53;
      sub_11F9AB0(0, ghKCU, &cbData, 1, 0);
      v85 = -1;
      free(v32);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || !v2 )
    {
      v33 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run");
      cbData = v33;
      v85 = 54;
      sub_11F9AB0(0, ghKCU, &cbData, 1, 0);
      v85 = -1;
      free(v33);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v34 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx");
      cbData = v34;
      v85 = 55;
      sub_11FF2D0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v34);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v35 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx");
      cbData = v35;
      v85 = 56;
      sub_11FF2D0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v35);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      v36 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx");
      cbData = v36;
      v85 = 57;
      sub_11FF2D0(0, ghKCU, &cbData, 1, 0);
      v85 = -1;
      free(v36);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || !v2 )
    {
      v37 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx");
      cbData = v37;
      v85 = 58;
      sub_11FF2D0(0, ghKCU, &cbData, 1, 0);
      v85 = -1;
      free(v37);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v38 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
      cbData = v38;
      v85 = 59;
      sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v38);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v39 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
      cbData = v39;
      v85 = 60;
      sub_11F9AB0(0, ghKLM, &cbData, 1, 0);
      v85 = -1;
      free(v39);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      v40 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
      cbData = v40;
      v85 = 61;
      sub_11F9AB0(0, ghKCU, &cbData, 1, 0);
      v85 = -1;
      free(v40);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || !v2 )
    {
      v41 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
      cbData = v41;
      v85 = 62;
      sub_11F9AB0(0, ghKCU, &cbData, 1, 0);
      v85 = -1;
      free(v41);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    v20 = a2;
  }
  cbData = a1 & 4;
  if ( a1 & 4 )
  {
    dword_12E48D8 = 4;
    if ( v2 == 2 || !v2 )
    {
      Type = _wcsdup(L"SOFTWARE\\Classes\\Protocols\\Filter");
      v85 = 63;
      sub_12030B0(0, ghKCU, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"SOFTWARE\\Classes\\Protocols\\Filter");
      v85 = 64;
      sub_12030B0(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || !v2 )
    {
      Type = _wcsdup(L"SOFTWARE\\Classes\\Protocols\\Handler");
      v85 = 65;
      sub_12030B0(0, ghKCU, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"SOFTWARE\\Classes\\Protocols\\Handler");
      v85 = 66;
      sub_12030B0(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( v2 == 2 || !v2 )
    {
      Type = _wcsdup(L"SOFTWARE\\Microsoft\\Internet Explorer\\Desktop\\Components");
      v85 = 67;
      sub_12039D0(0, ghKCU, &Type);
      v85 = -1;
      free(Type);
    }
  }
  if ( v20 )
  {
    dword_12E48D8 = 2;
    if ( v2 == 2 || !v2 )
      sub_120EFA0(0, ghKCU, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", L"AltStartup");
    if ( v2 == 2 || v2 == 1 )
      sub_120EFA0(
        0,
        ghKLM,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
        L"Common AltStartup");
    if ( v2 == 2 || v2 == 1 )
      sub_120EFA0(0, ghKLM, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", L"Common Startup");
    if ( v2 == 2 || !v2 )
      sub_120EFA0(0, ghKCU, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", L"Startup");
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows", L"Load", 32);
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows", L"Run", 32);
    if ( (GetVersion() & 0x80000000) != 0 )
      sub_1211840(0);
    if ( v2 == 2 || v2 == 1 )
    {
      v42 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run");
      Type = v42;
      v85 = 68;
      sub_11F9AB0(0, ghKLM, &Type, 1, 0);
      v85 = -1;
      free(v42);
    }
    if ( v2 == 2 || !v2 )
    {
      v43 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run");
      Type = v43;
      v85 = 69;
      sub_11F9AB0(0, ghKCU, &Type, 1, 0);
      v85 = -1;
      free(v43);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components");
      v85 = 70;
      sub_11F23D0(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      Type = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Active Setup\\Installed Components");
      v85 = 71;
      sub_11F23D0(0, ghKLM, &Type);
      v85 = -1;
      free(Type);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
      sub_11FAA30(0, ghKLM, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows", L"IconServiceLib", 44);
  }
  if ( cbData )
  {
    dword_12E48D8 = 4;
    if ( v2 == 2 || v2 == 1 )
    {
      v44 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SharedTaskScheduler");
      Type = v44;
      v85 = 72;
      sub_11F9AB0(0, ghKLM, &Type, 0, 1);
      v85 = -1;
      free(v44);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v45 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SharedTaskScheduler");
      Type = v45;
      v85 = 73;
      sub_11F9AB0(0, ghKLM, &Type, 0, 1);
      v85 = -1;
      free(v45);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v46 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellServiceObjects");
      Type = v46;
      v85 = 74;
      sub_11F86F0(0, ghKLM, &Type);
      v85 = -1;
      free(v46);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v47 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellServiceObjects");
      Type = v47;
      v85 = 75;
      sub_11F86F0(0, ghKLM, &Type);
      v85 = -1;
      free(v47);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      v48 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellServiceObjects");
      Type = v48;
      v85 = 76;
      sub_11F86F0(0, ghKCU, &Type);
      v85 = -1;
      free(v48);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v49 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
      Type = v49;
      v85 = 77;
      sub_11F9AB0(0, ghKLM, &Type, 0, 0);
      v85 = -1;
      free(v49);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v50 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
      Type = v50;
      v85 = 78;
      sub_11F9AB0(0, ghKLM, &Type, 0, 0);
      v85 = -1;
      free(v50);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      v51 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
      Type = v51;
      v85 = 79;
      sub_11F9AB0(0, ghKCU, &Type, 0, 0);
      v85 = -1;
      free(v51);
    }
  }
  if ( a2 )
  {
    dword_12E48D8 = 2;
    if ( v2 == 2 || !v2 )
    {
      v52 = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run");
      Type = v52;
      v85 = 80;
      sub_11F9AB0(0, ghKCU, &Type, 1, 0);
      v85 = -1;
      free(v52);
    }
    if ( IsWinServer() )
    {
      if ( v2 == 2 || !v2 )
      {
        v53 = _wcsdup(
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Microsoft\\Windows\\"
                 "CurrentVersion\\Runonce");
        Type = v53;
        v85 = 81;
        sub_11F9AB0(0, ghKCU, &Type, 1, 0);
        v85 = -1;
        free(v53);
      }
      if ( v2 == 2 || !v2 )
      {
        v54 = _wcsdup(
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Microsoft\\Windows\\"
                 "CurrentVersion\\RunonceEx");
        Type = v54;
        v85 = 82;
        sub_11FF2D0(0, ghKCU, &Type, 1, 0);
        v85 = -1;
        free(v54);
      }
      if ( v2 == 2 || !v2 )
      {
        v55 = _wcsdup(
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Microsoft\\Windows\\"
                 "CurrentVersion\\Run");
        Type = v55;
        v85 = 83;
        sub_11F9AB0(0, ghKCU, &Type, 1, 0);
        v85 = -1;
        free(v55);
      }
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v56 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows CE Services\\AutoStartOnConnect");
      Type = v56;
      v85 = 84;
      sub_11F9AB0(0, ghKLM, &Type, 1, 0);
      v85 = -1;
      free(v56);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v57 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows CE Services\\AutoStartOnConnect");
      Type = v57;
      v85 = 85;
      sub_11F9AB0(0, ghKLM, &Type, 1, 0);
      v85 = -1;
      free(v57);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v58 = _wcsdup(L"SOFTWARE\\Microsoft\\Windows CE Services\\AutoStartOnDisconnect");
      Type = v58;
      v85 = 86;
      sub_11F9AB0(0, ghKLM, &Type, 1, 0);
      v85 = -1;
      free(v58);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v59 = _wcsdup(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows CE Services\\AutoStartOnDisconnect");
      Type = v59;
      v85 = 87;
      sub_11F9AB0(0, ghKLM, &Type, 1, 0);
      v85 = -1;
      free(v59);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
  }
  v60 = a1;
  if ( a1 & 0x10 )
  {
    dword_12E48D8 = 16;
    if ( v2 == 2 || v2 == 1 )
    {
      sub_1210760(0);
      v60 = a1;
    }
  }
  *Data = v60 & 8;
  if ( v60 & 8 )
  {
    dword_12E48D8 = 8;
    if ( v2 == 2 || v2 == 1 )
    {
      v61 = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Browser Helper Objects");
      Type = v61;
      v85 = 88;
      sub_11F86F0(0, ghKLM, &Type);
      v85 = -1;
      free(v61);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v62 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Browser Helper Objects");
      Type = v62;
      v85 = 89;
      sub_11F86F0(0, ghKLM, &Type);
      v85 = -1;
      free(v62);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
  }
  if ( cbData )
  {
    dword_12E48D8 = 4;
    if ( v2 == 2 || v2 == 1 )
    {
      v63 = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellExecuteHooks");
      cbData = v63;
      v85 = 90;
      sub_11F9AB0(0, ghKLM, &cbData, 0, 1);
      v85 = -1;
      free(v63);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v64 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellExecuteHooks");
      cbData = v64;
      v85 = 91;
      sub_11F9AB0(0, ghKLM, &cbData, 0, 1);
      v85 = -1;
      free(v64);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\*\\ShellEx\\ContextMenuHandlers");
      v85 = 92;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\*\\ShellEx\\ContextMenuHandlers");
      v85 = 93;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\*\\ShellEx\\ContextMenuHandlers");
      v85 = 94;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Drive\\ShellEx\\ContextMenuHandlers");
      v85 = 95;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Drive\\ShellEx\\ContextMenuHandlers");
      v85 = 96;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Drive\\ShellEx\\ContextMenuHandlers");
      v85 = 97;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\*\\ShellEx\\PropertySheetHandlers");
      v85 = 98;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\*\\ShellEx\\PropertySheetHandlers");
      v85 = 99;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\*\\ShellEx\\PropertySheetHandlers");
      v85 = 100;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\AllFileSystemObjects\\ShellEx\\ContextMenuHandlers");
      v85 = 101;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\AllFileSystemObjects\\ShellEx\\ContextMenuHandlers");
      v85 = 102;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\AllFileSystemObjects\\ShellEx\\ContextMenuHandlers");
      v85 = 103;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\AllFileSystemObjects\\ShellEx\\DragDropHandlers");
      v85 = 104;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\AllFileSystemObjects\\ShellEx\\DragDropHandlers");
      v85 = 105;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\AllFileSystemObjects\\ShellEx\\DragDropHandlers");
      v85 = 106;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\AllFileSystemObjects\\ShellEx\\PropertySheetHandlers");
      v85 = 107;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\AllFileSystemObjects\\ShellEx\\PropertySheetHandlers");
      v85 = 108;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\AllFileSystemObjects\\ShellEx\\PropertySheetHandlers");
      v85 = 109;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\ShellEx\\ContextMenuHandlers");
      v85 = 110;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\ShellEx\\ContextMenuHandlers");
      v85 = 111;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Directory\\ShellEx\\ContextMenuHandlers");
      v85 = 112;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Shellex\\DragDropHandlers");
      v85 = 113;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Shellex\\DragDropHandlers");
      v85 = 114;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Directory\\Shellex\\DragDropHandlers");
      v85 = 115;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Shellex\\PropertySheetHandlers");
      v85 = 116;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Shellex\\PropertySheetHandlers");
      v85 = 117;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Directory\\Shellex\\PropertySheetHandlers");
      v85 = 118;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Shellex\\CopyHookHandlers");
      v85 = 119;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Shellex\\CopyHookHandlers");
      v85 = 120;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Directory\\Shellex\\CopyHookHandlers");
      v85 = 121;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Background\\ShellEx\\ContextMenuHandlers");
      v85 = 122;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Directory\\Background\\ShellEx\\ContextMenuHandlers");
      v85 = 123;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Directory\\Background\\ShellEx\\ContextMenuHandlers");
      v85 = 124;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      v65 = _wcsdup(L"Software\\Classes\\Folder\\Shellex\\ColumnHandlers");
      cbData = v65;
      v85 = 125;
      sub_11F86F0(0, ghKCU, &cbData);
      v85 = -1;
      free(v65);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v66 = _wcsdup(L"Software\\Classes\\Folder\\Shellex\\ColumnHandlers");
      cbData = v66;
      v85 = 126;
      sub_11F86F0(0, ghKLM, &cbData);
      v85 = -1;
      free(v66);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v67 = _wcsdup(L"Software\\Wow6432Node\\Classes\\Folder\\Shellex\\ColumnHandlers");
      cbData = v67;
      v85 = 127;
      sub_11F86F0(0, ghKLM, &cbData);
      v85 = -1;
      free(v67);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\ContextMenuHandlers");
      v85 = 128;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\ContextMenuHandlers");
      v85 = 129;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Folder\\ShellEx\\ContextMenuHandlers");
      v85 = 130;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\DragDropHandlers");
      v85 = 131;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\DragDropHandlers");
      v85 = 132;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Folder\\ShellEx\\DragDropHandlers");
      v85 = 133;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\ExtShellFolderViews");
      v85 = 134;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\ExtShellFolderViews");
      v85 = 135;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Folder\\ShellEx\\ExtShellFolderViews");
      v85 = 136;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\PropertySheetHandlers");
      v85 = 137;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Classes\\Folder\\ShellEx\\PropertySheetHandlers");
      v85 = 138;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Classes\\Folder\\ShellEx\\PropertySheetHandlers");
      v85 = 139;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers");
      v85 = 140;
      sub_120A070(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers");
      v85 = 141;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers");
      v85 = 142;
      sub_120A070(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
      sub_11FAA30(0, ghKCU, L"Software\\Classes\\Clsid\\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}", L"Inprocserver32", 32);
    if ( v2 == 2 || !v2 )
    {
      v68 = _wcsdup(L"Software\\Microsoft\\Ctf\\LangBarAddin");
      cbData = v68;
      v85 = 143;
      sub_11F86F0(0, ghKCU, &cbData);
      v85 = -1;
      free(v68);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v69 = _wcsdup(L"Software\\Microsoft\\Ctf\\LangBarAddin");
      cbData = v69;
      v85 = 144;
      sub_11F86F0(0, ghKLM, &cbData);
      v85 = -1;
      free(v69);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v70 = _wcsdup(L"Software\\Microsoft\\Ctf\\LangBarAddin");
      cbData = v70;
      v85 = 145;
      sub_11F86F0(0, ghKLM, &cbData);
      v85 = -1;
      free(v70);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
  }
  if ( *Data )
  {
    dword_12E48D8 = 8;
    if ( v2 == 2 || !v2 )
    {
      v71 = _wcsdup(L"Software\\Microsoft\\Internet Explorer\\UrlSearchHooks");
      *Data = v71;
      v85 = 146;
      sub_11F9AB0(0, ghKCU, Data, 0, 1);
      v85 = -1;
      free(v71);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v72 = _wcsdup(L"Software\\Microsoft\\Internet Explorer\\Toolbar");
      *Data = v72;
      v85 = 147;
      sub_11F9AB0(0, ghKLM, Data, 0, 1);
      v85 = -1;
      free(v72);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      v73 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Internet Explorer\\Toolbar");
      *Data = v73;
      v85 = 148;
      sub_11F9AB0(0, ghKLM, Data, 0, 1);
      v85 = -1;
      free(v73);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Microsoft\\Internet Explorer\\Explorer Bars");
      v85 = 149;
      sub_1204150(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Microsoft\\Internet Explorer\\Explorer Bars");
      v85 = 150;
      sub_1204150(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Internet Explorer\\Explorer Bars");
      v85 = 151;
      sub_1204150(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Internet Explorer\\Explorer Bars");
      v85 = 152;
      sub_1204150(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Microsoft\\Internet Explorer\\Extensions");
      v85 = 153;
      sub_1204150(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Microsoft\\Internet Explorer\\Extensions");
      v85 = 154;
      sub_1204150(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(1);
      TlsSetValue(gdwTlsIndex, 0x200);
    }
    if ( v2 == 2 || !v2 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Internet Explorer\\Extensions");
      v85 = 155;
      sub_1204150(0, ghKCU, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      cbData = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Internet Explorer\\Extensions");
      v85 = 156;
      sub_1204150(0, ghKLM, &cbData);
      v85 = -1;
      free(cbData);
    }
    if ( Wow64EnableWow64FsRedirection )
    {
      Wow64EnableWow64FsRedirection(0);
      TlsSetValue(gdwTlsIndex, 0x100);
    }
  }
  if ( a1 < 0 )
  {
    dword_12E48D8 = 128;
    if ( sub_11F67A0(ghKLM, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32", 0, 131097, Data) )
    {
      if ( dword_12E3628[0] && (v2 == 2 || v2 == 1) )
        wprintf(L"\nNo entry to display for codecs. Codecs are not supported on Nano Server.\n");
    }
    else
    {
      if ( v2 == 2 || !v2 )
      {
        v74 = _wcsdup(L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
        a1 = v74;
        v85 = 157;
        sub_11F9AB0(0, ghKCU, &a1, 1, 0);
        v85 = -1;
        free(v74);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v75 = _wcsdup(L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
        a1 = v75;
        v85 = 158;
        sub_11F9AB0(0, ghKLM, &a1, 1, 0);
        v85 = -1;
        free(v75);
      }
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(1);
        TlsSetValue(gdwTlsIndex, 0x200);
      }
      if ( v2 == 2 || !v2 )
      {
        v76 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
        a1 = v76;
        v85 = 159;
        sub_11F9AB0(0, ghKCU, &a1, 1, 0);
        v85 = -1;
        free(v76);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v77 = _wcsdup(L"Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
        a1 = v77;
        v85 = 160;
        sub_11F9AB0(0, ghKLM, &a1, 1, 0);
        v85 = -1;
        free(v77);
      }
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(0);
        TlsSetValue(gdwTlsIndex, 0x100);
      }
      if ( v2 == 2 || !v2 )
      {
        v78 = _wcsdup(L"Software\\Classes\\Filter");
        a1 = v78;
        v85 = 161;
        sub_11F86F0(0, ghKCU, &a1);
        v85 = -1;
        free(v78);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v79 = _wcsdup(L"Software\\Classes\\Filter");
        a1 = v79;
        v85 = 162;
        sub_11F86F0(0, ghKLM, &a1);
        v85 = -1;
        free(v79);
      }
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(1);
        TlsSetValue(gdwTlsIndex, 0x200);
      }
      if ( v2 == 2 || v2 == 1 )
      {
        v80 = _wcsdup(L"Software\\Classes\\Filter");
        a1 = v80;
        v85 = 163;
        sub_11F86F0(0, ghKLM, &a1);
        v85 = -1;
        free(v80);
      }
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(0);
        TlsSetValue(gdwTlsIndex, 0x100);
      }
      if ( v2 == 2 || !v2 )
        sub_11F9030(1, 0, ghKCU, L"{083863F1-70DE-11d0-BD40-00A0C911CE86}");
      if ( v2 == 2 || !v2 )
        sub_11F9030(1, 0, ghKCU, L"{AC757296-3522-4E11-9862-C17BE5A1767E}");
      if ( v2 == 2 || !v2 )
        sub_11F9030(1, 0, ghKCU, L"{7ED96837-96F0-4812-B211-F13C24117ED3}");
      if ( v2 == 2 || !v2 )
        sub_11F9030(1, 0, ghKCU, L"{ABE3B9A4-257D-4B97-BD1A-294AF496222E}");
      if ( v2 == 2 || v2 == 1 )
        sub_11F9030(1, 0, ghKLM, L"{083863F1-70DE-11d0-BD40-00A0C911CE86}");
      if ( v2 == 2 || v2 == 1 )
        sub_11F9030(1, 0, ghKLM, L"{AC757296-3522-4E11-9862-C17BE5A1767E}");
      if ( v2 == 2 || v2 == 1 )
        sub_11F9030(1, 0, ghKLM, L"{7ED96837-96F0-4812-B211-F13C24117ED3}");
      if ( v2 == 2 || v2 == 1 )
        sub_11F9030(1, 0, ghKLM, L"{ABE3B9A4-257D-4B97-BD1A-294AF496222E}");
    }
  }
  if ( a2 )
  {
    dword_12E48D8 = 2;
    if ( v2 == 2 || !v2 )
    {
      a1 = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logoff");
      v85 = 164;
      sub_1202060(0, ghKCU, &a1);
      v85 = -1;
      free(a1);
    }
    if ( v2 == 2 || v2 == 1 )
    {
      a1 = _wcsdup(L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\Shutdown");
      v85 = 165;
      sub_1202060(0, ghKLM, &a1);
      free(a1);
    }
  }
}
// 12E31C0: using guessed type int dword_12E31C0;
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);
// 12E3628: using guessed type int dword_12E3628[140];
// 12E48D8: using guessed type int dword_12E48D8;

//----- (011FF2D0) --------------------------------------------------------
void __cdecl sub_11FF2D0(int a1, void *a2, int a3, char a4, char a5)
{
  int v5; // edi
  OLECHAR *v6; // esi
  unsigned int v7; // eax
  _WORD *v8; // esi
  _WORD *v9; // ebx
  const wchar_t **v10; // eax
  unsigned __int16 **v11; // eax
  wchar_t *v12; // edi
  void *v13; // ebx
  const wchar_t **v14; // eax
  wchar_t *v15; // esi
  void *v16; // edi
  LSTATUS v17; // eax
  wchar_t *v18; // ebx
  wchar_t *v19; // edi
  wchar_t *v20; // esi
  unsigned __int16 **v21; // eax
  _WORD *v22; // [esp+10h] [ebp-40h]
  void *v23; // [esp+14h] [ebp-3Ch]
  void *v24; // [esp+18h] [ebp-38h]
  int v25; // [esp+1Ch] [ebp-34h]
  void *v26; // [esp+20h] [ebp-30h]
  void *v27; // [esp+24h] [ebp-2Ch]
  void *v28; // [esp+28h] [ebp-28h]
  void *v29; // [esp+2Ch] [ebp-24h]
  void *v30; // [esp+30h] [ebp-20h]
  void *v31; // [esp+34h] [ebp-1Ch]
  HKEY hKey; // [esp+38h] [ebp-18h]
  void *v33; // [esp+3Ch] [ebp-14h]
  void *v34; // [esp+40h] [ebp-10h]
  int v35; // [esp+4Ch] [ebp-4h]

  v22 = malloc(2u);
  *v22 = 0;
  v5 = a3;
  v35 = 0;
  v6 = *a3;
  v7 = TlsGetValue(gdwTlsIndex);
  if ( sub_11F67A0(a2, v6, 0, v7 | 0x20019, &hKey) )
  {
    v34 = _wcsdup(gpszTargetName);
    v33 = _wcsdup(gpszTargetName);
    v31 = _wcsdup(gpszTargetName);
    v30 = _wcsdup(gpszTargetName);
    v29 = _wcsdup(gpszTargetName);
    v18 = _wcsdup(gpszTargetName);
    v28 = v18;
    v19 = _wcsdup(gpszTargetName);
    v26 = v19;
    v20 = _wcsdup(gpszTargetName);
    v27 = v20;
    v25 = sub_11F7BE0(&v23, a2, a3, &v26);
    v21 = sub_11F7BE0(&v24, a2, a3, &v27);
    LOBYTE(v35) = 13;
    sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v21, v25, &v28);
    free(v24);
    free(v23);
    free(v20);
    free(v19);
    free(v18);
    free(v29);
    free(v30);
    free(v31);
    free(v33);
    free(v34);
  }
  else
  {
    v31 = 0;
    v8 = malloc(2u);
    v33 = v8;
    *v8 = 0;
    v9 = malloc(2u);
    v30 = v9;
    v29 = v9;
    *v9 = 0;
    v34 = malloc(2u);
    *v34 = 0;
    LOBYTE(v35) = 3;
    if ( !sub_12013D0(hKey, 0, &v34) )
    {
      do
      {
        v10 = sub_11F22B0(&v27, v5, L"\\");
        v11 = sub_1203070(&v28, v10, &v34);
        v12 = _wcsdup(*v11);
        v33 = v12;
        free(v8);
        free(v28);
        free(v27);
        v13 = sub_11F9B70(a1, a2, v12, a4, a5, 0xFFFFFFFF, 1, 0);
        v14 = sub_11F22B0(&v26, &v33, L"\\AutorunsDisabled");
        v15 = _wcsdup(*v14);
        v29 = v15;
        free(v30);
        free(v26);
        sub_11F9B70(a1, a2, v15, a4, a5, v13, 0, 0);
        free(v34);
        free(v15);
        free(v12);
        v31 = v31 + 1;
        v16 = v31;
        v8 = malloc(2u);
        v33 = v8;
        *v8 = 0;
        v9 = malloc(2u);
        v30 = v9;
        v29 = v9;
        *v9 = 0;
        v34 = malloc(2u);
        *v34 = 0;
        LOBYTE(v35) = 3;
        v17 = sub_12013D0(hKey, v16, &v34);
        v5 = a3;
      }
      while ( !v17 );
    }
    free(v34);
    free(v9);
    free(v8);
    RegCloseKey(hKey);
  }
  free(v22);
}

//----- (011FF610) --------------------------------------------------------
char __cdecl sub_11FF610(HWND hWnd, int a2, int a3)
{
  WCHAR *v3; // edi
  WCHAR *v4; // ebx
  _WORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // esi
  unsigned int v8; // edx
  int v9; // eax
  SystemMenuData *v10; // esi
  bool v11; // zf
  int v12; // eax
  WCHAR *v13; // ecx
  wchar_t *v14; // esi
  const wchar_t **v15; // eax
  const wchar_t **v16; // eax
  WCHAR *v17; // esi
  OLECHAR *v18; // esi
  int v19; // eax
  wchar_t *v20; // esi
  const wchar_t **v21; // eax
  wchar_t *v22; // ST48_4
  FILE *v23; // eax
  UINT v24; // ST2C_4
  HMENU v25; // eax
  UINT v26; // ST2C_4
  HMENU v27; // eax
  void *v29; // [esp+10h] [ebp-30h]
  wchar_t *v30; // [esp+14h] [ebp-2Ch]
  int v31; // [esp+18h] [ebp-28h]
  LPWSTR ppsz; // [esp+1Ch] [ebp-24h]
  DWORD dwMessageId; // [esp+20h] [ebp-20h]
  int v34; // [esp+24h] [ebp-1Ch]
  int v35; // [esp+28h] [ebp-18h]
  SystemMenuData *v36; // [esp+2Ch] [ebp-14h]
  char v37; // [esp+33h] [ebp-Dh]
  int v38; // [esp+3Ch] [ebp-4h]

  v3 = malloc(2u);
  v34 = v3;
  *v3 = 0;
  v38 = 0;
  v4 = malloc(2u);
  v31 = v4;
  *v4 = 0;
  v37 = 0;
  v5 = malloc(2u);
  v6 = 0;
  v29 = v5;
  *v5 = 0;
  v7 = dword_12E4C20;
  v8 = (dword_12E4C24 - dword_12E4C20) >> 2;
  LOBYTE(v38) = 2;
  if ( v8 )
  {
    while ( 1 )
    {
      v9 = v7[v6];
      v7 = dword_12E4C20;
      if ( *(v9 + 4) == a3 )
        break;
      if ( ++v6 >= v8 )
        goto LABEL_4;
    }
    v10 = *(dword_12E4C20 + v6);
  }
  else
  {
LABEL_4:
    v10 = v35;
  }
  v11 = v10->SystemAdministrative == 0;
  v36 = v10;
  if ( !v11 )
  {
    v35 = -2147483647;
LABEL_20:
    v37 = 1;
    if ( hWnd )
    {
      v24 = *(a2 + 4);
      v25 = GetMenu(hWnd);
      CheckMenuItem(v25, v24, 0);
      v26 = v36->nMenuPos;
      v27 = GetMenu(hWnd);
      CheckMenuItem(v27, v26, 8u);
    }
    if ( a2 && !*a2 )
    {
      RegCloseKey(ghKCU);
      RegUnLoadKeyW(HKEY_USERS, (a2 + 8));
    }
    gpSysMenuData = v36;
    ghKCU = v35;
    goto LABEL_26;
  }
  v30 = v10->szMenuName;
  v12 = wcscmp(v10->szMenuName, L"NT AUTHORITY\\SYSTEM");
  if ( v12 )
    v12 = -(v12 < 0) | 1;
  if ( v12 )
  {
    v13 = gpszTargetName;
    if ( v10 != -1048 )
      v13 = v10->SystemWinDirectory;
    v14 = _wcsdup(v13);
    v34 = v14;
    v15 = sub_11F22B0(&ppsz, &v34, L"\\ntuser.dat");
    dwMessageId = v3;
    v3 = _wcsdup(*v15);
    v34 = v3;
    free(dwMessageId);
    free(ppsz);
    free(v14);
    v16 = GetEnvironmentPathInfo(&ppsz, v3);
    v17 = v4;
    v4 = _wcsdup(*v16);
    v31 = v4;
    free(v17);
    free(ppsz);
    v18 = v36->strDefault;
    dwMessageId = RegLoadKeyW(HKEY_USERS, v36->strDefault, v4);
    if ( dwMessageId )
    {
      v20 = _wcsdup(L"Error loading profile for ");
      v31 = v20;
      v21 = sub_11F22B0(&ppsz, &v31, v30);
      v22 = v3;
      v3 = _wcsdup(*v21);
      free(v22);
      free(ppsz);
      free(v20);
      v23 = sub_1287B15();
      fputws(v3, v23 + 2);
      sub_11F7AE0(dwMessageId);
      goto LABEL_26;
    }
    v19 = sub_11F67A0(HKEY_USERS, v18, 0, 131103, &v35);
  }
  else
  {
    v19 = sub_11F67A0(HKEY_USERS, v10->strDefault, 0, 131103, &v35);
  }
  if ( !v19 )
    goto LABEL_20;
LABEL_26:
  free(v29);
  free(v4);
  free(v3);
  return v37;
}
// 12AD238: using guessed type wchar_t aNtAuthoritySys[20];
// 12E4C24: using guessed type int dword_12E4C24;

//----- (011FF8D0) --------------------------------------------------------
int __cdecl sub_11FF8D0(int a1, wchar_t *a2)
{
  WCHAR *v2; // ecx
  wchar_t *v3; // eax
  wchar_t *v4; // ecx
  wchar_t *v5; // edx
  wchar_t i; // ax

  v2 = gpszTargetName;
  if ( a2 )
    v2 = a2;
  v3 = _wcsdup(v2);
  v4 = v3;
  v5 = v3;
  *a1 = v3;
  for ( i = *v3; i; ++v4 )
  {
    if ( i != 34 )
    {
      *v5 = i;
      ++v5;
    }
    i = v4[1];
  }
  *v5 = 0;
  return a1;
}

//----- (011FF930) --------------------------------------------------------
char __thiscall sub_11FF930(_DWORD *this, unsigned int a2)
{
  _DWORD *v2; // esi
  char *v4; // eax

  v2 = this;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !a2 )
    return 0;
  if ( a2 > 0x3FFFFFFF )
    std::_Xlength_error("vector<T> too long");
  v4 = operator new(4 * a2);
  if ( !v4 )
    std::bad_alloc::bad_alloc();
  *v2 = v4;
  v2[1] = v4;
  v2[2] = &v4[4 * a2];
  return 1;
}

//----- (011FF9A0) --------------------------------------------------------
_DWORD *sub_11FF9A0()
{
  _DWORD *result; // eax

  result = operator new(0x20u);
  JUMPOUT(result, 0, std::bad_alloc::bad_alloc);
  *result = result;
  if ( result != -4 )
    result[1] = result;
  if ( result != -8 )
    result[2] = result;
  *(result + 6) = 257;
  return result;
}

//----- (011FF9D0) --------------------------------------------------------
int __thiscall sub_11FF9D0(int *this, unsigned int a2, int a3)
{
  int *v3; // esi
  unsigned int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  void *v8; // ecx
  int *v9; // edx
  int v10; // eax
  int result; // eax
  int v12; // [esp+0h] [ebp-28h]
  int *v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int *v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+24h] [ebp-4h]

  v15 = &v12;
  v3 = this;
  v13 = this;
  v4 = a2 | 7;
  if ( (a2 | 7) <= 0x7FFFFFFE )
  {
    v5 = this[5];
    v6 = this[5] >> 1;
    if ( v6 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > 2147483646 - v6 )
        v4 = 2147483646;
    }
  }
  else
  {
    v4 = a2;
  }
  v7 = v4 + 1;
  v16 = 0;
  v8 = 0;
  v14 = 0;
  if ( v4 != -1 )
  {
    if ( v7 > 0x7FFFFFFF || (v8 = operator new(2 * v7), (v14 = v8) == 0) )
      std::bad_alloc::bad_alloc();
  }
  if ( a3 )
  {
    v9 = v3[5] < 8 ? v3 : *v3;
    if ( a3 )
      memmove_0(v8, v9, 2 * a3);
  }
  if ( v3[5] >= 8 )
    j__free(*v3);
  v10 = v14;
  *v3 = v14;
  v3[5] = v4;
  v3[4] = a3;
  if ( v4 >= 8 )
    v3 = v10;
  result = 0;
  *(v3 + a3) = 0;
  return result;
}

//----- (011FFB40) --------------------------------------------------------
void __stdcall sub_11FFB40(void *a1)
{
  _DWORD *v1; // edi
  void *i; // ebx
  int v3; // esi
  int v4; // esi

  v1 = a1;
  for ( i = a1; !*(i + 13); v1 = i )
  {
    sub_11FFB40(*(i + 2));
    v3 = v1[7];
    i = *i;
    if ( v3 )
    {
      if ( !InterlockedDecrement((v3 + 8)) && v3 )
      {
        if ( *v3 )
        {
          SysFreeString(*v3);
          *v3 = 0;
        }
        if ( *(v3 + 4) )
        {
          j_j__free(*(v3 + 4));
          *(v3 + 4) = 0;
        }
        j__free(v3);
      }
      v1[7] = 0;
    }
    v4 = v1[5];
    if ( v4 )
    {
      if ( !InterlockedDecrement((v4 + 8)) && v4 )
      {
        if ( *v4 )
        {
          SysFreeString(*v4);
          *v4 = 0;
        }
        if ( *(v4 + 4) )
        {
          j_j__free(*(v4 + 4));
          *(v4 + 4) = 0;
        }
        j__free(v4);
      }
      v1[5] = 0;
    }
    j__free(v1);
  }
}

//----- (011FFC40) --------------------------------------------------------
BOOL __thiscall sub_11FFC40(void *this, int a2, int a3)
{
  int *v3; // esi
  unsigned int v4; // eax
  BOOL result; // eax
  unsigned int v6; // ebx
  int *v7; // ecx
  int v8; // [esp+14h] [ebp+Ch]

  v3 = this;
  if ( a2 > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v4 = *(this + 5);
  if ( v4 >= a2 )
  {
    if ( a3 && a2 < 8 )
    {
      v6 = *(this + 4);
      if ( a2 < v6 )
        v6 = a2;
      if ( v4 >= 8 )
      {
        v7 = *this;
        v8 = *v3;
        if ( v6 )
        {
          memmove_0(v3, v7, 2 * v6);
          v7 = v8;
        }
        j__free(v7);
      }
      v3[4] = v6;
      v3[5] = 7;
      *(v3 + v6) = 0;
      result = a2 > 0;
    }
    else
    {
      if ( !a2 )
      {
        *(this + 4) = 0;
        if ( v4 >= 8 )
          v3 = *this;
        *v3 = 0;
      }
      result = a2 > 0;
    }
  }
  else
  {
    sub_11FF9D0(this, a2, *(this + 4));
    result = a2 > 0;
  }
  return result;
}

//----- (011FFD00) --------------------------------------------------------
int *__thiscall sub_11FFD00(int *this, unsigned int a2)
{
  int *v2; // ebx
  unsigned int v3; // esi
  char *v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // ebx
  int *result; // eax
  int v9; // [esp+0h] [ebp-28h]
  void *v10; // [esp+10h] [ebp-18h]
  int *v11; // [esp+14h] [ebp-14h]
  int *v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+24h] [ebp-4h]

  v12 = &v9;
  v2 = this;
  v11 = this;
  v3 = a2;
  v4 = 0;
  v10 = 0;
  if ( a2 )
  {
    if ( a2 > 0xFFFFFFF || (v4 = operator new(16 * a2), (v10 = v4) == 0) )
      std::bad_alloc::bad_alloc();
  }
  v13 = 0;
  sub_11F3440(*v2, v2[1], v4);
  v5 = *v2;
  v6 = v2[1];
  v7 = v2[1] - *v2;
  if ( v5 )
  {
    sub_11F2BF0(v5, v6);
    j__free(*v11);
  }
  result = v11;
  v11[2] = &v4[16 * v3];
  result[1] = &v4[v7 & 0xFFFFFFF0];
  *result = v4;
  return result;
}

//----- (011FFDF0) --------------------------------------------------------
const wchar_t **__thiscall sub_11FFDF0(const wchar_t ***this, unsigned int a2)
{
  const wchar_t ***v2; // ebx
  char *v3; // edi
  const wchar_t **v4; // eax
  const wchar_t **v5; // esi
  int v6; // ecx
  int v7; // ecx
  const wchar_t **result; // eax
  int v9; // [esp+0h] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-1Ch]
  void *v11; // [esp+14h] [ebp-18h]
  int *v12; // [esp+1Ch] [ebp-10h]
  int v13; // [esp+28h] [ebp-4h]

  v12 = &v9;
  v2 = this;
  v3 = 0;
  v11 = 0;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFF || (v3 = operator new(4 * a2), (v11 = v3) == 0) )
      std::bad_alloc::bad_alloc();
  }
  v13 = 0;
  sub_11F34F0(*v2, v2[1], v3);
  v4 = v2[1];
  v5 = *v2;
  v6 = v2[1] - *v2;
  v11 = v2[1];
  v7 = v6 >> 2;
  v10 = v7;
  if ( v5 )
  {
    if ( v5 != v4 )
    {
      do
      {
        free(*v5);
        ++v5;
      }
      while ( v5 != v11 );
    }
    j__free(*v2);
    v7 = v10;
  }
  *v2 = v3;
  v2[2] = &v3[4 * a2];
  result = &v3[4 * v7];
  v2[1] = result;
  return result;
}

//----- (011FFEE0) --------------------------------------------------------
int *__thiscall sub_11FFEE0(int *this, unsigned int a2)
{
  int v2; // esi
  int *result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx

  v2 = this[1];
  result = ((this[2] - v2) >> 4);
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 4;
    if ( 0xFFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (this[2] - *this) >> 4;
    if ( 0xFFFFFFF - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v5 )
        v8 = v5;
      result = sub_11FFD00(this, v8);
    }
    else
    {
      v7 = 0;
      if ( v5 > 0 )
        v7 = v5;
      result = sub_11FFD00(this, v7);
    }
  }
  return result;
}

//----- (011FFF60) --------------------------------------------------------
unsigned int __thiscall sub_11FFF60(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx

  v2 = *(this + 4);
  result = (*(this + 8) - v2) >> 2;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 2;
    if ( 0x3FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(this + 8) - *this) >> 2;
    if ( 0x3FFFFFFF - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v5 )
        v8 = v5;
      result = sub_11FFDF0(this, v8);
    }
    else
    {
      v7 = 0;
      if ( v5 > 0 )
        v7 = v5;
      result = sub_11FFDF0(this, v7);
    }
  }
  return result;
}

//----- (011FFFE0) --------------------------------------------------------
void *__stdcall sub_11FFFE0(unsigned int a1)
{
  void *v1; // ecx

  v1 = 0;
  if ( a1 )
  {
    if ( a1 > 0x7FFFFFFF || (v1 = operator new(2 * a1)) == 0 )
      std::bad_alloc::bad_alloc();
  }
  return v1;
}

//----- (01200010) --------------------------------------------------------
int __thiscall sub_1200010(int *this)
{
  int *v1; // edi
  int v2; // ebx
  void **v3; // esi
  int result; // eax

  v1 = this;
  v2 = this[1];
  v3 = *this;
  if ( *this == v2 )
  {
    result = *this;
    this[1] = v3;
  }
  else
  {
    do
    {
      free(*v3);
      ++v3;
    }
    while ( v3 != v2 );
    result = *v1;
    v1[1] = *v1;
  }
  return result;
}

//----- (01200050) --------------------------------------------------------
int __thiscall sub_1200050(_DWORD *this, int a2, void *a3, int a4)
{
  void *v4; // eax
  _DWORD *v5; // esi
  void **v6; // ecx
  int *v7; // eax
  int v8; // ecx
  int result; // eax
  void *v10; // ecx
  _DWORD *i; // edx
  _BYTE *j; // eax
  int v13; // [esp+4h] [ebp-4h]

  v4 = a3;
  v5 = this;
  v6 = *this;
  if ( a3 != *v6 || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v10 = v4;
      if ( !*(v4 + 13) )
      {
        i = *(v4 + 2);
        if ( *(i + 13) )
        {
          for ( i = *(v4 + 1); !*(i + 13); i = i[1] )
          {
            if ( v4 != i[2] )
              break;
            v4 = i;
          }
        }
        else
        {
          for ( j = *i; !j[13]; j = *j )
            i = j;
        }
        a3 = i;
      }
      sub_1200110(v5, &v13, v10);
    }
    *a2 = v4;
    result = a2;
  }
  else
  {
    sub_11FFB40(v6[1]);
    *(*v5 + 4) = *v5;
    **v5 = *v5;
    *(*v5 + 8) = *v5;
    v7 = *v5;
    v5[1] = 0;
    v8 = *v7;
    result = a2;
    *a2 = v8;
  }
  return result;
}

//----- (01200110) --------------------------------------------------------
int __thiscall sub_1200110(void *this, int a2, void *a3)
{
  CMapNode **v3; // ebx
  CMapNode *v4; // edi
  CMapNode *v5; // ecx
  CMapNode *v6; // esi
  CMapNode *v7; // edx
  CMapNode *v8; // eax
  CMapNode *v9; // ecx
  CMapNode *v10; // eax
  CMapNode *v11; // eax
  CMapNode *i; // ecx
  CMapNode **v13; // eax
  char v14; // cl
  CMapNode *v15; // ecx
  CMapNode *v16; // ST00_4
  CMapNode *v17; // esi
  CMapNode *v18; // ST00_4
  CMapNode *v19; // edi
  LONG (__stdcall *v20)(volatile LONG *); // ecx
  CMapNode *v21; // edi
  CMapNode *v22; // eax
  void *v23; // ecx
  int result; // eax
  _BYTE *v25; // [esp+Ch] [ebp-8h]
  CMapNode *v26; // [esp+10h] [ebp-4h]

  v3 = a3;
  v26 = this;
  sub_1214CE0(&a3);
  if ( (*v3)->_isnil )
  {
    v4 = v3[2];
LABEL_6:
    v6 = v3[1];
    if ( !v4->_isnil )
      v4->_Parent = v6;
    v7 = v26;
    if ( v26->_Left->_Parent == v3 )
    {
      v26->_Left->_Parent = v4;
    }
    else if ( v6->_Left == v3 )
    {
      v6->_Left = v4;
    }
    else
    {
      v6->_Right = v4;
    }
    v8 = v26->_Left;
    if ( v26->_Left->_Left == v3 )
    {
      if ( v4->_isnil )
      {
        v9 = v6;
      }
      else
      {
        v10 = v4->_Left;
        v9 = v4;
        if ( !v4->_Left->_isnil )
        {
          do
          {
            v9 = v10;
            v10 = v10->_Left;
          }
          while ( !v10->_isnil );
        }
        v8 = v26->_Left;
      }
      v8->_Left = v9;
    }
    if ( v26->_Left->_Right == v3 )
    {
      if ( v4->_isnil )
      {
        v26->_Left->_Right = v6;
      }
      else
      {
        v11 = v4->_Right;
        for ( i = v4; !v11->_isnil; v11 = v11->_Right )
          i = v11;
        v26->_Left->_Right = i;
      }
    }
    goto LABEL_37;
  }
  if ( v3[2]->_isnil )
  {
    v4 = *v3;
    goto LABEL_6;
  }
  v5 = a3;
  v25 = a3;
  v4 = *(a3 + 2);
  if ( a3 == v3 )
    goto LABEL_6;
  (*v3)->_Parent = a3;
  v5->_Left = *v3;
  if ( v5 == v3[2] )
  {
    v6 = v5;
  }
  else
  {
    v6 = v5->_Parent;
    if ( !v4->_isnil )
      v4->_Parent = v6;
    v6->_Left = v4;
    v5->_Right = v3[2];
    v3[2]->_Parent = v5;
  }
  if ( v26->_Left->_Parent == v3 )
  {
    v26->_Left->_Parent = v5;
  }
  else
  {
    v13 = v3[1];
    if ( *v13 == v3 )
      *v13 = v5;
    else
      v13[2] = v5;
  }
  v5->_Parent = v3[1];
  v14 = v5->_Color;
  v25[12] = *(v3 + 12);
  v7 = v26;
  *(v3 + 12) = v14;
LABEL_37:
  if ( *(v3 + 12) == 1 )
  {
    for ( ; v4 != v7->_Left->_Parent; v6 = v6->_Parent )
    {
      if ( v4->_Color != 1 )
        break;
      v15 = v6->_Left;
      if ( v4 == v6->_Left )
      {
        v15 = v6->_Right;
        if ( !v15->_Color )
        {
          v15->_Color = 1;
          v6->_Color = 0;
          sub_12754B0(v7, v6);
          v15 = v6->_Right;
          v7 = v26;
        }
        if ( v15->_isnil )
          goto LABEL_55;
        if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
        {
          if ( v15->_Right->_Color == 1 )
          {
            v15->_Left->_Color = 1;
            v15->_Color = 0;
            sub_1282BB0(v7, v15);
            v15 = v6->_Right;
          }
          v15->_Color = v6->_Color;
          v6->_Color = 1;
          v16 = v6;
          v17 = v26;
          v15->_Right->_Color = 1;
          sub_12754B0(v26, v16);
          v4->_Color = 1;
          goto LABEL_61;
        }
      }
      else
      {
        if ( !v15->_Color )
        {
          v15->_Color = 1;
          v6->_Color = 0;
          sub_1282BB0(v7, v6);
          v15 = v6->_Left;
          v7 = v26;
        }
        if ( v15->_isnil )
          goto LABEL_55;
        if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
        {
          if ( v15->_Left->_Color == 1 )
          {
            v15->_Right->_Color = 1;
            v15->_Color = 0;
            sub_12754B0(v7, v15);
            v15 = v6->_Left;
          }
          v15->_Color = v6->_Color;
          v6->_Color = 1;
          v18 = v6;
          v17 = v26;
          v15->_Left->_Color = 1;
          sub_1282BB0(v26, v18);
          v4->_Color = 1;
          goto LABEL_61;
        }
      }
      v15->_Color = 0;
LABEL_55:
      v4 = v6;
    }
    v17 = v26;
    v4->_Color = 1;
  }
  else
  {
    v17 = v26;
  }
LABEL_61:
  v19 = v3[7];
  v20 = InterlockedDecrement;
  if ( v19 )
  {
    if ( !InterlockedDecrement(&v19->_Right) && v19 )
    {
      if ( v19->_Left )
      {
        SysFreeString(v19->_Left);
        v19->_Left = 0;
      }
      if ( v19->_Parent )
      {
        j_j__free(v19->_Parent);
        v19->_Parent = 0;
      }
      j__free(v19);
    }
    v20 = InterlockedDecrement;
    v3[7] = 0;
  }
  v21 = v3[5];
  if ( v21 )
  {
    if ( !v20(&v21->_Right) && v21 )
    {
      if ( v21->_Left )
      {
        SysFreeString(v21->_Left);
        v21->_Left = 0;
      }
      if ( v21->_Parent )
      {
        j_j__free(v21->_Parent);
        v21->_Parent = 0;
      }
      j__free(v21);
    }
    v3[5] = 0;
  }
  j__free(v3);
  v22 = v17->_Parent;
  v23 = a3;
  if ( v22 )
    v17->_Parent = (v22 - 1);
  result = a2;
  *a2 = v23;
  return result;
}

//----- (01200440) --------------------------------------------------------
UINT __thiscall sub_1200440(BSTR **this)
{
  UINT result; // eax

  if ( *this && **this )
    result = SysStringLen(**this);
  else
    result = 0;
  return result;
}

//----- (01200460) --------------------------------------------------------
const wchar_t **__thiscall sub_1200460(int *this, const wchar_t **a2)
{
  int *v2; // esi
  const wchar_t **result; // eax
  const wchar_t **v4; // edi
  int v5; // ecx
  unsigned int v6; // edi
  int v7; // ebx

  v2 = this;
  result = this[1];
  v4 = a2;
  if ( a2 >= result || (v5 = *this, *v2 > a2) )
  {
    if ( result == v2[2] )
      result = sub_11FFEE0(v2, 1u);
    v7 = v2[1];
    if ( v7 )
    {
      *v7 = _wcsdup(*a2);
      goto LABEL_11;
    }
  }
  else
  {
    v6 = a2 - v5;
    if ( result == v2[2] )
      result = sub_11FFEE0(v2, 1u);
    v7 = v2[1];
    v4 = (*v2 + (v6 & 0xFFFFFFF0));
    if ( v7 )
    {
      *v7 = _wcsdup(*v4);
LABEL_11:
      result = sub_11F35A0((v7 + 4), v4 + 1);
      goto LABEL_12;
    }
  }
LABEL_12:
  v2[1] += 16;
  return result;
}

//----- (01200530) --------------------------------------------------------
unsigned int __thiscall sub_1200530(_DWORD *this, const wchar_t **a2)
{
  _DWORD *v2; // esi
  unsigned int result; // eax
  int v4; // ecx
  int v5; // edi
  _DWORD *v6; // ebx

  v2 = this;
  result = this[1];
  if ( a2 >= result || (v4 = *this, *v2 > a2) )
  {
    if ( result == v2[2] )
      result = sub_11FFF60(v2, 1u);
    v6 = v2[1];
    if ( v6 )
    {
      result = _wcsdup(*a2);
      goto LABEL_11;
    }
  }
  else
  {
    v5 = (a2 - v4) >> 2;
    if ( result == v2[2] )
      result = sub_11FFF60(v2, 1u);
    v6 = v2[1];
    if ( v6 )
    {
      result = _wcsdup(*(*v2 + 4 * v5));
LABEL_11:
      *v6 = result;
      goto LABEL_12;
    }
  }
LABEL_12:
  v2[1] += 4;
  return result;
}

//----- (012005A0) --------------------------------------------------------
void *__cdecl sub_12005A0(int a1, void *a2, OLECHAR *psz, LPCWSTR lpValueName)
{
  CComBSTR **v4; // eax
  _bstr_t *v5; // eax
  void *v6; // esi
  CComBSTR *v7; // esi
  CComBSTR *v8; // esi
  void *v9; // eax
  wchar_t *v10; // ecx
  void *v11; // eax
  CComBSTR *v12; // esi
  void *v13; // edi
  CComBSTR *ppComBSTR1; // [esp+10h] [ebp-1Ch]
  CComBSTR *ppv; // [esp+14h] [ebp-18h]
  CComBSTR *v17; // [esp+18h] [ebp-14h]
  void *v18; // [esp+1Ch] [ebp-10h]
  int v19; // [esp+28h] [ebp-4h]

  bstr_t::EqualAssign(&ppv, L"AutorunsDisabled");
  v19 = 0;
  v4 = bstr_t::EqualAssign(&v17, L"\\");
  LOBYTE(v19) = 1;
  v5 = sub_11F3B50(&v18, psz, v4);
  LOBYTE(v19) = 2;
  CComBSTR::AppendTail(v5, &ppComBSTR1, &ppv);
  v6 = v18;
  if ( v18 )
  {
    if ( !InterlockedDecrement(v18 + 2) && v6 )
    {
      if ( *v6 )
      {
        SysFreeString(*v6);
        *v6 = 0;
      }
      if ( *(v6 + 1) )
      {
        j_j__free(*(v6 + 1));
        *(v6 + 1) = 0;
      }
      j__free(v6);
    }
    v18 = 0;
  }
  v7 = v17;
  if ( v17 )
  {
    if ( !InterlockedDecrement(&v17->Length) && v7 )
    {
      if ( v7->bstr )
      {
        SysFreeString(v7->bstr);
        v7->bstr = 0;
      }
      if ( v7->hKey )
      {
        j_j__free(v7->hKey);
        v7->hKey = 0;
      }
      j__free(v7);
    }
    v17 = 0;
  }
  v8 = ppv;
  LOBYTE(v19) = 6;
  if ( ppv && !InterlockedDecrement(&ppv->Length) )
  {
    if ( v8->bstr )
    {
      SysFreeString(v8->bstr);
      v8->bstr = 0;
    }
    if ( v8->hKey )
    {
      j_j__free(v8->hKey);
      v8->hKey = 0;
    }
    j__free(v8);
  }
  v9 = sub_1200790(a1, a2, psz, lpValueName, 0xFFFFFFFF);
  if ( ppComBSTR1 )
    v10 = ppComBSTR1->bstr;
  else
    v10 = 0;
  v11 = sub_1200790(a1, a2, v10, lpValueName, v9);
  v12 = ppComBSTR1;
  v13 = v11;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v12 )
  {
    if ( v12->bstr )
    {
      SysFreeString(v12->bstr);
      v12->bstr = 0;
    }
    if ( v12->hKey )
    {
      j_j__free(v12->hKey);
      v12->hKey = 0;
    }
    j__free(v12);
  }
  return v13;
}

//----- (01200790) --------------------------------------------------------
void *__cdecl sub_1200790(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, void *a5)
{
  void *v5; // edi
  const WCHAR *v6; // esi
  int v7; // ebx
  const wchar_t *v8; // eax
  WCHAR *v9; // eax
  const wchar_t *v10; // eax
  WCHAR *v11; // eax
  unsigned __int16 **v12; // esi
  unsigned __int16 **v13; // eax
  _WORD *v15; // eax
  wchar_t *v16; // edi
  DWORD v17; // eax
  _WORD *v18; // eax
  void *v19; // esi
  wchar_t *v20; // eax
  wchar_t *v21; // esi
  const wchar_t **v22; // eax
  wchar_t *v23; // ebx
  const wchar_t *v24; // ecx
  WCHAR *v25; // eax
  const wchar_t *v26; // eax
  WCHAR *v27; // eax
  unsigned __int16 **v28; // esi
  unsigned __int16 **v29; // eax
  char v30; // bl
  LPCWSTR v31; // ebx
  const wchar_t *v32; // eax
  WCHAR *v33; // eax
  const wchar_t *v34; // eax
  WCHAR *v35; // eax
  unsigned __int16 **v36; // esi
  unsigned __int16 **v37; // eax
  int v38; // ST34_4
  int v39; // esi
  WCHAR *v40; // eax
  WCHAR *v41; // eax
  unsigned __int16 **v42; // eax
  void *v43; // [esp+10h] [ebp-A4h]
  void *v44; // [esp+14h] [ebp-A0h]
  void *v45; // [esp+18h] [ebp-9Ch]
  void *v46; // [esp+1Ch] [ebp-98h]
  void *v47; // [esp+20h] [ebp-94h]
  int v48; // [esp+24h] [ebp-90h]
  void *v49; // [esp+28h] [ebp-8Ch]
  int v50; // [esp+2Ch] [ebp-88h]
  int v51; // [esp+30h] [ebp-84h]
  int v52; // [esp+34h] [ebp-80h]
  int v53; // [esp+38h] [ebp-7Ch]
  int v54; // [esp+3Ch] [ebp-78h]
  void *v55; // [esp+40h] [ebp-74h]
  void *v56; // [esp+44h] [ebp-70h]
  void *v57; // [esp+48h] [ebp-6Ch]
  void *v58; // [esp+4Ch] [ebp-68h]
  void *v59; // [esp+50h] [ebp-64h]
  void *v60; // [esp+54h] [ebp-60h]
  void *v61; // [esp+58h] [ebp-5Ch]
  void *v62; // [esp+5Ch] [ebp-58h]
  void *v63; // [esp+60h] [ebp-54h]
  void *v64; // [esp+64h] [ebp-50h]
  void *v65; // [esp+68h] [ebp-4Ch]
  void *v66; // [esp+6Ch] [ebp-48h]
  void *v67; // [esp+70h] [ebp-44h]
  HKEY hKey; // [esp+74h] [ebp-40h]
  void *v69; // [esp+78h] [ebp-3Ch]
  void *v70; // [esp+7Ch] [ebp-38h]
  void *v71; // [esp+80h] [ebp-34h]
  void *v72; // [esp+84h] [ebp-30h]
  void *v73; // [esp+88h] [ebp-2Ch]
  void *v74; // [esp+8Ch] [ebp-28h]
  void *v75; // [esp+90h] [ebp-24h]
  DWORD cbData; // [esp+94h] [ebp-20h]
  void *v77; // [esp+98h] [ebp-1Ch]
  void *v78; // [esp+9Ch] [ebp-18h]
  void *v79; // [esp+A0h] [ebp-14h]
  wchar_t *v80; // [esp+A4h] [ebp-10h]
  int v81; // [esp+B0h] [ebp-4h]

  v5 = a5;
  v6 = lpValueName;
  v7 = a1;
  if ( a5 == -1 )
  {
    v71 = _wcsdup(gpszTargetName);
    v81 = 0;
    v73 = _wcsdup(gpszTargetName);
    v70 = _wcsdup(gpszTargetName);
    v74 = _wcsdup(gpszTargetName);
    v72 = _wcsdup(gpszTargetName);
    v80 = _wcsdup(gpszTargetName);
    v8 = gpszTargetName;
    if ( lpValueName )
      v8 = lpValueName;
    v79 = _wcsdup(v8);
    v9 = gpszTargetName;
    if ( psz )
      v9 = psz;
    v78 = _wcsdup(v9);
    v10 = gpszTargetName;
    if ( lpValueName )
      v10 = lpValueName;
    v75 = _wcsdup(v10);
    v11 = gpszTargetName;
    if ( psz )
      v11 = psz;
    v77 = _wcsdup(v11);
    LOBYTE(v81) = 9;
    v12 = sub_11F7BE0(&v67, a2, &v78, &v79);
    LOBYTE(v81) = 10;
    v13 = sub_11F7BE0(&v69, a2, &v77, &v75);
    LOBYTE(v81) = 11;
    v5 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v13, v12, &v80);
    a5 = v5;
    free(v69);
    free(v67);
    free(v77);
    free(v75);
    free(v78);
    free(v79);
    free(v80);
    free(v72);
    free(v74);
    free(v70);
    free(v73);
    v81 = -1;
    free(v71);
    v6 = lpValueName;
  }
  hKey = 0;
  sub_11F67A0(a2, psz, 0, 131097, &hKey);
  if ( !hKey )
    return v5;
  cbData = 0;
  if ( !RegQueryValueExW(hKey, v6, 0, 0, 0, &cbData) )
  {
    v15 = malloc(2u);
    v78 = v15;
    *v15 = 0;
    v81 = 12;
    v16 = operator new[](2 * ((cbData >> 1) + 2));
    RegQueryValueExW(hKey, v6, 0, 0, v16, &cbData);
    v17 = cbData >> 1;
    cbData = v17;
    if ( v17 > 2 )
    {
      v16[v17 - 1] = 0;
      for ( v16[cbData] = 0; *v16; v16 = wcschr(v16 + 1, 0) + 1 )
      {
        v18 = malloc(2u);
        v50 = v18;
        *v18 = 0;
        v51 = 0;
        v52 = 0;
        v53 = 0;
        LOBYTE(v81) = 13;
        sub_11F6CC0(v16, &v50);
        v19 = v78;
        v78 = _wcsdup(v16);
        free(v19);
        sub_11F4EE0(&v80, v7, &v50, 0);
        v20 = v80;
        if ( v80 )
        {
          if ( !_wcsnicmp(v80, L"File not found: ", 0x10u) && !_wcsnicmp(v16, L"autocheck ", 0xAu) )
          {
            v21 = _wcsdup(v16);
            v54 = v21;
            LOBYTE(v81) = 15;
            sub_11F6CC0(v16 + 10, &v50);
            v22 = sub_11F4EE0(&v49, v7, &v50, 0);
            v23 = v80;
            v80 = _wcsdup(*v22);
            free(v23);
            free(v49);
            free(v21);
            v7 = a1;
          }
          v20 = v80;
        }
        if ( *v20 )
        {
          v79 = malloc(2u);
          *v79 = 0;
          v77 = malloc(2u);
          *v77 = 0;
          v75 = malloc(2u);
          *v75 = 0;
          LOBYTE(v81) = 18;
          v54 = sub_11F4ED0();
          v72 = _wcsdup(v16);
          v24 = gpszTargetName;
          if ( lpValueName )
            v24 = lpValueName;
          v74 = _wcsdup(v24);
          v25 = gpszTargetName;
          if ( psz )
            v25 = psz;
          v70 = _wcsdup(v25);
          v26 = gpszTargetName;
          if ( lpValueName )
            v26 = lpValueName;
          v73 = _wcsdup(v26);
          v27 = gpszTargetName;
          if ( psz )
            v27 = psz;
          v71 = _wcsdup(v27);
          LOBYTE(v81) = 23;
          v28 = sub_11F7BE0(&v43, a2, &v70, &v74);
          LOBYTE(v81) = 24;
          v29 = sub_11F7BE0(&v47, a2, &v71, &v73);
          LOBYTE(v81) = 25;
          v30 = sub_11F3D40(v7, v29, v28, &v72, &v80, &v79, &v75, &v48);
          free(v47);
          free(v43);
          free(v71);
          free(v73);
          free(v70);
          free(v74);
          free(v72);
          if ( v30 )
          {
            if ( a5 == -1 )
            {
              v58 = _wcsdup(gpszTargetName);
              v56 = _wcsdup(gpszTargetName);
              v60 = _wcsdup(gpszTargetName);
              v55 = _wcsdup(gpszTargetName);
              v66 = _wcsdup(gpszTargetName);
              v63 = _wcsdup(gpszTargetName);
              v31 = lpValueName;
              v32 = gpszTargetName;
              if ( lpValueName )
                v32 = lpValueName;
              v59 = _wcsdup(v32);
              v33 = gpszTargetName;
              if ( psz )
                v33 = psz;
              v64 = _wcsdup(v33);
              v34 = gpszTargetName;
              if ( lpValueName )
                v34 = lpValueName;
              v65 = _wcsdup(v34);
              v35 = gpszTargetName;
              if ( psz )
                v35 = psz;
              v57 = _wcsdup(v35);
              LOBYTE(v81) = 35;
              v36 = sub_11F7BE0(&v46, a2, &v64, &v59);
              LOBYTE(v81) = 36;
              v37 = sub_11F7BE0(&v44, a2, &v57, &v65);
              LOBYTE(v81) = 37;
              v38 = v36;
              v39 = a1;
              a5 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v37, v38, &v63);
              free(v44);
              free(v46);
              free(v57);
              free(v65);
              free(v64);
              free(v59);
              free(v63);
              free(v66);
              free(v55);
              free(v60);
              free(v56);
              free(v58);
            }
            else
            {
              v39 = a1;
              v31 = lpValueName;
            }
            v69 = _wcsdup(gpszTargetName);
            v40 = gpszTargetName;
            if ( v31 )
              v40 = v31;
            v67 = _wcsdup(v40);
            v41 = gpszTargetName;
            if ( psz )
              v41 = psz;
            v61 = _wcsdup(v41);
            v62 = _wcsdup(v16);
            LOBYTE(v81) = 41;
            v42 = sub_11F7BE0(&v45, a2, &v61, &v67);
            LOBYTE(v81) = 42;
            sub_11F3FF0(v39, v54, a5, 5, &v62, v42, &v80);
            free(v45);
            free(v62);
            free(v61);
            free(v67);
            free(v69);
          }
          free(v75);
          free(v77);
          free(v79);
          v20 = v80;
        }
        free(v20);
        LOBYTE(v81) = 12;
        sub_11F21F0(&v50);
        v7 = a1;
      }
    }
    free(v78);
  }
  RegCloseKey(hKey);
  return a5;
}

//----- (01200F50) --------------------------------------------------------
LPWSTR *__cdecl GetEnvironmentPathInfo(LPWSTR *ppsz, LPCWSTR lpSrc)
{
  DWORD dwLength; // eax
  DWORD v3; // edi
  WCHAR *ppv; // eax
  size_t dwAllocLength; // edi
  WCHAR *pszString; // eax
  DWORD nSize; // [esp+Ch] [ebp-4h]

  dwLength = ExpandEnvironmentStringsW(lpSrc, NULL, 0);
  v3 = dwLength;
  nSize = dwLength;
  ppv = malloc(2u);
  dwAllocLength = 2 * v3 + 2;
  *ppsz = ppv;
  *ppv = 0;
  pszString = realloc(*ppsz, dwAllocLength);
  *ppsz = pszString;
  if ( pszString )
    memset(pszString, 0, dwAllocLength);
  ExpandEnvironmentStringsW(lpSrc, *ppsz, nSize);
  return ppsz;
}

//----- (01200FC0) --------------------------------------------------------
HANDLE __cdecl sub_1200FC0(OLECHAR *psz, LPWIN32_FIND_DATAW lpFindFileData)
{
  void *v2; // esi
  const WCHAR *v3; // eax
  HANDLE v4; // edi
  void *v6; // [esp+8h] [ebp-4h]

  sub_11F7AB0(&dword_12E4C30, &v6, psz);
  v2 = v6;
  if ( v6 )
    v3 = *v6;
  else
    v3 = 0;
  v4 = FindFirstFileW(v3, lpFindFileData);
  if ( v2 && !InterlockedDecrement(v2 + 2) )
  {
    if ( *v2 )
    {
      SysFreeString(*v2);
      *v2 = 0;
    }
    if ( *(v2 + 1) )
    {
      j_j__free(*(v2 + 1));
      *(v2 + 1) = 0;
    }
    j__free(v2);
  }
  return v4;
}

//----- (01201040) --------------------------------------------------------
DWORD __cdecl sub_1201040(OLECHAR *psz)
{
  void *v1; // esi
  const WCHAR *v2; // eax
  DWORD v3; // edi
  void *v5; // [esp+8h] [ebp-4h]

  sub_11F7AB0(&dword_12E4C30, &v5, psz);
  v1 = v5;
  if ( v5 )
    v2 = *v5;
  else
    v2 = 0;
  v3 = GetFileAttributesW(v2);
  if ( v1 && !InterlockedDecrement(v1 + 2) )
  {
    if ( *v1 )
    {
      SysFreeString(*v1);
      *v1 = 0;
    }
    if ( *(v1 + 1) )
    {
      j_j__free(*(v1 + 1));
      *(v1 + 1) = 0;
    }
    j__free(v1);
  }
  return v3;
}

//----- (012010C0) --------------------------------------------------------
DWORD_PTR __cdecl sub_12010C0(OLECHAR *psz, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)
{
  void *v5; // esi
  const WCHAR *v6; // eax
  DWORD_PTR v7; // edi
  void *v9; // [esp+8h] [ebp-4h]

  sub_11F7AB0(&dword_12E4C30, &v9, psz);
  v5 = v9;
  if ( v9 )
    v6 = *v9;
  else
    v6 = 0;
  v7 = SHGetFileInfoW(v6, dwFileAttributes, psfi, cbFileInfo, uFlags);
  if ( v5 && !InterlockedDecrement(v5 + 2) )
  {
    if ( *v5 )
    {
      SysFreeString(*v5);
      *v5 = 0;
    }
    if ( *(v5 + 1) )
    {
      j_j__free(*(v5 + 1));
      *(v5 + 1) = 0;
    }
    j__free(v5);
  }
  return v7;
}

//----- (01201150) --------------------------------------------------------
bool __cdecl sub_1201150(int a1, wchar_t *a2, wchar_t *psz, int a4)
{
  int v4; // eax
  CComBSTR *v5; // esi
  const WCHAR *v6; // eax
  void *v7; // ebx
  bool v8; // bl
  WCHAR *v9; // ecx
  wchar_t *v10; // edi
  bool v11; // zf
  const wchar_t *v12; // esi
  wchar_t *v13; // ebx
  unsigned int v14; // ecx
  wchar_t *v15; // edx
  wchar_t v16; // ax
  size_t v17; // esi
  WCHAR *v18; // ecx
  wchar_t *v19; // ebx
  CComBSTR *v20; // esi
  const WCHAR *v21; // eax
  DWORD v22; // eax
  void *v24; // ebx
  CComBSTR *ppComBSTR; // [esp+14h] [ebp-18h]
  wchar_t *v26; // [esp+18h] [ebp-14h]
  wchar_t *v27; // [esp+1Ch] [ebp-10h]
  int v28; // [esp+28h] [ebp-4h]

  v4 = *psz;
  if ( v4 && psz[1] == 58 || v4 == 92 )
  {
    sub_11F7AB0(&dword_12E4C30, &ppComBSTR, psz);
    v5 = ppComBSTR;
    if ( ppComBSTR )
      v6 = ppComBSTR->bstr;
    else
      v6 = 0;
    ppComBSTR = GetFileAttributesW(v6);
    v7 = *a4;
    *a4 = _wcsdup(psz);
    free(v7);
    v8 = ppComBSTR != -1 && !(ppComBSTR & 0x10);
    if ( v5 && !InterlockedDecrement(&v5->Length) )
    {
      if ( v5->bstr )
      {
        SysFreeString(v5->bstr);
        v5->bstr = 0;
      }
      if ( v5->hKey )
      {
        j_j__free(v5->hKey);
        v5->hKey = 0;
      }
      j__free(v5);
    }
  }
  else
  {
    v9 = gpszTargetName;
    if ( a2 )
      v9 = a2;
    v10 = _wcsdup(v9);
    v11 = *v10 == 0;
    v12 = v10;
    v28 = 0;
    v27 = v10;
    if ( v11 )
    {
LABEL_42:
      v8 = 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = wcschr(v12, 0x3Bu);
        if ( v13 )
          *v13 = 0;
        v14 = wcslen(v12);
        v15 = psz;
        do
        {
          v16 = *v15;
          ++v15;
        }
        while ( v16 );
        v17 = v15 - (psz + 1) + v14 + 2;
        v26 = malloc(2 * v17);
        swprintf_s(v26, v17, L"%s\\%s", v27, psz);
        if ( v13 )
        {
          v18 = v13 + 1;
          *v13 = 59;
        }
        else
        {
          v18 = gpszTargetName;
        }
        v19 = v26;
        v27 = v18;
        sub_11F7AB0(&dword_12E4C30, &ppComBSTR, v26);
        v20 = ppComBSTR;
        v21 = ppComBSTR ? ppComBSTR->bstr : 0;
        v22 = GetFileAttributesW(v21);
        if ( v22 != -1 && !(v22 & 0x10) )
          break;
        free(v19);
        if ( v20 )
        {
          if ( !InterlockedDecrement(&v20->Length) )
          {
            if ( v20->bstr )
            {
              SysFreeString(v20->bstr);
              v20->bstr = 0;
            }
            if ( v20->hKey )
            {
              j_j__free(v20->hKey);
              v20->hKey = 0;
            }
            j__free(v20);
          }
          ppComBSTR = 0;
        }
        v12 = v27;
        if ( !*v27 )
          goto LABEL_42;
      }
      v24 = *a4;
      *a4 = _wcsdup(v26);
      free(v24);
      free(v26);
      bstr_t::Data_t::Free(&ppComBSTR);
      v8 = 1;
    }
    free(v10);
  }
  return v8;
}

//----- (012013D0) --------------------------------------------------------
LSTATUS __cdecl sub_12013D0(HKEY hKey, DWORD dwIndex, int a3)
{
  LSTATUS result; // eax
  DWORD v4; // eax
  size_t v5; // ebx
  void *v6; // eax
  DWORD cbMaxSubKeyLen; // [esp+0h] [ebp-4h]

  cbMaxSubKeyLen = 0;
  result = RegQueryInfoKeyW(hKey, 0, 0, 0, 0, &cbMaxSubKeyLen, 0, 0, 0, 0, 0, 0);
  if ( !result )
  {
    v4 = cbMaxSubKeyLen + 1;
    cbMaxSubKeyLen = v4;
    v5 = 2 * v4 + 2;
    v6 = realloc(*a3, v5);
    *a3 = v6;
    if ( v6 )
      memset(v6, 0, v5);
    result = RegEnumKeyW(hKey, dwIndex, *a3, cbMaxSubKeyLen);
  }
  return result;
}

//----- (01201450) --------------------------------------------------------
LSTATUS __cdecl sub_1201450(HKEY hKey, DWORD dwIndex, int a3, LPDWORD lpReserved, LPDWORD lpType, int a6)
{
  LSTATUS result; // eax
  size_t v7; // esi
  void *v8; // eax
  size_t v9; // esi
  void *v10; // eax
  DWORD cbMaxValueLen; // [esp+0h] [ebp-8h]
  DWORD cbMaxValueNameLen; // [esp+4h] [ebp-4h]

  cbMaxValueNameLen = 0;
  cbMaxValueLen = 0;
  result = RegQueryInfoKeyW(hKey, 0, 0, 0, 0, 0, 0, 0, &cbMaxValueNameLen, &cbMaxValueLen, 0, 0);
  if ( !result )
  {
    v7 = 2 * (cbMaxValueNameLen++ + 1) + 2;
    v8 = realloc(*a3, v7);
    *a3 = v8;
    if ( v8 )
      memset(v8, 0, v7);
    v9 = 2 * (((cbMaxValueLen + 1) >> 1) + 1);
    v10 = realloc(*a6, 2 * (((cbMaxValueLen + 1) >> 1) + 1));
    *a6 = v10;
    if ( v10 )
      memset(v10, 0, v9);
    result = RegEnumValueW(hKey, dwIndex, *a3, &cbMaxValueNameLen, lpReserved, lpType, *a6, &cbMaxValueLen);
  }
  return result;
}

//----- (01201520) --------------------------------------------------------
LSTATUS __cdecl sub_1201520(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, int a5)
{
  LSTATUS result; // eax
  void *v6; // eax
  DWORD v7; // [esp+0h] [ebp-8h]
  DWORD cbData; // [esp+4h] [ebp-4h]

  cbData = 0;
  result = RegQueryValueExW(hKey, lpValueName, lpReserved, 0, 0, &cbData);
  if ( !result )
  {
    v7 = 2 * (((cbData + 1) >> 1) + 1);
    v6 = realloc(*a5, 2 * (((cbData + 1) >> 1) + 1));
    *a5 = v6;
    if ( v6 )
      memset(v6, 0, v7);
    result = RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, *a5, &cbData);
  }
  return result;
}

//----- (012015A0) --------------------------------------------------------
LSTATUS __cdecl sub_12015A0(HKEY hKey, LPCWSTR lpSubKey, int a3)
{
  LSTATUS result; // eax
  void *v4; // eax
  unsigned int v5; // [esp+0h] [ebp-8h]
  LONG cbData; // [esp+4h] [ebp-4h]

  cbData = 0;
  result = RegQueryValueW(hKey, lpSubKey, 0, &cbData);
  if ( !result )
  {
    v5 = 2 * (((cbData + 1) >> 1) + 1);
    v4 = realloc(*a3, 2 * (((cbData + 1) >> 1) + 1));
    *a3 = v4;
    if ( v4 )
      memset(v4, 0, v5);
    result = RegQueryValueW(hKey, lpSubKey, *a3, &cbData);
  }
  return result;
}

//----- (01201610) --------------------------------------------------------
void *__cdecl sub_1201610(int a1, void *a2, wchar_t *psz)
{
  DWORD v3; // ebx
  wchar_t *v4; // eax
  wchar_t *v5; // eax
  _WORD *v6; // eax
  _WORD *v7; // eax
  _WORD *v8; // eax
  _WORD *v9; // eax
  _WORD *v10; // eax
  _WORD *v11; // eax
  WCHAR *v12; // eax
  WCHAR *v13; // eax
  unsigned __int16 **v14; // esi
  unsigned __int16 **v15; // eax
  void *v16; // esi
  LSTATUS (__stdcall *v17)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // esi
  LSTATUS v18; // eax
  void *v19; // esi
  int v20; // eax
  const wchar_t **v21; // eax
  wchar_t *v22; // esi
  const wchar_t **v23; // eax
  void *v24; // esi
  HMODULE v25; // eax
  FARPROC v26; // eax
  size_t v27; // esi
  void *v28; // eax
  void *v29; // esi
  WCHAR *v30; // eax
  WCHAR *v31; // eax
  unsigned __int16 **v32; // esi
  unsigned __int16 **v33; // eax
  char v34; // bl
  WCHAR *v35; // eax
  WCHAR *v36; // eax
  unsigned __int16 **v37; // esi
  unsigned __int16 **v38; // eax
  WCHAR *v39; // eax
  unsigned __int16 **v40; // eax
  BYTE v42; // [esp+10h] [ebp-2C4h]
  void *v43; // [esp+14h] [ebp-2C0h]
  BYTE v44[4]; // [esp+18h] [ebp-2BCh]
  BYTE Data[4]; // [esp+1Ch] [ebp-2B8h]
  void *v46; // [esp+20h] [ebp-2B4h]
  void *v47; // [esp+24h] [ebp-2B0h]
  int v48; // [esp+28h] [ebp-2ACh]
  void *v49; // [esp+2Ch] [ebp-2A8h]
  int v50; // [esp+30h] [ebp-2A4h]
  void *v51; // [esp+34h] [ebp-2A0h]
  void *v52; // [esp+38h] [ebp-29Ch]
  void *v53; // [esp+3Ch] [ebp-298h]
  void *v54; // [esp+40h] [ebp-294h]
  void *v55; // [esp+44h] [ebp-290h]
  void *v56; // [esp+48h] [ebp-28Ch]
  void *v57; // [esp+4Ch] [ebp-288h]
  void *v58; // [esp+50h] [ebp-284h]
  void *v59; // [esp+54h] [ebp-280h]
  void *v60; // [esp+58h] [ebp-27Ch]
  void *v61; // [esp+5Ch] [ebp-278h]
  void *v62; // [esp+60h] [ebp-274h]
  HKEY v63; // [esp+64h] [ebp-270h]
  DWORD v64; // [esp+68h] [ebp-26Ch]
  void *v65; // [esp+6Ch] [ebp-268h]
  void *v66; // [esp+70h] [ebp-264h]
  void *v67; // [esp+74h] [ebp-260h]
  void *v68; // [esp+78h] [ebp-25Ch]
  void *v69; // [esp+7Ch] [ebp-258h]
  void *v70; // [esp+80h] [ebp-254h]
  void *v71; // [esp+84h] [ebp-250h]
  void *v72; // [esp+88h] [ebp-24Ch]
  void *v73; // [esp+8Ch] [ebp-248h]
  void *v74; // [esp+90h] [ebp-244h]
  void *v75; // [esp+94h] [ebp-240h]
  int v76; // [esp+98h] [ebp-23Ch]
  void *v77; // [esp+9Ch] [ebp-238h]
  wchar_t *v78; // [esp+A0h] [ebp-234h]
  void *v79; // [esp+A4h] [ebp-230h]
  void *v80; // [esp+A8h] [ebp-22Ch]
  DWORD cbData; // [esp+ACh] [ebp-228h]
  void *v82; // [esp+B0h] [ebp-224h]
  HKEY hKey; // [esp+B4h] [ebp-220h]
  wchar_t *v84; // [esp+B8h] [ebp-21Ch]
  wchar_t Src; // [esp+BCh] [ebp-218h]
  int v86; // [esp+2D0h] [ebp-4h]

  v3 = 0;
  v76 = a1;
  v80 = a2;
  v64 = 0;
  v4 = malloc(2u);
  v78 = v4;
  *v4 = 0;
  v86 = 0;
  v5 = malloc(2u);
  v84 = v5;
  *v5 = 0;
  v6 = malloc(2u);
  v69 = v6;
  *v6 = 0;
  v7 = malloc(2u);
  v79 = v7;
  *v7 = 0;
  v8 = malloc(2u);
  v60 = v8;
  *v8 = 0;
  v9 = malloc(2u);
  v82 = v9;
  *v9 = 0;
  v10 = malloc(2u);
  v58 = v10;
  *v10 = 0;
  v11 = malloc(2u);
  v77 = v11;
  *v11 = 0;
  v72 = _wcsdup(gpszTargetName);
  v65 = _wcsdup(gpszTargetName);
  v67 = _wcsdup(gpszTargetName);
  v75 = _wcsdup(gpszTargetName);
  v71 = _wcsdup(gpszTargetName);
  v74 = _wcsdup(gpszTargetName);
  v73 = _wcsdup(gpszTargetName);
  v12 = gpszTargetName;
  if ( psz )
    v12 = psz;
  v66 = _wcsdup(v12);
  v70 = _wcsdup(gpszTargetName);
  v13 = gpszTargetName;
  if ( psz )
    v13 = psz;
  v68 = _wcsdup(v13);
  LOBYTE(v86) = 17;
  v14 = sub_11F7BE0(&v59, a2, &v66, &v73);
  LOBYTE(v86) = 18;
  v15 = sub_11F7BE0(&v62, v80, &v68, &v70);
  LOBYTE(v86) = 19;
  v16 = sub_11F3FF0(v76, 0, 0xFFFFFFFF, 0, v15, v14, &v74);
  v61 = v16;
  free(v62);
  free(v59);
  free(v68);
  free(v70);
  free(v66);
  free(v73);
  free(v74);
  free(v71);
  free(v75);
  free(v67);
  free(v65);
  LOBYTE(v86) = 7;
  free(v72);
  if ( !sub_11F67A0(ghKLM, psz, 0, 131097, &v63) )
  {
    if ( !sub_12013D0(v63, 0, &v84) )
    {
      v17 = RegQueryValueExW;
      do
      {
        if ( !sub_11F67A0(v63, v84, 0, 131097, &hKey) )
        {
          cbData = 4;
          if ( !v17(hKey, L"Type", 0, 0, Data, &cbData) && *Data <= 2u )
          {
            cbData = 4;
            if ( !v17(hKey, L"Start", 0, 0, v44, &cbData) )
            {
              cbData = 4;
              if ( *v44 != 4 || !v17(hKey, L"AutorunsDisabled", 0, 0, &v42, &cbData) )
              {
                v18 = sub_1201520(hKey, L"ImagePath", 0, 0, &v78);
                v19 = v77;
                if ( v18 )
                {
                  v77 = _wcsdup(v84);
                  free(v19);
                  v20 = sub_120F210(&v51, L"\\SystemRoot\\System32\\Drivers\\", &v84);
                  v21 = sub_11F22B0(&v47, v20, L".sys");
                  v22 = v78;
                  v78 = _wcsdup(*v21);
                  free(v22);
                  free(v47);
                  free(v51);
                }
                else
                {
                  v77 = _wcsdup(v78);
                  free(v19);
                }
                v23 = sub_11F4F20(&v43, v76, v78);
                v24 = v79;
                v79 = _wcsdup(*v23);
                free(v24);
                free(v43);
                v48 = sub_11F4ED0();
                sub_1201520(hKey, L"Description", 0, 0, &v82);
                if ( *v82 == 64 )
                {
                  v25 = LoadLibraryW(L"Advapi32.dll");
                  v26 = GetProcAddress(v25, "RegLoadMUIStringW");
                  RegLoadMUIStringW = v26;
                  if ( v26 )
                  {
                    if ( !(v26)(hKey, L"Description", &Src, 260, &cbData, 0, 0) )
                    {
                      v27 = 2 * cbData + 4;
                      v28 = realloc(v82, v27);
                      v82 = v28;
                      if ( v28 )
                      {
                        memset(v28, 0, v27);
                        v28 = v82;
                      }
                      sub_11F47C0(&Src, v28, cbData + 1);
                    }
                  }
                }
                v29 = v69;
                v69 = _wcsdup(v84);
                free(v29);
                v30 = gpszTargetName;
                if ( psz )
                  v30 = psz;
                v67 = _wcsdup(v30);
                v65 = _wcsdup(gpszTargetName);
                v31 = gpszTargetName;
                if ( psz )
                  v31 = psz;
                v72 = _wcsdup(v31);
                LOBYTE(v86) = 22;
                v32 = sub_11F7BE0(&v54, v80, &v67, &v84);
                LOBYTE(v86) = 23;
                v33 = sub_11F7BE0(&v49, v80, &v72, &v65);
                LOBYTE(v86) = 24;
                v34 = sub_11F3D40(v76, v33, v32, &v69, &v79, &v60, &v58, &v50);
                free(v49);
                free(v54);
                free(v72);
                free(v65);
                LOBYTE(v86) = 7;
                free(v67);
                if ( v34 )
                {
                  if ( v61 == -1 )
                  {
                    v57 = _wcsdup(gpszTargetName);
                    v56 = _wcsdup(gpszTargetName);
                    v55 = _wcsdup(gpszTargetName);
                    v68 = _wcsdup(gpszTargetName);
                    v70 = _wcsdup(gpszTargetName);
                    v66 = _wcsdup(gpszTargetName);
                    v73 = _wcsdup(gpszTargetName);
                    v35 = gpszTargetName;
                    if ( psz )
                      v35 = psz;
                    v74 = _wcsdup(v35);
                    v71 = _wcsdup(gpszTargetName);
                    v36 = gpszTargetName;
                    if ( psz )
                      v36 = psz;
                    v75 = _wcsdup(v36);
                    LOBYTE(v86) = 34;
                    v37 = sub_11F7BE0(&v52, v80, &v74, &v73);
                    LOBYTE(v86) = 35;
                    v38 = sub_11F7BE0(&v53, v80, &v75, &v71);
                    LOBYTE(v86) = 36;
                    v61 = sub_11F3FF0(v76, 0, 0xFFFFFFFF, 0, v38, v37, &v66);
                    free(v53);
                    free(v52);
                    free(v75);
                    free(v71);
                    free(v74);
                    free(v73);
                    free(v66);
                    free(v70);
                    free(v68);
                    free(v55);
                    free(v56);
                    free(v57);
                  }
                  v62 = _wcsdup(gpszTargetName);
                  v39 = gpszTargetName;
                  if ( psz )
                    v39 = psz;
                  v59 = _wcsdup(v39);
                  LOBYTE(v86) = 38;
                  v40 = sub_11F7BE0(&v46, v80, &v59, &v84);
                  LOBYTE(v86) = 39;
                  sub_11F3FF0(v76, v48, v61, 13, &v69, v40, &v79);
                  free(v46);
                  free(v59);
                  LOBYTE(v86) = 7;
                  free(v62);
                }
                v17 = RegQueryValueExW;
                v3 = v64;
              }
            }
          }
          RegCloseKey(hKey);
        }
        v64 = ++v3;
      }
      while ( !sub_12013D0(v63, v3, &v84) );
      v16 = v61;
    }
    RegCloseKey(v63);
  }
  free(v77);
  free(v58);
  free(v82);
  free(v60);
  free(v79);
  free(v69);
  free(v84);
  free(v78);
  return v16;
}
// 12E4C4C: using guessed type int RegLoadMUIStringW;

//----- (01202060) --------------------------------------------------------
void *__cdecl sub_1202060(int a1, int a2, int *a3)
{
  void *v3; // eax

  v3 = sub_1202090(a1, a2, *a3, 0xFFFFFFFF, 1);
  return sub_1202090(a1, a2, *a3, v3, 0);
}

//----- (01202090) --------------------------------------------------------
void *__cdecl sub_1202090(int a1, int a2, int a3, void *a4, char a5)
{
  wchar_t *v5; // edi
  const wchar_t *v6; // ecx
  WCHAR *v7; // eax
  wchar_t *v8; // esi
  int v9; // eax
  const wchar_t **v10; // eax
  void *v11; // ebx
  OLECHAR *v12; // ebx
  unsigned int v13; // eax
  void (__stdcall *v14)(HKEY); // esi
  char *v15; // ebx
  _WORD *v16; // eax
  WCHAR *v17; // eax
  WCHAR *v18; // esi
  _WORD *v19; // eax
  WCHAR *v20; // eax
  WCHAR *v21; // edi
  WCHAR *v22; // ebx
  const wchar_t **v23; // eax
  unsigned __int16 **v24; // eax
  const wchar_t **v25; // eax
  unsigned __int16 **v26; // eax
  WCHAR *v27; // ebx
  int v28; // ebx
  const wchar_t **v29; // eax
  int v30; // ebx
  void **v31; // ebx
  void **v32; // esi
  unsigned int v33; // eax
  LSTATUS v34; // eax
  OLECHAR *v35; // esi
  unsigned int v36; // eax
  void *v37; // esi
  wchar_t *v38; // eax
  void *v39; // esi
  OLECHAR *v40; // esi
  unsigned int v41; // eax
  LSTATUS v42; // eax
  int v43; // ebx
  OLECHAR *v44; // esi
  unsigned int v45; // eax
  int v46; // eax
  const wchar_t **v47; // eax
  unsigned __int16 **v48; // eax
  const wchar_t **v49; // eax
  unsigned __int16 **v50; // eax
  wchar_t *v51; // esi
  const wchar_t **v52; // eax
  WCHAR *v53; // esi
  void **v54; // ecx
  const wchar_t **v55; // eax
  WCHAR *v56; // esi
  const wchar_t **v57; // eax
  unsigned __int16 **v58; // eax
  const wchar_t **v59; // eax
  unsigned __int16 **v60; // eax
  void *v61; // esi
  int v63; // [esp+10h] [ebp-118h]
  int v64; // [esp+20h] [ebp-108h]
  HKEY v65; // [esp+24h] [ebp-104h]
  wchar_t *v66; // [esp+28h] [ebp-100h]
  void *v67; // [esp+2Ch] [ebp-FCh]
  int v68; // [esp+30h] [ebp-F8h]
  void *v69; // [esp+34h] [ebp-F4h]
  void *v70; // [esp+38h] [ebp-F0h]
  HKEY v71; // [esp+3Ch] [ebp-ECh]
  void *v72; // [esp+40h] [ebp-E8h]
  void *v73; // [esp+44h] [ebp-E4h]
  wchar_t *psz; // [esp+48h] [ebp-E0h]
  void *v75; // [esp+4Ch] [ebp-DCh]
  void *v76; // [esp+50h] [ebp-D8h]
  void **v77; // [esp+54h] [ebp-D4h]
  int v78; // [esp+58h] [ebp-D0h]
  void *v79; // [esp+5Ch] [ebp-CCh]
  HKEY v80; // [esp+60h] [ebp-C8h]
  void *v81; // [esp+64h] [ebp-C4h]
  void *v82; // [esp+68h] [ebp-C0h]
  void *v83; // [esp+6Ch] [ebp-BCh]
  void *v84; // [esp+70h] [ebp-B8h]
  void *v85; // [esp+74h] [ebp-B4h]
  OLECHAR *v86; // [esp+78h] [ebp-B0h]
  void *v87; // [esp+7Ch] [ebp-ACh]
  void *v88; // [esp+80h] [ebp-A8h]
  int v89; // [esp+84h] [ebp-A4h]
  void *v90; // [esp+88h] [ebp-A0h]
  void *v91; // [esp+8Ch] [ebp-9Ch]
  void *v92; // [esp+90h] [ebp-98h]
  void *v93; // [esp+94h] [ebp-94h]
  void *v94; // [esp+98h] [ebp-90h]
  void *v95; // [esp+9Ch] [ebp-8Ch]
  void *v96; // [esp+A0h] [ebp-88h]
  void *v97; // [esp+A4h] [ebp-84h]
  void *v98; // [esp+A8h] [ebp-80h]
  void *v99; // [esp+ACh] [ebp-7Ch]
  void *v100; // [esp+B0h] [ebp-78h]
  void *v101; // [esp+B4h] [ebp-74h]
  void *v102; // [esp+B8h] [ebp-70h]
  OLECHAR *v103; // [esp+BCh] [ebp-6Ch]
  void *v104; // [esp+C0h] [ebp-68h]
  HKEY hKey; // [esp+C4h] [ebp-64h]
  LPCWSTR lpAppName; // [esp+C8h] [ebp-60h]
  void *v107; // [esp+CCh] [ebp-5Ch]
  LPCWSTR v108; // [esp+D0h] [ebp-58h]
  void *v109; // [esp+D4h] [ebp-54h]
  LPCWSTR lpFileName; // [esp+D8h] [ebp-50h]
  WCHAR KeyName; // [esp+DCh] [ebp-4Ch]
  int v112; // [esp+124h] [ebp-4h]

  v89 = a1;
  v91 = a2;
  psz = a3;
  hKey = 0;
  v108 = malloc(2u);
  *v108 = 0;
  v112 = 0;
  v5 = malloc(2u);
  v66 = v5;
  *v5 = 0;
  v107 = malloc(2u);
  *v107 = 0;
  lpAppName = malloc(2u);
  *lpAppName = 0;
  v86 = malloc(2u);
  *v86 = 0;
  v79 = malloc(2u);
  *v79 = 0;
  v104 = malloc(2u);
  *v104 = 0;
  v93 = malloc(2u);
  *v93 = 0;
  v98 = malloc(2u);
  *v98 = 0;
  v88 = malloc(2u);
  *v88 = 0;
  v96 = malloc(2u);
  v103 = v96;
  *v96 = 0;
  v90 = malloc(2u);
  *v90 = 0;
  v6 = L"HKCU";
  LOBYTE(v112) = 11;
  if ( a2 != ghKCU )
    v6 = L"HKLM";
  v7 = gpszTargetName;
  if ( v6 )
    v7 = v6;
  v8 = _wcsdup(v7);
  v100 = v8;
  v9 = sub_11F22B0(&v94, &v100, L"\\");
  v10 = sub_11F22B0(&v97, v9, psz);
  v11 = v107;
  v107 = _wcsdup(*v10);
  free(v11);
  free(v97);
  free(v94);
  free(v8);
  if ( a4 == -1 )
  {
    v102 = _wcsdup(gpszTargetName);
    v101 = _wcsdup(gpszTargetName);
    v95 = _wcsdup(gpszTargetName);
    v99 = _wcsdup(gpszTargetName);
    lpFileName = _wcsdup(gpszTargetName);
    v109 = _wcsdup(gpszTargetName);
    LOBYTE(v112) = 17;
    a4 = sub_11F3FF0(v89, 0, 0xFFFFFFFF, 0, &v107, &v107, &v109);
    free(v109);
    free(lpFileName);
    free(v99);
    free(v95);
    free(v101);
    LOBYTE(v112) = 11;
    free(v102);
  }
  v12 = _wcsdup(psz);
  v103 = v12;
  free(v96);
  if ( !a5 )
  {
    sub_11F2300(&v103, L"\\AutorunsDisabled", 0x7FFFFFFF, 0);
    v12 = v103;
  }
  v13 = TlsGetValue(gdwTlsIndex);
  v14 = RegCloseKey;
  if ( !sub_11F67A0(v91, v12, 0, v13 | 0x20019, &hKey) )
  {
    v100 = 0;
    if ( !sub_1201450(hKey, 0, &lpAppName, 0, 0, &v104) )
    {
      do
      {
        sub_11F22B0(&lpFileName, &v104, L"\\Scripts.Ini");
        if ( GetFileAttributesW(lpFileName) == -1 )
        {
          LOBYTE(v112) = 11;
          free(lpFileName);
        }
        else
        {
          v15 = 0;
          while ( 1 )
          {
            v97 = v15;
            _swprintf(&KeyName, L"%dCmdLine", v15);
            v16 = malloc(2u);
            *v16 = 0;
            v17 = realloc(v16, 0x412u);
            v18 = v17;
            v94 = v17;
            if ( v17 )
              memset(v17, 0, 0x412u);
            v84 = GetPrivateProfileStringW(lpAppName, &KeyName, gpszTargetName, v18, 0x208u, lpFileName);
            if ( !v84 )
              break;
            _swprintf(&KeyName, L"%dParameters", v15);
            v19 = malloc(2u);
            *v19 = 0;
            v20 = realloc(v19, 0x412u);
            v21 = v20;
            v82 = v20;
            if ( v20 )
              memset(v20, 0, 0x412u);
            GetPrivateProfileStringW(lpAppName, &KeyName, gpszTargetName, v21, 0x208u, lpFileName);
            if ( v84 > 2 && (!wcsncmp(v18, L"\\\\", 2u) || v18[1] == 58) )
            {
              v22 = v108;
              v108 = _wcsdup(v18);
              free(v22);
            }
            else
            {
              v23 = sub_11F22B0(&v72, &v104, L"\\");
              v24 = sub_1203070(&v70, v23, &lpAppName);
              v25 = sub_11F22B0(&v73, v24, L"\\");
              v26 = sub_1203070(&v67, v25, &v94);
              v27 = v108;
              v108 = _wcsdup(*v26);
              free(v27);
              free(v67);
              free(v73);
              free(v70);
              free(v72);
            }
            if ( GetFileAttributesW(v108) == -1 )
            {
              free(v21);
              free(v18);
              v15 = v97 + 1;
            }
            else
            {
              v75 = malloc(2u);
              *v75 = 0;
              v76 = 0;
              v77 = 0;
              v78 = 0;
              LOBYTE(v112) = 21;
              sub_11F7040(v108, &v75);
              v28 = v89;
              sub_11F4EE0(&v109, v89, &v75, 0);
              LOBYTE(v112) = 22;
              v84 = sub_11F4ED0();
              v29 = sub_11F22B0(&v69, &v108, L" ");
              sub_1203070(&v96, v29, &v82);
              free(v69);
              v102 = _wcsdup(&KeyName);
              LOBYTE(v112) = 24;
              LOBYTE(v28) = sub_11F3D40(v28, &v107, &v102, &v96, &v109, &v98, &v90, &v68);
              free(v102);
              if ( v28 )
              {
                if ( a4 == -1 )
                {
                  v85 = _wcsdup(gpszTargetName);
                  v83 = _wcsdup(gpszTargetName);
                  v87 = _wcsdup(gpszTargetName);
                  v99 = _wcsdup(gpszTargetName);
                  v95 = _wcsdup(gpszTargetName);
                  v101 = _wcsdup(gpszTargetName);
                  v30 = v89;
                  LOBYTE(v112) = 30;
                  a4 = sub_11F3FF0(v89, 0, 0xFFFFFFFF, 0, &v107, &v107, &v101);
                  free(v101);
                  free(v95);
                  free(v99);
                  free(v87);
                  free(v83);
                  free(v85);
                }
                else
                {
                  v30 = v89;
                }
                v92 = _wcsdup(gpszTargetName);
                v81 = _wcsdup(&KeyName);
                LOBYTE(v112) = 32;
                sub_11F3FF0(v30, v84, a4, 10, &v81, &v108, &v109);
                free(v81);
                free(v92);
              }
              free(v96);
              free(v109);
              v31 = v76;
              if ( v76 )
              {
                if ( v76 != v77 )
                {
                  v32 = v77;
                  do
                  {
                    free(*v31);
                    ++v31;
                  }
                  while ( v31 != v32 );
                  v31 = v76;
                  v18 = v94;
                }
                j__free(v31);
                v76 = 0;
                v77 = 0;
                v78 = 0;
              }
              free(v75);
              free(v21);
              free(v18);
              v15 = v97 + 1;
            }
          }
          free(v18);
          LOBYTE(v112) = 11;
          free(lpFileName);
        }
        v100 = v100 + 1;
      }
      while ( !sub_1201450(hKey, v100, &lpAppName, 0, 0, &v104) );
      v12 = v103;
      v5 = v66;
      v14 = RegCloseKey;
    }
    v14(hKey);
  }
  v33 = TlsGetValue(gdwTlsIndex);
  if ( sub_11F67A0(v91, psz, 0, v33 | 0x20019, &hKey) )
    goto LABEL_74;
  v87 = 0;
  v34 = sub_12013D0(hKey, 0, &lpAppName);
  if ( v34 == 259 )
    goto LABEL_73;
  while ( !v34 )
  {
    v35 = lpAppName;
    v36 = TlsGetValue(gdwTlsIndex);
    if ( !sub_11F67A0(hKey, v35, 0, v36 | 0x20019, &v71) )
    {
      v109 = malloc(2u);
      *v109 = 0;
      LOBYTE(v112) = 33;
      if ( sub_1201520(v71, L"DisplayName", 0, 0, &v109) )
        goto LABEL_69;
      v37 = v93;
      v93 = _wcsdup(gpszTargetName);
      free(v37);
      sub_1201520(v71, L"FileSysPath", 0, 0, &v93);
      v38 = wcsrchr(psz, 0x5Cu);
      v39 = v79;
      v79 = _wcsdup(v38);
      free(v39);
      v40 = v12;
      v12 = _wcsdup(lpAppName);
      v103 = v12;
      free(v40);
      if ( !a5 )
      {
        sub_11F2300(&v103, L"\\AutorunsDisabled", 0x7FFFFFFF, 0);
        v12 = v103;
      }
      v41 = TlsGetValue(gdwTlsIndex);
      if ( !sub_11F67A0(hKey, v12, 0, v41 | 0x20019, &v80) )
      {
        v83 = 0;
        v42 = sub_12013D0(v80, 0, &v86);
        if ( v42 != 259 )
        {
          v43 = v89;
          do
          {
            if ( v42 )
              break;
            v44 = v86;
            v45 = TlsGetValue(gdwTlsIndex);
            if ( !sub_11F67A0(v80, v44, 0, v45 | 0x20019, &v65) )
            {
              if ( !sub_1201520(v65, L"Script", 0, 0, &v108) )
              {
                lpFileName = malloc(2u);
                *lpFileName = 0;
                if ( *v93 && *v108 != 92 && v108[1] != 58 )
                {
                  v46 = sub_11F22B0(&v73, &v93, L"\\");
                  v47 = sub_11F22B0(&v70, v46, L"Scripts");
                  v48 = sub_1203070(&v72, v47, &v79);
                  v49 = sub_11F22B0(&v82, v48, L"\\");
                  v50 = sub_1203070(&v69, v49, &v108);
                  v51 = v5;
                  v5 = _wcsdup(*v50);
                  v66 = v5;
                  free(v51);
                  free(v69);
                  free(v82);
                  free(v72);
                  free(v70);
                  free(v73);
                  sub_11F2170(&v63);
                  LOBYTE(v112) = 35;
                  sub_11F7040(v5, &v63);
                  v52 = sub_11F4EE0(&v67, v43, &v63, 0);
                  v53 = lpFileName;
                  lpFileName = _wcsdup(*v52);
                  free(v53);
                  free(v67);
                  v54 = &v63;
                }
                else
                {
                  v75 = malloc(2u);
                  *v75 = 0;
                  v76 = 0;
                  v77 = 0;
                  v78 = 0;
                  LOBYTE(v112) = 36;
                  sub_11F7040(v108, &v75);
                  v55 = sub_11F4EE0(&v84, v43, &v75, 0);
                  v56 = lpFileName;
                  lpFileName = _wcsdup(*v55);
                  free(v56);
                  free(v84);
                  v54 = &v75;
                }
                LOBYTE(v112) = 34;
                sub_11F21F0(v54);
                v64 = sub_11F4ED0();
                v57 = sub_11F22B0(&v99, &v107, L"\\");
                v58 = sub_1203070(&v95, v57, &lpAppName);
                v59 = sub_11F22B0(&v101, v58, L"\\");
                v60 = sub_1203070(&v102, v59, &v86);
                v61 = v104;
                v104 = _wcsdup(*v60);
                free(v61);
                free(v102);
                free(v101);
                free(v95);
                free(v99);
                if ( sub_11F3D40(v43, &v107, &v104, &v109, &lpFileName, &v98, &v90, &v68) )
                {
                  if ( a4 == -1 )
                  {
                    v92 = _wcsdup(gpszTargetName);
                    v96 = _wcsdup(gpszTargetName);
                    v94 = _wcsdup(gpszTargetName);
                    v97 = _wcsdup(gpszTargetName);
                    v100 = _wcsdup(gpszTargetName);
                    v91 = _wcsdup(gpszTargetName);
                    LOBYTE(v112) = 42;
                    a4 = sub_11F3FF0(v43, 0, 0xFFFFFFFF, 0, &v107, &v107, &v91);
                    free(v91);
                    free(v100);
                    free(v97);
                    free(v94);
                    free(v96);
                    free(v92);
                  }
                  v85 = _wcsdup(gpszTargetName);
                  v81 = _wcsdup(gpszTargetName);
                  LOBYTE(v112) = 44;
                  sub_11F3FF0(v43, v64, a4, 3, &v109, &v104, &lpFileName);
                  free(v81);
                  free(v85);
                }
                LOBYTE(v112) = 33;
                free(lpFileName);
              }
              RegCloseKey(v65);
            }
            v83 = v83 + 1;
            v42 = sub_12013D0(v80, v83, &v86);
          }
          while ( v42 != 259 );
          v12 = v103;
        }
        RegCloseKey(v80);
LABEL_69:
        RegCloseKey(v71);
      }
      LOBYTE(v112) = 11;
      free(v109);
    }
    v87 = v87 + 1;
    v34 = sub_12013D0(hKey, v87, &lpAppName);
    if ( v34 == 259 )
      break;
  }
  v14 = RegCloseKey;
LABEL_73:
  v14(hKey);
LABEL_74:
  free(v90);
  free(v12);
  free(v88);
  free(v98);
  free(v93);
  free(v104);
  free(v79);
  free(v86);
  free(lpAppName);
  free(v107);
  free(v5);
  free(v108);
  return a4;
}

//----- (01203070) --------------------------------------------------------
unsigned __int16 **__cdecl sub_1203070(unsigned __int16 **a1, const wchar_t **a2, void **a3)
{
  *a1 = _wcsdup(*a2);
  sub_11F2300(a1, *a3, 0x7FFFFFFF, 0);
  return a1;
}

//----- (012030B0) --------------------------------------------------------
void __cdecl sub_12030B0(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_1203160(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_1203160(a1, a2, v7, v5);
  free(v7);
}

//----- (01203160) --------------------------------------------------------
void *__cdecl sub_1203160(int a1, void *a2, wchar_t *psz, void *a4)
{
  WCHAR *v4; // eax
  WCHAR *v5; // eax
  unsigned __int16 **v6; // esi
  unsigned __int16 **v7; // eax
  unsigned int v8; // eax
  void (__stdcall *v9)(HKEY); // ebx
  OLECHAR *v10; // esi
  unsigned int v11; // eax
  int v12; // eax
  const wchar_t **v13; // eax
  wchar_t *v14; // esi
  const wchar_t **v15; // eax
  void *v16; // esi
  OLECHAR *v17; // esi
  unsigned int v18; // eax
  wchar_t *v19; // esi
  const wchar_t **v20; // eax
  void *v21; // esi
  WCHAR *v22; // ecx
  WCHAR *v23; // eax
  unsigned __int16 **v24; // esi
  unsigned __int16 **v25; // eax
  char v26; // bl
  WCHAR *v27; // eax
  WCHAR *v28; // eax
  void *v29; // ebx
  unsigned __int16 **v30; // esi
  unsigned __int16 **v31; // eax
  WCHAR *v32; // eax
  unsigned __int16 **v33; // eax
  void *v34; // esi
  int v36; // [esp+10h] [ebp-B0h]
  int v37; // [esp+14h] [ebp-ACh]
  int v38; // [esp+18h] [ebp-A8h]
  int v39; // [esp+1Ch] [ebp-A4h]
  void *v40; // [esp+20h] [ebp-A0h]
  void *v41; // [esp+24h] [ebp-9Ch]
  void *v42; // [esp+28h] [ebp-98h]
  void *v43; // [esp+2Ch] [ebp-94h]
  void *v44; // [esp+30h] [ebp-90h]
  int v45; // [esp+34h] [ebp-8Ch]
  void *v46; // [esp+38h] [ebp-88h]
  void *v47; // [esp+3Ch] [ebp-84h]
  void *v48; // [esp+40h] [ebp-80h]
  void *v49; // [esp+44h] [ebp-7Ch]
  void *v50; // [esp+48h] [ebp-78h]
  int v51; // [esp+4Ch] [ebp-74h]
  void *v52; // [esp+50h] [ebp-70h]
  void *v53; // [esp+54h] [ebp-6Ch]
  void *v54; // [esp+58h] [ebp-68h]
  void *v55; // [esp+5Ch] [ebp-64h]
  void *v56; // [esp+60h] [ebp-60h]
  void *v57; // [esp+64h] [ebp-5Ch]
  void *v58; // [esp+68h] [ebp-58h]
  void *v59; // [esp+6Ch] [ebp-54h]
  void *v60; // [esp+70h] [ebp-50h]
  void *v61; // [esp+74h] [ebp-4Ch]
  void *v62; // [esp+78h] [ebp-48h]
  HKEY v63; // [esp+7Ch] [ebp-44h]
  void *v64; // [esp+80h] [ebp-40h]
  void *v65; // [esp+84h] [ebp-3Ch]
  void *v66; // [esp+88h] [ebp-38h]
  void *v67; // [esp+8Ch] [ebp-34h]
  void *v68; // [esp+90h] [ebp-30h]
  void *v69; // [esp+94h] [ebp-2Ch]
  void *v70; // [esp+98h] [ebp-28h]
  HKEY hKey; // [esp+9Ch] [ebp-24h]
  void *v72; // [esp+A0h] [ebp-20h]
  void *v73; // [esp+A4h] [ebp-1Ch]
  void *v74; // [esp+A8h] [ebp-18h]
  OLECHAR *v75; // [esp+ACh] [ebp-14h]
  wchar_t *v76; // [esp+B0h] [ebp-10h]
  int v77; // [esp+BCh] [ebp-4h]

  v66 = malloc(2u);
  *v66 = 0;
  v77 = 0;
  v62 = malloc(2u);
  *v62 = 0;
  v61 = malloc(2u);
  *v61 = 0;
  LOBYTE(v77) = 2;
  if ( a4 == -1 )
  {
    v67 = _wcsdup(gpszTargetName);
    v69 = _wcsdup(gpszTargetName);
    v68 = _wcsdup(gpszTargetName);
    v70 = _wcsdup(gpszTargetName);
    v76 = _wcsdup(gpszTargetName);
    v75 = _wcsdup(gpszTargetName);
    v74 = _wcsdup(gpszTargetName);
    v4 = gpszTargetName;
    if ( psz )
      v4 = psz;
    v72 = _wcsdup(v4);
    v73 = _wcsdup(gpszTargetName);
    v5 = gpszTargetName;
    if ( psz )
      v5 = psz;
    hKey = _wcsdup(v5);
    LOBYTE(v77) = 12;
    v6 = sub_11F7BE0(&v64, a2, &v72, &v74);
    LOBYTE(v77) = 13;
    v7 = sub_11F7BE0(&v65, a2, &hKey, &v73);
    LOBYTE(v77) = 14;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v7, v6, &v75);
    free(v65);
    free(v64);
    free(hKey);
    free(v73);
    free(v72);
    free(v74);
    free(v75);
    free(v76);
    free(v70);
    free(v68);
    free(v69);
    LOBYTE(v77) = 2;
    free(v67);
  }
  v8 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, psz, 0, v8 | 0x20019, &v63) )
  {
    v65 = 0;
    v75 = malloc(2u);
    *v75 = 0;
    v73 = malloc(2u);
    *v73 = 0;
    v76 = malloc(2u);
    *v76 = 0;
    v74 = malloc(2u);
    *v74 = 0;
    v72 = malloc(2u);
    *v72 = 0;
    LOBYTE(v77) = 19;
    v9 = RegCloseKey;
    if ( !sub_12013D0(v63, 0, &v75) )
    {
      do
      {
        v10 = v75;
        v11 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v63, v10, 0, v11 | 0x20019, &hKey) )
        {
          if ( sub_1201520(hKey, L"CLSID", 0, 0, &v73) )
          {
            v9(hKey);
          }
          else
          {
            v9(hKey);
            v12 = sub_120F210(&v49, L"CLSID\\", &v73);
            v13 = sub_11F22B0(&v43, v12, L"\\InprocServer32");
            v14 = v76;
            v76 = _wcsdup(*v13);
            free(v14);
            free(v43);
            free(v49);
            v15 = sub_120F210(&v40, L"HKCR\\CLSID\\", &v73);
            v16 = v72;
            v72 = _wcsdup(*v15);
            free(v16);
            free(v40);
            v17 = v76;
            v18 = TlsGetValue(gdwTlsIndex);
            if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v17, 0, v18 | 0x20019, &hKey) )
            {
              v19 = v76;
              v76 = _wcsdup(gpszTargetName);
              free(v19);
              sub_1201520(hKey, gpszTargetName, 0, 0, &v76);
              v9(hKey);
              if ( wcslen(v76) )
              {
                v36 = malloc(2u);
                *v36 = 0;
                v37 = 0;
                v38 = 0;
                v39 = 0;
                LOBYTE(v77) = 20;
                sub_11F7040(v76, &v36);
                v20 = sub_11F4EE0(&v46, a1, &v36, 0);
                v21 = v74;
                v74 = _wcsdup(*v20);
                free(v21);
                free(v46);
                v51 = sub_11F4ED0();
                v22 = gpszTargetName;
                if ( psz )
                  v22 = psz;
                v68 = _wcsdup(v22);
                v69 = _wcsdup(gpszTargetName);
                v23 = gpszTargetName;
                if ( psz )
                  v23 = psz;
                v67 = _wcsdup(v23);
                LOBYTE(v77) = 23;
                v24 = sub_11F7BE0(&v44, a2, &v68, &v75);
                LOBYTE(v77) = 24;
                v25 = sub_11F7BE0(&v42, a2, &v67, &v69);
                LOBYTE(v77) = 25;
                v26 = sub_11F3D40(a1, &v75, v25, v24, &v74, &v66, &v61, &v45);
                free(v42);
                free(v44);
                free(v67);
                free(v69);
                free(v68);
                if ( v26 )
                {
                  if ( a4 == -1 )
                  {
                    v58 = _wcsdup(gpszTargetName);
                    v59 = _wcsdup(gpszTargetName);
                    v55 = _wcsdup(gpszTargetName);
                    v53 = _wcsdup(gpszTargetName);
                    v60 = _wcsdup(gpszTargetName);
                    v50 = _wcsdup(gpszTargetName);
                    v52 = _wcsdup(gpszTargetName);
                    v27 = gpszTargetName;
                    if ( psz )
                      v27 = psz;
                    v54 = _wcsdup(v27);
                    v57 = _wcsdup(gpszTargetName);
                    v28 = gpszTargetName;
                    if ( psz )
                      v28 = psz;
                    v70 = _wcsdup(v28);
                    v29 = a2;
                    LOBYTE(v77) = 35;
                    v30 = sub_11F7BE0(&v47, a2, &v54, &v52);
                    LOBYTE(v77) = 36;
                    v31 = sub_11F7BE0(&v48, a2, &v70, &v57);
                    LOBYTE(v77) = 37;
                    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v31, v30, &v50);
                    free(v48);
                    free(v47);
                    free(v70);
                    free(v57);
                    free(v54);
                    free(v52);
                    free(v50);
                    free(v60);
                    free(v53);
                    free(v55);
                    free(v59);
                    free(v58);
                  }
                  else
                  {
                    v29 = a2;
                  }
                  v64 = _wcsdup(gpszTargetName);
                  v32 = gpszTargetName;
                  if ( psz )
                    v32 = psz;
                  v56 = _wcsdup(v32);
                  LOBYTE(v77) = 39;
                  v33 = sub_11F7BE0(&v41, v29, &v56, &v75);
                  LOBYTE(v77) = 40;
                  sub_11F3FF0(a1, v51, a4, 3, &v75, v33, &v74);
                  free(v41);
                  free(v56);
                  free(v64);
                }
                sub_11F21F0(&v36);
                free(v72);
                free(v74);
                free(v76);
                free(v73);
                free(v75);
                v9 = RegCloseKey;
                goto LABEL_31;
              }
            }
          }
        }
        free(v72);
        free(v74);
        free(v76);
        free(v73);
        free(v75);
LABEL_31:
        v65 = v65 + 1;
        v34 = v65;
        v75 = malloc(2u);
        *v75 = 0;
        v73 = malloc(2u);
        *v73 = 0;
        v76 = malloc(2u);
        *v76 = 0;
        v74 = malloc(2u);
        *v74 = 0;
        v72 = malloc(2u);
        *v72 = 0;
        LOBYTE(v77) = 19;
      }
      while ( !sub_12013D0(v63, v34, &v75) );
    }
    free(v72);
    free(v74);
    free(v76);
    free(v73);
    free(v75);
    v9(v63);
  }
  free(v61);
  free(v62);
  free(v66);
  return a4;
}

//----- (012039D0) --------------------------------------------------------
void __cdecl sub_12039D0(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_1203A80(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_1203A80(a1, a2, v7, v5);
  free(v7);
}

//----- (01203A80) --------------------------------------------------------
void *__cdecl sub_1203A80(int a1, void *a2, wchar_t *psz, void *a4)
{
  DWORD v4; // ebx
  _WORD *v5; // esi
  OLECHAR *v6; // edi
  WCHAR *v7; // eax
  WCHAR *v8; // eax
  unsigned __int16 **v9; // edi
  unsigned __int16 **v10; // eax
  unsigned int v11; // eax
  void *v12; // esi
  OLECHAR *v13; // edi
  unsigned int v14; // eax
  const wchar_t **v15; // eax
  void *v16; // edi
  int v17; // eax
  WCHAR *v18; // ecx
  WCHAR *v19; // eax
  unsigned __int16 **v20; // edi
  unsigned __int16 **v21; // eax
  char v22; // bl
  wchar_t *v23; // ebx
  WCHAR *v24; // eax
  WCHAR *v25; // eax
  unsigned __int16 **v26; // edi
  unsigned __int16 **v27; // eax
  WCHAR *v28; // eax
  unsigned __int16 **v29; // eax
  int v31; // [esp+10h] [ebp-A0h]
  int v32; // [esp+14h] [ebp-9Ch]
  int v33; // [esp+18h] [ebp-98h]
  int v34; // [esp+1Ch] [ebp-94h]
  void *v35; // [esp+20h] [ebp-90h]
  _WORD *v36; // [esp+24h] [ebp-8Ch]
  void *v37; // [esp+28h] [ebp-88h]
  void *v38; // [esp+2Ch] [ebp-84h]
  void *v39; // [esp+30h] [ebp-80h]
  int v40; // [esp+34h] [ebp-7Ch]
  void *v41; // [esp+38h] [ebp-78h]
  int v42; // [esp+3Ch] [ebp-74h]
  void *v43; // [esp+40h] [ebp-70h]
  HKEY hKey; // [esp+44h] [ebp-6Ch]
  void *v45; // [esp+48h] [ebp-68h]
  void *v46; // [esp+4Ch] [ebp-64h]
  void *v47; // [esp+50h] [ebp-60h]
  wchar_t *v48; // [esp+54h] [ebp-5Ch]
  void *v49; // [esp+58h] [ebp-58h]
  DWORD v50; // [esp+5Ch] [ebp-54h]
  void *v51; // [esp+60h] [ebp-50h]
  void *v52; // [esp+64h] [ebp-4Ch]
  void *v53; // [esp+68h] [ebp-48h]
  HKEY v54; // [esp+6Ch] [ebp-44h]
  void *v55; // [esp+70h] [ebp-40h]
  void *v56; // [esp+74h] [ebp-3Ch]
  void *v57; // [esp+78h] [ebp-38h]
  void *v58; // [esp+7Ch] [ebp-34h]
  void *v59; // [esp+80h] [ebp-30h]
  void *v60; // [esp+84h] [ebp-2Ch]
  void *v61; // [esp+88h] [ebp-28h]
  void *v62; // [esp+8Ch] [ebp-24h]
  void *v63; // [esp+90h] [ebp-20h]
  void *v64; // [esp+94h] [ebp-1Ch]
  void *v65; // [esp+98h] [ebp-18h]
  void *v66; // [esp+9Ch] [ebp-14h]
  OLECHAR *v67; // [esp+A0h] [ebp-10h]
  int v68; // [esp+ACh] [ebp-4h]

  v4 = 0;
  v50 = 0;
  v48 = malloc(2u);
  *v48 = 0;
  v68 = 0;
  v67 = malloc(2u);
  *v67 = 0;
  v5 = malloc(2u);
  v36 = v5;
  *v5 = 0;
  v66 = malloc(2u);
  *v66 = 0;
  v52 = malloc(2u);
  *v52 = 0;
  v51 = malloc(2u);
  *v51 = 0;
  v49 = malloc(2u);
  *v49 = 0;
  v6 = psz;
  LOBYTE(v68) = 6;
  if ( a4 == -1 )
  {
    v59 = _wcsdup(gpszTargetName);
    v65 = _wcsdup(gpszTargetName);
    v56 = _wcsdup(gpszTargetName);
    v58 = _wcsdup(gpszTargetName);
    v60 = _wcsdup(gpszTargetName);
    v62 = _wcsdup(gpszTargetName);
    v64 = _wcsdup(gpszTargetName);
    v7 = gpszTargetName;
    if ( psz )
      v7 = psz;
    v63 = _wcsdup(v7);
    v57 = _wcsdup(gpszTargetName);
    v8 = gpszTargetName;
    if ( psz )
      v8 = psz;
    v61 = _wcsdup(v8);
    LOBYTE(v68) = 16;
    v9 = sub_11F7BE0(&v53, a2, &v63, &v64);
    LOBYTE(v68) = 17;
    v10 = sub_11F7BE0(&v55, a2, &v61, &v57);
    LOBYTE(v68) = 18;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v10, v9, &v62);
    free(v55);
    free(v53);
    free(v61);
    free(v57);
    free(v63);
    free(v64);
    free(v62);
    free(v60);
    free(v58);
    free(v56);
    free(v65);
    LOBYTE(v68) = 6;
    free(v59);
    v6 = psz;
  }
  v11 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, v6, 0, v11 | 0x20019, &v54) )
  {
    if ( !sub_12013D0(v54, 0, &v67) )
    {
      v12 = a4;
      do
      {
        v13 = v67;
        v14 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v54, v13, 0, v14 | 0x20019, &hKey) )
        {
          if ( !sub_1201520(hKey, L"Source", 0, 0, &v48) )
          {
            v31 = malloc(2u);
            *v31 = 0;
            v32 = 0;
            v33 = 0;
            v34 = 0;
            LOBYTE(v68) = 19;
            if ( sub_11F6CC0(v48, &v31) )
            {
              v15 = sub_11F4EE0(&v39, a1, &v31, 0);
              v16 = v66;
              v66 = _wcsdup(*v15);
              free(v16);
              free(v39);
              v17 = sub_11F4ED0();
              v18 = gpszTargetName;
              v40 = v17;
              if ( psz )
                v18 = psz;
              v65 = _wcsdup(v18);
              v59 = _wcsdup(gpszTargetName);
              v19 = gpszTargetName;
              if ( psz )
                v19 = psz;
              a4 = _wcsdup(v19);
              LOBYTE(v68) = 22;
              v20 = sub_11F7BE0(&v37, a2, &v65, &v67);
              LOBYTE(v68) = 23;
              v21 = sub_11F7BE0(&v41, a2, &a4, &v59);
              LOBYTE(v68) = 24;
              v22 = sub_11F3D40(a1, &v67, v21, v20, &v66, &v52, &v49, &v42);
              free(v41);
              free(v37);
              free(a4);
              free(v59);
              free(v65);
              if ( v22 )
              {
                if ( v12 == -1 )
                {
                  v45 = _wcsdup(gpszTargetName);
                  v47 = _wcsdup(gpszTargetName);
                  v61 = _wcsdup(gpszTargetName);
                  v57 = _wcsdup(gpszTargetName);
                  v63 = _wcsdup(gpszTargetName);
                  v64 = _wcsdup(gpszTargetName);
                  v62 = _wcsdup(gpszTargetName);
                  v23 = psz;
                  v24 = gpszTargetName;
                  if ( psz )
                    v24 = psz;
                  v60 = _wcsdup(v24);
                  v58 = _wcsdup(gpszTargetName);
                  v25 = gpszTargetName;
                  if ( psz )
                    v25 = psz;
                  v56 = _wcsdup(v25);
                  LOBYTE(v68) = 34;
                  v26 = sub_11F7BE0(&v35, a2, &v60, &v62);
                  LOBYTE(v68) = 35;
                  v27 = sub_11F7BE0(&v43, a2, &v56, &v58);
                  LOBYTE(v68) = 36;
                  v12 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v27, v26, &v64);
                  free(v43);
                  free(v35);
                  free(v56);
                  free(v58);
                  free(v60);
                  free(v62);
                  free(v64);
                  free(v63);
                  free(v57);
                  free(v61);
                  free(v47);
                  free(v45);
                }
                else
                {
                  v23 = psz;
                }
                v55 = _wcsdup(gpszTargetName);
                v53 = _wcsdup(gpszTargetName);
                v28 = gpszTargetName;
                if ( v23 )
                  v28 = v23;
                v46 = _wcsdup(v28);
                LOBYTE(v68) = 39;
                v29 = sub_11F7BE0(&v38, a2, &v46, &v67);
                LOBYTE(v68) = 40;
                sub_11F3FF0(a1, v40, v12, 3, &v67, v29, &v66);
                free(v38);
                free(v46);
                free(v53);
                free(v55);
              }
              v4 = v50;
            }
            LOBYTE(v68) = 6;
            sub_11F21F0(&v31);
          }
          RegCloseKey(hKey);
        }
        v50 = ++v4;
      }
      while ( !sub_12013D0(v54, v4, &v67) );
      a4 = v12;
      v5 = v36;
    }
    RegCloseKey(v54);
  }
  free(v49);
  free(v51);
  free(v52);
  free(v66);
  free(v5);
  free(v67);
  free(v48);
  return a4;
}

//----- (01204150) --------------------------------------------------------
void __cdecl sub_1204150(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_1204200(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_1204200(a1, a2, v7, v5);
  free(v7);
}

//----- (01204200) --------------------------------------------------------
void *__cdecl sub_1204200(int a1, void *a2, wchar_t *psz, void *a4)
{
  wchar_t *v4; // edi
  WCHAR *v5; // eax
  WCHAR *v6; // eax
  unsigned __int16 **v7; // esi
  unsigned __int16 **v8; // eax
  unsigned int v9; // eax
  void (__stdcall *v10)(HKEY); // ebx
  OLECHAR *v11; // esi
  unsigned int v12; // eax
  wchar_t *v13; // ebx
  UINT v14; // edi
  wchar_t *v15; // eax
  const wchar_t **v16; // eax
  wchar_t *v17; // esi
  HMODULE v18; // ebx
  wchar_t *v19; // edi
  LSTATUS v20; // eax
  int v21; // eax
  const wchar_t **v22; // eax
  wchar_t *v23; // esi
  OLECHAR *v24; // esi
  unsigned int v25; // eax
  void *v26; // esi
  wchar_t *v28; // esi
  const wchar_t *v29; // eax
  void *v30; // esi
  const wchar_t **v31; // eax
  void *v32; // esi
  WCHAR *v33; // ecx
  WCHAR *v34; // eax
  void *v35; // ebx
  unsigned __int16 **v36; // esi
  unsigned __int16 **v37; // eax
  WCHAR *v38; // eax
  WCHAR *v39; // eax
  void *v40; // ebx
  unsigned __int16 **v41; // esi
  unsigned __int16 **v42; // eax
  WCHAR *v43; // eax
  unsigned __int16 **v44; // eax
  HKEY v45; // [esp-4h] [ebp-2E0h]
  int v46; // [esp+10h] [ebp-2CCh]
  int v47; // [esp+14h] [ebp-2C8h]
  int v48; // [esp+18h] [ebp-2C4h]
  int v49; // [esp+1Ch] [ebp-2C0h]
  void *v50; // [esp+20h] [ebp-2BCh]
  void *v51; // [esp+24h] [ebp-2B8h]
  void *v52; // [esp+28h] [ebp-2B4h]
  void *v53; // [esp+2Ch] [ebp-2B0h]
  void *v54; // [esp+30h] [ebp-2ACh]
  wchar_t *v55; // [esp+34h] [ebp-2A8h]
  void *v56; // [esp+38h] [ebp-2A4h]
  int v57; // [esp+3Ch] [ebp-2A0h]
  LPWSTR ppsz; // [esp+40h] [ebp-29Ch]
  void *v59; // [esp+44h] [ebp-298h]
  void *v60; // [esp+48h] [ebp-294h]
  int v61; // [esp+4Ch] [ebp-290h]
  void *v62; // [esp+50h] [ebp-28Ch]
  void *v63; // [esp+54h] [ebp-288h]
  void *v64; // [esp+58h] [ebp-284h]
  void *v65; // [esp+5Ch] [ebp-280h]
  void *v66; // [esp+60h] [ebp-27Ch]
  void *v67; // [esp+64h] [ebp-278h]
  void *v68; // [esp+68h] [ebp-274h]
  void *v69; // [esp+6Ch] [ebp-270h]
  void *v70; // [esp+70h] [ebp-26Ch]
  void *v71; // [esp+74h] [ebp-268h]
  void *v72; // [esp+78h] [ebp-264h]
  void *v73; // [esp+7Ch] [ebp-260h]
  void *v74; // [esp+80h] [ebp-25Ch]
  void *v75; // [esp+84h] [ebp-258h]
  HKEY v76; // [esp+88h] [ebp-254h]
  void *v77; // [esp+8Ch] [ebp-250h]
  void *v78; // [esp+90h] [ebp-24Ch]
  void *v79; // [esp+94h] [ebp-248h]
  void *v80; // [esp+98h] [ebp-244h]
  void *v81; // [esp+9Ch] [ebp-240h]
  void *v82; // [esp+A0h] [ebp-23Ch]
  void *v83; // [esp+A4h] [ebp-238h]
  int v84; // [esp+A8h] [ebp-234h]
  wchar_t *v85; // [esp+ACh] [ebp-230h]
  void *v86; // [esp+B0h] [ebp-22Ch]
  HKEY hKey; // [esp+B4h] [ebp-228h]
  OLECHAR *v88; // [esp+B8h] [ebp-224h]
  void *v89; // [esp+BCh] [ebp-220h]
  wchar_t *v90; // [esp+C0h] [ebp-21Ch]
  WCHAR Buffer; // [esp+C4h] [ebp-218h]
  int v92; // [esp+2D8h] [ebp-4h]

  v4 = psz;
  v84 = a1;
  v73 = a2;
  v55 = psz;
  v85 = malloc(2u);
  *v85 = 0;
  v92 = 0;
  v77 = malloc(2u);
  *v77 = 0;
  v71 = malloc(2u);
  *v71 = 0;
  v72 = malloc(2u);
  *v72 = 0;
  v78 = malloc(2u);
  *v78 = 0;
  LOBYTE(v92) = 4;
  if ( a4 == -1 )
  {
    v79 = _wcsdup(gpszTargetName);
    v81 = _wcsdup(gpszTargetName);
    v83 = _wcsdup(gpszTargetName);
    v80 = _wcsdup(gpszTargetName);
    v82 = _wcsdup(gpszTargetName);
    v90 = _wcsdup(gpszTargetName);
    v89 = _wcsdup(gpszTargetName);
    v5 = gpszTargetName;
    if ( psz )
      v5 = psz;
    v88 = _wcsdup(v5);
    hKey = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( psz )
      v6 = psz;
    v86 = _wcsdup(v6);
    LOBYTE(v92) = 14;
    v7 = sub_11F7BE0(&v74, a2, &v88, &v89);
    LOBYTE(v92) = 15;
    v8 = sub_11F7BE0(&v75, a2, &v86, &hKey);
    LOBYTE(v92) = 16;
    a4 = sub_11F3FF0(v84, 0, 0xFFFFFFFF, 0, v8, v7, &v90);
    free(v75);
    free(v74);
    free(v86);
    free(hKey);
    free(v88);
    free(v89);
    free(v90);
    free(v82);
    free(v80);
    free(v83);
    free(v81);
    LOBYTE(v92) = 4;
    free(v79);
  }
  v9 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, psz, 0, v9 | 0x20019, &v76) )
  {
    v75 = 0;
    v88 = malloc(2u);
    *v88 = 0;
    v86 = malloc(2u);
    *v86 = 0;
    v90 = malloc(2u);
    *v90 = 0;
    v89 = malloc(2u);
    *v89 = 0;
    LOBYTE(v92) = 20;
    v10 = RegCloseKey;
    if ( !sub_12013D0(v76, 0, &v88) )
    {
      while ( 1 )
      {
        v11 = v88;
        v12 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v76, v11, 0, v12 | 0x20019, &hKey) )
        {
          if ( sub_1201520(hKey, L"MenuText", 0, 0, &v85) && sub_1201520(hKey, L"ButtonText", 0, 0, &v85) )
            goto LABEL_25;
          if ( *v85 == 64 )
          {
            v13 = _wcsdup(v85);
            v61 = v13;
            LOBYTE(v92) = 21;
            v14 = 0;
            if ( wcschr(v13, ',') )
            {
              v15 = wcschr(v13, ',');
              *v15 = 0;
              v14 = abs(_wtoi(v15 + 1));
            }
            v16 = GetEnvironmentPathInfo(&ppsz, v13 + 1);
            v17 = _wcsdup(*v16);
            free(v13);
            free(ppsz);
            v18 = LoadLibraryExW(v17, 0, 2u);
            if ( v18 )
            {
              if ( LoadStringW(v18, v14, &Buffer, 260) )
              {
                v19 = v85;
                v85 = _wcsdup(&Buffer);
                free(v19);
              }
              FreeLibrary(v18);
            }
            LOBYTE(v92) = 20;
            free(v17);
            v10 = RegCloseKey;
            v4 = v55;
          }
          if ( !sub_1201520(hKey, L"Exec", 0, 0, &v90) )
            goto LABEL_36;
          if ( !sub_1201520(hKey, L"Script", 0, 0, &v90) )
          {
            if ( !_wcsnicmp(v90, L"res://", 6u) )
            {
              v28 = v90;
              v29 = v90 + 6;
              goto LABEL_35;
            }
            if ( !_wcsnicmp(v90, L"file://", 7u) )
            {
              v28 = v90;
              v29 = v90 + 7;
LABEL_35:
              v90 = _wcsdup(v29);
              free(v28);
            }
LABEL_36:
            v10(hKey);
            v46 = malloc(2u);
            *v46 = 0;
            v47 = 0;
            v48 = 0;
            v49 = 0;
            LOBYTE(v92) = 22;
            sub_11F7040(v90, &v46);
            v30 = v78;
            v78 = _wcsdup(v90);
            free(v30);
            v31 = sub_11F4EE0(&v50, v84, &v46, 0);
            v32 = v89;
            v89 = _wcsdup(*v31);
            free(v32);
            free(v50);
            v61 = sub_11F4ED0();
            v33 = gpszTargetName;
            if ( v4 )
              v33 = v4;
            v83 = _wcsdup(v33);
            v81 = _wcsdup(gpszTargetName);
            v34 = gpszTargetName;
            if ( v4 )
              v34 = v4;
            v79 = _wcsdup(v34);
            v35 = v73;
            LOBYTE(v92) = 25;
            v36 = sub_11F7BE0(&v52, v73, &v83, &v88);
            LOBYTE(v92) = 26;
            v37 = sub_11F7BE0(&v56, v35, &v79, &v81);
            LOBYTE(v92) = 27;
            LOBYTE(v35) = sub_11F3D40(v84, &v85, v37, v36, &v89, &v77, &v72, &v57);
            free(v56);
            free(v52);
            free(v79);
            free(v81);
            free(v83);
            if ( v35 )
            {
              if ( a4 == -1 )
              {
                v62 = _wcsdup(gpszTargetName);
                v66 = _wcsdup(gpszTargetName);
                v64 = _wcsdup(gpszTargetName);
                v63 = _wcsdup(gpszTargetName);
                v70 = _wcsdup(gpszTargetName);
                v65 = _wcsdup(gpszTargetName);
                v67 = _wcsdup(gpszTargetName);
                v38 = gpszTargetName;
                if ( v4 )
                  v38 = v4;
                v68 = _wcsdup(v38);
                v82 = _wcsdup(gpszTargetName);
                v39 = gpszTargetName;
                if ( v4 )
                  v39 = v4;
                v80 = _wcsdup(v39);
                v40 = v73;
                LOBYTE(v92) = 37;
                v41 = sub_11F7BE0(&v59, v73, &v68, &v67);
                LOBYTE(v92) = 38;
                v42 = sub_11F7BE0(&v54, v40, &v80, &v82);
                LOBYTE(v92) = 39;
                a4 = sub_11F3FF0(v84, 0, 0xFFFFFFFF, 0, v42, v41, &v65);
                free(v54);
                free(v59);
                free(v80);
                free(v82);
                free(v68);
                free(v67);
                free(v65);
                free(v70);
                free(v63);
                free(v64);
                free(v66);
                free(v62);
              }
              else
              {
                v40 = v73;
              }
              v74 = _wcsdup(gpszTargetName);
              v43 = gpszTargetName;
              if ( v4 )
                v43 = v4;
              v69 = _wcsdup(v43);
              LOBYTE(v92) = 41;
              v44 = sub_11F7BE0(&v53, v40, &v69, &v88);
              LOBYTE(v92) = 42;
              sub_11F3FF0(v84, v61, a4, 3, &v85, v44, &v89);
              free(v53);
              free(v69);
              free(v74);
            }
            sub_11F21F0(&v46);
            free(v89);
            free(v90);
            free(v86);
            free(v88);
            v10 = RegCloseKey;
            goto LABEL_28;
          }
          v20 = sub_1201520(hKey, L"ClsidExtension", 0, 0, &v86);
          v45 = hKey;
          if ( v20 )
            goto LABEL_26;
          v10(hKey);
          v21 = sub_120F210(&v60, L"CLSID\\", &v86);
          v22 = sub_11F22B0(&v51, v21, L"\\InprocServer32");
          v23 = v90;
          v90 = _wcsdup(*v22);
          free(v23);
          free(v51);
          free(v60);
          v24 = v90;
          v25 = TlsGetValue(gdwTlsIndex);
          if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v24, 0, v25 | 0x20019, &hKey) )
            break;
        }
LABEL_27:
        free(v89);
        free(v90);
        free(v86);
        free(v88);
LABEL_28:
        v75 = v75 + 1;
        v26 = v75;
        v88 = malloc(2u);
        *v88 = 0;
        v86 = malloc(2u);
        *v86 = 0;
        v90 = malloc(2u);
        *v90 = 0;
        v89 = malloc(2u);
        *v89 = 0;
        LOBYTE(v92) = 20;
        if ( sub_12013D0(v76, v26, &v88) )
          goto LABEL_29;
      }
      if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v90) )
        goto LABEL_36;
LABEL_25:
      v45 = hKey;
LABEL_26:
      v10(v45);
      goto LABEL_27;
    }
LABEL_29:
    free(v89);
    free(v90);
    free(v86);
    free(v88);
    v10(v76);
  }
  free(v78);
  free(v72);
  free(v71);
  free(v77);
  free(v85);
  return a4;
}

//----- (01204E10) --------------------------------------------------------
void *__cdecl sub_1204E10(int a1, void *a2, OLECHAR *psz)
{
  CComBSTR **v3; // eax
  _bstr_t *v4; // eax
  void *v5; // esi
  CComBSTR *v6; // esi
  CComBSTR *v7; // esi
  void *v8; // eax
  void *v9; // eax
  CComBSTR *v10; // esi
  void *v11; // edi
  CComBSTR *ppComBSTR1; // [esp+10h] [ebp-1Ch]
  CComBSTR *ppv; // [esp+14h] [ebp-18h]
  CComBSTR *v15; // [esp+18h] [ebp-14h]
  void *v16; // [esp+1Ch] [ebp-10h]
  int v17; // [esp+28h] [ebp-4h]

  bstr_t::EqualAssign(&ppv, L"AutorunsDisabled");
  v17 = 0;
  v3 = bstr_t::EqualAssign(&v15, L"\\");
  LOBYTE(v17) = 1;
  v4 = sub_11F3B50(&v16, psz, v3);
  LOBYTE(v17) = 2;
  CComBSTR::AppendTail(v4, &ppComBSTR1, &ppv);
  v5 = v16;
  if ( v16 )
  {
    if ( !InterlockedDecrement(v16 + 2) && v5 )
    {
      if ( *v5 )
      {
        SysFreeString(*v5);
        *v5 = 0;
      }
      if ( *(v5 + 1) )
      {
        j_j__free(*(v5 + 1));
        *(v5 + 1) = 0;
      }
      j__free(v5);
    }
    v16 = 0;
  }
  v6 = v15;
  if ( v15 )
  {
    if ( !InterlockedDecrement(&v15->Length) && v6 )
    {
      if ( v6->bstr )
      {
        SysFreeString(v6->bstr);
        v6->bstr = 0;
      }
      if ( v6->hKey )
      {
        j_j__free(v6->hKey);
        v6->hKey = 0;
      }
      j__free(v6);
    }
    v15 = 0;
  }
  v7 = ppv;
  LOBYTE(v17) = 6;
  if ( ppv && !InterlockedDecrement(&ppv->Length) )
  {
    if ( v7->bstr )
    {
      SysFreeString(v7->bstr);
      v7->bstr = 0;
    }
    if ( v7->hKey )
    {
      j_j__free(v7->hKey);
      v7->hKey = 0;
    }
    j__free(v7);
  }
  v8 = sub_1204FF0(a1, a2, psz, 0xFFFFFFFF, 1);
  v9 = sub_1204FF0(a1, a2, psz, v8, 0);
  v10 = ppComBSTR1;
  v11 = v9;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v10 )
  {
    if ( v10->bstr )
    {
      SysFreeString(v10->bstr);
      v10->bstr = 0;
    }
    if ( v10->hKey )
    {
      j_j__free(v10->hKey);
      v10->hKey = 0;
    }
    j__free(v10);
  }
  return v11;
}

//----- (01204FF0) --------------------------------------------------------
void *__cdecl sub_1204FF0(int a1, void *a2, wchar_t *psz, void *a4, char a5)
{
  void *v5; // esi
  WCHAR *v6; // eax
  WCHAR *v7; // eax
  unsigned __int16 **v8; // esi
  unsigned __int16 **v9; // eax
  unsigned int v10; // eax
  wchar_t *v12; // ebx
  void *v13; // edi
  int v14; // esi
  wchar_t *v15; // eax
  wchar_t *v16; // eax
  wchar_t *v17; // esi
  unsigned int v18; // eax
  int v19; // eax
  wchar_t *v20; // esi
  WCHAR *v21; // ecx
  WCHAR *v22; // eax
  wchar_t *v23; // esi
  int v24; // eax
  unsigned __int16 **v25; // edi
  unsigned __int16 **v26; // eax
  wchar_t *v27; // edi
  WCHAR *v28; // eax
  WCHAR *v29; // eax
  unsigned __int16 **v30; // esi
  unsigned __int16 **v31; // eax
  WCHAR *v32; // eax
  wchar_t *v33; // esi
  int v34; // eax
  unsigned __int16 **v35; // eax
  unsigned int v36; // eax
  wchar_t *v37; // esi
  WCHAR *v38; // eax
  WCHAR *v39; // eax
  void *v40; // edi
  unsigned __int16 **v41; // esi
  unsigned __int16 **v42; // eax
  wchar_t **v43; // eax
  wchar_t *v44; // eax
  wchar_t *v45; // eax
  wchar_t *v46; // edi
  WCHAR *v47; // eax
  wchar_t *v48; // eax
  wchar_t *v49; // esi
  const wchar_t **v50; // eax
  unsigned __int16 **v51; // eax
  int v52; // eax
  wchar_t *v53; // esi
  int v54; // [esp+10h] [ebp-528h]
  int v55; // [esp+14h] [ebp-524h]
  int v56; // [esp+18h] [ebp-520h]
  int v57; // [esp+1Ch] [ebp-51Ch]
  void *v58; // [esp+20h] [ebp-518h]
  void *v59; // [esp+24h] [ebp-514h]
  int v60; // [esp+28h] [ebp-510h]
  BYTE v61[4]; // [esp+2Ch] [ebp-50Ch]
  void *v62; // [esp+30h] [ebp-508h]
  wchar_t *v63; // [esp+34h] [ebp-504h]
  void *v64; // [esp+38h] [ebp-500h]
  void *v65; // [esp+3Ch] [ebp-4FCh]
  void *v66; // [esp+40h] [ebp-4F8h]
  void *v67; // [esp+44h] [ebp-4F4h]
  void *v68; // [esp+48h] [ebp-4F0h]
  void *v69; // [esp+4Ch] [ebp-4ECh]
  void *v70; // [esp+50h] [ebp-4E8h]
  void *v71; // [esp+54h] [ebp-4E4h]
  void *v72; // [esp+58h] [ebp-4E0h]
  void *v73; // [esp+5Ch] [ebp-4DCh]
  void *v74; // [esp+60h] [ebp-4D8h]
  void *v75; // [esp+64h] [ebp-4D4h]
  void *v76; // [esp+68h] [ebp-4D0h]
  void *v77; // [esp+6Ch] [ebp-4CCh]
  void *v78; // [esp+70h] [ebp-4C8h]
  void *v79; // [esp+74h] [ebp-4C4h]
  void *v80; // [esp+78h] [ebp-4C0h]
  void *v81; // [esp+7Ch] [ebp-4BCh]
  void *v82; // [esp+80h] [ebp-4B8h]
  void *v83; // [esp+84h] [ebp-4B4h]
  void *v84; // [esp+88h] [ebp-4B0h]
  void *v85; // [esp+8Ch] [ebp-4ACh]
  void *v86; // [esp+90h] [ebp-4A8h]
  void *v87; // [esp+94h] [ebp-4A4h]
  void *v88; // [esp+98h] [ebp-4A0h]
  void *v89; // [esp+9Ch] [ebp-49Ch]
  void *v90; // [esp+A0h] [ebp-498h]
  void *v91; // [esp+A4h] [ebp-494h]
  void *v92; // [esp+A8h] [ebp-490h]
  void *v93; // [esp+ACh] [ebp-48Ch]
  void *v94; // [esp+B0h] [ebp-488h]
  void *v95; // [esp+B4h] [ebp-484h]
  void *v96; // [esp+B8h] [ebp-480h]
  void *v97; // [esp+BCh] [ebp-47Ch]
  void *v98; // [esp+C0h] [ebp-478h]
  DWORD cbData; // [esp+C4h] [ebp-474h]
  int v100; // [esp+C8h] [ebp-470h]
  void *v101; // [esp+CCh] [ebp-46Ch]
  void *v102; // [esp+D0h] [ebp-468h]
  void *v103; // [esp+D4h] [ebp-464h]
  wchar_t *v104; // [esp+D8h] [ebp-460h]
  void *v105; // [esp+DCh] [ebp-45Ch]
  void *v106; // [esp+E0h] [ebp-458h]
  void *v107; // [esp+E4h] [ebp-454h]
  int v108; // [esp+E8h] [ebp-450h]
  HKEY hKey; // [esp+ECh] [ebp-44Ch]
  void *v110; // [esp+F0h] [ebp-448h]
  void *v111; // [esp+F4h] [ebp-444h]
  int v112; // [esp+F8h] [ebp-440h]
  void *v113; // [esp+FCh] [ebp-43Ch]
  void *v114; // [esp+100h] [ebp-438h]
  HKEY v115; // [esp+104h] [ebp-434h]
  void *v116; // [esp+108h] [ebp-430h]
  int v117; // [esp+10Ch] [ebp-42Ch]
  char v118; // [esp+113h] [ebp-425h]
  wchar_t *v119; // [esp+114h] [ebp-424h]
  wchar_t Data[260]; // [esp+118h] [ebp-420h]
  WCHAR Name; // [esp+320h] [ebp-218h]
  int v122; // [esp+534h] [ebp-4h]

  v5 = a4;
  v112 = a1;
  v111 = a2;
  v104 = psz;
  v117 = 0;
  v108 = 0;
  if ( a4 == -1 )
  {
    v105 = _wcsdup(gpszTargetName);
    v122 = 0;
    v119 = _wcsdup(gpszTargetName);
    v103 = _wcsdup(gpszTargetName);
    v107 = _wcsdup(gpszTargetName);
    v106 = _wcsdup(gpszTargetName);
    v115 = _wcsdup(gpszTargetName);
    v113 = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( psz )
      v6 = psz;
    v114 = _wcsdup(v6);
    v110 = _wcsdup(gpszTargetName);
    v7 = gpszTargetName;
    if ( psz )
      v7 = psz;
    v116 = _wcsdup(v7);
    LOBYTE(v122) = 9;
    v8 = sub_11F7BE0(&v102, a2, &v114, &v113);
    LOBYTE(v122) = 10;
    v9 = sub_11F7BE0(&v101, a2, &v116, &v110);
    LOBYTE(v122) = 11;
    v5 = sub_11F3FF0(v112, 0, 0xFFFFFFFF, 0, v9, v8, &v115);
    a4 = v5;
    free(v101);
    free(v102);
    free(v116);
    free(v110);
    free(v114);
    free(v113);
    free(v115);
    free(v106);
    free(v107);
    free(v103);
    free(v119);
    v122 = -1;
    free(v105);
  }
  hKey = 0;
  v10 = TlsGetValue(gdwTlsIndex);
  if ( sub_11F67A0(a2, psz, 0, v10 | 0x20019, &hKey) )
    return v5;
  v101 = 0;
  if ( !RegEnumKeyW(hKey, 0, &Name, 0x104u) )
  {
    v12 = v119;
    do
    {
      v115 = 0;
      if ( a5 )
      {
        v13 = v105;
        v119 = gpszTargetName;
      }
      else
      {
        v13 = _wcsdup(L"AutorunsDisabled");
        v105 = v13;
        v14 = v117 | 1;
        v15 = *sub_120F210(&v68, L"\\", &v105);
        v117 = v14 | 2;
        v108 = v14 | 2;
        v119 = v15;
      }
      v16 = _wcsdup(&Name);
      v17 = v16;
      v116 = v16;
      v122 = 14;
      v119 = *sub_11F22B0(&v74, &v116, v119);
      LOBYTE(v122) = 15;
      v18 = TlsGetValue(gdwTlsIndex);
      v118 = sub_11F67A0(hKey, v119, 0, v18 | 0x20019, &v115) == 0;
      free(v74);
      free(v17);
      v19 = v117;
      if ( v117 & 2 )
      {
        v117 &= 0xFFFFFFFD;
        v108 = v117;
        free(v68);
        v19 = v117;
      }
      v122 = -1;
      if ( v19 & 1 )
      {
        v117 = v19 & 0xFFFFFFFE;
        v108 = v19 & 0xFFFFFFFE;
        free(v13);
      }
      if ( v118 )
      {
        cbData = 520;
        if ( !RegQueryValueExW(v115, L"Debugger", 0, 0, Data, &cbData) )
        {
          v114 = malloc(2u);
          *v114 = 0;
          v122 = 16;
          v116 = malloc(2u);
          *v116 = 0;
          v110 = malloc(2u);
          *v110 = 0;
          v54 = malloc(2u);
          *v54 = 0;
          v55 = 0;
          v56 = 0;
          v57 = 0;
          LOBYTE(v122) = 19;
          sub_11F7040(Data, &v54);
          sub_11F4EE0(&v113, v112, &v54, 0);
          LOBYTE(v122) = 20;
          v100 = sub_11F4ED0();
          v88 = _wcsdup(&Name);
          v20 = v104;
          v21 = gpszTargetName;
          if ( v104 )
            v21 = v104;
          v106 = _wcsdup(v21);
          v107 = _wcsdup(gpszTargetName);
          v22 = gpszTargetName;
          if ( v20 )
            v22 = v20;
          v103 = _wcsdup(v22);
          v23 = _wcsdup(&Name);
          v119 = v23;
          v24 = sub_11F22B0(&v72, &v119, L"\\Debugger");
          LOBYTE(v122) = 26;
          v25 = sub_11F7BE0(&v59, v111, &v106, v24);
          LOBYTE(v122) = 27;
          v26 = sub_11F7BE0(&v58, v111, &v103, &v107);
          LOBYTE(v122) = 28;
          v118 = sub_11F3D40(v112, v26, v25, &v88, &v113, &v114, &v110, &v60);
          free(v58);
          free(v59);
          free(v72);
          free(v23);
          free(v103);
          free(v107);
          free(v106);
          free(v88);
          if ( v118 )
          {
            if ( a4 == -1 )
            {
              v92 = _wcsdup(gpszTargetName);
              v84 = _wcsdup(gpszTargetName);
              v94 = _wcsdup(gpszTargetName);
              v80 = _wcsdup(gpszTargetName);
              v79 = _wcsdup(gpszTargetName);
              v96 = _wcsdup(gpszTargetName);
              v75 = _wcsdup(gpszTargetName);
              v27 = v104;
              v28 = gpszTargetName;
              if ( v104 )
                v28 = v104;
              v77 = _wcsdup(v28);
              v81 = _wcsdup(gpszTargetName);
              v29 = gpszTargetName;
              if ( v27 )
                v29 = v27;
              v83 = _wcsdup(v29);
              LOBYTE(v122) = 38;
              v30 = sub_11F7BE0(&v70, v111, &v77, &v75);
              LOBYTE(v122) = 39;
              v31 = sub_11F7BE0(&v64, v111, &v83, &v81);
              LOBYTE(v122) = 40;
              a4 = sub_11F3FF0(v112, 0, 0xFFFFFFFF, 0, v31, v30, &v96);
              free(v64);
              free(v70);
              free(v83);
              free(v81);
              free(v77);
              free(v75);
              free(v96);
              free(v79);
              free(v80);
              free(v94);
              free(v84);
              free(v92);
            }
            else
            {
              v27 = v104;
            }
            v98 = _wcsdup(gpszTargetName);
            v82 = _wcsdup(Data);
            v32 = gpszTargetName;
            if ( v27 )
              v32 = v27;
            v90 = _wcsdup(v32);
            v76 = _wcsdup(&Name);
            v33 = _wcsdup(&Name);
            v119 = v33;
            v34 = sub_11F22B0(&v66, &v119, L"\\Debugger");
            LOBYTE(v122) = 46;
            v35 = sub_11F7BE0(&v62, v111, &v90, v34);
            LOBYTE(v122) = 47;
            sub_11F3FF0(v112, v100, a4, 1, &v76, v35, &v113);
            free(v62);
            free(v66);
            free(v33);
            free(v76);
            free(v90);
            free(v82);
            free(v98);
          }
          free(v113);
          sub_11F21F0(&v54);
          free(v110);
          free(v116);
          v122 = -1;
          free(v114);
        }
        RegCloseKey(v115);
      }
      v36 = TlsGetValue(gdwTlsIndex);
      if ( !sub_11F67A0(hKey, &Name, 0, v36 | 0x20019, &v115) )
      {
        cbData = 4;
        if ( !RegQueryValueExW(v115, L"GlobalFlag", 0, 0, v61, &cbData) && *v61 & 0x100 )
        {
          if ( a4 == -1 )
          {
            v102 = _wcsdup(gpszTargetName);
            v122 = 48;
            v85 = _wcsdup(gpszTargetName);
            v87 = _wcsdup(gpszTargetName);
            v89 = _wcsdup(gpszTargetName);
            v91 = _wcsdup(gpszTargetName);
            v93 = _wcsdup(gpszTargetName);
            v95 = _wcsdup(gpszTargetName);
            v37 = v104;
            v38 = gpszTargetName;
            if ( v104 )
              v38 = v104;
            v97 = _wcsdup(v38);
            v86 = _wcsdup(gpszTargetName);
            v39 = gpszTargetName;
            if ( v37 )
              v39 = v37;
            v78 = _wcsdup(v39);
            v40 = v111;
            LOBYTE(v122) = 57;
            v41 = sub_11F7BE0(&v71, v111, &v97, &v95);
            LOBYTE(v122) = 58;
            v42 = sub_11F7BE0(&v73, v40, &v78, &v86);
            LOBYTE(v122) = 59;
            a4 = sub_11F3FF0(v112, 0, 0xFFFFFFFF, 0, v42, v41, &v93);
            free(v73);
            free(v71);
            free(v78);
            free(v86);
            free(v97);
            free(v95);
            free(v93);
            free(v91);
            free(v89);
            free(v87);
            free(v85);
            free(v102);
          }
          if ( a5 )
          {
            v119 = gpszTargetName;
          }
          else
          {
            v12 = _wcsdup(L"AutorunsDisabled");
            v119 = v12;
            v43 = sub_120F210(&v65, L"\\", &v119);
            v117 |= 0xCu;
            v44 = *v43;
            v108 = v117;
            v119 = v44;
          }
          v45 = _wcsdup(&Name);
          v46 = v45;
          v116 = v45;
          v47 = gpszTargetName;
          if ( v104 )
            v47 = v104;
          v48 = _wcsdup(v47);
          v49 = v48;
          v100 = v48;
          v50 = sub_11F22B0(&v67, &v100, L"\\");
          v51 = sub_1203070(&v69, v50, &v116);
          sub_11F22B0(&v63, v51, v119);
          v122 = 60;
          free(v69);
          free(v67);
          free(v49);
          free(v46);
          v52 = v117;
          if ( v117 & 8 )
          {
            v117 &= 0xFFFFFFF7;
            v108 = v117;
            free(v65);
            v52 = v117;
          }
          if ( v52 & 4 )
          {
            v117 = v52 & 0xFFFFFFFB;
            v108 = v52 & 0xFFFFFFFB;
            free(v12);
          }
          v53 = v63;
          sub_1206A10(v112, v111, v63, L"VerifierDlls", &Name, 32, a4);
          v122 = -1;
          free(v53);
        }
        RegCloseKey(v115);
      }
      v101 = v101 + 1;
    }
    while ( !RegEnumKeyW(hKey, v101, &Name, 0x104u) );
  }
  RegCloseKey(hKey);
  return a4;
}

//----- (01205E10) --------------------------------------------------------
void *__cdecl sub_1205E10(int a1, void *a2, OLECHAR *psz)
{
  CComBSTR **v3; // eax
  _bstr_t *v4; // eax
  void *v5; // esi
  CComBSTR *v6; // esi
  CComBSTR *v7; // esi
  void *v8; // eax
  void *v9; // eax
  CComBSTR *v10; // esi
  void *v11; // edi
  CComBSTR *ppComBSTR1; // [esp+10h] [ebp-1Ch]
  CComBSTR *ppv; // [esp+14h] [ebp-18h]
  CComBSTR *v15; // [esp+18h] [ebp-14h]
  void *v16; // [esp+1Ch] [ebp-10h]
  int v17; // [esp+28h] [ebp-4h]

  bstr_t::EqualAssign(&ppv, L"AutorunsDisabled");
  v17 = 0;
  v3 = bstr_t::EqualAssign(&v15, L"\\");
  LOBYTE(v17) = 1;
  v4 = sub_11F3B50(&v16, psz, v3);
  LOBYTE(v17) = 2;
  CComBSTR::AppendTail(v4, &ppComBSTR1, &ppv);
  v5 = v16;
  if ( v16 )
  {
    if ( !InterlockedDecrement(v16 + 2) && v5 )
    {
      if ( *v5 )
      {
        SysFreeString(*v5);
        *v5 = 0;
      }
      if ( *(v5 + 1) )
      {
        j_j__free(*(v5 + 1));
        *(v5 + 1) = 0;
      }
      j__free(v5);
    }
    v16 = 0;
  }
  v6 = v15;
  if ( v15 )
  {
    if ( !InterlockedDecrement(&v15->Length) && v6 )
    {
      if ( v6->bstr )
      {
        SysFreeString(v6->bstr);
        v6->bstr = 0;
      }
      if ( v6->hKey )
      {
        j_j__free(v6->hKey);
        v6->hKey = 0;
      }
      j__free(v6);
    }
    v15 = 0;
  }
  v7 = ppv;
  LOBYTE(v17) = 6;
  if ( ppv && !InterlockedDecrement(&ppv->Length) )
  {
    if ( v7->bstr )
    {
      SysFreeString(v7->bstr);
      v7->bstr = 0;
    }
    if ( v7->hKey )
    {
      j_j__free(v7->hKey);
      v7->hKey = 0;
    }
    j__free(v7);
  }
  v8 = sub_1205FF0(a1, a2, psz, 0xFFFFFFFF, 1);
  v9 = sub_1205FF0(a1, a2, psz, v8, 0);
  v10 = ppComBSTR1;
  v11 = v9;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v10 )
  {
    if ( v10->bstr )
    {
      SysFreeString(v10->bstr);
      v10->bstr = 0;
    }
    if ( v10->hKey )
    {
      j_j__free(v10->hKey);
      v10->hKey = 0;
    }
    j__free(v10);
  }
  return v11;
}

//----- (01205FF0) --------------------------------------------------------
void *__cdecl sub_1205FF0(int a1, void *a2, wchar_t *a3, void *a4, char a5)
{
  WCHAR *v5; // eax
  WCHAR *v6; // eax
  unsigned __int16 **v7; // esi
  unsigned __int16 **v8; // eax
  wchar_t *v9; // eax
  wchar_t *v10; // eax
  int v11; // ecx
  void *v12; // ebx
  WCHAR *v13; // eax
  wchar_t *v14; // eax
  wchar_t *v15; // ebx
  wchar_t *v16; // eax
  wchar_t *v17; // edi
  WCHAR *v18; // eax
  wchar_t *v19; // esi
  const wchar_t **v20; // eax
  unsigned __int16 **v21; // eax
  const wchar_t **v22; // eax
  unsigned __int16 **v23; // eax
  unsigned int v24; // eax
  wchar_t *v25; // esi
  int v26; // eax
  OLECHAR *v27; // edi
  unsigned int v28; // eax
  int v29; // eax
  wchar_t *v30; // edi
  WCHAR *v31; // ecx
  WCHAR *v32; // eax
  WCHAR *v33; // eax
  unsigned __int16 **v34; // esi
  unsigned __int16 **v35; // eax
  WCHAR *v36; // esi
  WCHAR *v37; // eax
  WCHAR *v38; // eax
  unsigned __int16 **v39; // eax
  WCHAR *v40; // eax
  unsigned __int16 **v41; // eax
  int v43; // [esp+10h] [ebp-494h]
  int v44; // [esp+20h] [ebp-484h]
  int v45; // [esp+24h] [ebp-480h]
  DWORD cbData; // [esp+28h] [ebp-47Ch]
  HKEY v47; // [esp+2Ch] [ebp-478h]
  HKEY hKey; // [esp+30h] [ebp-474h]
  wchar_t *v49; // [esp+34h] [ebp-470h]
  wchar_t *v50; // [esp+38h] [ebp-46Ch]
  int v51; // [esp+3Ch] [ebp-468h]
  void *v52; // [esp+40h] [ebp-464h]
  wchar_t *v53; // [esp+44h] [ebp-460h]
  void *v54; // [esp+48h] [ebp-45Ch]
  void *v55; // [esp+4Ch] [ebp-458h]
  void *v56; // [esp+50h] [ebp-454h]
  void *v57; // [esp+54h] [ebp-450h]
  void *v58; // [esp+58h] [ebp-44Ch]
  void *v59; // [esp+5Ch] [ebp-448h]
  void *v60; // [esp+60h] [ebp-444h]
  void *v61; // [esp+64h] [ebp-440h]
  void *v62; // [esp+68h] [ebp-43Ch]
  void *v63; // [esp+6Ch] [ebp-438h]
  void *v64; // [esp+70h] [ebp-434h]
  void *v65; // [esp+74h] [ebp-430h]
  void *v66; // [esp+78h] [ebp-42Ch]
  void *v67; // [esp+7Ch] [ebp-428h]
  char v68; // [esp+83h] [ebp-421h]
  wchar_t Data[260]; // [esp+84h] [ebp-420h]
  wchar_t v70[260]; // [esp+28Ch] [ebp-218h]
  int v71; // [esp+4A0h] [ebp-4h]

  v51 = a1;
  v56 = a2;
  v50 = a3;
  if ( a4 == -1 )
  {
    v65 = _wcsdup(gpszTargetName);
    v71 = 0;
    v52 = _wcsdup(gpszTargetName);
    v64 = _wcsdup(gpszTargetName);
    v63 = _wcsdup(gpszTargetName);
    v60 = _wcsdup(gpszTargetName);
    v58 = _wcsdup(gpszTargetName);
    v57 = _wcsdup(gpszTargetName);
    v5 = gpszTargetName;
    if ( a3 )
      v5 = a3;
    v54 = _wcsdup(v5);
    v55 = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( a3 )
      v6 = a3;
    v53 = _wcsdup(v6);
    LOBYTE(v71) = 9;
    v7 = sub_11F7BE0(&v67, a2, &v54, &v57);
    LOBYTE(v71) = 10;
    v8 = sub_11F7BE0(&v66, a2, &v53, &v55);
    LOBYTE(v71) = 11;
    a4 = sub_11F3FF0(v51, 0, 0xFFFFFFFF, 0, v8, v7, &v58);
    free(v66);
    free(v67);
    free(v53);
    free(v55);
    free(v54);
    free(v57);
    free(v58);
    free(v60);
    free(v63);
    free(v64);
    free(v52);
    free(v65);
  }
  v65 = malloc(2u);
  *v65 = 0;
  v71 = 12;
  hKey = 0;
  v9 = _wcsdup(a3);
  v53 = v9;
  v10 = wcsrchr(v9, 0x5Cu);
  *v10 = 0;
  v11 = (v10 + 1);
  v49 = v10 + 1;
  if ( a5 )
  {
    v12 = _wcsdup(a3);
    v52 = v12;
    free(v65);
  }
  else
  {
    v13 = gpszTargetName;
    if ( v11 )
      v13 = v11;
    v14 = _wcsdup(v13);
    v15 = v14;
    v61 = v14;
    v16 = _wcsdup(L"AutorunsDisabled");
    v17 = v16;
    v67 = v16;
    v18 = gpszTargetName;
    if ( v53 )
      v18 = v53;
    v19 = _wcsdup(v18);
    v66 = v19;
    v20 = sub_11F22B0(&v63, &v66, L"\\");
    v21 = sub_1203070(&v64, v20, &v67);
    v22 = sub_11F22B0(&v62, v21, L"\\");
    v23 = sub_1203070(&v59, v22, &v61);
    v52 = _wcsdup(*v23);
    free(v65);
    free(v59);
    free(v62);
    free(v64);
    free(v63);
    free(v19);
    free(v17);
    free(v15);
    v12 = v52;
  }
  v24 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(v56, v12, 0, v24 | 0x20019, &hKey) )
  {
    v47 = 0;
    cbData = 520;
    if ( !RegQueryValueExW(hKey, 0, 0, 0, Data, &cbData) )
    {
      v25 = _wcsdup(Data);
      v66 = v25;
      v26 = sub_120F210(&v61, L"Software\\Classes\\", &v66);
      v27 = *sub_11F22B0(&v67, v26, L"\\shell\\open\\command");
      LOBYTE(v71) = 15;
      v28 = TlsGetValue(gdwTlsIndex);
      v68 = sub_11F67A0(v56, v27, 0, v28 | 0x20019, &v47) == 0;
      free(v67);
      free(v61);
      LOBYTE(v71) = 12;
      free(v25);
      if ( v68 )
      {
        cbData = 520;
        if ( !RegQueryValueExW(v47, 0, 0, 0, v70, &cbData) )
        {
          v29 = wcscmp(v70, L"\"%1\" %*");
          if ( v29 )
            v29 = -(v29 < 0) | 1;
          if ( v29 )
          {
            v57 = malloc(2u);
            *v57 = 0;
            v55 = malloc(2u);
            *v55 = 0;
            v54 = malloc(2u);
            *v54 = 0;
            sub_11F2170(&v43);
            LOBYTE(v71) = 19;
            sub_11F7040(v70, &v43);
            sub_11F4EE0(&v58, v51, &v43, 0);
            LOBYTE(v71) = 20;
            v45 = sub_11F4ED0();
            v62 = _wcsdup(gpszTargetName);
            v30 = v50;
            v31 = gpszTargetName;
            if ( v50 )
              v31 = v50;
            v60 = _wcsdup(v31);
            v63 = _wcsdup(gpszTargetName);
            v32 = gpszTargetName;
            if ( v30 )
              v32 = v30;
            v64 = _wcsdup(v32);
            v33 = gpszTargetName;
            if ( v30 )
              v33 = v30;
            v65 = _wcsdup(v33);
            LOBYTE(v71) = 25;
            v34 = sub_11F7BE0(&v67, v56, &v60, &v62);
            LOBYTE(v71) = 26;
            v35 = sub_11F7BE0(&v66, v56, &v64, &v63);
            LOBYTE(v71) = 27;
            v68 = sub_11F3D40(v51, &v65, v35, v34, &v58, &v57, &v54, &v44);
            free(v66);
            free(v67);
            free(v65);
            free(v64);
            free(v63);
            free(v60);
            LOBYTE(v71) = 20;
            free(v62);
            if ( v68 )
            {
              if ( a4 == -1 )
              {
                v66 = _wcsdup(gpszTargetName);
                v67 = _wcsdup(gpszTargetName);
                v61 = _wcsdup(gpszTargetName);
                v59 = _wcsdup(gpszTargetName);
                v60 = _wcsdup(gpszTargetName);
                v63 = _wcsdup(gpszTargetName);
                v64 = _wcsdup(gpszTargetName);
                v36 = gpszTargetName;
                v37 = gpszTargetName;
                if ( v30 )
                  v37 = v30;
                v65 = _wcsdup(v37);
                v38 = gpszTargetName;
                if ( v49 )
                  v38 = v49;
                v62 = _wcsdup(v38);
                LOBYTE(v71) = 36;
                v39 = sub_11F7BE0(&v50, v56, &v65, &v64);
                LOBYTE(v71) = 37;
                a4 = sub_11F3FF0(v51, 0, 0xFFFFFFFF, 0, &v62, v39, &v63);
                free(v50);
                free(v62);
                free(v65);
                free(v64);
                free(v63);
                free(v60);
                free(v59);
                free(v61);
                free(v67);
                free(v66);
              }
              else
              {
                v36 = gpszTargetName;
              }
              v62 = _wcsdup(gpszTargetName);
              v59 = _wcsdup(v70);
              v61 = _wcsdup(gpszTargetName);
              v40 = gpszTargetName;
              if ( v30 )
                v40 = v30;
              v67 = _wcsdup(v40);
              if ( v30 )
                v36 = v30;
              v66 = _wcsdup(v36);
              LOBYTE(v71) = 42;
              v41 = sub_11F7BE0(&v49, v56, &v67, &v61);
              LOBYTE(v71) = 43;
              sub_11F3FF0(v51, v45, a4, 3, &v66, v41, &v58);
              free(v49);
              free(v66);
              free(v67);
              free(v61);
              free(v59);
              free(v62);
            }
            free(v58);
            sub_11F21F0(&v43);
            free(v54);
            free(v55);
            free(v57);
          }
        }
        RegCloseKey(v47);
      }
    }
    RegCloseKey(hKey);
  }
  free(v53);
  free(v12);
  return a4;
}
// 12B244C: using guessed type wchar_t a1_0[8];

//----- (01206A10) --------------------------------------------------------
void *__cdecl sub_1206A10(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, wchar_t *a5, int a6, void *a7)
{
  unsigned int v7; // eax
  int v8; // esi
  char *v9; // ecx
  int v10; // ebx
  OLECHAR **v11; // edi
  void *v12; // esi
  const wchar_t **v13; // eax
  void *v14; // esi
  const wchar_t *v15; // ecx
  WCHAR *v16; // eax
  WCHAR *v17; // eax
  unsigned __int16 **v18; // esi
  unsigned __int16 **v19; // eax
  char v20; // bl
  const wchar_t *v21; // eax
  const wchar_t *v22; // eax
  WCHAR *v23; // eax
  WCHAR *v24; // eax
  unsigned __int16 **v25; // eax
  void *v27; // [esp+10h] [ebp-78h]
  int v28; // [esp+14h] [ebp-74h]
  int v29; // [esp+18h] [ebp-70h]
  void *v30; // [esp+1Ch] [ebp-6Ch]
  int v31; // [esp+20h] [ebp-68h]
  int v32; // [esp+24h] [ebp-64h]
  void *v33; // [esp+28h] [ebp-60h]
  void *v34; // [esp+2Ch] [ebp-5Ch]
  void *v35; // [esp+30h] [ebp-58h]
  HKEY hKey; // [esp+34h] [ebp-54h]
  int v37; // [esp+38h] [ebp-50h]
  unsigned int v38; // [esp+3Ch] [ebp-4Ch]
  void *v39; // [esp+40h] [ebp-48h]
  void *v40; // [esp+44h] [ebp-44h]
  void *v41; // [esp+48h] [ebp-40h]
  void *v42; // [esp+4Ch] [ebp-3Ch]
  void *v43; // [esp+50h] [ebp-38h]
  void *v44; // [esp+54h] [ebp-34h]
  void *v45; // [esp+58h] [ebp-30h]
  void *v46; // [esp+5Ch] [ebp-2Ch]
  void *v47; // [esp+60h] [ebp-28h]
  void *v48; // [esp+64h] [ebp-24h]
  wchar_t *v49; // [esp+68h] [ebp-20h]
  void *v50; // [esp+6Ch] [ebp-1Ch]
  void *v51; // [esp+70h] [ebp-18h]
  void *v52; // [esp+74h] [ebp-14h]
  int v53; // [esp+84h] [ebp-4h]

  v52 = malloc(2u);
  *v52 = 0;
  v53 = 0;
  v50 = malloc(2u);
  *v50 = 0;
  v47 = malloc(2u);
  *v47 = 0;
  v48 = malloc(2u);
  *v48 = 0;
  v51 = malloc(2u);
  *v51 = 0;
  LOBYTE(v53) = 4;
  v7 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, psz, 0, v7 | 0x20019, &hKey) )
  {
    v49 = malloc(2u);
    *v49 = 0;
    LOBYTE(v53) = 5;
    if ( !sub_1201520(hKey, lpValueName, 0, 0, &v49) && wcslen(v49) )
    {
      v27 = 0;
      v28 = 0;
      v29 = 0;
      LOBYTE(v53) = 6;
      sub_11F6DD0(v49, 44, &v27, 0);
      v8 = v28;
      v9 = v27;
      v38 = 0;
      if ( (v28 - v27) >> 4 )
      {
        v10 = 0;
        v37 = 0;
        do
        {
          v11 = &v9[v10];
          v12 = v51;
          v51 = _wcsdup(**&v9[v10 + 4]);
          free(v12);
          v13 = sub_11F4EE0(&v35, a1, v11, 0);
          v14 = v52;
          v52 = _wcsdup(*v13);
          free(v14);
          free(v35);
          v31 = sub_11F4ED0();
          v15 = gpszTargetName;
          if ( lpValueName )
            v15 = lpValueName;
          v43 = _wcsdup(v15);
          v16 = gpszTargetName;
          if ( psz )
            v16 = psz;
          v44 = _wcsdup(v16);
          v45 = _wcsdup(gpszTargetName);
          v17 = gpszTargetName;
          if ( psz )
            v17 = psz;
          v46 = _wcsdup(v17);
          LOBYTE(v53) = 10;
          v18 = sub_11F7BE0(&v33, a2, &v44, &v43);
          LOBYTE(v53) = 11;
          v19 = sub_11F7BE0(&v34, a2, &v46, &v45);
          LOBYTE(v53) = 12;
          v20 = sub_11F3D40(a1, v19, v18, v11, &v52, &v50, &v48, &v32);
          free(v34);
          free(v33);
          free(v46);
          free(v45);
          free(v44);
          LOBYTE(v53) = 6;
          free(v43);
          if ( v20 )
          {
            v21 = gpszTargetName;
            if ( lpValueName )
              v21 = lpValueName;
            v39 = _wcsdup(v21);
            v22 = gpszTargetName;
            if ( lpValueName )
              v22 = lpValueName;
            v40 = _wcsdup(v22);
            v23 = gpszTargetName;
            if ( psz )
              v23 = psz;
            v41 = _wcsdup(v23);
            v24 = gpszTargetName;
            if ( a5 )
              v24 = a5;
            v42 = _wcsdup(v24);
            LOBYTE(v53) = 16;
            v25 = sub_11F7BE0(&v30, a2, &v41, &v40);
            LOBYTE(v53) = 17;
            sub_11F3FF0(a1, v31, a7, 1, &v42, v25, &v52);
            free(v30);
            free(v42);
            free(v41);
            free(v40);
            LOBYTE(v53) = 6;
            free(v39);
          }
          v8 = v28;
          v9 = v27;
          v10 = v37 + 16;
          ++v38;
          v37 += 16;
        }
        while ( v38 < (v28 - v27) >> 4 );
      }
      if ( v9 )
      {
        sub_11F2BF0(v9, v8);
        j__free(v27);
      }
    }
    RegCloseKey(hKey);
    free(v49);
  }
  free(v51);
  free(v48);
  free(v47);
  free(v50);
  free(v52);
  return a7;
}

//----- (01206E10) --------------------------------------------------------
void *__cdecl sub_1206E10(int a1, void *a2, OLECHAR *psz, LPCWSTR lpValueName)
{
  CComBSTR **v4; // eax
  _bstr_t *v5; // eax
  void *v6; // esi
  CComBSTR *v7; // esi
  CComBSTR *v8; // esi
  void *v9; // eax
  wchar_t *v10; // ecx
  void *v11; // eax
  CComBSTR *v12; // esi
  void *v13; // edi
  CComBSTR *ppComBSTR1; // [esp+10h] [ebp-1Ch]
  CComBSTR *ppv; // [esp+14h] [ebp-18h]
  CComBSTR *v17; // [esp+18h] [ebp-14h]
  void *v18; // [esp+1Ch] [ebp-10h]
  int v19; // [esp+28h] [ebp-4h]

  bstr_t::EqualAssign(&ppv, L"AutorunsDisabled");
  v19 = 0;
  v4 = bstr_t::EqualAssign(&v17, L"\\");
  LOBYTE(v19) = 1;
  v5 = sub_11F3B50(&v18, psz, v4);
  LOBYTE(v19) = 2;
  CComBSTR::AppendTail(v5, &ppComBSTR1, &ppv);
  v6 = v18;
  if ( v18 )
  {
    if ( !InterlockedDecrement(v18 + 2) && v6 )
    {
      if ( *v6 )
      {
        SysFreeString(*v6);
        *v6 = 0;
      }
      if ( *(v6 + 1) )
      {
        j_j__free(*(v6 + 1));
        *(v6 + 1) = 0;
      }
      j__free(v6);
    }
    v18 = 0;
  }
  v7 = v17;
  if ( v17 )
  {
    if ( !InterlockedDecrement(&v17->Length) && v7 )
    {
      if ( v7->bstr )
      {
        SysFreeString(v7->bstr);
        v7->bstr = 0;
      }
      if ( v7->hKey )
      {
        j_j__free(v7->hKey);
        v7->hKey = 0;
      }
      j__free(v7);
    }
    v17 = 0;
  }
  v8 = ppv;
  LOBYTE(v19) = 6;
  if ( ppv && !InterlockedDecrement(&ppv->Length) )
  {
    if ( v8->bstr )
    {
      SysFreeString(v8->bstr);
      v8->bstr = 0;
    }
    if ( v8->hKey )
    {
      j_j__free(v8->hKey);
      v8->hKey = 0;
    }
    j__free(v8);
  }
  v9 = sub_1207000(a1, a2, psz, lpValueName, -1);
  if ( ppComBSTR1 )
    v10 = ppComBSTR1->bstr;
  else
    v10 = 0;
  v11 = sub_1207000(a1, a2, v10, lpValueName, v9);
  v12 = ppComBSTR1;
  v13 = v11;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v12 )
  {
    if ( v12->bstr )
    {
      SysFreeString(v12->bstr);
      v12->bstr = 0;
    }
    if ( v12->hKey )
    {
      j_j__free(v12->hKey);
      v12->hKey = 0;
    }
    j__free(v12);
  }
  return v13;
}

//----- (01207000) --------------------------------------------------------
void *__cdecl sub_1207000(int a1, void *a2, wchar_t *psz, LPCWSTR lpValueName, int a5)
{
  void *v5; // ebx
  const wchar_t *v6; // eax
  WCHAR *v7; // eax
  const wchar_t *v8; // eax
  WCHAR *v9; // eax
  unsigned __int16 **v10; // esi
  unsigned __int16 **v11; // eax
  LPCWSTR v13; // ebx
  wchar_t *v14; // esi
  DWORD v15; // eax
  int v16; // edi
  _WORD *v17; // eax
  void *v18; // eax
  WCHAR *v19; // ecx
  WCHAR *v20; // eax
  WCHAR *v21; // eax
  WCHAR *v22; // eax
  unsigned __int16 **v23; // edi
  unsigned __int16 **v24; // eax
  OLECHAR **v25; // ST40_4
  char v26; // bl
  const wchar_t *v27; // eax
  WCHAR *v28; // eax
  const wchar_t *v29; // eax
  WCHAR *v30; // eax
  unsigned __int16 **v31; // edi
  unsigned __int16 **v32; // eax
  WCHAR *v33; // eax
  WCHAR *v34; // eax
  unsigned __int16 **v35; // eax
  int v36; // [esp+10h] [ebp-A4h]
  int v37; // [esp+14h] [ebp-A0h]
  int v38; // [esp+18h] [ebp-9Ch]
  int v39; // [esp+1Ch] [ebp-98h]
  void *v40; // [esp+20h] [ebp-94h]
  void *v41; // [esp+24h] [ebp-90h]
  void *v42; // [esp+28h] [ebp-8Ch]
  int v43; // [esp+2Ch] [ebp-88h]
  void *v44; // [esp+30h] [ebp-84h]
  int v45; // [esp+34h] [ebp-80h]
  void *v46; // [esp+38h] [ebp-7Ch]
  void *v47; // [esp+3Ch] [ebp-78h]
  void *v48; // [esp+40h] [ebp-74h]
  void *v49; // [esp+44h] [ebp-70h]
  void *v50; // [esp+48h] [ebp-6Ch]
  void *v51; // [esp+4Ch] [ebp-68h]
  void *v52; // [esp+50h] [ebp-64h]
  void *v53; // [esp+54h] [ebp-60h]
  void *v54; // [esp+58h] [ebp-5Ch]
  void *v55; // [esp+5Ch] [ebp-58h]
  void *v56; // [esp+60h] [ebp-54h]
  void *v57; // [esp+64h] [ebp-50h]
  void *v58; // [esp+68h] [ebp-4Ch]
  void *v59; // [esp+6Ch] [ebp-48h]
  HKEY hKey; // [esp+70h] [ebp-44h]
  void *v61; // [esp+74h] [ebp-40h]
  void *v62; // [esp+78h] [ebp-3Ch]
  void *v63; // [esp+7Ch] [ebp-38h]
  void *v64; // [esp+80h] [ebp-34h]
  void *v65; // [esp+84h] [ebp-30h]
  void *v66; // [esp+88h] [ebp-2Ch]
  void *v67; // [esp+8Ch] [ebp-28h]
  void *v68; // [esp+90h] [ebp-24h]
  DWORD cbData; // [esp+94h] [ebp-20h]
  void *v70; // [esp+98h] [ebp-1Ch]
  void *v71; // [esp+9Ch] [ebp-18h]
  void *v72; // [esp+A0h] [ebp-14h]
  void *v73; // [esp+A4h] [ebp-10h]
  int v74; // [esp+B0h] [ebp-4h]

  v5 = a5;
  v71 = a5;
  if ( dword_12E31D8 && a5 == -1 )
  {
    v63 = _wcsdup(gpszTargetName);
    v74 = 0;
    v65 = _wcsdup(gpszTargetName);
    v66 = _wcsdup(gpszTargetName);
    v62 = _wcsdup(gpszTargetName);
    v64 = _wcsdup(gpszTargetName);
    v67 = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( lpValueName )
      v6 = lpValueName;
    v73 = _wcsdup(v6);
    v7 = gpszTargetName;
    if ( psz )
      v7 = psz;
    v72 = _wcsdup(v7);
    v8 = gpszTargetName;
    if ( lpValueName )
      v8 = lpValueName;
    v70 = _wcsdup(v8);
    v9 = gpszTargetName;
    if ( psz )
      v9 = psz;
    v68 = _wcsdup(v9);
    LOBYTE(v74) = 9;
    v10 = sub_11F7BE0(&v59, a2, &v72, &v73);
    LOBYTE(v74) = 10;
    v11 = sub_11F7BE0(&v61, a2, &v68, &v70);
    LOBYTE(v74) = 11;
    v5 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v11, v10, &v67);
    v71 = v5;
    free(v61);
    free(v59);
    free(v68);
    free(v70);
    free(v72);
    free(v73);
    free(v67);
    free(v64);
    free(v62);
    free(v66);
    free(v65);
    v74 = -1;
    free(v63);
  }
  hKey = 0;
  sub_11F67A0(a2, psz, 0, 131097, &hKey);
  if ( !hKey )
    return v5;
  v13 = lpValueName;
  cbData = 0;
  RegQueryValueExW(hKey, lpValueName, 0, 0, 0, &cbData);
  v14 = operator new[](2 * ((cbData >> 1) + 2));
  RegQueryValueExW(hKey, lpValueName, 0, 0, v14, &cbData);
  v15 = cbData >> 1;
  cbData = v15;
  if ( v15 > 2 )
  {
    v14[v15 - 1] = 0;
    v14[cbData] = 0;
    if ( *v14 )
    {
      v16 = a1;
      do
      {
        v17 = malloc(2u);
        v36 = v17;
        *v17 = 0;
        v37 = 0;
        v38 = 0;
        v39 = 0;
        v74 = 12;
        sub_11F6CC0(v14, &v36);
        v61 = _wcsdup(v14);
        LOBYTE(v74) = 13;
        sub_11F4EE0(&v73, v16, &v36, 0);
        v18 = v73;
        if ( *v73 )
        {
          v72 = malloc(2u);
          *v72 = 0;
          v68 = malloc(2u);
          *v68 = 0;
          v70 = malloc(2u);
          *v70 = 0;
          LOBYTE(v74) = 17;
          v43 = sub_11F4ED0();
          v19 = gpszTargetName;
          if ( v13 )
            v19 = v13;
          v64 = _wcsdup(v19);
          v20 = gpszTargetName;
          if ( psz )
            v20 = psz;
          v62 = _wcsdup(v20);
          v21 = gpszTargetName;
          if ( v13 )
            v21 = v13;
          v66 = _wcsdup(v21);
          v22 = gpszTargetName;
          if ( psz )
            v22 = psz;
          v65 = _wcsdup(v22);
          v63 = _wcsdup(v14);
          LOBYTE(v74) = 22;
          v23 = sub_11F7BE0(&v44, a2, &v62, &v64);
          LOBYTE(v74) = 23;
          v24 = sub_11F7BE0(&v46, a2, &v65, &v66);
          LOBYTE(v74) = 24;
          v25 = v23;
          v16 = a1;
          v26 = sub_11F3D40(a1, &v63, v24, v25, &v73, &v72, &v70, &v45);
          free(v46);
          free(v44);
          free(v63);
          free(v65);
          free(v66);
          free(v62);
          free(v64);
          if ( v26 )
          {
            if ( v71 == -1 )
            {
              v48 = _wcsdup(gpszTargetName);
              v52 = _wcsdup(gpszTargetName);
              v47 = _wcsdup(gpszTargetName);
              v54 = _wcsdup(gpszTargetName);
              v58 = _wcsdup(gpszTargetName);
              v56 = _wcsdup(gpszTargetName);
              v13 = lpValueName;
              v27 = gpszTargetName;
              if ( lpValueName )
                v27 = lpValueName;
              v55 = _wcsdup(v27);
              v28 = gpszTargetName;
              if ( psz )
                v28 = psz;
              v57 = _wcsdup(v28);
              v29 = gpszTargetName;
              if ( lpValueName )
                v29 = lpValueName;
              v49 = _wcsdup(v29);
              v30 = gpszTargetName;
              if ( psz )
                v30 = psz;
              v67 = _wcsdup(v30);
              LOBYTE(v74) = 34;
              v31 = sub_11F7BE0(&v42, a2, &v57, &v55);
              LOBYTE(v74) = 35;
              v32 = sub_11F7BE0(&v40, a2, &v67, &v49);
              LOBYTE(v74) = 36;
              v71 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v32, v31, &v56);
              free(v40);
              free(v42);
              free(v67);
              free(v49);
              free(v57);
              free(v55);
              free(v56);
              free(v58);
              free(v54);
              free(v47);
              free(v52);
              free(v48);
            }
            else
            {
              v13 = lpValueName;
            }
            v59 = _wcsdup(gpszTargetName);
            v33 = gpszTargetName;
            if ( v13 )
              v33 = v13;
            v51 = _wcsdup(v33);
            v34 = gpszTargetName;
            if ( psz )
              v34 = psz;
            v53 = _wcsdup(v34);
            v50 = _wcsdup(v14);
            LOBYTE(v74) = 40;
            v35 = sub_11F7BE0(&v41, a2, &v53, &v51);
            v16 = a1;
            LOBYTE(v74) = 41;
            sub_11F3FF0(a1, v43, v71, 5, &v50, v35, &v73);
            free(v41);
            free(v50);
            free(v53);
            free(v51);
            free(v59);
          }
          else
          {
            v13 = lpValueName;
          }
          free(v70);
          free(v68);
          free(v72);
          v18 = v73;
        }
        free(v18);
        free(v61);
        v74 = -1;
        sub_11F21F0(&v36);
        v14 = wcschr(v14 + 1, 0) + 1;
      }
      while ( *v14 );
    }
  }
  RegCloseKey(hKey);
  return v71;
}
// 12E31D8: using guessed type int dword_12E31D8;

//----- (01207710) --------------------------------------------------------
void __cdecl sub_1207710(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_12077C0(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_12077C0(a1, a2, v7, v5);
  free(v7);
}

//----- (012077C0) --------------------------------------------------------
void *__cdecl sub_12077C0(int a1, void *a2, wchar_t *psz, void *a4)
{
  wchar_t *v4; // edi
  _WORD *v5; // ebx
  OLECHAR *v6; // esi
  WCHAR *v7; // eax
  WCHAR *v8; // eax
  unsigned __int16 **v9; // esi
  unsigned __int16 **v10; // eax
  void **v11; // ebx
  __int16 *v12; // eax
  _WORD *v13; // edx
  __int16 v14; // cx
  wchar_t *v15; // esi
  unsigned __int16 **v16; // eax
  wchar_t *v17; // esi
  unsigned __int16 **v18; // eax
  _WORD *v19; // eax
  const wchar_t **v20; // eax
  void *v21; // esi
  WCHAR *v22; // eax
  WCHAR *v23; // eax
  unsigned __int16 **v24; // esi
  unsigned __int16 **v25; // eax
  WCHAR *v26; // eax
  WCHAR *v27; // eax
  unsigned __int16 **v28; // esi
  unsigned __int16 **v29; // eax
  WCHAR *v30; // eax
  unsigned __int16 **v31; // eax
  __int16 v32; // cx
  int v34; // [esp+10h] [ebp-BCh]
  int v35; // [esp+14h] [ebp-B8h]
  int v36; // [esp+18h] [ebp-B4h]
  int v37; // [esp+1Ch] [ebp-B0h]
  void *v38; // [esp+20h] [ebp-ACh]
  _WORD *v39; // [esp+24h] [ebp-A8h]
  void *v40; // [esp+28h] [ebp-A4h]
  void *v41; // [esp+2Ch] [ebp-A0h]
  void *v42; // [esp+30h] [ebp-9Ch]
  int v43; // [esp+34h] [ebp-98h]
  void *v44; // [esp+38h] [ebp-94h]
  void *v45; // [esp+3Ch] [ebp-90h]
  void *v46; // [esp+40h] [ebp-8Ch]
  void *v47; // [esp+44h] [ebp-88h]
  void *v48; // [esp+48h] [ebp-84h]
  void *v49; // [esp+4Ch] [ebp-80h]
  HKEY v50; // [esp+50h] [ebp-7Ch]
  void *v51; // [esp+54h] [ebp-78h]
  void *v52; // [esp+58h] [ebp-74h]
  void *v53; // [esp+5Ch] [ebp-70h]
  void *v54; // [esp+60h] [ebp-6Ch]
  void *v55; // [esp+64h] [ebp-68h]
  void *v56; // [esp+68h] [ebp-64h]
  HKEY hKey; // [esp+6Ch] [ebp-60h]
  void *v58; // [esp+70h] [ebp-5Ch]
  void *v59; // [esp+74h] [ebp-58h]
  void *v60; // [esp+78h] [ebp-54h]
  void *v61; // [esp+7Ch] [ebp-50h]
  wchar_t *v62; // [esp+80h] [ebp-4Ch]
  wchar_t *v63; // [esp+84h] [ebp-48h]
  wchar_t *v64; // [esp+88h] [ebp-44h]
  void *v65; // [esp+8Ch] [ebp-40h]
  void *v66; // [esp+90h] [ebp-3Ch]
  void *v67; // [esp+94h] [ebp-38h]
  void *v68; // [esp+98h] [ebp-34h]
  void *v69; // [esp+9Ch] [ebp-30h]
  void *v70; // [esp+A0h] [ebp-2Ch]
  void *v71; // [esp+A4h] [ebp-28h]
  void *v72; // [esp+A8h] [ebp-24h]
  void *v73; // [esp+ACh] [ebp-20h]
  void *v74; // [esp+B0h] [ebp-1Ch]
  void *v75; // [esp+B4h] [ebp-18h]
  void *v76; // [esp+B8h] [ebp-14h]
  char v77; // [esp+BFh] [ebp-Dh]
  int v78; // [esp+C8h] [ebp-4h]

  v64 = malloc(2u);
  *v64 = 0;
  v78 = 0;
  v4 = malloc(2u);
  v62 = v4;
  *v4 = 0;
  v63 = malloc(2u);
  *v63 = 0;
  v5 = malloc(2u);
  v39 = v5;
  *v5 = 0;
  v76 = malloc(2u);
  *v76 = 0;
  v60 = malloc(2u);
  *v60 = 0;
  v61 = malloc(2u);
  *v61 = 0;
  v56 = malloc(2u);
  *v56 = 0;
  v6 = psz;
  LOBYTE(v78) = 7;
  if ( a4 == -1 )
  {
    v70 = _wcsdup(gpszTargetName);
    v65 = _wcsdup(gpszTargetName);
    v67 = _wcsdup(gpszTargetName);
    v69 = _wcsdup(gpszTargetName);
    v72 = _wcsdup(gpszTargetName);
    v73 = _wcsdup(gpszTargetName);
    v71 = _wcsdup(gpszTargetName);
    v7 = gpszTargetName;
    if ( psz )
      v7 = psz;
    v74 = _wcsdup(v7);
    v66 = _wcsdup(gpszTargetName);
    v8 = gpszTargetName;
    if ( psz )
      v8 = psz;
    v75 = _wcsdup(v8);
    LOBYTE(v78) = 17;
    v9 = sub_11F7BE0(&v58, a2, &v74, &v71);
    LOBYTE(v78) = 18;
    v10 = sub_11F7BE0(&v59, a2, &v75, &v66);
    LOBYTE(v78) = 19;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v10, v9, &v73);
    free(v59);
    free(v58);
    free(v75);
    free(v66);
    free(v74);
    free(v71);
    free(v73);
    free(v72);
    free(v69);
    free(v67);
    free(v65);
    LOBYTE(v78) = 7;
    free(v70);
    v6 = psz;
  }
  if ( !sub_11F67A0(ghKLM, v6, 0, 1, &v50) )
  {
    if ( !sub_1201520(v50, L"ProviderOrder", 0, 0, &v64) )
    {
      v11 = operator new(4u);
      if ( v11 )
        *v11 = _wcsdup(v64);
      else
        v11 = 0;
      v12 = v64;
      v75 = v64;
      do
      {
        v13 = *v11;
        **v11 = 0;
        v14 = *v12;
        if ( *v12 )
        {
          do
          {
            if ( v14 == 44 )
              break;
            if ( v14 == 32 )
              break;
            ++v12;
            *v13 = v14;
            ++v13;
            v14 = *v12;
          }
          while ( *v12 );
          v75 = v12;
        }
        *v13 = 0;
        v15 = _wcsdup(L"System\\CurrentControlSet\\Services\\");
        v62 = v15;
        v16 = sub_1203070(&v38, &v62, v11);
        v68 = v4;
        v4 = _wcsdup(*v16);
        v62 = v4;
        free(v68);
        free(v38);
        free(v15);
        v17 = _wcsdup(L"\\NetworkProvider");
        v68 = v17;
        v18 = sub_1203070(&v47, &v62, &v68);
        LOBYTE(v78) = 21;
        v77 = sub_11F67A0(a2, *v18, 0, 1, &hKey) == 0;
        free(v47);
        LOBYTE(v78) = 7;
        free(v17);
        if ( v77 )
        {
          if ( !sub_1201520(hKey, L"ProviderPath", 0, 0, &v63) )
          {
            v19 = malloc(2u);
            v34 = v19;
            *v19 = 0;
            v35 = 0;
            v36 = 0;
            v37 = 0;
            LOBYTE(v78) = 22;
            sub_11F7040(v63, &v34);
            v59 = _wcsdup(v63);
            LOBYTE(v78) = 23;
            v20 = sub_11F4EE0(&v44, a1, &v34, 0);
            v21 = v76;
            v76 = _wcsdup(*v20);
            free(v21);
            free(v44);
            v68 = sub_11F4ED0();
            sub_1201520(hKey, L"Name", 0, 0, &v61);
            v69 = _wcsdup(L"ProviderOrder");
            v22 = gpszTargetName;
            if ( psz )
              v22 = psz;
            v67 = _wcsdup(v22);
            v65 = _wcsdup(gpszTargetName);
            v23 = gpszTargetName;
            if ( psz )
              v23 = psz;
            v70 = _wcsdup(v23);
            LOBYTE(v78) = 27;
            v24 = sub_11F7BE0(&v42, a2, &v67, &v69);
            LOBYTE(v78) = 28;
            v25 = sub_11F7BE0(&v40, a2, &v70, &v65);
            LOBYTE(v78) = 29;
            v77 = sub_11F3D40(a1, v11, v25, v24, &v76, &v60, &v56, &v43);
            free(v40);
            free(v42);
            free(v70);
            free(v65);
            free(v67);
            free(v69);
            if ( v77 )
            {
              if ( a4 == -1 )
              {
                v53 = _wcsdup(gpszTargetName);
                v48 = _wcsdup(gpszTargetName);
                v52 = _wcsdup(gpszTargetName);
                v55 = _wcsdup(gpszTargetName);
                v54 = _wcsdup(gpszTargetName);
                v66 = _wcsdup(gpszTargetName);
                v74 = _wcsdup(gpszTargetName);
                v26 = gpszTargetName;
                if ( psz )
                  v26 = psz;
                v71 = _wcsdup(v26);
                v73 = _wcsdup(gpszTargetName);
                v27 = gpszTargetName;
                if ( psz )
                  v27 = psz;
                v72 = _wcsdup(v27);
                LOBYTE(v78) = 39;
                v28 = sub_11F7BE0(&v45, a2, &v71, &v74);
                LOBYTE(v78) = 40;
                v29 = sub_11F7BE0(&v46, a2, &v72, &v73);
                LOBYTE(v78) = 41;
                a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v29, v28, &v66);
                free(v46);
                free(v45);
                free(v72);
                free(v73);
                free(v71);
                free(v74);
                free(v66);
                free(v54);
                free(v55);
                free(v52);
                free(v48);
                free(v53);
              }
              v58 = _wcsdup(gpszTargetName);
              v51 = _wcsdup(L"ProviderOrder");
              v30 = gpszTargetName;
              if ( psz )
                v30 = psz;
              v49 = _wcsdup(v30);
              LOBYTE(v78) = 44;
              v31 = sub_11F7BE0(&v41, a2, &v49, &v51);
              LOBYTE(v78) = 45;
              sub_11F3FF0(a1, v68, a4, 5, v11, v31, &v76);
              free(v41);
              free(v49);
              free(v51);
              free(v58);
            }
            free(v59);
            LOBYTE(v78) = 7;
            sub_11F21F0(&v34);
          }
          RegCloseKey(hKey);
        }
        v12 = v75;
        v32 = *v75;
        if ( !*v75 )
          break;
        while ( v32 == 44 || v32 == 32 )
        {
          v32 = v12[1];
          ++v12;
          v75 = v12;
          if ( !v32 )
            goto LABEL_42;
        }
      }
      while ( *v12 );
LABEL_42:
      v5 = v39;
    }
    RegCloseKey(v50);
  }
  free(v56);
  free(v61);
  free(v60);
  free(v76);
  free(v5);
  free(v63);
  free(v4);
  free(v64);
  return a4;
}

//----- (01207FE0) --------------------------------------------------------
void __cdecl sub_1207FE0(int a1, void *a2, LPCTSTR a3)
{
  _WORD *v3; // ST20_4

  v3 = malloc(2u);
  *v3 = 0;
  sub_1208050(a1, a2, *a3, 0xFFFFFFFF);
  free(v3);
}

//----- (01208050) --------------------------------------------------------
void *__cdecl sub_1208050(int a1, void *a2, wchar_t *psz, void *a4)
{
  WCHAR *v4; // eax
  WCHAR *v5; // eax
  unsigned __int16 **v6; // esi
  unsigned __int16 **v7; // eax
  LPVOID (__stdcall *v8)(DWORD); // ebx
  unsigned int v9; // eax
  void (__stdcall *v10)(HKEY); // edi
  void *v11; // esi
  OLECHAR *v12; // esi
  unsigned int v13; // eax
  OLECHAR *v14; // esi
  unsigned int v15; // eax
  int v16; // eax
  bool v17; // bl
  int v18; // eax
  const wchar_t **v19; // eax
  wchar_t *v20; // esi
  const wchar_t **v21; // eax
  void *v22; // esi
  OLECHAR *v23; // esi
  unsigned int v24; // eax
  const wchar_t **v25; // eax
  void *v26; // esi
  wchar_t *v27; // esi
  unsigned __int16 **v28; // eax
  wchar_t *v29; // edi
  void *v30; // esi
  OLECHAR *v31; // esi
  unsigned int v32; // eax
  void *v33; // esi
  WCHAR *v34; // eax
  WCHAR *v35; // eax
  unsigned __int16 **v36; // esi
  unsigned __int16 **v37; // eax
  char v38; // bl
  wchar_t *v39; // ebx
  WCHAR *v40; // eax
  WCHAR *v41; // eax
  unsigned __int16 **v42; // esi
  unsigned __int16 **v43; // eax
  WCHAR *v44; // eax
  unsigned __int16 **v45; // eax
  void *v46; // esi
  void **v47; // esi
  void **v48; // ebx
  DWORD cbData; // [esp+10h] [ebp-CCh]
  void *v51; // [esp+14h] [ebp-C8h]
  void *v52; // [esp+18h] [ebp-C4h]
  void *v53; // [esp+1Ch] [ebp-C0h]
  void *v54; // [esp+20h] [ebp-BCh]
  void *v55; // [esp+24h] [ebp-B8h]
  int v56; // [esp+28h] [ebp-B4h]
  void *v57; // [esp+2Ch] [ebp-B0h]
  int v58; // [esp+30h] [ebp-ACh]
  void *v59; // [esp+34h] [ebp-A8h]
  void *v60; // [esp+38h] [ebp-A4h]
  void *v61; // [esp+3Ch] [ebp-A0h]
  void *v62; // [esp+40h] [ebp-9Ch]
  void *v63; // [esp+44h] [ebp-98h]
  wchar_t *v64; // [esp+48h] [ebp-94h]
  void *v65; // [esp+4Ch] [ebp-90h]
  BYTE Data[4]; // [esp+50h] [ebp-8Ch]
  void *v67; // [esp+54h] [ebp-88h]
  void *v68; // [esp+58h] [ebp-84h]
  void *v69; // [esp+5Ch] [ebp-80h]
  void *v70; // [esp+60h] [ebp-7Ch]
  void *v71; // [esp+64h] [ebp-78h]
  void *v72; // [esp+68h] [ebp-74h]
  void *v73; // [esp+6Ch] [ebp-70h]
  void *v74; // [esp+70h] [ebp-6Ch]
  void *v75; // [esp+74h] [ebp-68h]
  void *v76; // [esp+78h] [ebp-64h]
  void *v77; // [esp+7Ch] [ebp-60h]
  void *v78; // [esp+80h] [ebp-5Ch]
  HKEY v79; // [esp+84h] [ebp-58h]
  void *v80; // [esp+88h] [ebp-54h]
  void *v81; // [esp+8Ch] [ebp-50h]
  void *v82; // [esp+90h] [ebp-4Ch]
  void *v83; // [esp+94h] [ebp-48h]
  void **v84; // [esp+98h] [ebp-44h]
  int v85; // [esp+9Ch] [ebp-40h]
  void *v86; // [esp+A0h] [ebp-3Ch]
  void *v87; // [esp+A4h] [ebp-38h]
  void *v88; // [esp+A8h] [ebp-34h]
  void *v89; // [esp+ACh] [ebp-30h]
  void *v90; // [esp+B0h] [ebp-2Ch]
  void *v91; // [esp+B4h] [ebp-28h]
  void *v92; // [esp+B8h] [ebp-24h]
  bool v93; // [esp+BFh] [ebp-1Dh]
  void *v94; // [esp+C0h] [ebp-1Ch]
  HKEY hKey; // [esp+C4h] [ebp-18h]
  wchar_t *v96; // [esp+C8h] [ebp-14h]
  wchar_t *v97; // [esp+CCh] [ebp-10h]
  int v98; // [esp+D8h] [ebp-4h]

  v92 = malloc(2u);
  *v92 = 0;
  v98 = 0;
  v81 = malloc(2u);
  *v81 = 0;
  v74 = malloc(2u);
  *v74 = 0;
  v75 = malloc(2u);
  *v75 = 0;
  v80 = malloc(2u);
  *v80 = 0;
  v77 = malloc(2u);
  *v77 = 0;
  LOBYTE(v98) = 5;
  *Data = 0;
  if ( a4 == -1 )
  {
    v87 = _wcsdup(gpszTargetName);
    v86 = _wcsdup(gpszTargetName);
    v88 = _wcsdup(gpszTargetName);
    v90 = _wcsdup(gpszTargetName);
    v91 = _wcsdup(gpszTargetName);
    v89 = _wcsdup(gpszTargetName);
    v97 = _wcsdup(gpszTargetName);
    v4 = gpszTargetName;
    if ( psz )
      v4 = psz;
    v96 = _wcsdup(v4);
    hKey = _wcsdup(gpszTargetName);
    v5 = gpszTargetName;
    if ( psz )
      v5 = psz;
    v94 = _wcsdup(v5);
    LOBYTE(v98) = 15;
    v6 = sub_11F7BE0(&v76, a2, &v96, &v97);
    LOBYTE(v98) = 16;
    v7 = sub_11F7BE0(&v78, a2, &v94, &hKey);
    LOBYTE(v98) = 17;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v7, v6, &v89);
    free(v78);
    free(v76);
    free(v94);
    free(hKey);
    free(v96);
    free(v97);
    free(v89);
    free(v91);
    free(v90);
    free(v88);
    free(v86);
    LOBYTE(v98) = 5;
    free(v87);
  }
  v8 = TlsGetValue;
  v9 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, psz, 0, v9 | 0x20019, &v79) )
  {
    v78 = 0;
    v96 = malloc(2u);
    *v96 = 0;
    v97 = malloc(2u);
    *v97 = 0;
    v94 = malloc(2u);
    *v94 = 0;
    v82 = malloc(2u);
    *v82 = 0;
    v83 = 0;
    v84 = 0;
    v85 = 0;
    LOBYTE(v98) = 21;
    v10 = RegCloseKey;
    if ( !sub_12013D0(v79, 0, &v97) )
    {
      while ( 1 )
      {
        v11 = v77;
        v77 = _wcsdup(v97);
        free(v11);
        v12 = v97;
        v13 = v8(gdwTlsIndex);
        if ( !sub_11F67A0(v79, v12, 0, v13 | 0x20019, &hKey) )
        {
          RegQueryValueExW(hKey, L"LoadBehavior", 0, 0, Data, &cbData);
          v10(hKey);
        }
        v93 = *Data > 1u;
        v14 = *sub_11F22B0(&v55, &v97, L"\\CLSID");
        LOBYTE(v98) = 22;
        v15 = v8(gdwTlsIndex);
        v16 = sub_11F67A0(HKEY_CLASSES_ROOT, v14, 0, v15 | 0x20019, &hKey);
        LOBYTE(v98) = 21;
        v17 = v16 == 0;
        free(v55);
        if ( !v17 )
          goto LABEL_39;
        if ( sub_1201520(hKey, gpszTargetName, 0, 0, &v97) )
          break;
        v10(hKey);
        v18 = sub_120F210(&v52, L"CLSID\\", &v97);
        v19 = sub_11F22B0(&v59, v18, L"\\InprocServer32");
        v20 = v96;
        v96 = _wcsdup(*v19);
        free(v20);
        free(v59);
        free(v52);
        v21 = sub_120F210(&v61, L"HKCR\\CLSID\\", &v97);
        v22 = v80;
        v80 = _wcsdup(*v21);
        free(v22);
        free(v61);
        v23 = v96;
        v8 = TlsGetValue;
        v24 = TlsGetValue(gdwTlsIndex);
        if ( sub_11F67A0(HKEY_CLASSES_ROOT, v23, 0, v24 | 0x20019, &hKey) )
          goto LABEL_16;
        if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v96) )
        {
          sub_11F7040(v96, &v82);
          v25 = sub_11F4EE0(&v63, a1, &v82, 0);
          v26 = v94;
          v94 = _wcsdup(*v25);
          free(v26);
          free(v63);
          v10(hKey);
LABEL_16:
          v56 = sub_11F4ED0();
          v27 = _wcsdup(L"CLSID\\");
          v64 = v27;
          v28 = sub_1203070(&v51, &v64, &v97);
          v29 = v96;
          v96 = _wcsdup(*v28);
          free(v29);
          free(v51);
          free(v27);
          v30 = v92;
          v92 = _wcsdup(v97);
          free(v30);
          v31 = v96;
          v32 = TlsGetValue(gdwTlsIndex);
          if ( sub_11F67A0(HKEY_CLASSES_ROOT, v31, 0, v32 | 0x20019, &hKey) )
          {
            v10 = RegCloseKey;
          }
          else
          {
            if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v96) && wcslen(v96) )
            {
              v33 = v92;
              v92 = _wcsdup(v96);
              free(v33);
            }
            v10 = RegCloseKey;
            RegCloseKey(hKey);
          }
          v34 = gpszTargetName;
          if ( psz )
            v34 = psz;
          v88 = _wcsdup(v34);
          v86 = _wcsdup(gpszTargetName);
          v35 = gpszTargetName;
          if ( psz )
            v35 = psz;
          v87 = _wcsdup(v35);
          LOBYTE(v98) = 25;
          v36 = sub_11F7BE0(&v53, a2, &v88, &v97);
          LOBYTE(v98) = 26;
          v37 = sub_11F7BE0(&v57, a2, &v87, &v86);
          LOBYTE(v98) = 27;
          v38 = sub_11F3D40(a1, &v92, v37, v36, &v94, &v81, &v75, &v58);
          free(v57);
          free(v53);
          free(v87);
          free(v86);
          free(v88);
          if ( v38 )
          {
            if ( a4 == -1 )
            {
              v65 = _wcsdup(gpszTargetName);
              v69 = _wcsdup(gpszTargetName);
              v67 = _wcsdup(gpszTargetName);
              v73 = _wcsdup(gpszTargetName);
              v71 = _wcsdup(gpszTargetName);
              v68 = _wcsdup(gpszTargetName);
              v70 = _wcsdup(gpszTargetName);
              v39 = psz;
              v40 = gpszTargetName;
              if ( psz )
                v40 = psz;
              v89 = _wcsdup(v40);
              v91 = _wcsdup(gpszTargetName);
              v41 = gpszTargetName;
              if ( psz )
                v41 = psz;
              v90 = _wcsdup(v41);
              LOBYTE(v98) = 37;
              v42 = sub_11F7BE0(&v60, a2, &v89, &v70);
              LOBYTE(v98) = 38;
              v43 = sub_11F7BE0(&v62, a2, &v90, &v91);
              LOBYTE(v98) = 39;
              a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v43, v42, &v68);
              free(v62);
              free(v60);
              free(v90);
              free(v91);
              free(v89);
              free(v70);
              free(v68);
              free(v71);
              free(v73);
              free(v67);
              free(v69);
              free(v65);
            }
            else
            {
              v39 = psz;
            }
            v76 = _wcsdup(gpszTargetName);
            v44 = gpszTargetName;
            if ( v39 )
              v44 = v39;
            v72 = _wcsdup(v44);
            LOBYTE(v98) = 41;
            v45 = sub_11F7BE0(&v54, a2, &v72, &v77);
            LOBYTE(v98) = 42;
            sub_11F3FF0(a1, v56, a4, 18, &v92, v45, &v94);
            free(v54);
            free(v72);
            free(v76);
          }
LABEL_39:
          sub_11F21F0(&v82);
          free(v94);
          free(v97);
          free(v96);
          v8 = TlsGetValue;
          goto LABEL_40;
        }
        v10(hKey);
        sub_11F21F0(&v82);
        free(v94);
        free(v97);
        free(v96);
LABEL_40:
        v78 = v78 + 1;
        v46 = v78;
        v96 = malloc(2u);
        *v96 = 0;
        v97 = malloc(2u);
        *v97 = 0;
        v94 = malloc(2u);
        *v94 = 0;
        v82 = malloc(2u);
        *v82 = 0;
        v83 = 0;
        v84 = 0;
        v85 = 0;
        LOBYTE(v98) = 21;
        if ( sub_12013D0(v79, v46, &v97) )
          goto LABEL_41;
      }
      v10(hKey);
      goto LABEL_39;
    }
LABEL_41:
    v47 = v83;
    if ( v83 )
    {
      v48 = v84;
      if ( v83 != v84 )
      {
        do
        {
          free(*v47);
          ++v47;
        }
        while ( v47 != v48 );
        v47 = v83;
      }
      j__free(v47);
      v83 = 0;
      v84 = 0;
      v85 = 0;
    }
    free(v82);
    free(v94);
    free(v97);
    free(v96);
    v10(v79);
  }
  free(v77);
  free(v80);
  free(v75);
  free(v74);
  free(v81);
  free(v92);
  return a4;
}

//----- (01208A90) --------------------------------------------------------
void __cdecl sub_1208A90(int a1, void *a2, int a3, int a4)
{
  wchar_t *v4; // esi
  void *v5; // ebx
  const wchar_t **v6; // eax
  wchar_t *v7; // edi
  HKEY hKey; // [esp+14h] [ebp-10h]
  int v9; // [esp+20h] [ebp-4h]

  v4 = malloc(2u);
  *v4 = 0;
  v9 = 0;
  if ( byte_12E4C58 )
  {
LABEL_10:
    v5 = sub_1208C20(a1, a2, *a3, 0xFFFFFFFF, 1, a4);
    v6 = sub_11F22B0(&hKey, a3, L"\\AutorunsDisabled");
    v7 = v4;
    v4 = _wcsdup(*v6);
    free(v7);
    free(hKey);
    sub_1208C20(a1, a2, v4, v5, 0, a4);
    goto LABEL_11;
  }
  if ( !sub_11F67A0(ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\Print", 0, KEY_READ, &hKey) || !dword_12E3628[0] )
  {
    if ( !sub_11F67A0(
            ghKLM,
            L"SYSTEM\\CurrentControlSet\\Control\\Print\\Environments\\Windows NT x86",
            0,
            131097,
            &hKey) )
    {
      sub_1201520(hKey, L"Directory", 0, 0, &dword_12E4C50);
      RegCloseKey(hKey);
    }
    if ( !sub_11F67A0(ghKLM, L"SYSTEM\\CurrentControlSet\\Control\\Print\\Environments\\Windows x64", 0, 131097, &hKey) )
    {
      sub_1201520(hKey, L"Directory", 0, 0, &dword_12E4C54);
      RegCloseKey(hKey);
    }
    byte_12E4C58 = 1;
    goto LABEL_10;
  }
  wprintf(L"\nNo entry to display for printer. Printer is not supported on Nano Server.\n");
LABEL_11:
  free(v4);
}
// 12E3628: using guessed type int dword_12E3628[140];
// 12E4C58: using guessed type char byte_12E4C58;

//----- (01208C20) --------------------------------------------------------
void *__cdecl sub_1208C20(int a1, void *a2, wchar_t *psz, void *a4, char a5, int a6)
{
  wchar_t *v6; // edi
  int v7; // ebx
  WCHAR *v8; // eax
  WCHAR *v9; // eax
  unsigned __int16 **v10; // esi
  unsigned __int16 **v11; // eax
  unsigned int v12; // eax
  OLECHAR *v13; // esi
  unsigned int v14; // eax
  const wchar_t **v15; // eax
  void *v16; // esi
  void **v17; // edi
  wchar_t *v18; // esi
  const wchar_t **v19; // eax
  unsigned __int16 **v20; // eax
  wchar_t *v21; // esi
  const wchar_t **v22; // eax
  wchar_t *v23; // edi
  void *v24; // edi
  WCHAR *v25; // ecx
  WCHAR *v26; // eax
  unsigned __int16 **v27; // esi
  unsigned __int16 **v28; // eax
  char v29; // bl
  WCHAR *v30; // eax
  WCHAR *v31; // eax
  unsigned __int16 **v32; // esi
  unsigned __int16 **v33; // eax
  WCHAR *v34; // eax
  unsigned __int16 **v35; // eax
  int v37; // [esp+10h] [ebp-B0h]
  int v38; // [esp+14h] [ebp-ACh]
  int v39; // [esp+18h] [ebp-A8h]
  int v40; // [esp+1Ch] [ebp-A4h]
  void *v41; // [esp+20h] [ebp-A0h]
  void *v42; // [esp+24h] [ebp-9Ch]
  void *v43; // [esp+28h] [ebp-98h]
  int v44; // [esp+2Ch] [ebp-94h]
  void *v45; // [esp+30h] [ebp-90h]
  void *v46; // [esp+34h] [ebp-8Ch]
  void *v47; // [esp+38h] [ebp-88h]
  void *v48; // [esp+3Ch] [ebp-84h]
  void *v49; // [esp+40h] [ebp-80h]
  void *v50; // [esp+44h] [ebp-7Ch]
  wchar_t *v51; // [esp+48h] [ebp-78h]
  void *v52; // [esp+4Ch] [ebp-74h]
  void *v53; // [esp+50h] [ebp-70h]
  DWORD v54; // [esp+54h] [ebp-6Ch]
  void *v55; // [esp+58h] [ebp-68h]
  HKEY hKey; // [esp+5Ch] [ebp-64h]
  void *v57; // [esp+60h] [ebp-60h]
  int v58; // [esp+64h] [ebp-5Ch]
  void *v59; // [esp+68h] [ebp-58h]
  void *v60; // [esp+6Ch] [ebp-54h]
  void *v61; // [esp+70h] [ebp-50h]
  void *v62; // [esp+74h] [ebp-4Ch]
  HKEY v63; // [esp+78h] [ebp-48h]
  void *v64; // [esp+7Ch] [ebp-44h]
  void *v65; // [esp+80h] [ebp-40h]
  void *v66; // [esp+84h] [ebp-3Ch]
  void *v67; // [esp+88h] [ebp-38h]
  void *v68; // [esp+8Ch] [ebp-34h]
  void *v69; // [esp+90h] [ebp-30h]
  void *v70; // [esp+94h] [ebp-2Ch]
  void *v71; // [esp+98h] [ebp-28h]
  void *v72; // [esp+9Ch] [ebp-24h]
  void *v73; // [esp+A0h] [ebp-20h]
  void *v74; // [esp+A4h] [ebp-1Ch]
  void *v75; // [esp+A8h] [ebp-18h]
  OLECHAR *v76; // [esp+ACh] [ebp-14h]
  wchar_t *v77; // [esp+B0h] [ebp-10h]
  int v78; // [esp+BCh] [ebp-4h]

  v54 = 0;
  v77 = malloc(2u);
  *v77 = 0;
  v78 = 0;
  v75 = malloc(2u);
  *v75 = 0;
  v62 = malloc(2u);
  *v62 = 0;
  v59 = malloc(2u);
  *v59 = 0;
  v60 = malloc(2u);
  *v60 = 0;
  v6 = psz;
  v7 = a1;
  LOBYTE(v78) = 4;
  if ( a4 == -1 )
  {
    v66 = _wcsdup(gpszTargetName);
    v65 = _wcsdup(gpszTargetName);
    v67 = _wcsdup(gpszTargetName);
    v71 = _wcsdup(gpszTargetName);
    v72 = _wcsdup(gpszTargetName);
    v73 = _wcsdup(gpszTargetName);
    v70 = _wcsdup(gpszTargetName);
    v8 = gpszTargetName;
    if ( psz )
      v8 = psz;
    v74 = _wcsdup(v8);
    v68 = _wcsdup(gpszTargetName);
    v9 = gpszTargetName;
    if ( psz )
      v9 = psz;
    v69 = _wcsdup(v9);
    LOBYTE(v78) = 14;
    v10 = sub_11F7BE0(&v61, a2, &v74, &v70);
    LOBYTE(v78) = 15;
    v11 = sub_11F7BE0(&v64, a2, &v69, &v68);
    LOBYTE(v78) = 16;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v11, v10, &v73);
    free(v64);
    free(v61);
    free(v69);
    free(v68);
    free(v74);
    free(v70);
    free(v73);
    free(v72);
    free(v71);
    free(v67);
    free(v65);
    LOBYTE(v78) = 4;
    free(v66);
  }
  v12 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(ghKLM, psz, 0, v12 | 0x20019, &v63) )
  {
    v76 = malloc(2u);
    *v76 = 0;
    LOBYTE(v78) = 17;
    if ( !sub_12013D0(v63, 0, &v76) )
    {
      do
      {
        v13 = v76;
        v14 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v63, v13, 0, v14 | 0x20019, &hKey) )
        {
          if ( !sub_1201520(hKey, L"Driver", 0, 0, &v77) )
          {
            v37 = malloc(2u);
            *v37 = 0;
            v38 = 0;
            v39 = 0;
            v40 = 0;
            LOBYTE(v78) = 18;
            sub_11F7040(v77, &v37);
            v64 = _wcsdup(v77);
            LOBYTE(v78) = 19;
            v15 = sub_11F4EE0(&v47, v7, &v37, 0);
            v16 = v75;
            v75 = _wcsdup(*v15);
            free(v16);
            free(v47);
            if ( !wcschr(v77, 0x5Cu) )
            {
              v17 = &dword_12E4C54;
              if ( !a6 )
                v17 = &dword_12E4C50;
              v18 = _wcsdup(L"\\");
              v58 = v18;
              v19 = sub_120F210(&v41, L"\\SystemRoot\\System32\\Spool\\Prtprocs\\", v17);
              v20 = sub_1203070(&v49, v19, &v58);
              sub_1203070(&v51, v20, &v77);
              LOBYTE(v78) = 20;
              free(v49);
              free(v41);
              free(v18);
              v21 = v51;
              v22 = sub_11F4F20(&v43, v7, v51);
              v23 = v77;
              v77 = _wcsdup(*v22);
              free(v23);
              free(v43);
              if ( wcsncmp(v77, L"File not found: ", 0x10u) )
              {
                v24 = v75;
                v75 = _wcsdup(v77);
                free(v24);
              }
              LOBYTE(v78) = 19;
              free(v21);
              v6 = psz;
            }
            v58 = sub_11F4ED0();
            v25 = gpszTargetName;
            if ( v6 )
              v25 = v6;
            v67 = _wcsdup(v25);
            v65 = _wcsdup(gpszTargetName);
            v26 = gpszTargetName;
            if ( v6 )
              v26 = v6;
            v66 = _wcsdup(v26);
            LOBYTE(v78) = 23;
            v27 = sub_11F7BE0(&v50, a2, &v67, &v76);
            LOBYTE(v78) = 24;
            v28 = sub_11F7BE0(&v45, a2, &v66, &v65);
            LOBYTE(v78) = 25;
            v29 = sub_11F3D40(v7, &v76, v28, v27, &v75, &v62, &v60, &v44);
            free(v45);
            free(v50);
            free(v66);
            free(v65);
            free(v67);
            if ( v29 )
            {
              if ( a4 == -1 )
              {
                v53 = _wcsdup(gpszTargetName);
                v57 = _wcsdup(gpszTargetName);
                v55 = _wcsdup(gpszTargetName);
                v69 = _wcsdup(gpszTargetName);
                v68 = _wcsdup(gpszTargetName);
                v74 = _wcsdup(gpszTargetName);
                v70 = _wcsdup(gpszTargetName);
                v30 = gpszTargetName;
                if ( v6 )
                  v30 = v6;
                v73 = _wcsdup(v30);
                v72 = _wcsdup(gpszTargetName);
                v31 = gpszTargetName;
                if ( v6 )
                  v31 = v6;
                v71 = _wcsdup(v31);
                LOBYTE(v78) = 35;
                v32 = sub_11F7BE0(&v46, a2, &v73, &v70);
                LOBYTE(v78) = 36;
                v33 = sub_11F7BE0(&v48, a2, &v71, &v72);
                LOBYTE(v78) = 37;
                v7 = a1;
                a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v33, v32, &v74);
                free(v48);
                free(v46);
                free(v71);
                free(v72);
                free(v73);
                free(v70);
                free(v74);
                free(v68);
                free(v69);
                free(v55);
                free(v57);
                free(v53);
              }
              else
              {
                v7 = a1;
              }
              v61 = _wcsdup(gpszTargetName);
              v34 = gpszTargetName;
              if ( v6 )
                v34 = v6;
              v52 = _wcsdup(v34);
              LOBYTE(v78) = 39;
              v35 = sub_11F7BE0(&v42, a2, &v52, &v76);
              LOBYTE(v78) = 40;
              sub_11F3FF0(v7, v58, a4, 3, &v76, v35, &v75);
              free(v42);
              free(v52);
              free(v61);
            }
            else
            {
              v7 = a1;
            }
            free(v64);
            LOBYTE(v78) = 17;
            sub_11F21F0(&v37);
          }
          RegCloseKey(hKey);
        }
        ++v54;
      }
      while ( !sub_12013D0(v63, v54, &v76) );
    }
    RegCloseKey(v63);
    free(v76);
  }
  free(v60);
  free(v59);
  free(v62);
  free(v75);
  free(v77);
  return a4;
}

//----- (012093C0) --------------------------------------------------------
char __cdecl sub_12093C0(LPCWSTR lpServiceName, int a2)
{
  char v2; // bl
  SC_HANDLE v3; // eax
  void *v4; // edi
  SC_HANDLE v5; // esi
  FARPROC v7; // eax
  HMODULE v8; // eax
  size_t v9; // ST0C_4
  wchar_t **v10; // esi
  wchar_t *v11; // edx
  wchar_t *v12; // ecx
  wchar_t v13; // ax
  wchar_t *v14; // ecx
  wchar_t v15; // ax
  wchar_t *v16; // ecx
  wchar_t v17; // ax
  wchar_t *v18; // edx
  wchar_t *v19; // ecx
  wchar_t v20; // ax
  wchar_t *v21; // ecx
  wchar_t v22; // ax
  SC_HANDLE v23; // [esp+14h] [ebp-14h]
  size_t v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+24h] [ebp-4h]

  v25 = 0;
  v2 = 0;
  v3 = OpenSCManagerW(0, 0, 0x80000000);
  v4 = v3;
  if ( !v3 )
    goto LABEL_4;
  v5 = OpenServiceW(v3, lpServiceName, 1u);
  v23 = v5;
  if ( !v5 )
  {
    CloseServiceHandle(v4);
LABEL_4:
    v2 = 0;
    goto LABEL_5;
  }
  v7 = QueryServiceConfig2W_0;
  v24 = 0;
  if ( QueryServiceConfig2W_0
    || (v8 = LoadLibraryW(L"Advapi32.dll"),
        v7 = GetProcAddress(v8, "QueryServiceConfig2W"),
        (QueryServiceConfig2W_0 = v7) != 0) )
  {
    if ( !(v7)(v5, 1, 0, 0, &v24) )
    {
      v9 = v24;
      v10 = malloc(v24);
      if ( QueryServiceConfig2W_0(v23, 1, v10, v9, &v24) )
      {
        v11 = *v10;
        if ( *v10 )
        {
          v12 = *v10;
          do
          {
            v13 = *v12;
            ++v12;
          }
          while ( v13 );
          if ( (v12 - (v11 + 1)) > 3 )
          {
            v14 = *v10;
            do
            {
              v15 = *v14;
              ++v14;
            }
            while ( v15 );
            if ( v11[v14 - (v11 + 1) - 1] == 10 )
            {
              v16 = *v10;
              do
              {
                v17 = *v16;
                ++v16;
              }
              while ( v17 );
              v11[v16 - (v11 + 1) - 1] = 0;
              v18 = *v10;
              v19 = *v10;
              do
              {
                v20 = *v19;
                ++v19;
              }
              while ( v20 );
              if ( v18[v19 - (*v10 + 1) - 1] == 13 )
              {
                v21 = *v10;
                do
                {
                  v22 = *v21;
                  ++v21;
                }
                while ( v22 );
                v18[v21 - (v18 + 1) - 1] = 0;
              }
            }
          }
        }
        sub_11F2280(a2, *v10);
        v2 = 1;
      }
      free(v10);
      v5 = v23;
    }
  }
  CloseServiceHandle(v5);
  CloseServiceHandle(v4);
LABEL_5:
  free(lpServiceName);
  return v2;
}
// 12E4C5C: using guessed type int (__stdcall *QueryServiceConfig2W_0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (01209580) --------------------------------------------------------
void *__cdecl sub_1209580(int a1, void *a2, wchar_t *psz)
{
  wchar_t *v3; // eax
  wchar_t *v4; // eax
  _WORD *v5; // eax
  _WORD *v6; // eax
  _WORD *v7; // eax
  _WORD *v8; // eax
  _WORD *v9; // eax
  _WORD *v10; // eax
  wchar_t *v11; // ebx
  WCHAR *v12; // eax
  WCHAR *v13; // eax
  unsigned __int16 **v14; // esi
  unsigned __int16 **v15; // eax
  void *v16; // esi
  LSTATUS (__stdcall *v17)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // esi
  void *v18; // esi
  void *v19; // esi
  const wchar_t **v20; // eax
  void *v21; // esi
  void *v22; // esi
  const wchar_t **v23; // eax
  void *v24; // esi
  const wchar_t **v25; // eax
  void *v26; // esi
  wchar_t *v27; // eax
  const wchar_t **v28; // eax
  wchar_t *v29; // eax
  void *v30; // esi
  WCHAR *v31; // eax
  WCHAR *v32; // eax
  unsigned __int16 **v33; // esi
  unsigned __int16 **v34; // eax
  char v35; // bl
  WCHAR *v36; // eax
  WCHAR *v37; // eax
  unsigned __int16 **v38; // esi
  unsigned __int16 **v39; // eax
  WCHAR *v40; // eax
  unsigned __int16 **v41; // eax
  int v43; // [esp+10h] [ebp-F4h]
  int v44; // [esp+20h] [ebp-E4h]
  int v45; // [esp+30h] [ebp-D4h]
  int v46; // [esp+34h] [ebp-D0h]
  int v47; // [esp+38h] [ebp-CCh]
  int v48; // [esp+3Ch] [ebp-C8h]
  void *v49; // [esp+40h] [ebp-C4h]
  BYTE v50[4]; // [esp+44h] [ebp-C0h]
  BYTE v51[4]; // [esp+48h] [ebp-BCh]
  void *v52; // [esp+50h] [ebp-B4h]
  void *v53; // [esp+54h] [ebp-B0h]
  void *v54; // [esp+58h] [ebp-ACh]
  void *v55; // [esp+5Ch] [ebp-A8h]
  void *v56; // [esp+60h] [ebp-A4h]
  int v57; // [esp+64h] [ebp-A0h]
  void *v58; // [esp+68h] [ebp-9Ch]
  void *v59; // [esp+6Ch] [ebp-98h]
  void *v60; // [esp+70h] [ebp-94h]
  void *v61; // [esp+74h] [ebp-90h]
  void *v62; // [esp+78h] [ebp-8Ch]
  void *v63; // [esp+7Ch] [ebp-88h]
  void *v64; // [esp+80h] [ebp-84h]
  int v65; // [esp+84h] [ebp-80h]
  HKEY v66; // [esp+88h] [ebp-7Ch]
  BYTE Data[4]; // [esp+8Ch] [ebp-78h]
  void *v68; // [esp+90h] [ebp-74h]
  DWORD v69; // [esp+94h] [ebp-70h]
  void *v70; // [esp+98h] [ebp-6Ch]
  HKEY v71; // [esp+9Ch] [ebp-68h]
  void *v72; // [esp+A0h] [ebp-64h]
  void *v73; // [esp+A4h] [ebp-60h]
  void *v74; // [esp+A8h] [ebp-5Ch]
  void *v75; // [esp+ACh] [ebp-58h]
  void *v76; // [esp+B0h] [ebp-54h]
  void *v77; // [esp+B4h] [ebp-50h]
  void *v78; // [esp+B8h] [ebp-4Ch]
  void *v79; // [esp+BCh] [ebp-48h]
  void *v80; // [esp+C0h] [ebp-44h]
  void *v81; // [esp+C4h] [ebp-40h]
  void *v82; // [esp+C8h] [ebp-3Ch]
  void *v83; // [esp+CCh] [ebp-38h]
  void *v84; // [esp+D0h] [ebp-34h]
  void *v85; // [esp+D4h] [ebp-30h]
  DWORD cbData; // [esp+D8h] [ebp-2Ch]
  void *v87; // [esp+DCh] [ebp-28h]
  wchar_t *v88; // [esp+E0h] [ebp-24h]
  void *v89; // [esp+E4h] [ebp-20h]
  HKEY hKey; // [esp+E8h] [ebp-1Ch]
  void *v91; // [esp+ECh] [ebp-18h]
  wchar_t *v92; // [esp+F0h] [ebp-14h]
  char v93; // [esp+F7h] [ebp-Dh]
  int v94; // [esp+100h] [ebp-4h]

  v69 = 0;
  v3 = malloc(2u);
  v92 = v3;
  *v3 = 0;
  v94 = 0;
  v4 = malloc(2u);
  v88 = v4;
  *v4 = 0;
  v5 = malloc(2u);
  v76 = v5;
  *v5 = 0;
  v6 = malloc(2u);
  v91 = v6;
  *v6 = 0;
  v7 = malloc(2u);
  v74 = v7;
  *v7 = 0;
  v8 = malloc(2u);
  v87 = v8;
  *v8 = 0;
  v9 = malloc(2u);
  v68 = v9;
  *v9 = 0;
  v10 = malloc(2u);
  v89 = v10;
  *v10 = 0;
  v75 = _wcsdup(gpszTargetName);
  v77 = _wcsdup(gpszTargetName);
  v79 = _wcsdup(gpszTargetName);
  v81 = _wcsdup(gpszTargetName);
  v83 = _wcsdup(gpszTargetName);
  v84 = _wcsdup(gpszTargetName);
  v80 = _wcsdup(gpszTargetName);
  v11 = psz;
  v12 = gpszTargetName;
  if ( psz )
    v12 = psz;
  v78 = _wcsdup(v12);
  v82 = _wcsdup(gpszTargetName);
  v13 = gpszTargetName;
  if ( psz )
    v13 = psz;
  v85 = _wcsdup(v13);
  LOBYTE(v94) = 17;
  v14 = sub_11F7BE0(&v70, a2, &v78, &v80);
  LOBYTE(v94) = 18;
  v15 = sub_11F7BE0(&v73, a2, &v85, &v82);
  LOBYTE(v94) = 19;
  v16 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v15, v14, &v84);
  v72 = v16;
  free(v73);
  free(v70);
  free(v85);
  free(v82);
  free(v78);
  free(v80);
  free(v84);
  free(v83);
  free(v81);
  free(v79);
  free(v77);
  LOBYTE(v94) = 7;
  free(v75);
  if ( sub_11F67A0(ghKLM, psz, 0, 131097, &v71) )
    goto LABEL_64;
  if ( sub_12013D0(v71, 0, &v88) )
    goto LABEL_63;
  v17 = RegQueryValueExW;
  do
  {
    if ( sub_11F67A0(v71, v88, 0, 131097, &hKey) )
      goto LABEL_61;
    cbData = 4;
    if ( v17(hKey, L"Start", 0, 0, Data, &cbData) || *Data != 2 && *Data != 4 && *Data != 3 )
      goto LABEL_60;
    cbData = 4;
    if ( *Data == 4 )
    {
      if ( v17(hKey, L"AutorunsDisabled", 0, 0, Data, &cbData) )
        goto LABEL_60;
      v93 = 0;
    }
    else
    {
      v93 = 1;
    }
    if ( v17(hKey, L"Type", 0, 0, v51, &cbData) || *v51 <= 2u )
      goto LABEL_60;
    v18 = v91;
    v91 = _wcsdup(gpszTargetName);
    free(v18);
    if ( sub_1201520(hKey, L"ServiceDll", 0, 0, &v92) )
    {
      if ( !sub_11F67A0(hKey, L"Parameters", 0, 1, &v66) )
      {
        if ( !sub_1201520(v66, L"ServiceDll", 0, 0, &v92) )
        {
          v22 = v89;
          v89 = _wcsdup(v92);
          free(v22);
          sub_11F2170(&v44);
          LOBYTE(v94) = 21;
          sub_11F7040(v92, &v44);
          v23 = sub_11F4EE0(&v52, a1, &v44, 0);
          sub_11F2250(&v91, v23);
          free(v52);
          LOBYTE(v94) = 7;
          sub_11F21F0(&v44);
        }
        RegCloseKey(v66);
      }
    }
    else
    {
      v19 = v89;
      v89 = _wcsdup(v92);
      free(v19);
      v45 = malloc(2u);
      *v45 = 0;
      v46 = 0;
      v47 = 0;
      v48 = 0;
      LOBYTE(v94) = 20;
      sub_11F7040(v92, &v45);
      v20 = sub_11F4EE0(&v55, a1, &v45, 0);
      v21 = v91;
      v91 = _wcsdup(*v20);
      free(v21);
      free(v55);
      LOBYTE(v94) = 7;
      sub_11F21F0(&v45);
    }
    if ( *v91 )
    {
LABEL_36:
      v65 = sub_11F4ED0();
      sub_1201520(hKey, L"Description", 0, 0, &v87);
      if ( wcslen(v87) && *v87 == 64 )
      {
        v29 = _wcsdup(v88);
        sub_12093C0(v29, &v87);
      }
      else if ( wcslen(v87) > 3 && *(v87 + wcslen(v87) - 1) == 10 )
      {
        *(v87 + wcslen(v87) - 1) = 0;
        if ( *(v87 + wcslen(v87) - 1) == 13 )
          *(v87 + wcslen(v87) - 1) = 0;
      }
      v30 = v76;
      v76 = _wcsdup(v88);
      free(v30);
      v31 = gpszTargetName;
      if ( v11 )
        v31 = v11;
      v79 = _wcsdup(v31);
      v77 = _wcsdup(gpszTargetName);
      v32 = gpszTargetName;
      if ( v11 )
        v32 = v11;
      v75 = _wcsdup(v32);
      LOBYTE(v94) = 25;
      v33 = sub_11F7BE0(&v49, a2, &v79, &v88);
      LOBYTE(v94) = 26;
      v34 = sub_11F7BE0(&v54, a2, &v75, &v77);
      LOBYTE(v94) = 27;
      v35 = sub_11F3D40(a1, &v76, v34, v33, &v91, &v74, &v68, &v57);
      free(v54);
      free(v49);
      free(v75);
      free(v77);
      LOBYTE(v94) = 7;
      free(v79);
      if ( v35 )
      {
        if ( v72 == -1 )
        {
          v63 = _wcsdup(gpszTargetName);
          v62 = _wcsdup(gpszTargetName);
          v64 = _wcsdup(gpszTargetName);
          v85 = _wcsdup(gpszTargetName);
          v82 = _wcsdup(gpszTargetName);
          v78 = _wcsdup(gpszTargetName);
          v80 = _wcsdup(gpszTargetName);
          v11 = psz;
          v36 = gpszTargetName;
          if ( psz )
            v36 = psz;
          v84 = _wcsdup(v36);
          v83 = _wcsdup(gpszTargetName);
          v37 = gpszTargetName;
          if ( psz )
            v37 = psz;
          v81 = _wcsdup(v37);
          LOBYTE(v94) = 37;
          v38 = sub_11F7BE0(&v59, a2, &v84, &v80);
          LOBYTE(v94) = 38;
          v39 = sub_11F7BE0(&v60, a2, &v81, &v83);
          LOBYTE(v94) = 39;
          v72 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v39, v38, &v78);
          free(v60);
          free(v59);
          free(v81);
          free(v83);
          free(v84);
          free(v80);
          free(v78);
          free(v82);
          free(v85);
          free(v64);
          free(v62);
          free(v63);
        }
        else
        {
          v11 = psz;
        }
        v73 = _wcsdup(gpszTargetName);
        v40 = gpszTargetName;
        if ( v11 )
          v40 = v11;
        v70 = _wcsdup(v40);
        LOBYTE(v94) = 41;
        v41 = sub_11F7BE0(&v53, a2, &v70, &v88);
        LOBYTE(v94) = 42;
        sub_11F3FF0(a1, v65, v72, 8, &v76, v41, &v91);
        free(v53);
        free(v70);
        LOBYTE(v94) = 7;
        free(v73);
      }
      else
      {
        v11 = psz;
      }
      v17 = RegQueryValueExW;
      goto LABEL_60;
    }
    v17 = RegQueryValueExW;
    if ( !sub_1201520(hKey, L"ImagePath", 0, 0, &v92) )
    {
      cbData = 4;
      if ( RegQueryValueExW(hKey, L"WOW64", 0, 0, v50, &cbData) )
      {
        v24 = v89;
        v89 = _wcsdup(v92);
        free(v24);
        sub_11F2170(&v43);
        LOBYTE(v94) = 22;
        sub_11F6CC0(v92, &v43);
        v25 = sub_11F4EE0(&v58, a1, &v43, 0);
        sub_11F2250(&v91, v25);
        free(v58);
        LOBYTE(v94) = 7;
        sub_11F21F0(&v43);
      }
      else
      {
        if ( !*v50 )
          goto LABEL_35;
        if ( Wow64EnableWow64FsRedirection )
        {
          Wow64EnableWow64FsRedirection(1);
          TlsSetValue(gdwTlsIndex, 0x200);
        }
        v26 = v89;
        v89 = _wcsdup(v92);
        free(v26);
        v27 = _wcsdup(v92);
        sub_11F5C70(&v56, v27);
        free(v56);
        v28 = sub_11F4F20(&v61, a1, v92);
        sub_11F2250(&v91, v28);
        free(v61);
        if ( Wow64EnableWow64FsRedirection )
        {
          Wow64EnableWow64FsRedirection(0);
          TlsSetValue(gdwTlsIndex, 0x100);
        }
      }
      v17 = RegQueryValueExW;
    }
LABEL_35:
    if ( *v91 )
      goto LABEL_36;
LABEL_60:
    RegCloseKey(hKey);
LABEL_61:
    ++v69;
  }
  while ( !sub_12013D0(v71, v69, &v88) );
  v16 = v72;
LABEL_63:
  RegCloseKey(v71);
LABEL_64:
  free(v89);
  free(v68);
  free(v87);
  free(v74);
  free(v91);
  free(v76);
  free(v88);
  free(v92);
  return v16;
}
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);

//----- (0120A070) --------------------------------------------------------
void __cdecl sub_120A070(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_120A120(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_120A120(a1, a2, v7, v5);
  free(v7);
}

//----- (0120A120) --------------------------------------------------------
void *__cdecl sub_120A120(int a1, void *a2, wchar_t *psz, void *a4)
{
  WCHAR *v4; // eax
  WCHAR *v5; // eax
  unsigned __int16 **v6; // esi
  unsigned __int16 **v7; // eax
  unsigned int v8; // eax
  void (__stdcall *v9)(HKEY); // ebx
  LPVOID (__stdcall *v10)(DWORD); // edi
  const wchar_t **v11; // eax
  wchar_t *v12; // esi
  OLECHAR *v13; // esi
  unsigned int v14; // eax
  wchar_t *v15; // esi
  OLECHAR *v16; // esi
  unsigned int v17; // eax
  wchar_t *v18; // esi
  int v19; // eax
  const wchar_t **v20; // eax
  wchar_t *v21; // esi
  OLECHAR *v22; // esi
  unsigned int v23; // eax
  WCHAR *v24; // ecx
  wchar_t *v25; // eax
  wchar_t *v26; // edi
  wchar_t *v27; // esi
  const wchar_t **v28; // eax
  void *v29; // esi
  const wchar_t **v30; // eax
  void *v31; // esi
  wchar_t *v32; // esi
  unsigned __int16 **v33; // eax
  wchar_t *v34; // edi
  void *v35; // esi
  OLECHAR *v36; // esi
  unsigned int v37; // eax
  void *v38; // esi
  WCHAR *v39; // eax
  WCHAR *v40; // eax
  unsigned __int16 **v41; // esi
  unsigned __int16 **v42; // eax
  char v43; // bl
  WCHAR *v44; // eax
  WCHAR *v45; // eax
  unsigned __int16 **v46; // esi
  unsigned __int16 **v47; // eax
  int v48; // ebx
  const wchar_t *v49; // eax
  void *v50; // esi
  char *v51; // edx
  __int16 v52; // cx
  WCHAR *v53; // eax
  unsigned __int16 **v54; // eax
  void *v55; // esi
  void **v56; // esi
  void **v57; // edi
  void *v59; // [esp+10h] [ebp-C4h]
  void *v60; // [esp+14h] [ebp-C0h]
  void *v61; // [esp+18h] [ebp-BCh]
  void *v62; // [esp+1Ch] [ebp-B8h]
  int v63; // [esp+20h] [ebp-B4h]
  void *v64; // [esp+24h] [ebp-B0h]
  int v65; // [esp+28h] [ebp-ACh]
  void *v66; // [esp+2Ch] [ebp-A8h]
  void *v67; // [esp+30h] [ebp-A4h]
  void *v68; // [esp+34h] [ebp-A0h]
  void *v69; // [esp+38h] [ebp-9Ch]
  void *v70; // [esp+3Ch] [ebp-98h]
  int v71; // [esp+40h] [ebp-94h]
  void *v72; // [esp+44h] [ebp-90h]
  void *v73; // [esp+48h] [ebp-8Ch]
  void *v74; // [esp+4Ch] [ebp-88h]
  void *v75; // [esp+50h] [ebp-84h]
  void *v76; // [esp+54h] [ebp-80h]
  void *v77; // [esp+58h] [ebp-7Ch]
  void *v78; // [esp+5Ch] [ebp-78h]
  void *v79; // [esp+60h] [ebp-74h]
  void *v80; // [esp+64h] [ebp-70h]
  void *v81; // [esp+68h] [ebp-6Ch]
  void *v82; // [esp+6Ch] [ebp-68h]
  void *v83; // [esp+70h] [ebp-64h]
  void *v84; // [esp+74h] [ebp-60h]
  HKEY v85; // [esp+78h] [ebp-5Ch]
  void *v86; // [esp+7Ch] [ebp-58h]
  void *v87; // [esp+80h] [ebp-54h]
  void *v88; // [esp+84h] [ebp-50h]
  void *v89; // [esp+88h] [ebp-4Ch]
  void *v90; // [esp+8Ch] [ebp-48h]
  void **v91; // [esp+90h] [ebp-44h]
  int v92; // [esp+94h] [ebp-40h]
  void *v93; // [esp+98h] [ebp-3Ch]
  void *v94; // [esp+9Ch] [ebp-38h]
  void *v95; // [esp+A0h] [ebp-34h]
  void *v96; // [esp+A4h] [ebp-30h]
  wchar_t *v97; // [esp+A8h] [ebp-2Ch]
  wchar_t *v98; // [esp+ACh] [ebp-28h]
  void *v99; // [esp+B0h] [ebp-24h]
  wchar_t *v100; // [esp+B4h] [ebp-20h]
  HKEY hKey; // [esp+B8h] [ebp-1Ch]
  void *v102; // [esp+BCh] [ebp-18h]
  wchar_t *v103; // [esp+C0h] [ebp-14h]
  wchar_t *v104; // [esp+C4h] [ebp-10h]
  int v105; // [esp+D0h] [ebp-4h]

  v99 = malloc(2u);
  *v99 = 0;
  v105 = 0;
  v98 = malloc(2u);
  *v98 = 0;
  v87 = malloc(2u);
  *v87 = 0;
  v83 = malloc(2u);
  *v83 = 0;
  v82 = malloc(2u);
  *v82 = 0;
  LOBYTE(v105) = 4;
  if ( a4 == -1 )
  {
    v93 = _wcsdup(gpszTargetName);
    v95 = _wcsdup(gpszTargetName);
    v96 = _wcsdup(gpszTargetName);
    v94 = _wcsdup(gpszTargetName);
    v88 = _wcsdup(gpszTargetName);
    v104 = _wcsdup(gpszTargetName);
    v102 = _wcsdup(gpszTargetName);
    v4 = gpszTargetName;
    if ( psz )
      v4 = psz;
    v103 = _wcsdup(v4);
    hKey = _wcsdup(gpszTargetName);
    v5 = gpszTargetName;
    if ( psz )
      v5 = psz;
    v100 = _wcsdup(v5);
    LOBYTE(v105) = 14;
    v6 = sub_11F7BE0(&v86, a2, &v103, &v102);
    LOBYTE(v105) = 15;
    v7 = sub_11F7BE0(&v84, a2, &v100, &hKey);
    LOBYTE(v105) = 16;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v7, v6, &v104);
    free(v84);
    free(v86);
    free(v100);
    free(hKey);
    free(v103);
    free(v102);
    free(v104);
    free(v88);
    free(v94);
    free(v96);
    free(v95);
    LOBYTE(v105) = 4;
    free(v93);
  }
  v8 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(a2, psz, 0, v8 | 0x20019, &v85) )
  {
    v84 = 0;
    v100 = malloc(2u);
    *v100 = 0;
    v104 = malloc(2u);
    *v104 = 0;
    v103 = malloc(2u);
    *v103 = 0;
    v102 = malloc(2u);
    *v102 = 0;
    v89 = malloc(2u);
    *v89 = 0;
    v90 = 0;
    v91 = 0;
    v92 = 0;
    LOBYTE(v105) = 21;
    v9 = RegCloseKey;
    if ( !sub_12013D0(v85, 0, &v98) )
    {
      v10 = TlsGetValue;
      do
      {
        v11 = sub_120F210(&v64, L"CLSID\\", &v98);
        v12 = v104;
        v104 = _wcsdup(*v11);
        free(v12);
        free(v64);
        v13 = v104;
        v14 = v10(gdwTlsIndex);
        if ( sub_11F67A0(HKEY_CLASSES_ROOT, v13, 0, v14 | 0x20019, &hKey) )
        {
          v16 = v98;
          v17 = v10(gdwTlsIndex);
          if ( sub_11F67A0(v85, v16, 0, v17 | 0x20019, &hKey) )
            goto LABEL_52;
          if ( sub_1201520(hKey, gpszTargetName, 0, 0, &v103) )
            goto LABEL_51;
          v18 = v100;
          v100 = _wcsdup(v98);
          free(v18);
        }
        else
        {
          v15 = v103;
          v103 = _wcsdup(v98);
          free(v15);
          sub_1201520(hKey, gpszTargetName, 0, 0, &v100);
        }
        v9(hKey);
        v19 = sub_120F210(&v59, L"CLSID\\", &v103);
        v20 = sub_11F22B0(&v60, v19, L"\\InprocServer32");
        v21 = v104;
        v104 = _wcsdup(*v20);
        free(v21);
        free(v60);
        free(v59);
        v22 = v104;
        v23 = v10(gdwTlsIndex);
        if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v22, 0, v23 | 0x20019, &hKey) )
        {
          if ( !sub_1201520(hKey, L"CodeBase", 0, 0, &v104) )
          {
            if ( !wcscspn(v104, L"file:////") )
            {
              v24 = gpszTargetName;
              if ( v104 != -18 )
                v24 = v104 + 9;
              v25 = _wcsdup(v24);
              v26 = v104;
              v27 = v25;
              v104 = _wcsdup(v25);
              free(v26);
              free(v27);
            }
            sub_11F7040(v104, &v89);
            v28 = sub_11F4EE0(&v71, a1, &v89, 0);
            v29 = v102;
            v102 = _wcsdup(*v28);
            free(v29);
            free(v71);
            goto LABEL_24;
          }
          if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v104) )
          {
            sub_11F7040(v104, &v89);
            v30 = sub_11F4EE0(&v68, a1, &v89, 0);
            v31 = v102;
            v102 = _wcsdup(*v30);
            free(v31);
            free(v68);
LABEL_24:
            v9(hKey);
            v63 = sub_11F4ED0();
            v32 = _wcsdup(L"CLSID\\");
            v97 = v32;
            v33 = sub_1203070(&v66, &v97, &v103);
            v34 = v104;
            v104 = _wcsdup(*v33);
            free(v34);
            free(v66);
            free(v32);
            sub_120F210(&v86, L"HKCR\\CLSID\\", &v103);
            v35 = v99;
            LOBYTE(v105) = 22;
            v99 = _wcsdup(v103);
            free(v35);
            v36 = v104;
            v37 = TlsGetValue(gdwTlsIndex);
            if ( !sub_11F67A0(HKEY_CLASSES_ROOT, v36, 0, v37 | 0x20019, &hKey) )
            {
              if ( !sub_1201520(hKey, gpszTargetName, 0, 0, &v104) && wcslen(v104) )
              {
                v38 = v99;
                v99 = _wcsdup(v104);
                free(v38);
              }
              v9(hKey);
            }
            v39 = gpszTargetName;
            if ( psz )
              v39 = psz;
            v96 = _wcsdup(v39);
            v95 = _wcsdup(gpszTargetName);
            v40 = gpszTargetName;
            if ( psz )
              v40 = psz;
            v93 = _wcsdup(v40);
            LOBYTE(v105) = 25;
            v41 = sub_11F7BE0(&v70, a2, &v96, &v98);
            LOBYTE(v105) = 26;
            v42 = sub_11F7BE0(&v62, a2, &v93, &v95);
            LOBYTE(v105) = 27;
            v43 = sub_11F3D40(a1, &v99, v42, v41, &v102, &v87, &v82, &v65);
            free(v62);
            free(v70);
            free(v93);
            free(v95);
            free(v96);
            if ( v43 )
            {
              if ( a4 == -1 )
              {
                v77 = _wcsdup(gpszTargetName);
                v75 = _wcsdup(gpszTargetName);
                v81 = _wcsdup(gpszTargetName);
                v79 = _wcsdup(gpszTargetName);
                v72 = _wcsdup(gpszTargetName);
                v76 = _wcsdup(gpszTargetName);
                v78 = _wcsdup(gpszTargetName);
                v44 = gpszTargetName;
                if ( psz )
                  v44 = psz;
                v74 = _wcsdup(v44);
                v88 = _wcsdup(gpszTargetName);
                v45 = gpszTargetName;
                if ( psz )
                  v45 = psz;
                v94 = _wcsdup(v45);
                LOBYTE(v105) = 37;
                v46 = sub_11F7BE0(&v67, a2, &v74, &v78);
                LOBYTE(v105) = 38;
                v47 = sub_11F7BE0(&v69, a2, &v94, &v88);
                LOBYTE(v105) = 39;
                v48 = a1;
                a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v47, v46, &v76);
                free(v69);
                free(v67);
                free(v94);
                free(v88);
                free(v74);
                free(v78);
                free(v76);
                free(v72);
                free(v79);
                free(v81);
                free(v75);
                free(v77);
              }
              else
              {
                v48 = a1;
              }
              v49 = v100;
              v50 = v99;
              if ( wcslen(v100) )
                goto LABEL_63;
              if ( *v99 == 123 )
              {
                v49 = v83;
                v51 = v83;
                v97 = (v83 + 2);
                do
                {
                  v52 = *v51;
                  v51 += 2;
                }
                while ( v52 );
                if ( (v51 - v97) >> 1 )
                {
LABEL_63:
                  v99 = _wcsdup(v49);
                  free(v50);
                }
              }
              v80 = _wcsdup(gpszTargetName);
              v53 = gpszTargetName;
              if ( psz )
                v53 = psz;
              v73 = _wcsdup(v53);
              LOBYTE(v105) = 41;
              v54 = sub_11F7BE0(&v61, a2, &v73, &v98);
              LOBYTE(v105) = 42;
              sub_11F3FF0(v48, v63, a4, 3, &v99, v54, &v102);
              free(v61);
              free(v73);
              free(v80);
            }
            free(v86);
            sub_11F21F0(&v89);
            free(v102);
            free(v103);
            free(v104);
            free(v100);
            v9 = RegCloseKey;
            v10 = TlsGetValue;
            goto LABEL_53;
          }
LABEL_51:
          v9(hKey);
        }
LABEL_52:
        sub_11F21F0(&v89);
        free(v102);
        free(v103);
        free(v104);
        free(v100);
LABEL_53:
        v84 = v84 + 1;
        v55 = v84;
        v100 = malloc(2u);
        *v100 = 0;
        v104 = malloc(2u);
        *v104 = 0;
        v103 = malloc(2u);
        *v103 = 0;
        v102 = malloc(2u);
        *v102 = 0;
        v89 = malloc(2u);
        *v89 = 0;
        v90 = 0;
        v91 = 0;
        v92 = 0;
        LOBYTE(v105) = 21;
      }
      while ( !sub_12013D0(v85, v55, &v98) );
    }
    v56 = v90;
    if ( v90 )
    {
      v57 = v91;
      if ( v90 != v91 )
      {
        do
        {
          free(*v56);
          ++v56;
        }
        while ( v56 != v57 );
        v56 = v90;
      }
      j__free(v56);
      v90 = 0;
      v91 = 0;
      v92 = 0;
    }
    free(v89);
    free(v102);
    free(v103);
    free(v104);
    free(v100);
    v9(v85);
  }
  free(v82);
  free(v83);
  free(v87);
  free(v98);
  free(v99);
  return a4;
}

//----- (0120AC50) --------------------------------------------------------
_DWORD *__stdcall sub_120AC50(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // esi

  result = sub_120E320(a1, a2);
  v4 = result;
  if ( result != -8 )
  {
    sub_120AC80(result + 2, a3);
    result = v4;
  }
  return result;
}

//----- (0120AC80) --------------------------------------------------------
_DWORD *__thiscall sub_120AC80(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax

  v2 = this;
  *this = *a2;
  *(this + 4) = *(a2 + 4);
  v3 = *(a2 + 8);
  this[2] = v3;
  if ( v3 )
    InterlockedIncrement((v3 + 8));
  v4 = *(a2 + 12);
  v2[3] = v4;
  if ( v4 )
    InterlockedIncrement((v4 + 8));
  v5 = *(a2 + 16);
  v2[4] = v5;
  if ( v5 )
    InterlockedIncrement((v5 + 8));
  v6 = *(a2 + 20);
  v2[5] = v6;
  if ( v6 )
    InterlockedIncrement((v6 + 8));
  v7 = *(a2 + 24);
  v2[6] = v7;
  if ( v7 )
    InterlockedIncrement((v7 + 8));
  v8 = *(a2 + 28);
  v2[7] = v8;
  if ( v8 )
    InterlockedIncrement((v8 + 8));
  v9 = *(a2 + 32);
  v2[8] = v9;
  if ( v9 )
    InterlockedIncrement((v9 + 8));
  return v2;
}

//----- (0120AD20) --------------------------------------------------------
BSTR **__thiscall sub_120AD20(BSTR **this, VARIANTARG *pvarSrc)
{
  BSTR **v2; // esi
  int v3; // eax
  VARIANTARG pvarg; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+24h] [ebp-4h]

  v2 = this;
  *this = 0;
  if ( pvarSrc->vt == 8 )
  {
    bstr_t::Assign(this, pvarSrc->bstrVal);
  }
  else
  {
    VariantInit(&pvarg);
    v6 = 0;
    if ( &pvarg != pvarSrc || pvarg.vt != 8 )
    {
      v3 = VariantChangeType(&pvarg, pvarSrc, 0, 8u);
      if ( v3 < 0 )
        com_error::throw(v3);
    }
    bstr_t::Assign(v2, pvarg.bstrVal);
    VariantClear(&pvarg);
  }
  return v2;
}

//----- (0120ADD0) --------------------------------------------------------
BSTR **__thiscall CComBSTR::AssignA(BSTR **this, LPCSTR lpString)
{
  BSTR **v2; // edi
  CComBSTR *v3; // eax
  CComBSTR *v4; // esi

  v2 = this;
  v3 = operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    v3->hKey = 0;
    v3->Length = 1;
    v3->bstr = AsciiToUTF(lpString);
  }
  else
  {
    v4 = 0;
  }
  *v2 = &v4->bstr;
  if ( !v4 )
    com_error::throw(E_OUTOFMEMORY);
  return v2;
}

//----- (0120AE80) --------------------------------------------------------
void __thiscall sub_120AE80(_DWORD *this)
{
  _DWORD *v1; // esi
  LONG (__stdcall *v2)(volatile LONG *); // ecx
  int v3; // edi
  int v4; // edi
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // edi

  v1 = this;
  v2 = InterlockedDecrement;
  v3 = v1[8];
  if ( v3 )
  {
    if ( !InterlockedDecrement((v3 + 8)) && v3 )
    {
      if ( *v3 )
      {
        SysFreeString(*v3);
        *v3 = 0;
      }
      if ( *(v3 + 4) )
      {
        j_j__free(*(v3 + 4));
        *(v3 + 4) = 0;
      }
      j__free(v3);
    }
    v2 = InterlockedDecrement;
    v1[8] = 0;
  }
  v4 = v1[7];
  if ( v4 )
  {
    if ( !v2((v4 + 8)) && v4 )
    {
      if ( *v4 )
      {
        SysFreeString(*v4);
        *v4 = 0;
      }
      if ( *(v4 + 4) )
      {
        j_j__free(*(v4 + 4));
        *(v4 + 4) = 0;
      }
      j__free(v4);
    }
    v1[7] = 0;
  }
  v5 = v1[6];
  if ( v5 )
  {
    if ( !InterlockedDecrement((v5 + 8)) && v5 )
    {
      if ( *v5 )
      {
        SysFreeString(*v5);
        *v5 = 0;
      }
      if ( *(v5 + 4) )
      {
        j_j__free(*(v5 + 4));
        *(v5 + 4) = 0;
      }
      j__free(v5);
    }
    v1[6] = 0;
  }
  v6 = v1[5];
  if ( v6 )
  {
    if ( !InterlockedDecrement((v6 + 8)) && v6 )
    {
      if ( *v6 )
      {
        SysFreeString(*v6);
        *v6 = 0;
      }
      if ( *(v6 + 4) )
      {
        j_j__free(*(v6 + 4));
        *(v6 + 4) = 0;
      }
      j__free(v6);
    }
    v1[5] = 0;
  }
  v7 = v1[4];
  if ( v7 )
  {
    if ( !InterlockedDecrement((v7 + 8)) && v7 )
    {
      if ( *v7 )
      {
        SysFreeString(*v7);
        *v7 = 0;
      }
      if ( *(v7 + 4) )
      {
        j_j__free(*(v7 + 4));
        *(v7 + 4) = 0;
      }
      j__free(v7);
    }
    v1[4] = 0;
  }
  v8 = v1[3];
  if ( v8 )
  {
    if ( !InterlockedDecrement((v8 + 8)) && v8 )
    {
      if ( *v8 )
      {
        SysFreeString(*v8);
        *v8 = 0;
      }
      if ( *(v8 + 4) )
      {
        j_j__free(*(v8 + 4));
        *(v8 + 4) = 0;
      }
      j__free(v8);
    }
    v1[3] = 0;
  }
  v9 = v1[2];
  if ( v9 )
  {
    if ( !InterlockedDecrement((v9 + 8)) && v9 )
    {
      if ( *v9 )
      {
        SysFreeString(*v9);
        *v9 = 0;
      }
      if ( *(v9 + 4) )
      {
        j_j__free(*(v9 + 4));
        *(v9 + 4) = 0;
      }
      j__free(v9);
    }
    v1[2] = 0;
  }
}

//----- (0120B0D0) --------------------------------------------------------
int *__thiscall sub_120B0D0(_DWORD *this, int a2)
{
  _DWORD *v2; // edi
  int v3; // esi
  int *result; // eax

  v2 = this;
  v3 = *this;
  if ( *this )
  {
    if ( !InterlockedDecrement((v3 + 8)) && v3 )
    {
      if ( *v3 )
      {
        SysFreeString(*v3);
        *v3 = 0;
      }
      if ( *(v3 + 4) )
      {
        j_j__free(*(v3 + 4));
        *(v3 + 4) = 0;
      }
      j__free(v3);
    }
    *v2 = 0;
  }
  result = operator new(0xCu);
  if ( result )
  {
    result[1] = 0;
    result[2] = 1;
    *result = a2;
  }
  else
  {
    result = 0;
  }
  *v2 = result;
  if ( !result )
    com_error::throw(-2147024882);
  return result;
}

//----- (0120B1A0) --------------------------------------------------------
char __cdecl sub_120B1A0(int **a1, void **a2)
{
  HMODULE v2; // eax
  HMODULE v3; // eax
  int v4; // esi
  int v5; // edi
  const WCHAR *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // ecx
  const WCHAR *v9; // eax
  CComBSTR *v10; // eax
  CComBSTR *v11; // edi
  BSTR v12; // eax
  const WCHAR ***v13; // esi
  BSTR **v14; // eax
  const WCHAR *v15; // ecx
  const WCHAR **v16; // eax
  const WCHAR *v17; // eax
  DWORD v18; // eax
  void *v19; // esi
  CComBSTR *v20; // esi
  CComBSTR *v21; // edi
  _DWORD *v22; // eax
  _DWORD *v23; // edi
  HANDLE v24; // esi
  BSTR **v25; // eax
  const WCHAR *v26; // esi
  const WCHAR *v27; // eax
  void *v28; // esi
  int v29; // eax
  BSTR **v30; // eax
  const WCHAR *v31; // esi
  const WCHAR *v32; // eax
  void *v33; // esi
  CComBSTR *v34; // eax
  WCHAR *v35; // esi
  BSTR v36; // eax
  const WCHAR ***v37; // esi
  BSTR **v38; // eax
  const WCHAR *v39; // ecx
  const WCHAR **v40; // eax
  const WCHAR *v41; // eax
  void *v42; // esi
  CComBSTR *v43; // esi
  LPVOID v44; // esi
  HMODULE v45; // eax
  FARPROC v46; // eax
  HANDLE v47; // eax
  wchar_t *v48; // edx
  OLECHAR *v49; // ST18_4
  HKEY v50; // esi
  CComBSTR *v51; // eax
  BSTR v52; // eax
  CComBSTR *v53; // ecx
  CComBSTR *v54; // eax
  CComBSTR *v55; // eax
  BSTR v56; // eax
  DWORD v57; // ecx
  CComBSTR *v58; // eax
  WCHAR *v59; // eax
  BSTR v60; // eax
  LPWSTR v61; // ecx
  LPWSTR v62; // eax
  _bstr_t *v63; // eax
  _bstr_t *v64; // eax
  CComBSTR *v65; // eax
  void **v66; // eax
  void **v67; // eax
  void **v68; // eax
  void **v69; // eax
  void **v70; // eax
  void **v71; // eax
  OLECHAR *v72; // eax
  HANDLE v73; // eax
  CComBSTR *v74; // eax
  BSTR v75; // eax
  DWORD v76; // ecx
  void *v77; // eax
  WCHAR *v78; // eax
  BSTR v79; // eax
  LPWSTR v80; // ecx
  CComBSTR *v81; // eax
  CComBSTR *v82; // eax
  BSTR v83; // eax
  CComBSTR *v84; // ecx
  CComBSTR *v85; // eax
  _bstr_t *v86; // eax
  _bstr_t *v87; // eax
  CComBSTR *v88; // eax
  void **v89; // eax
  void **v90; // eax
  void **v91; // eax
  void **v92; // eax
  void **v93; // eax
  DWORD v94; // eax
  void *v95; // eax
  void *v96; // eax
  OLECHAR *v97; // eax
  CComBSTR *v98; // eax
  BSTR v99; // eax
  CComBSTR *v100; // ecx
  CComBSTR *v101; // eax
  CComBSTR *v102; // eax
  void **v103; // eax
  void **v104; // eax
  OLECHAR *v105; // eax
  CComBSTR *v106; // eax
  BSTR v107; // eax
  CComBSTR *v108; // ecx
  CComBSTR *v109; // eax
  CComBSTR *v110; // eax
  void **v111; // eax
  void **v112; // eax
  OLECHAR *v113; // eax
  void **v114; // eax
  volatile LONG *v115; // eax
  int v116; // eax
  unsigned int v117; // ecx
  DWORD v118; // eax
  LPWSTR v119; // edx
  unsigned int v120; // esi
  _WORD *v121; // edi
  WCHAR v122; // ax
  void **v123; // eax
  BSTR v124; // esi
  const wchar_t *v125; // eax
  const wchar_t *v126; // eax
  wchar_t *v127; // eax
  wint_t v128; // cx
  _WORD *v129; // edi
  wint_t v130; // ax
  CComBSTR *v131; // eax
  const OLECHAR *v132; // ST18_4
  BSTR v133; // eax
  DWORD v134; // ecx
  DWORD v135; // eax
  void **v136; // eax
  CComBSTR *v137; // eax
  void (__stdcall *v138)(signed int); // ecx
  BSTR v139; // edx
  CComBSTR *v140; // eax
  BSTR v141; // eax
  CComBSTR *v142; // edx
  BSTR v143; // ST14_4
  int v144; // eax
  LONG v145; // eax
  void **v146; // eax
  CComBSTR *v147; // eax
  BSTR v148; // eax
  CComBSTR *v149; // edx
  BSTR v150; // ST14_4
  int v151; // eax
  void **v152; // eax
  BSTR *v153; // eax
  BSTR v154; // edx
  int v155; // eax
  BSTR *v156; // eax
  BSTR v157; // edx
  int v158; // eax
  BSTR *v159; // eax
  BSTR v160; // edx
  int v161; // eax
  BSTR *v162; // eax
  BSTR v163; // edx
  int v164; // eax
  BSTR *v165; // eax
  BSTR v166; // edx
  int v167; // eax
  CComBSTR *v168; // edi
  BSTR *v169; // eax
  BSTR v170; // edx
  int v171; // eax
  BSTR *v172; // eax
  const wchar_t *v173; // eax
  BSTR *v174; // eax
  BSTR v175; // edx
  int v176; // eax
  signed int v177; // esi
  BSTR *v178; // eax
  const wchar_t *v179; // eax
  BSTR *v180; // eax
  BSTR v181; // edx
  int v182; // eax
  int v183; // esi
  const wchar_t *v184; // eax
  wchar_t *v185; // eax
  _bstr_t *v186; // eax
  CComBSTR *v187; // eax
  HKEY v188; // edx
  char *v189; // eax
  _DWORD *v190; // edi
  _DWORD *v191; // eax
  _DWORD *v192; // esi
  __int128 v194; // [esp+Ch] [ebp-5C4h]
  double v195; // [esp+1Ch] [ebp-5B4h]
  int v196; // [esp+24h] [ebp-5ACh]
  VARIANTARG pvarg; // [esp+28h] [ebp-5A8h]
  DWORD pcchUnescaped; // [esp+38h] [ebp-598h]
  BSTR *v199; // [esp+3Ch] [ebp-594h]
  BSTR *v200; // [esp+40h] [ebp-590h]
  OLECHAR **v201; // [esp+44h] [ebp-58Ch]
  BSTR *v202; // [esp+48h] [ebp-588h]
  LPWSTR ppsz; // [esp+4Ch] [ebp-584h]
  BSTR *v204; // [esp+50h] [ebp-580h]
  BSTR *v205; // [esp+54h] [ebp-57Ch]
  BSTR *v206; // [esp+58h] [ebp-578h]
  BSTR *v207; // [esp+5Ch] [ebp-574h]
  VARIANTARG pvarSrc; // [esp+60h] [ebp-570h]
  BSTR *v209; // [esp+70h] [ebp-560h]
  BSTR *v210; // [esp+74h] [ebp-55Ch]
  BSTR *v211; // [esp+78h] [ebp-558h]
  CComBSTR *v212; // [esp+7Ch] [ebp-554h]
  BSTR *v213; // [esp+80h] [ebp-550h]
  CComBSTR *v214; // [esp+84h] [ebp-54Ch]
  CComBSTR *v215; // [esp+88h] [ebp-548h]
  CComBSTR *v216; // [esp+8Ch] [ebp-544h]
  int v217; // [esp+90h] [ebp-540h]
  int v218; // [esp+94h] [ebp-53Ch]
  void *v219; // [esp+98h] [ebp-538h]
  CComBSTR *v220; // [esp+9Ch] [ebp-534h]
  int v221; // [esp+A0h] [ebp-530h]
  CComBSTR *v222; // [esp+A4h] [ebp-52Ch]
  DWORD NumberOfBytesRead; // [esp+A8h] [ebp-528h]
  CComBSTR *v224; // [esp+ACh] [ebp-524h]
  CComBSTR *v225; // [esp+B0h] [ebp-520h]
  void *v226; // [esp+B4h] [ebp-51Ch]
  CComBSTR *v227; // [esp+B8h] [ebp-518h]
  void *v228; // [esp+BCh] [ebp-514h]
  CComBSTR *v229; // [esp+C0h] [ebp-510h]
  int v230; // [esp+C4h] [ebp-50Ch]
  void **v231; // [esp+C8h] [ebp-508h]
  HANDLE v232; // [esp+CCh] [ebp-504h]
  bool v233; // [esp+D0h] [ebp-500h]
  void *v234[4]; // [esp+D4h] [ebp-4FCh]
  int v235; // [esp+E4h] [ebp-4ECh]
  int v236; // [esp+E8h] [ebp-4E8h]
  CComBSTR *ppComBSTR; // [esp+ECh] [ebp-4E4h]
  int v238; // [esp+F0h] [ebp-4E0h]
  LPVOID ppv; // [esp+F4h] [ebp-4DCh]
  CComBSTR **v240; // [esp+F8h] [ebp-4D8h]
  CComBSTR *v241; // [esp+FCh] [ebp-4D4h]
  void *v242; // [esp+100h] [ebp-4D0h]
  int v243; // [esp+104h] [ebp-4CCh]
  CComBSTR *ppComBSTR1; // [esp+108h] [ebp-4C8h]
  CComBSTR *v245; // [esp+10Ch] [ebp-4C4h]
  void *v246; // [esp+110h] [ebp-4C0h]
  int v247; // [esp+114h] [ebp-4BCh]
  _DWORD *v248; // [esp+118h] [ebp-4B8h]
  int v249; // [esp+11Ch] [ebp-4B4h]
  CComBSTR *ppComBSTR2; // [esp+120h] [ebp-4B0h]
  int v251; // [esp+124h] [ebp-4ACh]
  CComBSTR v252; // [esp+128h] [ebp-4A8h]
  LPWSTR lpWideCharStr; // [esp+134h] [ebp-49Ch]
  CComBSTR *v254; // [esp+138h] [ebp-498h]
  DWORD nNumberOfBytesToRead; // [esp+13Ch] [ebp-494h]
  HANDLE hFile; // [esp+140h] [ebp-490h]
  LPVOID lpBuffer; // [esp+144h] [ebp-48Ch]
  bool v258; // [esp+14Bh] [ebp-485h]
  OLECHAR psz; // [esp+14Ch] [ebp-484h]
  WCHAR ReturnedString; // [esp+354h] [ebp-27Ch]
  char v261; // [esp+356h] [ebp-27Ah]
  WCHAR KeyName; // [esp+55Ch] [ebp-74h]
  int v263; // [esp+5CCh] [ebp-4h]

  v240 = a1;
  v231 = a2;
  if ( !GetSystemDefaultLocaleName )
  {
    v2 = LoadLibraryW(L"Kernel32.dll");
    GetSystemDefaultLocaleName = GetProcAddress(v2, "GetSystemDefaultLocaleName");
    v3 = LoadLibraryW(L"Kernel32.dll");
    GetUserDefaultLocaleName = GetProcAddress(v3, "GetUserDefaultLocaleName");
  }
  sub_120E360(a2);
  v4 = 0;
  v247 = 0;
  v246 = sub_1282A70(0, 0);
  v5 = 0;
  v263 = 0;
  _swprintf(&KeyName, L"Section%d", 0);
  ReturnedString = 0;
  memset(&v261, 0, 0x206u);
  v6 = sub_11F3B40(v240);
  if ( GetPrivateProfileStringW(L"Root", &KeyName, gpszTargetName, &ReturnedString, 0x104u, v6) )
  {
    do
    {
      ppComBSTR2 = _wtoi(&ReturnedString);
      v7 = sub_1281420(v246, *(v246 + 1), &ppComBSTR2);
      if ( (357913940 - v4) < 1 )
LABEL_10:
        std::_Xlength_error("list<T> too long");
      ++v5;
      ++v4;
      *(v246 + 1) = v7;
      v8 = v7[1];
      v247 = v4;
      *v8 = v7;
      _swprintf(&KeyName, L"Section%d", v5);
      ReturnedString = 0;
      memset(&v261, 0, 0x206u);
      v9 = sub_11F3B40(v240);
    }
    while ( GetPrivateProfileStringW(L"Root", &KeyName, gpszTargetName, &ReturnedString, 0x104u, v9) );
  }
  v251 = 0;
  v245 = -1;
  while ( 1 )
  {
    ReturnedString = 0;
    memset(&v261, 0, 0x206u);
    v10 = operator new(0xCu);
    v11 = v10;
    v220 = v10;
    LOBYTE(v263) = 1;
    if ( v10 )
    {
      v10->hKey = 0;
      v10->Length = 1;
      v12 = SysAllocString(L".disabled");
      v11->bstr = v12;
      if ( !v12 )
        goto LABEL_9;
    }
    else
    {
      v11 = 0;
    }
    LOBYTE(v263) = 0;
    ppComBSTR2 = v11;
    if ( !v11 )
LABEL_9:
      com_error::throw(-2147024882);
    LOBYTE(v263) = 2;
    v13 = CComBSTR::AppendTail(v240, &ppComBSTR1, &ppComBSTR2);
    LOBYTE(v263) = 3;
    v14 = sub_120E1B0(&v242, v251);
    if ( *v13 )
      v15 = **v13;
    else
      v15 = 0;
    v16 = *v14;
    if ( v16 )
      v17 = *v16;
    else
      v17 = 0;
    v18 = GetPrivateProfileStringW(v17, L"PrivateSetting_GadgetName", gpszTargetName, &ReturnedString, 0x104u, v15);
    v19 = v242;
    v258 = v18 == 0;
    if ( v242 )
    {
      if ( !InterlockedDecrement(v242 + 2) && v19 )
      {
        if ( *v19 )
        {
          SysFreeString(*v19);
          *v19 = 0;
        }
        if ( *(v19 + 1) )
        {
          j_j__free(*(v19 + 1));
          *(v19 + 1) = 0;
        }
        j__free(v19);
      }
      v242 = 0;
    }
    v20 = ppComBSTR1;
    if ( ppComBSTR1 )
    {
      if ( !InterlockedDecrement(&ppComBSTR1->Length) && v20 )
      {
        if ( v20->bstr )
        {
          SysFreeString(v20->bstr);
          v20->bstr = 0;
        }
        if ( v20->hKey )
        {
          j_j__free(v20->hKey);
          v20->hKey = 0;
        }
        j__free(v20);
      }
      ppComBSTR1 = 0;
    }
    LOBYTE(v263) = 0;
    if ( !InterlockedDecrement(&v11->Length) )
    {
      if ( v11->bstr )
      {
        SysFreeString(v11->bstr);
        v11->bstr = 0;
      }
      if ( v11->hKey )
      {
        j_j__free(v11->hKey);
        v11->hKey = 0;
      }
      j__free(v11);
    }
    if ( v258 )
      break;
    v21 = v245;
    ppComBSTR2 = v245;
    v22 = sub_1281420(v246, *(v246 + 1), &ppComBSTR2);
    if ( (357913940 - v247) < 1 )
      goto LABEL_10;
    ++v251;
    ++v247;
    v245 = (v21 - 1);
    *(v246 + 1) = v22;
    *v22[1] = v22;
  }
  v23 = *v246;
  v248 = v23;
  if ( v23 != v246 )
  {
    while ( 1 )
    {
      v235 = 0;
      _mm_storeu_si128(v234, 0i64);
      v236 = 0;
      ppComBSTR = 0;
      v24 = v23[2];
      ReturnedString = 0;
      LOBYTE(v263) = 4;
      hFile = v24;
      v232 = v24;
      memset(&v261, 0, 0x206u);
      if ( v24 < 0 )
      {
        v233 = 0;
      }
      else
      {
        v25 = sub_120E1B0(&v219, v24);
        if ( *v25 )
          v26 = **v25;
        else
          v26 = 0;
        v27 = sub_11F3B40(v240);
        GetPrivateProfileStringW(v26, L"PrivateSetting_Enabled", gpszTargetName, &ReturnedString, 0x104u, v27);
        v28 = v219;
        if ( v219 )
        {
          if ( !InterlockedDecrement(v219 + 2) && v28 )
          {
            if ( *v28 )
            {
              SysFreeString(*v28);
              *v28 = 0;
            }
            if ( *(v28 + 1) )
            {
              j_j__free(*(v28 + 1));
              *(v28 + 1) = 0;
            }
            j__free(v28);
          }
          v219 = 0;
        }
        v29 = _wcsicmp(&ReturnedString, L"false");
        v24 = hFile;
        v233 = v29 != 0;
      }
      ReturnedString = 0;
      if ( v24 < 0 )
      {
        v34 = operator new(0xCu);
        v35 = v34;
        lpBuffer = v34;
        v254 = v34;
        LOBYTE(v263) = 5;
        if ( v34 )
        {
          v34->hKey = 0;
          v34->Length = 1;
          v36 = SysAllocString(L".disabled");
          *v35 = v36;
          if ( !v36 )
            goto LABEL_9;
        }
        else
        {
          v35 = 0;
          lpBuffer = 0;
        }
        LOBYTE(v263) = 4;
        lpWideCharStr = v35;
        if ( !v35 )
          goto LABEL_9;
        LOBYTE(v263) = 6;
        v37 = CComBSTR::AppendTail(v240, &v224, &lpWideCharStr);
        LOBYTE(v263) = 7;
        v38 = sub_120E1B0(&v226, -1 - hFile);
        if ( *v37 )
          v39 = **v37;
        else
          v39 = 0;
        v40 = *v38;
        if ( v40 )
          v41 = *v40;
        else
          v41 = 0;
        GetPrivateProfileStringW(v41, L"PrivateSetting_GadgetName", gpszTargetName, &ReturnedString, 0x104u, v39);
        v42 = v226;
        if ( v226 )
        {
          if ( !InterlockedDecrement(v226 + 2) && v42 )
          {
            if ( *v42 )
            {
              SysFreeString(*v42);
              *v42 = 0;
            }
            if ( *(v42 + 1) )
            {
              j_j__free(*(v42 + 1));
              *(v42 + 1) = 0;
            }
            j__free(v42);
          }
          v226 = 0;
        }
        v43 = v224;
        if ( v224 )
        {
          if ( !InterlockedDecrement(&v224->Length) && v43 )
          {
            if ( v43->bstr )
            {
              SysFreeString(v43->bstr);
              v43->bstr = 0;
            }
            if ( v43->hKey )
            {
              j_j__free(v43->hKey);
              v43->hKey = 0;
            }
            j__free(v43);
          }
          v224 = 0;
        }
        v44 = lpBuffer;
        LOBYTE(v263) = 4;
        if ( !InterlockedDecrement(lpBuffer + 2) )
        {
          if ( *v44 )
          {
            SysFreeString(*v44);
            *v44 = 0;
          }
          if ( *(v44 + 1) )
          {
            j_j__free(*(v44 + 1));
            *(v44 + 1) = 0;
          }
          j__free(v44);
        }
      }
      else
      {
        v30 = sub_120E1B0(&v228, v24);
        if ( *v30 )
          v31 = **v30;
        else
          v31 = 0;
        v32 = sub_11F3B40(v240);
        GetPrivateProfileStringW(v31, L"PrivateSetting_GadgetName", gpszTargetName, &ReturnedString, 0x104u, v32);
        v33 = v228;
        if ( v228 )
        {
          if ( !InterlockedDecrement(v228 + 2) && v33 )
          {
            if ( *v33 )
            {
              SysFreeString(*v33);
              *v33 = 0;
            }
            if ( *(v33 + 1) )
            {
              j_j__free(*(v33 + 1));
              *(v33 + 1) = 0;
            }
            j__free(v33);
          }
          v228 = 0;
        }
      }
      pcchUnescaped = 260;
      UrlUnescapeW(&ReturnedString, 0, &pcchUnescaped, 0x100000u);
      if ( dword_12E4C68 & 1 )
      {
        v46 = IsWow64Process;
      }
      else
      {
        dword_12E4C68 |= 1u;
        v45 = GetModuleHandle(L"kernel32");
        v46 = GetProcAddress(v45, "IsWow64Process");
        IsWow64Process = v46;
      }
      v218 = 0;
      if ( v46 )
      {
        v47 = GetCurrentProcess();
        if ( IsWow64Process(v47, &v218) )
        {
          if ( v218 )
          {
            v48 = wcsstr(&ReturnedString, L"%PROGRAMFILES%");
            if ( v48 )
            {
              v196 = 50;
              _mm_storeu_si128(&v194, _mm_loadu_si128(&xmmword_12B28CC));
              v195 = dbl_12B28DC;
              memmove_0(v48, &v194, 2 * wcslen(&v194));
            }
          }
        }
      }
      v49 = *GetEnvironmentPathInfo(&ppsz, &ReturnedString);
      LOBYTE(v263) = 8;
      bstr_t::Assign(v234, v49);
      free(ppsz);
      v252.bstr = 0;
      v50 = 0;
      v252.hKey = 0;
      LOBYTE(v263) = 10;
      if ( !GetUserDefaultLocaleName(&psz, 260) )
        goto LABEL_532;
      v51 = operator new(0xCu);
      lpBuffer = v51;
      v254 = v51;
      LOBYTE(v263) = 11;
      if ( v51 )
      {
        v51->hKey = 0;
        v51->Length = 1;
        v52 = SysAllocString(L"\\Gadget.xml");
        v53 = lpBuffer;
        *lpBuffer = v52;
        if ( !v52 )
          goto LABEL_9;
        v54 = v53;
      }
      else
      {
        v54 = 0;
        lpBuffer = 0;
      }
      LOBYTE(v263) = 10;
      v254 = v54;
      if ( !v54 )
        goto LABEL_9;
      LOBYTE(v263) = 12;
      v55 = operator new(0xCu);
      nNumberOfBytesToRead = v55;
      v241 = v55;
      LOBYTE(v263) = 13;
      if ( v55 )
      {
        v55->hKey = 0;
        v55->Length = 1;
        v56 = SysAllocString(&psz);
        v57 = nNumberOfBytesToRead;
        *nNumberOfBytesToRead = v56;
        if ( !v56 )
          goto LABEL_9;
        v58 = v57;
      }
      else
      {
        v58 = 0;
        nNumberOfBytesToRead = 0;
      }
      LOBYTE(v263) = 12;
      v241 = v58;
      if ( !v58 )
        goto LABEL_9;
      LOBYTE(v263) = 14;
      v59 = operator new(0xCu);
      lpWideCharStr = v59;
      hFile = v59;
      LOBYTE(v263) = 15;
      if ( v59 )
      {
        *(v59 + 1) = 0;
        *(v59 + 2) = 1;
        v60 = SysAllocString(L"\\");
        v61 = lpWideCharStr;
        *lpWideCharStr = v60;
        if ( !v60 )
          goto LABEL_9;
        v62 = v61;
      }
      else
      {
        v62 = 0;
        lpWideCharStr = 0;
      }
      LOBYTE(v263) = 14;
      hFile = v62;
      if ( !v62 )
        goto LABEL_9;
      LOBYTE(v263) = 16;
      v63 = CComBSTR::AppendTail(v234, &v212, &hFile);
      LOBYTE(v263) = 17;
      v64 = CComBSTR::AppendTail(v63, &v214, &v241);
      LOBYTE(v263) = 18;
      v65 = CComBSTR::AppendTail(v64, &v216, &v254);
      if ( &v252.hKey != v65 )
      {
        v50 = v65->bstr;
        v252.hKey = v50;
        if ( v50 )
          InterlockedIncrement(v50 + 2);
      }
      hFile = v216;
      if ( v216 )
      {
        if ( !InterlockedDecrement(&v216->Length) )
        {
          v66 = hFile;
          if ( hFile )
          {
            if ( *hFile )
            {
              SysFreeString(*hFile);
              v66 = hFile;
              *hFile = 0;
            }
            if ( v66[1] )
            {
              j_j__free(v66[1]);
              v66 = hFile;
              *(hFile + 1) = 0;
            }
            j__free(v66);
          }
        }
        v216 = 0;
      }
      hFile = v214;
      if ( v214 )
      {
        if ( !InterlockedDecrement(&v214->Length) )
        {
          v67 = hFile;
          if ( hFile )
          {
            if ( *hFile )
            {
              SysFreeString(*hFile);
              v67 = hFile;
              *hFile = 0;
            }
            if ( v67[1] )
            {
              j_j__free(v67[1]);
              v67 = hFile;
              *(hFile + 1) = 0;
            }
            j__free(v67);
          }
        }
        v214 = 0;
      }
      hFile = v212;
      if ( v212 )
      {
        if ( !InterlockedDecrement(&v212->Length) )
        {
          v68 = hFile;
          if ( hFile )
          {
            if ( *hFile )
            {
              SysFreeString(*hFile);
              v68 = hFile;
              *hFile = 0;
            }
            if ( v68[1] )
            {
              j_j__free(v68[1]);
              v68 = hFile;
              *(hFile + 1) = 0;
            }
            j__free(v68);
          }
        }
        v212 = 0;
      }
      if ( !InterlockedDecrement(lpWideCharStr + 2) )
      {
        v69 = lpWideCharStr;
        if ( *lpWideCharStr )
        {
          SysFreeString(*lpWideCharStr);
          v69 = lpWideCharStr;
          *lpWideCharStr = 0;
        }
        if ( v69[1] )
        {
          j_j__free(v69[1]);
          v69 = lpWideCharStr;
          *(lpWideCharStr + 1) = 0;
        }
        j__free(v69);
      }
      if ( !InterlockedDecrement((nNumberOfBytesToRead + 8)) )
      {
        v70 = nNumberOfBytesToRead;
        if ( *nNumberOfBytesToRead )
        {
          SysFreeString(*nNumberOfBytesToRead);
          v70 = nNumberOfBytesToRead;
          *nNumberOfBytesToRead = 0;
        }
        if ( v70[1] )
        {
          j_j__free(v70[1]);
          v70 = nNumberOfBytesToRead;
          *(nNumberOfBytesToRead + 4) = 0;
        }
        j__free(v70);
      }
      LOBYTE(v263) = 10;
      if ( !InterlockedDecrement(lpBuffer + 2) )
      {
        v71 = lpBuffer;
        if ( *lpBuffer )
        {
          SysFreeString(*lpBuffer);
          v71 = lpBuffer;
          *lpBuffer = 0;
        }
        if ( v71[1] )
        {
          j_j__free(v71[1]);
          v71 = lpBuffer;
          *(lpBuffer + 1) = 0;
        }
        j__free(v71);
      }
      v72 = (v50 ? *v50 : 0);
      v73 = sub_11F6640(v72, 0x80000000, 1u, 0, 3u, 0, 0);
      hFile = v73;
      if ( v73 == -1 )
      {
LABEL_532:
        if ( !GetSystemDefaultLocaleName(&psz, 260) )
          goto LABEL_533;
        v74 = operator new(0xCu);
        nNumberOfBytesToRead = v74;
        v254 = v74;
        LOBYTE(v263) = 19;
        if ( v74 )
        {
          v74->hKey = 0;
          v74->Length = 1;
          v75 = SysAllocString(L"\\Gadget.xml");
          v76 = nNumberOfBytesToRead;
          *nNumberOfBytesToRead = v75;
          if ( !v75 )
            goto LABEL_9;
          v77 = v76;
        }
        else
        {
          v77 = 0;
          nNumberOfBytesToRead = 0;
        }
        LOBYTE(v263) = 10;
        hFile = v77;
        if ( !v77 )
          goto LABEL_9;
        LOBYTE(v263) = 20;
        v78 = operator new(0xCu);
        lpWideCharStr = v78;
        v254 = v78;
        LOBYTE(v263) = 21;
        if ( v78 )
        {
          *(v78 + 1) = 0;
          *(v78 + 2) = 1;
          v79 = SysAllocString(&psz);
          v80 = lpWideCharStr;
          *lpWideCharStr = v79;
          if ( !v79 )
            goto LABEL_9;
          v81 = v80;
        }
        else
        {
          v81 = 0;
          lpWideCharStr = 0;
        }
        LOBYTE(v263) = 20;
        v241 = v81;
        if ( !v81 )
          goto LABEL_9;
        LOBYTE(v263) = 22;
        v82 = operator new(0xCu);
        lpBuffer = v82;
        v254 = v82;
        LOBYTE(v263) = 23;
        if ( v82 )
        {
          v82->hKey = 0;
          v82->Length = 1;
          v83 = SysAllocString(L"\\");
          v84 = lpBuffer;
          *lpBuffer = v83;
          if ( !v83 )
            goto LABEL_9;
          v85 = v84;
        }
        else
        {
          v85 = 0;
          lpBuffer = 0;
        }
        LOBYTE(v263) = 22;
        v254 = v85;
        if ( !v85 )
          goto LABEL_9;
        LOBYTE(v263) = 24;
        v86 = CComBSTR::AppendTail(v234, &v229, &v254);
        LOBYTE(v263) = 25;
        v87 = CComBSTR::AppendTail(v86, &v222, &v241);
        LOBYTE(v263) = 26;
        v88 = CComBSTR::AppendTail(v87, &v227, &hFile);
        hFile = v88;
        if ( &v252.hKey != v88 )
        {
          if ( v50 )
          {
            if ( !InterlockedDecrement(v50 + 2) )
            {
              if ( *v50 )
              {
                SysFreeString(*v50);
                *v50 = 0;
              }
              if ( *(v50 + 1) )
              {
                j_j__free(*(v50 + 1));
                *(v50 + 1) = 0;
              }
              j__free(v50);
            }
            v88 = hFile;
          }
          v50 = v88->bstr;
          v252.hKey = v50;
          if ( v50 )
            InterlockedIncrement(v50 + 2);
        }
        hFile = v227;
        if ( v227 )
        {
          if ( !InterlockedDecrement(&v227->Length) )
          {
            v89 = hFile;
            if ( hFile )
            {
              if ( *hFile )
              {
                SysFreeString(*hFile);
                v89 = hFile;
                *hFile = 0;
              }
              if ( v89[1] )
              {
                j_j__free(v89[1]);
                v89 = hFile;
                *(hFile + 1) = 0;
              }
              j__free(v89);
            }
          }
          v227 = 0;
        }
        hFile = v222;
        if ( v222 )
        {
          if ( !InterlockedDecrement(&v222->Length) )
          {
            v90 = hFile;
            if ( hFile )
            {
              if ( *hFile )
              {
                SysFreeString(*hFile);
                v90 = hFile;
                *hFile = 0;
              }
              if ( v90[1] )
              {
                j_j__free(v90[1]);
                v90 = hFile;
                *(hFile + 1) = 0;
              }
              j__free(v90);
            }
          }
          v222 = 0;
        }
        hFile = v229;
        if ( v229 )
        {
          if ( !InterlockedDecrement(&v229->Length) )
          {
            v91 = hFile;
            if ( hFile )
            {
              if ( *hFile )
              {
                SysFreeString(*hFile);
                v91 = hFile;
                *hFile = 0;
              }
              if ( v91[1] )
              {
                j_j__free(v91[1]);
                v91 = hFile;
                *(hFile + 1) = 0;
              }
              j__free(v91);
            }
          }
          v229 = 0;
        }
        if ( !InterlockedDecrement(lpBuffer + 2) )
        {
          v92 = lpBuffer;
          if ( *lpBuffer )
          {
            SysFreeString(*lpBuffer);
            v92 = lpBuffer;
            *lpBuffer = 0;
          }
          if ( v92[1] )
          {
            j_j__free(v92[1]);
            v92 = lpBuffer;
            *(lpBuffer + 1) = 0;
          }
          j__free(v92);
        }
        if ( !InterlockedDecrement(lpWideCharStr + 2) )
        {
          v93 = lpWideCharStr;
          if ( *lpWideCharStr )
          {
            SysFreeString(*lpWideCharStr);
            v93 = lpWideCharStr;
            *lpWideCharStr = 0;
          }
          if ( v93[1] )
          {
            j_j__free(v93[1]);
            v93 = lpWideCharStr;
            *(lpWideCharStr + 1) = 0;
          }
          j__free(v93);
        }
        LOBYTE(v263) = 10;
        if ( !InterlockedDecrement((nNumberOfBytesToRead + 8)) )
        {
          if ( *nNumberOfBytesToRead )
          {
            SysFreeString(*nNumberOfBytesToRead);
            v94 = nNumberOfBytesToRead;
            *nNumberOfBytesToRead = 0;
          }
          else
          {
            v94 = nNumberOfBytesToRead;
          }
          v95 = *(v94 + 4);
          if ( v95 )
          {
            j_j__free(v95);
            v96 = nNumberOfBytesToRead;
            *(nNumberOfBytesToRead + 4) = 0;
          }
          else
          {
            v96 = nNumberOfBytesToRead;
          }
          j__free(v96);
        }
        v97 = (v50 ? *v50 : 0);
        v73 = sub_11F6640(v97, 0x80000000, 1u, 0, 3u, 0, 0);
        hFile = v73;
        if ( v73 == -1 )
        {
LABEL_533:
          v98 = operator new(0xCu);
          lpBuffer = v98;
          v254 = v98;
          LOBYTE(v263) = 27;
          if ( v98 )
          {
            v98->hKey = 0;
            v98->Length = 1;
            v99 = SysAllocString(L"\\en-us\\Gadget.xml");
            v100 = lpBuffer;
            *lpBuffer = v99;
            if ( !v99 )
              goto LABEL_9;
            v101 = v100;
          }
          else
          {
            v101 = 0;
            lpBuffer = 0;
          }
          LOBYTE(v263) = 10;
          v254 = v101;
          if ( !v101 )
            goto LABEL_9;
          LOBYTE(v263) = 28;
          v102 = CComBSTR::AppendTail(v234, &v225, &v254);
          hFile = v102;
          if ( &v252.hKey != v102 )
          {
            if ( v50 )
            {
              if ( !InterlockedDecrement(v50 + 2) )
              {
                if ( *v50 )
                {
                  SysFreeString(*v50);
                  *v50 = 0;
                }
                if ( *(v50 + 1) )
                {
                  j_j__free(*(v50 + 1));
                  *(v50 + 1) = 0;
                }
                j__free(v50);
              }
              v102 = hFile;
            }
            v50 = v102->bstr;
            v252.hKey = v50;
            if ( v50 )
              InterlockedIncrement(v50 + 2);
          }
          hFile = v225;
          if ( v225 )
          {
            if ( !InterlockedDecrement(&v225->Length) )
            {
              v103 = hFile;
              if ( hFile )
              {
                if ( *hFile )
                {
                  SysFreeString(*hFile);
                  v103 = hFile;
                  *hFile = 0;
                }
                if ( v103[1] )
                {
                  j_j__free(v103[1]);
                  v103 = hFile;
                  *(hFile + 1) = 0;
                }
                j__free(v103);
              }
            }
            v225 = 0;
          }
          LOBYTE(v263) = 10;
          if ( !InterlockedDecrement(lpBuffer + 2) )
          {
            v104 = lpBuffer;
            if ( *lpBuffer )
            {
              SysFreeString(*lpBuffer);
              v104 = lpBuffer;
              *lpBuffer = 0;
            }
            if ( v104[1] )
            {
              j_j__free(v104[1]);
              v104 = lpBuffer;
              *(lpBuffer + 1) = 0;
            }
            j__free(v104);
          }
          v105 = (v50 ? *v50 : 0);
          v73 = sub_11F6640(v105, 0x80000000, 1u, 0, 3u, 0, 0);
          hFile = v73;
          if ( v73 == -1 )
          {
            v106 = operator new(0xCu);
            lpBuffer = v106;
            v254 = v106;
            LOBYTE(v263) = 29;
            if ( v106 )
            {
              v106->hKey = 0;
              v106->Length = 1;
              v107 = SysAllocString(L"\\Gadget.xml");
              v108 = lpBuffer;
              *lpBuffer = v107;
              if ( !v107 )
                goto LABEL_9;
              v109 = v108;
            }
            else
            {
              v109 = 0;
              lpBuffer = 0;
            }
            LOBYTE(v263) = 10;
            v254 = v109;
            if ( !v109 )
              goto LABEL_9;
            LOBYTE(v263) = 30;
            v110 = CComBSTR::AppendTail(v234, &v215, &v254);
            hFile = v110;
            if ( &v252.hKey != v110 )
            {
              if ( v50 )
              {
                if ( !InterlockedDecrement(v50 + 2) )
                {
                  if ( *v50 )
                  {
                    SysFreeString(*v50);
                    *v50 = 0;
                  }
                  if ( *(v50 + 1) )
                  {
                    j_j__free(*(v50 + 1));
                    *(v50 + 1) = 0;
                  }
                  j__free(v50);
                }
                v110 = hFile;
              }
              v50 = v110->bstr;
              v252.hKey = v50;
              if ( v50 )
                InterlockedIncrement(v50 + 2);
            }
            hFile = v215;
            if ( v215 )
            {
              if ( !InterlockedDecrement(&v215->Length) )
              {
                v111 = hFile;
                if ( hFile )
                {
                  if ( *hFile )
                  {
                    SysFreeString(*hFile);
                    v111 = hFile;
                    *hFile = 0;
                  }
                  if ( v111[1] )
                  {
                    j_j__free(v111[1]);
                    v111 = hFile;
                    *(hFile + 1) = 0;
                  }
                  j__free(v111);
                }
              }
              v215 = 0;
            }
            LOBYTE(v263) = 10;
            if ( !InterlockedDecrement(lpBuffer + 2) )
            {
              v112 = lpBuffer;
              if ( *lpBuffer )
              {
                SysFreeString(*lpBuffer);
                v112 = lpBuffer;
                *lpBuffer = 0;
              }
              if ( v112[1] )
              {
                j_j__free(v112[1]);
                v112 = lpBuffer;
                *(lpBuffer + 1) = 0;
              }
              j__free(v112);
            }
            v113 = (v50 ? *v50 : 0);
            v73 = sub_11F6640(v113, 0x80000000, 1u, 0, 3u, 0, 0);
            hFile = v73;
            if ( v73 == -1 )
            {
              bstr_t::Assign(&v252, gpszTargetName);
              if ( v234[1] && !InterlockedDecrement(v234[1] + 2) )
              {
                v114 = v234[1];
                if ( *v234[1] )
                {
                  SysFreeString(*v234[1]);
                  v114 = v234[1];
                  *v234[1] = 0;
                }
                if ( v114[1] )
                {
                  j_j__free(v114[1]);
                  v114 = v234[1];
                  *(v234[1] + 1) = 0;
                }
                j__free(v114);
              }
              v234[1] = v234[0];
              if ( v234[0] )
              {
                v115 = (v234[0] + 8);
LABEL_367:
                InterlockedIncrement(v115);
                goto LABEL_368;
              }
              goto LABEL_368;
            }
          }
        }
      }
      nNumberOfBytesToRead = GetFileSize(v73, 0);
      lpBuffer = operator new[](nNumberOfBytesToRead);
      lpWideCharStr = operator new[](2 * (nNumberOfBytesToRead + 1));
      NumberOfBytesRead = 0;
      ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
      if ( NumberOfBytesRead >= 3 && *lpBuffer == -17 && *(lpBuffer + 1) == -69 && *(lpBuffer + 2) == -65 )
        break;
      if ( NumberOfBytesRead < 2 || *lpBuffer != -1 || *(lpBuffer + 1) != -2 )
      {
        v116 = MultiByteToWideChar(0, 0, lpBuffer, nNumberOfBytesToRead, lpWideCharStr, nNumberOfBytesToRead);
        goto LABEL_357;
      }
      v117 = 1;
      v118 = nNumberOfBytesToRead >> 1;
      nNumberOfBytesToRead = v118;
      if ( v118 > 1 )
      {
        v119 = lpWideCharStr;
        v120 = v118;
        v121 = lpBuffer;
        do
        {
          v122 = v121[v117];
          ++v119;
          ++v117;
          *(v119 - 1) = v122;
        }
        while ( v117 < v120 );
        v50 = v252.hKey;
        v23 = v248;
        v118 = nNumberOfBytesToRead;
      }
      lpWideCharStr[v118 - 1] = 0;
LABEL_358:
      bstr_t::Assign(&v252, lpWideCharStr);
      j_j__free(lpWideCharStr);
      j_j__free(lpBuffer);
      CloseHandle(hFile);
      if ( v234[1] && !InterlockedDecrement(v234[1] + 2) )
      {
        v123 = v234[1];
        if ( *v234[1] )
        {
          SysFreeString(*v234[1]);
          v123 = v234[1];
          *v234[1] = 0;
        }
        if ( v123[1] )
        {
          j_j__free(v123[1]);
          v123 = v234[1];
          *(v234[1] + 1) = 0;
        }
        j__free(v123);
      }
      v234[1] = v50;
      if ( v50 )
      {
        v115 = (v50 + 2);
        goto LABEL_367;
      }
LABEL_368:
      LOBYTE(v263) = 9;
      if ( v50 && !InterlockedDecrement(v50 + 2) )
      {
        if ( *v50 )
        {
          SysFreeString(*v50);
          *v50 = 0;
        }
        if ( *(v50 + 1) )
        {
          j_j__free(*(v50 + 1));
          *(v50 + 1) = 0;
        }
        j__free(v50);
      }
      v124 = v252.bstr;
      while ( 1 )
      {
        v125 = (v124 ? *v124 : 0);
        if ( wcsncmp(v125, L"<!--", 4u) )
          break;
        v126 = (v124 ? *v124 : 0);
        v127 = wcsstr(v126, L"-->");
        if ( !v127 )
          break;
        v128 = v127[3];
        hFile = v127 + 3;
        if ( iswspace(v128) )
        {
          v129 = hFile;
          do
          {
            v130 = v129[1];
            ++v129;
          }
          while ( iswspace(v130) );
          hFile = v129;
          v23 = v248;
        }
        v131 = operator new(0xCu);
        nNumberOfBytesToRead = v131;
        v254 = v131;
        LOBYTE(v263) = 31;
        if ( v131 )
        {
          v132 = hFile;
          v131->hKey = 0;
          v131->Length = 1;
          v133 = SysAllocString(v132);
          v134 = nNumberOfBytesToRead;
          *nNumberOfBytesToRead = v133;
          if ( !v133 )
            goto LABEL_9;
          v135 = v134;
        }
        else
        {
          v135 = 0;
          nNumberOfBytesToRead = 0;
        }
        LOBYTE(v263) = 9;
        if ( !v135 )
          goto LABEL_9;
        if ( v124 )
        {
          if ( !InterlockedDecrement(v124 + 2) )
          {
            if ( *v124 )
            {
              SysFreeString(*v124);
              *v124 = 0;
            }
            if ( *(v124 + 1) )
            {
              j_j__free(*(v124 + 1));
              *(v124 + 1) = 0;
            }
            j__free(v124);
          }
          v135 = nNumberOfBytesToRead;
        }
        v124 = v135;
        v252.bstr = v135;
        InterlockedIncrement((v135 + 8));
        if ( !InterlockedDecrement((nNumberOfBytesToRead + 8)) )
        {
          v136 = nNumberOfBytesToRead;
          if ( *nNumberOfBytesToRead )
          {
            SysFreeString(*nNumberOfBytesToRead);
            v136 = nNumberOfBytesToRead;
            *nNumberOfBytesToRead = 0;
          }
          if ( v136[1] )
          {
            j_j__free(v136[1]);
            v136 = nNumberOfBytesToRead;
            *(nNumberOfBytesToRead + 4) = 0;
          }
          j__free(v136);
        }
      }
      CoInitializeEx(0, 0);
      ppv = 0;
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(1);
        TlsSetValue(gdwTlsIndex, 0x200);
      }
      v137 = CoCreateInstance(&rclsid, 0, 1u, &riid, &ppv);
      v138 = Wow64EnableWow64FsRedirection;
      v254 = v137;
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(0);
        TlsSetValue(gdwTlsIndex, 0x100);
        v138 = Wow64EnableWow64FsRedirection;
        v137 = v254;
      }
      if ( !v137 )
      {
        v230 = 0;
        if ( v138 )
        {
          v138(1);
          TlsSetValue(gdwTlsIndex, 0x200);
        }
        if ( v124 )
          v139 = *v124;
        else
          v139 = 0;
        (*(*ppv + 260))(ppv, v139, &v230);
        v23 = v248;
        if ( Wow64EnableWow64FsRedirection )
        {
          Wow64EnableWow64FsRedirection(0);
          TlsSetValue(gdwTlsIndex, 0x100);
        }
        if ( v230 )
          goto LABEL_531;
        lpBuffer = 0;
        (*(*ppv + 240))(ppv, &lpBuffer);
        if ( lpBuffer )
        {
          v254 = 0;
          v241 = -1;
          hFile = -1;
          lpWideCharStr = 0;
          (*(*lpBuffer + 36))(lpBuffer, &v254);
          (*(*lpBuffer + 44))(lpBuffer, &v241);
          (*(*lpBuffer + 48))(lpBuffer, &hFile);
          (*(*lpBuffer + 40))(lpBuffer, &lpWideCharStr);
          (*(*lpBuffer + 8))(lpBuffer);
        }
        if ( v230 )
        {
LABEL_531:
          v140 = operator new(0xCu);
          lpBuffer = v140;
          v254 = v140;
          LOBYTE(v263) = 32;
          if ( v140 )
          {
            v140->hKey = 0;
            v140->Length = 1;
            v141 = AsciiToUTF("gadget");
            v142 = lpBuffer;
            *lpBuffer = v141;
          }
          else
          {
            v142 = 0;
            lpBuffer = 0;
          }
          LOBYTE(v263) = 9;
          v254 = v142;
          if ( !v142 )
            goto LABEL_9;
          v143 = v142->bstr;
          LOBYTE(v263) = 33;
          v144 = (*(*ppv + 148))(ppv, v143, &v243);
          LOBYTE(v263) = 9;
          v258 = v144 == 0;
          v145 = InterlockedDecrement(lpBuffer + 2);
          v124 = v252.bstr;
          if ( !v145 )
          {
            v146 = lpBuffer;
            if ( *lpBuffer )
            {
              SysFreeString(*lpBuffer);
              v146 = lpBuffer;
              *lpBuffer = 0;
            }
            if ( v146[1] )
            {
              j_j__free(v146[1]);
              v146 = lpBuffer;
              *(lpBuffer + 1) = 0;
            }
            j__free(v146);
          }
          if ( v258 )
          {
            v147 = operator new(0xCu);
            lpBuffer = v147;
            v254 = v147;
            LOBYTE(v263) = 34;
            if ( v147 )
            {
              v147->hKey = 0;
              v147->Length = 1;
              v148 = AsciiToUTF("name");
              v149 = lpBuffer;
              *lpBuffer = v148;
            }
            else
            {
              v149 = 0;
              lpBuffer = 0;
            }
            LOBYTE(v263) = 9;
            v254 = v149;
            if ( !v149 )
              goto LABEL_9;
            v150 = v149->bstr;
            LOBYTE(v263) = 35;
            v151 = (*(*v243 + 148))(v243, v150, &v252.Length);
            LOBYTE(v263) = 9;
            v258 = v151 == 0;
            if ( !InterlockedDecrement(lpBuffer + 2) )
            {
              v152 = lpBuffer;
              if ( *lpBuffer )
              {
                SysFreeString(*lpBuffer);
                v152 = lpBuffer;
                *lpBuffer = 0;
              }
              if ( v152[1] )
              {
                j_j__free(v152[1]);
                v152 = lpBuffer;
                *(lpBuffer + 1) = 0;
              }
              j__free(v152);
            }
            if ( v258 )
            {
              sub_120B0D0(&v234[2], 0);
              (*(*v252.Length + 104))(v252.Length, v234[2]);
              (*(*v252.Length + 8))(v252.Length);
            }
            v153 = *CComBSTR::AssignA(&v210, "description");
            LOBYTE(v263) = 36;
            if ( v153 )
              v154 = *v153;
            else
              v154 = 0;
            v155 = (*(*v243 + 148))(v243, v154, &v252.Length);
            LOBYTE(v263) = 9;
            v258 = v155 == 0;
            bstr_t::Data_t::Free(&v210);
            if ( v258 )
            {
              VariantInit(&pvarg);
              LOBYTE(v263) = 37;
              (*(*v252.Length + 32))(v252.Length, &pvarg);
              sub_120B0D0(&v235, 0);
              (*(*v252.Length + 104))(v252.Length, v235);
              (*(*v252.Length + 8))(v252.Length);
              LOBYTE(v263) = 9;
              VariantClear(&pvarg);
            }
            v156 = *CComBSTR::AssignA(&v202, "author");
            LOBYTE(v263) = 38;
            if ( v156 )
              v157 = *v156;
            else
              v157 = 0;
            v158 = (*(*v243 + 148))(v243, v157, &v252.Length);
            LOBYTE(v263) = 9;
            v258 = v158 == 0;
            bstr_t::Data_t::Free(&v202);
            if ( v258 )
            {
              if ( !(*(*v252.Length + 68))(v252.Length, &v221) )
              {
                v159 = *CComBSTR::AssignA(&v200, "name");
                LOBYTE(v263) = 39;
                if ( v159 )
                  v160 = *v159;
                else
                  v160 = 0;
                v161 = (*(*v221 + 28))(v221, v160, &v217);
                LOBYTE(v263) = 9;
                v258 = v161 == 0;
                bstr_t::Data_t::Free(&v200);
                if ( v258 )
                {
                  sub_120B0D0(&v234[3], 0);
                  (*(*v217 + 104))(v217, v234[3]);
                  (*(*v217 + 8))(v217);
                }
                (*(*v221 + 8))(v221);
              }
              (*(*v252.Length + 8))(v252.Length);
            }
            v162 = *CComBSTR::AssignA(&v211, "version");
            LOBYTE(v263) = 40;
            if ( v162 )
              v163 = *v162;
            else
              v163 = 0;
            v164 = (*(*v243 + 148))(v243, v163, &v252.Length);
            LOBYTE(v263) = 9;
            v258 = v164 == 0;
            bstr_t::Data_t::Free(&v211);
            v23 = v248;
            if ( v258 )
            {
              sub_120B0D0(&v236, 0);
              (*(*v252.Length + 104))(v252.Length, v236);
              (*(*v252.Length + 8))(v252.Length);
            }
            v165 = *CComBSTR::AssignA(&v205, "icons");
            LOBYTE(v263) = 41;
            if ( v165 )
              v166 = *v165;
            else
              v166 = 0;
            v167 = (*(*v243 + 148))(v243, v166, &v252.Length);
            LOBYTE(v263) = 9;
            v258 = v167 == 0;
            bstr_t::Data_t::Free(&v205);
            v124 = v252.bstr;
            if ( v258 )
            {
              if ( !(*(*v252.Length + 48))(v252.Length, &v242) )
              {
                v254 = 4096;
                if ( !(*(*v242 + 36))(v242, &ppComBSTR1) )
                {
                  v168 = v254;
                  do
                  {
                    if ( !(*(ppComBSTR1->bstr + 17))(ppComBSTR1, &v251) )
                    {
                      VariantInit(&pvarSrc);
                      LOBYTE(v263) = 42;
                      v169 = *CComBSTR::AssignA(&v209, "height");
                      LOBYTE(v263) = 43;
                      if ( v169 )
                        v170 = *v169;
                      else
                        v170 = 0;
                      v171 = (*(*v251 + 28))(v251, v170, &v249);
                      LOBYTE(v263) = 42;
                      v258 = v171 == 0;
                      bstr_t::Data_t::Free(&v209);
                      if ( v258 )
                      {
                        (*(*v249 + 32))(v249, &pvarSrc);
                        v172 = *sub_120AD20(&v199, &pvarSrc);
                        if ( v172 )
                          v173 = *v172;
                        else
                          v173 = 0;
                        v238 = _wtoi(v173);
                        bstr_t::Data_t::Free(&v199);
                        (*(*v249 + 8))(v249);
                      }
                      v174 = *CComBSTR::AssignA(&v207, "width");
                      LOBYTE(v263) = 44;
                      if ( v174 )
                        v175 = *v174;
                      else
                        v175 = 0;
                      v176 = (*(*v251 + 28))(v251, v175, &v249);
                      LOBYTE(v263) = 42;
                      v258 = v176 == 0;
                      bstr_t::Data_t::Free(&v207);
                      v177 = v238;
                      if ( v258 )
                      {
                        (*(*v249 + 32))(v249, &pvarSrc);
                        v178 = *sub_120AD20(&v206, &pvarSrc);
                        if ( v178 )
                          v179 = *v178;
                        else
                          v179 = 0;
                        ppComBSTR2 = _wtoi(v179);
                        bstr_t::Data_t::Free(&v206);
                        (*(*v249 + 8))(v249);
                      }
                      if ( v177 >= 16 && ppComBSTR2 >= 16 && ppComBSTR2 + v177 < v168 )
                      {
                        v180 = *CComBSTR::AssignA(&v204, "src");
                        LOBYTE(v263) = 45;
                        v181 = v180 ? *v180 : 0;
                        v182 = (*(*v251 + 28))(v251, v181, &v249);
                        LOBYTE(v263) = 42;
                        v258 = v182 == 0;
                        bstr_t::Data_t::Free(&v204);
                        v183 = v238;
                        if ( v258 )
                        {
                          (*(*v249 + 32))(v249, &pvarSrc);
                          sub_120AD20(&v245, &pvarSrc);
                          LOBYTE(v263) = 46;
                          if ( v245 )
                            v184 = v245->bstr;
                          else
                            v184 = 0;
                          v185 = wcschr(v184, 0x2Fu);
                          if ( v185 )
                          {
                            do
                            {
                              *v185 = 92;
                              v185 = wcschr(v185 + 1, 0x2Fu);
                            }
                            while ( v185 );
                            v183 = v238;
                          }
                          bstr_t::EqualAssign(&v213, L"\\");
                          LOBYTE(v263) = 47;
                          v186 = CComBSTR::AppendTail(v234, &v220, &v213);
                          LOBYTE(v263) = 48;
                          v254 = CComBSTR::AppendTail(v186, &v201, &v245);
                          if ( &ppComBSTR != v254 )
                          {
                            bstr_t::Data_t::Free(&ppComBSTR);
                            v187 = v254->bstr;
                            ppComBSTR = v187;
                            if ( v187 )
                              InterlockedIncrement(&v187->Length);
                          }
                          bstr_t::Data_t::Free(&v201);
                          bstr_t::Data_t::Free(&v220);
                          LOBYTE(v263) = 46;
                          bstr_t::Data_t::Free(&v213);
                          v168 = (ppComBSTR2 + v183);
                          (*(*v249 + 8))(v249);
                          LOBYTE(v263) = 42;
                          bstr_t::Data_t::Free(&v245);
                        }
                      }
                      (*(*v251 + 8))(v251);
                      LOBYTE(v263) = 9;
                      VariantClear(&pvarSrc);
                    }
                    (*(ppComBSTR1->bstr + 2))(ppComBSTR1);
                  }
                  while ( !(*(*v242 + 36))(v242, &ppComBSTR1) );
                  v124 = v252.bstr;
                  v23 = v248;
                }
                (*(*v242 + 8))(v242);
              }
              (*(*v252.Length + 8))(v252.Length);
            }
            (*(*v243 + 8))(v243);
          }
        }
      }
      v254 = *v231;
      v188 = sub_120AC50(v254, v254->hKey, &v232);
      v189 = v231[1];
      if ( (97612892 - v189) < 1 )
        goto LABEL_10;
      v231[1] = v189 + 1;
      v254->hKey = v188;
      **(v188 + 1) = v188;
      if ( ppv )
        (*(*ppv + 8))(ppv);
      if ( v124 && !InterlockedDecrement(v124 + 2) )
      {
        if ( *v124 )
        {
          SysFreeString(*v124);
          *v124 = 0;
        }
        if ( *(v124 + 1) )
        {
          j_j__free(*(v124 + 1));
          *(v124 + 1) = 0;
        }
        j__free(v124);
      }
      LOBYTE(v263) = 0;
      sub_120AE80(&v232);
      v23 = *v23;
      v248 = v23;
      if ( v23 == v246 )
        goto LABEL_526;
    }
    v116 = MultiByteToWideChar(0xFDE9u, 0, lpBuffer + 3, nNumberOfBytesToRead - 3, lpWideCharStr, nNumberOfBytesToRead);
LABEL_357:
    lpWideCharStr[v116] = 0;
    goto LABEL_358;
  }
LABEL_526:
  v190 = v246;
  v191 = *v246;
  *v190 = v190;
  v190[1] = v190;
  if ( v191 != v190 )
  {
    do
    {
      v192 = *v191;
      j__free(v191);
      v191 = v192;
    }
    while ( v192 != v190 );
  }
  j__free(v190);
  return 1;
}
// 12B28CC: using guessed type __int128 xmmword_12B28CC;
// 12B28DC: using guessed type double dbl_12B28DC;
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);
// 12E4C64: using guessed type int (__stdcall *IsWow64Process)(_DWORD, _DWORD);
// 12E4C68: using guessed type int dword_12E4C68;
// 12E4C6C: using guessed type int (__stdcall *GetSystemDefaultLocaleName)(_DWORD, _DWORD);
// 12E4C70: using guessed type int (__stdcall *GetUserDefaultLocaleName)(_DWORD, _DWORD);

//----- (0120D790) --------------------------------------------------------
void *__cdecl sub_120D790(HWND a1)
{
  HWND v1; // ebx
  HMODULE v2; // eax
  WCHAR **v3; // esi
  WCHAR *v4; // eax
  WCHAR *v5; // eax
  void ***v6; // eax
  void *v7; // edi
  unsigned __int8 *i; // esi
  OLECHAR **v9; // eax
  OLECHAR *v10; // eax
  _WORD *v11; // eax
  WCHAR **v12; // eax
  WCHAR *v13; // eax
  WCHAR **v14; // eax
  WCHAR *v15; // eax
  WCHAR *v16; // eax
  WCHAR *v17; // eax
  WCHAR **v18; // eax
  WCHAR *v19; // eax
  char v20; // bl
  WCHAR *v21; // eax
  WCHAR *v22; // eax
  int *v23; // eax
  int v24; // ebx
  int v25; // eax
  HBITMAP v26; // ST40_4
  _IMAGELIST *v27; // eax
  HBITMAP v28; // ST40_4
  _IMAGELIST *v29; // eax
  _DWORD *v30; // eax
  OLECHAR *v31; // eax
  HICON v32; // ST44_4
  _IMAGELIST *v33; // eax
  _DWORD *v34; // eax
  OLECHAR *v35; // eax
  HICON v36; // ST44_4
  _IMAGELIST *v37; // eax
  OLECHAR **v38; // eax
  OLECHAR *v39; // eax
  HBITMAP v40; // eax
  HBITMAP v41; // eax
  int *v42; // eax
  int v43; // eax
  WCHAR **v44; // eax
  WCHAR *v45; // eax
  WCHAR **v46; // eax
  WCHAR *v47; // eax
  WCHAR **v48; // eax
  WCHAR *v49; // eax
  WCHAR **v50; // eax
  WCHAR *v51; // eax
  WCHAR **v52; // eax
  WCHAR *v53; // eax
  WCHAR **v54; // eax
  WCHAR *v55; // eax
  int *v56; // eax
  int v57; // eax
  int v58; // ST40_4
  int v59; // ST34_4
  int v60; // ST08_4
  void **v61; // ebx
  void **v62; // esi
  int v64; // [esp+10h] [ebp-344h]
  void *v65; // [esp+14h] [ebp-340h]
  void *v66; // [esp+18h] [ebp-33Ch]
  void *v67; // [esp+1Ch] [ebp-338h]
  void *v68; // [esp+20h] [ebp-334h]
  void *v69; // [esp+24h] [ebp-330h]
  void *v70; // [esp+28h] [ebp-32Ch]
  void *v71; // [esp+2Ch] [ebp-328h]
  void *v72; // [esp+30h] [ebp-324h]
  int v73; // [esp+34h] [ebp-320h]
  void *v74; // [esp+38h] [ebp-31Ch]
  void *v75; // [esp+3Ch] [ebp-318h]
  void *v76; // [esp+40h] [ebp-314h]
  void *v77; // [esp+44h] [ebp-310h]
  void *v78; // [esp+48h] [ebp-30Ch]
  void *v79; // [esp+4Ch] [ebp-308h]
  void *v80; // [esp+50h] [ebp-304h]
  void *v81; // [esp+54h] [ebp-300h]
  void *v82; // [esp+58h] [ebp-2FCh]
  void *v83; // [esp+5Ch] [ebp-2F8h]
  int v84; // [esp+60h] [ebp-2F4h]
  void *v85; // [esp+64h] [ebp-2F0h]
  void *v86; // [esp+68h] [ebp-2ECh]
  void *v87; // [esp+6Ch] [ebp-2E8h]
  void *v88; // [esp+70h] [ebp-2E4h]
  void *v89; // [esp+74h] [ebp-2E0h]
  void *v90; // [esp+78h] [ebp-2DCh]
  void *v91; // [esp+7Ch] [ebp-2D8h]
  void *v92; // [esp+80h] [ebp-2D4h]
  HWND hWnd; // [esp+84h] [ebp-2D0h]
  HBITMAP hbmImage; // [esp+88h] [ebp-2CCh]
  HBITMAP v95; // [esp+8Ch] [ebp-2C8h]
  HICON hicon; // [esp+90h] [ebp-2C4h]
  char v97; // [esp+94h] [ebp-2C0h]
  int v98; // [esp+350h] [ebp-4h]

  v1 = a1;
  hWnd = a1;
  sub_120E210(&v85);
  v98 = 0;
  if ( !SHCreateItemFromParsingName )
  {
    v2 = LoadLibraryW(L"Shell32.dll");
    SHCreateItemFromParsingName = GetProcAddress(v2, "SHCreateItemFromParsingName");
  }
  v87 = _wcsdup(gpszTargetName);
  v88 = _wcsdup(gpszTargetName);
  v86 = _wcsdup(gpszTargetName);
  v91 = _wcsdup(gpszTargetName);
  v92 = _wcsdup(gpszTargetName);
  hbmImage = _wcsdup(gpszTargetName);
  v3 = v85;
  if ( !v85 || (v4 = *v85) == 0 )
    v4 = gpszTargetName;
  v95 = _wcsdup(v4);
  if ( !v3 || (v5 = *v3) == 0 )
    v5 = gpszTargetName;
  v90 = _wcsdup(v5);
  LOBYTE(v98) = 8;
  v89 = sub_11F3FF0(a1, 7, 0xFFFFFFFF, 7, &v90, &v95, &hbmImage);
  free(v90);
  free(v95);
  free(hbmImage);
  free(v92);
  free(v91);
  free(v86);
  free(v88);
  LOBYTE(v98) = 0;
  free(v87);
  v84 = 0;
  v83 = sub_120E320(0, 0);
  LOBYTE(v98) = 9;
  sub_120B1A0(&v85, &v83);
  v6 = v83;
  v7 = v85;
  for ( i = *v83; i != v83; v6 = v83 )
  {
    v9 = *(i + 4);
    if ( v9 )
    {
      v10 = *v9;
      if ( v10 )
      {
        if ( SysStringLen(v10) )
        {
          v11 = malloc(2u);
          v90 = v11;
          *v11 = 0;
          v12 = *(i + 7);
          if ( !v12 || (v13 = *v12) == 0 )
            v13 = gpszTargetName;
          v65 = _wcsdup(v13);
          v14 = *(i + 5);
          if ( !v14 || (v15 = *v14) == 0 )
            v15 = gpszTargetName;
          v79 = _wcsdup(v15);
          if ( !v7 || (v16 = *v7) == 0 )
            v16 = gpszTargetName;
          v86 = _wcsdup(v16);
          if ( !v7 || (v17 = *v7) == 0 )
            v17 = gpszTargetName;
          v88 = _wcsdup(v17);
          v18 = *(i + 6);
          if ( !v18 || (v19 = *v18) == 0 )
            v19 = gpszTargetName;
          v87 = _wcsdup(v19);
          LOBYTE(v98) = 15;
          v20 = sub_11F3D40(v1, &v87, &v88, &v86, &v79, &v65, &v90, &v64);
          free(v87);
          free(v88);
          free(v86);
          free(v79);
          LOBYTE(v98) = 10;
          free(v65);
          if ( v20 )
          {
            if ( v89 == -1 )
            {
              v69 = _wcsdup(gpszTargetName);
              v75 = _wcsdup(gpszTargetName);
              v67 = _wcsdup(gpszTargetName);
              v77 = _wcsdup(gpszTargetName);
              v71 = _wcsdup(gpszTargetName);
              v82 = _wcsdup(gpszTargetName);
              if ( !v7 || (v21 = *v7) == 0 )
                v21 = gpszTargetName;
              v68 = _wcsdup(v21);
              if ( !v7 || (v22 = *v7) == 0 )
                v22 = gpszTargetName;
              v66 = _wcsdup(v22);
              LOBYTE(v98) = 23;
              v89 = sub_11F3FF0(hWnd, 7, 0xFFFFFFFF, 7, &v66, &v68, &v82);
              free(v66);
              free(v68);
              free(v82);
              free(v71);
              free(v77);
              free(v67);
              free(v75);
              LOBYTE(v98) = 10;
              free(v69);
            }
            v23 = *(i + 10);
            v24 = -1;
            v92 = -1;
            if ( v23 )
              v25 = *v23;
            else
              v25 = 0;
            if ( SHCreateItemFromParsingName(v25, 0, &CLSID_IShellItem2, &v73) >= 0 )
            {
              v91 = 0;
              if ( (**v73)(v73, &CLSID_IShellItemImageFactory, &v91) >= 0 )
              {
                hbmImage = 0;
                v95 = 0;
                (*(*v91 + 12))(v91, 16, 16, 0, &hbmImage);
                (*(*v91 + 12))(v91, 32, 32, 0, &v95);
                if ( hbmImage )
                {
                  v26 = hbmImage;
                  v27 = SendMessageW(hWnd, 0x1002u, 1u, 0);
                  v24 = ImageList_Add(v27, v26, 0);
                  DeleteObject(hbmImage);
                }
                if ( v95 )
                {
                  v28 = v95;
                  v29 = SendMessageW(hWnd, 0x1002u, 0, 0);
                  v92 = ImageList_Add(v29, v28, 0);
                  DeleteObject(v95);
                }
                (*(*v91 + 8))(v91);
              }
              (*(*v73 + 8))(v73);
            }
            if ( v24 < 0 )
            {
              hicon = 0;
              memset(&v97, 0, 0x2B0u);
              v30 = *(i + 10);
              v31 = (v30 ? *v30 : 0);
              if ( sub_12010C0(v31, 0, &hicon, 0x2B4u, 0x101u) )
              {
                v32 = hicon;
                v33 = SendMessageW(hWnd, 0x1002u, 1u, 0);
                v24 = ImageList_ReplaceIcon(v33, -1, v32);
                DestroyIcon(hicon);
              }
            }
            if ( v92 < 0 )
            {
              hicon = 0;
              memset(&v97, 0, 0x2B0u);
              v34 = *(i + 10);
              v35 = (v34 ? *v34 : 0);
              if ( sub_12010C0(v35, 0, &hicon, 0x2B4u, 0x100u) )
              {
                v36 = hicon;
                v37 = SendMessageW(hWnd, 0x1002u, 0, 0);
                v92 = ImageList_ReplaceIcon(v37, -1, v36);
                DestroyIcon(hicon);
              }
            }
            v38 = *(i + 10);
            if ( v38 )
            {
              v39 = *v38;
              if ( v39 )
              {
                if ( SysStringLen(v39) && v24 < 0 )
                {
                  v40 = malloc(2u);
                  hbmImage = v40;
                  *v40 = 0;
                  v41 = malloc(2u);
                  v95 = v41;
                  *v41 = 0;
                  v42 = *(i + 10);
                  LOBYTE(v98) = 25;
                  if ( v42 )
                    v43 = *v42;
                  v24 = sub_11F4ED0();
                  free(v95);
                  free(hbmImage);
                }
              }
            }
            v70 = _wcsdup(gpszTargetName);
            v44 = *(i + 4);
            if ( !v44 || (v45 = *v44) == 0 )
              v45 = gpszTargetName;
            v72 = _wcsdup(v45);
            v46 = *(i + 8);
            if ( !v46 || (v47 = *v46) == 0 )
              v47 = gpszTargetName;
            v74 = _wcsdup(v47);
            v48 = *(i + 7);
            if ( !v48 || (v49 = *v48) == 0 )
              v49 = gpszTargetName;
            v76 = _wcsdup(v49);
            v50 = *(i + 5);
            if ( !v50 || (v51 = *v50) == 0 )
              v51 = gpszTargetName;
            v78 = _wcsdup(v51);
            v52 = *(i + 4);
            if ( !v52 || (v53 = *v52) == 0 )
              v53 = gpszTargetName;
            v80 = _wcsdup(v53);
            v54 = *(i + 6);
            if ( !v54 || (v55 = *v54) == 0 )
              v55 = gpszTargetName;
            v81 = _wcsdup(v55);
            v56 = *(i + 9);
            LOBYTE(v98) = 32;
            if ( v56 )
              v57 = *v56;
            v58 = *(i + 2);
            v59 = i[12];
            v60 = v24;
            v1 = hWnd;
            sub_11F3FF0(hWnd, v60, v89, 15, &v81, &v80, &v78);
            free(v81);
            free(v80);
            free(v78);
            free(v76);
            free(v74);
            free(v72);
            free(v70);
          }
          else
          {
            v1 = hWnd;
          }
          LOBYTE(v98) = 9;
          free(v90);
        }
      }
    }
    i = *i;
  }
  v61 = *v6;
  *v6 = v6;
  v6[1] = v6;
  if ( v61 != v6 )
  {
    do
    {
      v62 = *v61;
      sub_120AE80(v61 + 2);
      j__free(v61);
      v6 = v83;
      v61 = v62;
    }
    while ( v62 != v83 );
  }
  j__free(v6);
  if ( v7 && !InterlockedDecrement(v7 + 2) )
  {
    if ( *v7 )
    {
      SysFreeString(*v7);
      *v7 = 0;
    }
    if ( *(v7 + 1) )
    {
      j_j__free(*(v7 + 1));
      *(v7 + 1) = 0;
    }
    j__free(v7);
  }
  return v89;
}
// 12B2A90: using guessed type GUID CLSID_IShellItem2;
// 12C7B6C: using guessed type GUID CLSID_IShellItemImageFactory;
// 12E4C74: using guessed type int (__stdcall *SHCreateItemFromParsingName)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0120E1B0) --------------------------------------------------------
BSTR **__cdecl sub_120E1B0(BSTR **a1, int a2)
{
  wchar_t Dest; // [esp+8h] [ebp-20Ch]

  _swprintf(&Dest, L"Section %d", a2);
  bstr_t::EqualAssign(a1, &Dest);
  return a1;
}

//----- (0120E210) --------------------------------------------------------
BSTR **__cdecl sub_120E210(BSTR **a1)
{
  FARPROC v1; // eax
  HMODULE v2; // eax
  __int16 *v3; // ecx
  int v4; // edx
  __int16 v5; // ax
  _WORD *v6; // edi
  __int16 v7; // ax
  _WORD *v8; // edi
  __int16 v9; // ax
  int v11; // [esp+Ch] [ebp-210h]
  OLECHAR psz; // [esp+10h] [ebp-20Ch]
  char v13; // [esp+12h] [ebp-20Ah]

  psz = 0;
  v11 = 0;
  memset(&v13, 0, 0x206u);
  if ( gpSysMenuData )
  {
    v3 = gpSysMenuData->SystemWinDirectory;
    v4 = &psz - gpSysMenuData->SystemWinDirectory;
    do
    {
      v5 = *v3;
      ++v3;
      *(v3 + v4 - 2) = v5;
    }
    while ( v5 );
    v6 = (&v11 + 2);
    do
    {
      v7 = v6[1];
      ++v6;
    }
    while ( v7 );
    qmemcpy(v6, L"\\AppData\\Local", 0x1Eu);
  }
  else
  {
    v1 = dword_12E4C60;
    if ( !dword_12E4C60 )
    {
      v2 = LoadLibraryW(L"shell32.dll");
      v1 = GetProcAddress(v2, "SHGetFolderPathW");
      dword_12E4C60 = v1;
    }
    (v1)(0, 28, 0, 0, &psz);
  }
  v8 = (&v11 + 2);
  do
  {
    v9 = v8[1];
    ++v8;
  }
  while ( v9 );
  qmemcpy(v8, L"\\Microsoft\\Windows Sidebar\\Settings.ini", 0x50u);
  bstr_t::EqualAssign(a1, &psz);
  return a1;
}
// 12B2848: using guessed type wchar_t aAppdataLocal[15];
// 12B2868: using guessed type wchar_t aMicrosoftWindo[40];
// 12E4C60: using guessed type int dword_12E4C60;

//----- (0120E320) --------------------------------------------------------
_DWORD *__stdcall sub_120E320(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx

  result = operator new(0x2Cu);
  if ( !result )
    std::bad_alloc::bad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
  }
  else
  {
    v3 = result;
    v4 = result;
  }
  *result = v3;
  if ( result != -4 )
    result[1] = v4;
  return result;
}

//----- (0120E360) --------------------------------------------------------
void __thiscall sub_120E360(_DWORD *this)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // esi
  _DWORD *v3; // edi

  v1 = this;
  v2 = **this;
  **this = *this;
  *(*this + 4) = *this;
  this[1] = 0;
  if ( v2 != *this )
  {
    do
    {
      v3 = *v2;
      sub_120AE80(v2 + 2);
      j__free(v2);
      v2 = v3;
    }
    while ( v3 != *v1 );
  }
}

//----- (0120E3A0) --------------------------------------------------------
void *__cdecl sub_120E3A0(int a1, void *a2, wchar_t *a3, void *a4, char a5)
{
  int v5; // edi
  wchar_t *v6; // ebx
  WCHAR *v7; // eax
  WCHAR *v8; // eax
  OLECHAR **v9; // eax
  HANDLE v10; // esi
  unsigned __int16 *v11; // esi
  wchar_t *v12; // edx
  wchar_t v13; // cx
  wchar_t *v14; // eax
  wchar_t **v15; // eax
  unsigned __int16 *v16; // edi
  _WORD *v17; // eax
  void *v18; // edi
  const wchar_t **v19; // eax
  wchar_t *v20; // edi
  wchar_t *v21; // eax
  wchar_t *v22; // edi
  const wchar_t **v23; // eax
  WCHAR *v24; // ecx
  WCHAR *v25; // eax
  WCHAR *v26; // eax
  void *v27; // edi
  const wchar_t **v28; // eax
  void *v29; // edi
  WCHAR *v30; // ecx
  WCHAR *v31; // eax
  WCHAR *v32; // eax
  HANDLE v33; // esi
  int v35; // [esp+10h] [ebp-334h]
  int v36; // [esp+14h] [ebp-330h]
  int v37; // [esp+18h] [ebp-32Ch]
  int v38; // [esp+1Ch] [ebp-328h]
  void *v39; // [esp+20h] [ebp-324h]
  unsigned __int16 *v40; // [esp+24h] [ebp-320h]
  wchar_t *v41; // [esp+28h] [ebp-31Ch]
  int v42; // [esp+2Ch] [ebp-318h]
  int v43; // [esp+30h] [ebp-314h]
  int v44; // [esp+34h] [ebp-310h]
  int v45; // [esp+38h] [ebp-30Ch]
  void *v46; // [esp+3Ch] [ebp-308h]
  HANDLE hFindFile; // [esp+40h] [ebp-304h]
  void *v48; // [esp+44h] [ebp-300h]
  void *v49; // [esp+48h] [ebp-2FCh]
  void *v50; // [esp+4Ch] [ebp-2F8h]
  void *v51; // [esp+50h] [ebp-2F4h]
  void *v52; // [esp+54h] [ebp-2F0h]
  void *v53; // [esp+58h] [ebp-2ECh]
  void *v54; // [esp+5Ch] [ebp-2E8h]
  void *v55; // [esp+60h] [ebp-2E4h]
  void *v56; // [esp+64h] [ebp-2E0h]
  void *v57; // [esp+68h] [ebp-2DCh]
  void *v58; // [esp+6Ch] [ebp-2D8h]
  void *v59; // [esp+70h] [ebp-2D4h]
  void *v60; // [esp+74h] [ebp-2D0h]
  void *v61; // [esp+78h] [ebp-2CCh]
  void *v62; // [esp+7Ch] [ebp-2C8h]
  void *v63; // [esp+80h] [ebp-2C4h]
  void *v64; // [esp+84h] [ebp-2C0h]
  void *v65; // [esp+88h] [ebp-2BCh]
  void *v66; // [esp+8Ch] [ebp-2B8h]
  void *v67; // [esp+90h] [ebp-2B4h]
  void *v68; // [esp+94h] [ebp-2B0h]
  void *v69; // [esp+98h] [ebp-2ACh]
  int v70; // [esp+9Ch] [ebp-2A8h]
  int v71; // [esp+A0h] [ebp-2A4h]
  void *v72; // [esp+A4h] [ebp-2A0h]
  void *v73; // [esp+A8h] [ebp-29Ch]
  void *v74; // [esp+ACh] [ebp-298h]
  void *v75; // [esp+B0h] [ebp-294h]
  void *v76; // [esp+B4h] [ebp-290h]
  void *v77; // [esp+B8h] [ebp-28Ch]
  void *v78; // [esp+BCh] [ebp-288h]
  wchar_t *v79; // [esp+C0h] [ebp-284h]
  void *v80; // [esp+C4h] [ebp-280h]
  void *v81; // [esp+C8h] [ebp-27Ch]
  void *v82; // [esp+CCh] [ebp-278h]
  int v83; // [esp+D0h] [ebp-274h]
  void *v84; // [esp+D4h] [ebp-270h]
  void *v85; // [esp+D8h] [ebp-26Ch]
  wchar_t *v86; // [esp+DCh] [ebp-268h]
  char v87; // [esp+E3h] [ebp-261h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+E4h] [ebp-260h]
  int v89; // [esp+340h] [ebp-4h]

  v5 = a1;
  v83 = a1;
  v79 = a3;
  v71 = 0;
  v89 = 0;
  v80 = malloc(2u);
  *v80 = 0;
  v78 = malloc(2u);
  *v78 = 0;
  v6 = malloc(2u);
  v41 = v6;
  *v6 = 0;
  v85 = malloc(2u);
  *v85 = 0;
  v81 = malloc(2u);
  *v81 = 0;
  v74 = malloc(2u);
  *v74 = 0;
  if ( a2 == -1 && a5 )
  {
    v84 = _wcsdup(gpszTargetName);
    v82 = _wcsdup(gpszTargetName);
    v76 = _wcsdup(gpszTargetName);
    v77 = _wcsdup(gpszTargetName);
    v75 = _wcsdup(gpszTargetName);
    v73 = _wcsdup(gpszTargetName);
    v7 = gpszTargetName;
    if ( a3 )
      v7 = a3;
    v72 = _wcsdup(v7);
    v8 = gpszTargetName;
    if ( a3 )
      v8 = a3;
    v86 = _wcsdup(v8);
    LOBYTE(v89) = 14;
    sub_11F3FF0(a1, 2, 0xFFFFFFFF, 0, &v86, &v72, &v73);
    free(v86);
    free(v72);
    free(v73);
    free(v75);
    free(v77);
    free(v76);
    free(v82);
    free(v84);
  }
  sub_11F2300(&a4, L"\\", 0x7FFFFFFF, 0);
  v9 = sub_11F22B0(&v50, &a4, "*");
  LOBYTE(v89) = 15;
  v10 = sub_1200FC0(*v9, &FindFileData);
  LOBYTE(v89) = 6;
  hFindFile = v10;
  free(v50);
  if ( v10 != -1 )
  {
    do
    {
      v11 = malloc(2u);
      v40 = v11;
      *v11 = 0;
      if ( FindFileData.cFileName[0] != 46 && _wcsicmp(FindFileData.cFileName, L"AutorunsDisabled") )
      {
        sub_11F22B0(&v86, &a4, FindFileData.cFileName);
        v12 = v86;
        LOBYTE(v89) = 17;
        v84 = v86 + 1;
        do
        {
          v13 = *v12;
          ++v12;
        }
        while ( v13 );
        if ( ((v12 - v84) >> 1) < 4 )
          goto LABEL_54;
        v14 = wcschr(v86, 0);
        if ( _wcsicmp(v14 - 4, L".lnk")
          || (v15 = sub_11F4FB0(&v48, v5, v86),
              v71 |= 1u,
              v16 = v11,
              v11 = _wcsdup(*v15),
              v40 = v11,
              free(v16),
              v87 = 1,
              !wcslen(v11)) )
        {
LABEL_54:
          v87 = 0;
        }
        if ( v71 & 1 )
        {
          v71 &= 0xFFFFFFFE;
          free(v48);
        }
        v17 = malloc(2u);
        if ( v87 )
        {
          v82 = v17;
          v84 = v17;
          *v17 = 0;
          v42 = malloc(2u);
          *v42 = 0;
          v43 = 0;
          v44 = 0;
          v45 = 0;
          LOBYTE(v89) = 19;
          sub_11F6CC0(v11, &v42);
          v18 = v81;
          v81 = _wcsdup(v86);
          free(v18);
          v19 = sub_11F4EE0(&v46, v83, &v42, 0);
          v20 = v6;
          v6 = _wcsdup(*v19);
          v41 = v6;
          free(v20);
          free(v46);
          if ( wcsrchr(v6, 0x5Cu) )
          {
            v21 = wcsrchr(v6, 0x5Cu);
            v22 = _wcsdup(v21 + 1);
            v84 = v22;
            free(v82);
          }
          else
          {
            v22 = _wcsdup(v6);
            v84 = v22;
            free(v82);
          }
          v23 = sub_11F4EE0(&v39, v83, &v42, 0);
          v82 = v85;
          v85 = _wcsdup(*v23);
          free(v82);
          free(v39);
          v82 = sub_11F4ED0();
          v24 = gpszTargetName;
          if ( v79 )
            v24 = v79;
          v77 = _wcsdup(v24);
          v76 = _wcsdup(FindFileData.cFileName);
          LOBYTE(v89) = 21;
          v87 = sub_11F3D40(v83, &v76, &v77, &v86, &v85, &v80, &v74, &v70);
          free(v76);
          LOBYTE(v89) = 19;
          free(v77);
          if ( v87 )
          {
            if ( a2 != -1 )
              goto LABEL_55;
            if ( sub_11F63B0(v22) )
            {
              v57 = _wcsdup(gpszTargetName);
              v66 = _wcsdup(gpszTargetName);
              v59 = _wcsdup(gpszTargetName);
              v60 = _wcsdup(gpszTargetName);
              v64 = _wcsdup(gpszTargetName);
              v72 = _wcsdup(gpszTargetName);
              v25 = gpszTargetName;
              if ( v79 )
                v25 = v79;
              v73 = _wcsdup(v25);
              v26 = gpszTargetName;
              if ( v79 )
                v26 = v79;
              v75 = _wcsdup(v26);
              LOBYTE(v89) = 29;
              a2 = sub_11F3FF0(v83, 2, 0xFFFFFFFF, 0, &v75, &v73, &v72);
              free(v75);
              free(v73);
              free(v72);
              free(v64);
              free(v60);
              free(v59);
              free(v66);
              free(v57);
              if ( a2 != -1 )
              {
LABEL_55:
                v55 = _wcsdup(gpszTargetName);
                v69 = _wcsdup(FindFileData.cFileName);
                LOBYTE(v89) = 31;
                sub_11F3FF0(v83, v82, a2, 7, &v69, &v86, &v85);
                free(v69);
                free(v55);
              }
            }
          }
          sub_11F21F0(&v42);
          free(v22);
          v5 = v83;
        }
        else
        {
          v35 = v17;
          *v17 = 0;
          v36 = 0;
          v37 = 0;
          v38 = 0;
          LOBYTE(v89) = 32;
          sub_11F7040(v86, &v35);
          v27 = v81;
          v81 = _wcsdup(v86);
          free(v27);
          v28 = sub_11F4EE0(&v49, v83, &v35, 0);
          v29 = v85;
          v85 = _wcsdup(*v28);
          free(v29);
          free(v49);
          v5 = v83;
          v84 = sub_11F4ED0();
          v30 = gpszTargetName;
          if ( v79 )
            v30 = v79;
          v53 = _wcsdup(v30);
          v62 = _wcsdup(FindFileData.cFileName);
          LOBYTE(v89) = 34;
          v87 = sub_11F3D40(v5, &v62, &v53, &v86, &v85, &v80, &v74, &v70);
          free(v62);
          LOBYTE(v89) = 32;
          free(v53);
          if ( v87 )
          {
            if ( a2 != -1 )
              goto LABEL_56;
            if ( sub_11F63B0(FindFileData.cFileName) )
            {
              v67 = _wcsdup(gpszTargetName);
              v68 = _wcsdup(gpszTargetName);
              v61 = _wcsdup(gpszTargetName);
              v56 = _wcsdup(gpszTargetName);
              v54 = _wcsdup(gpszTargetName);
              v58 = _wcsdup(gpszTargetName);
              v31 = gpszTargetName;
              if ( v79 )
                v31 = v79;
              v52 = _wcsdup(v31);
              v32 = gpszTargetName;
              if ( v79 )
                v32 = v79;
              v51 = _wcsdup(v32);
              LOBYTE(v89) = 42;
              a2 = sub_11F3FF0(v5, 2, 0xFFFFFFFF, 0, &v51, &v52, &v58);
              free(v51);
              free(v52);
              free(v58);
              free(v54);
              free(v56);
              free(v61);
              free(v68);
              free(v67);
              if ( a2 != -1 )
              {
LABEL_56:
                v63 = _wcsdup(gpszTargetName);
                v65 = _wcsdup(FindFileData.cFileName);
                LOBYTE(v89) = 44;
                sub_11F3FF0(v5, v84, a2, 6, &v65, &v86, &v85);
                free(v65);
                free(v63);
              }
            }
          }
          sub_11F21F0(&v35);
        }
        free(v86);
        LOBYTE(v89) = 6;
        free(v11);
      }
      else
      {
        LOBYTE(v89) = 6;
        free(v11);
      }
      v33 = hFindFile;
    }
    while ( FindNextFileW(hFindFile, &FindFileData) );
    FindClose(v33);
  }
  free(v74);
  free(v81);
  free(v85);
  free(v6);
  free(v78);
  free(v80);
  free(a4);
  return a2;
}

//----- (0120EFA0) --------------------------------------------------------
void *__cdecl sub_120EFA0(int a1, int a2, OLECHAR *psz, LPCWSTR lpValueName)
{
  void *v4; // eax

  v4 = sub_120EFE0(a1, a2, psz, lpValueName, 0xFFFFFFFF, 1);
  return sub_120EFE0(a1, a2, psz, lpValueName, v4, 0);
}

//----- (0120EFE0) --------------------------------------------------------
void *__cdecl sub_120EFE0(int a1, int a2, OLECHAR *psz, LPCWSTR lpValueName, void *a5, char a6)
{
  unsigned int v6; // eax
  void *v7; // esi
  HKEY hKey; // [esp+8h] [ebp-14h]
  wchar_t *v10; // [esp+Ch] [ebp-10h]
  int v11; // [esp+18h] [ebp-4h]

  v10 = malloc(2u);
  *v10 = 0;
  v11 = 0;
  v6 = TlsGetValue(gdwTlsIndex);
  if ( sub_11F67A0(a2, psz, 0, v6 | 0x20019, &hKey) )
  {
    v7 = a5;
  }
  else if ( sub_1201520(hKey, lpValueName, 0, 0, &v10) )
  {
    v7 = a5;
    RegCloseKey(hKey);
  }
  else
  {
    if ( !a6 )
    {
      sub_11F2300(&v10, L"\\", 0x7FFFFFFF, 0);
      sub_11F2300(&v10, L"AutorunsDisabled", 0x7FFFFFFF, 0);
    }
    v7 = sub_120F0E0(a1, v10, v10, a5, a6);
    RegCloseKey(hKey);
  }
  free(v10);
  return v7;
}

//----- (0120F0E0) --------------------------------------------------------
void *__cdecl sub_120F0E0(int a1, wchar_t *a2, wchar_t *a3, void *a4, char a5)
{
  wchar_t *v5; // esi
  wchar_t *v6; // ebx
  wchar_t *v7; // edi
  const wchar_t **v8; // eax
  wchar_t *v9; // edi
  wchar_t *v10; // ebx
  wchar_t *v11; // eax
  void *v12; // ebx
  int v14; // [esp+10h] [ebp-28h]
  int v15; // [esp+14h] [ebp-24h]
  int v16; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]
  wchar_t *v18; // [esp+20h] [ebp-18h]
  void *v19; // [esp+24h] [ebp-14h]
  wchar_t *v20; // [esp+28h] [ebp-10h]
  int v21; // [esp+34h] [ebp-4h]
  wchar_t *v22; // [esp+48h] [ebp+10h]

  v5 = malloc(2u);
  v18 = v5;
  *v5 = 0;
  v21 = 0;
  v6 = malloc(2u);
  v20 = v6;
  *v6 = 0;
  v7 = a3;
  if ( !a3 )
    v7 = a2;
  v22 = v7;
  v14 = malloc(2u);
  *v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  LOBYTE(v21) = 2;
  sub_11F7040(v7, &v14);
  v8 = sub_11F4EE0(&v19, a1, &v14, 1);
  v9 = _wcsdup(*v8);
  v20 = v9;
  free(v6);
  free(v19);
  if ( wcslen(v9) )
  {
    v10 = v5;
    v5 = _wcsdup(v22);
    v18 = v5;
    free(v10);
    v11 = _wcsdup(v5);
    v12 = sub_120E3A0(a1, a4, v22, v11, a5);
  }
  else
  {
    v12 = a4;
  }
  sub_11F21F0(&v14);
  free(v9);
  free(v5);
  return v12;
}

//----- (0120F210) --------------------------------------------------------
int __cdecl sub_120F210(int a1, wchar_t *a2, int a3)
{
  WCHAR *v3; // ecx
  wchar_t *v4; // eax
  wchar_t *v5; // esi

  v3 = gpszTargetName;
  if ( a2 )
    v3 = a2;
  v4 = _wcsdup(v3);
  v5 = v4;
  a2 = v4;
  sub_1203070(a1, &a2, a3);
  free(v5);
  return a1;
}

//----- (0120F260) --------------------------------------------------------
void __cdecl sub_120F260(int a1, int a2, wchar_t *a3, void *a4, int a5)
{
  int *v5; // esi
  void (__stdcall *v6)(BSTR); // ebx
  LONG (__stdcall *v7)(volatile LONG *); // edi
  CComBSTR *v8; // ecx
  __m128i v9; // xmm0
  int v10; // edx
  int v11; // ST4C_4
  int v12; // esi
  _bstr_t *v13; // eax
  int v14; // ecx
  int v15; // esi
  int v16; // ecx
  int (__stdcall **v17)(int, int *, wchar_t **); // ecx
  int v18; // ecx
  OLECHAR *v19; // ebx
  bool v20; // al
  CComBSTR *v21; // esi
  CComBSTR **v22; // eax
  _bstr_t *v23; // eax
  wchar_t **v24; // eax
  wchar_t *v25; // eax
  OLECHAR *v26; // edi
  const wchar_t *v27; // eax
  int v28; // eax
  int v29; // eax
  WCHAR *v30; // eax
  WCHAR *v31; // eax
  WCHAR *v32; // eax
  char v33; // bl
  WCHAR *v34; // eax
  WCHAR *v35; // eax
  int v36; // ebx
  int v37; // eax
  WCHAR *v38; // eax
  WCHAR *v39; // eax
  int (__stdcall **v40)(int, void *, wchar_t **); // ecx
  int v41; // ecx
  _WORD *v42; // eax
  CComBSTR *v43; // edi
  OLECHAR *v44; // eax
  CComBSTR **v45; // eax
  _bstr_t *v46; // eax
  _bstr_t *v47; // eax
  CComBSTR **v48; // esi
  CComBSTR *v49; // esi
  CComBSTR *v50; // esi
  CComBSTR *v51; // esi
  CComBSTR *v52; // esi
  CComBSTR *v53; // esi
  CComBSTR *v54; // esi
  CComBSTR *v55; // esi
  wchar_t *v56; // esi
  const wchar_t **v57; // eax
  void *v58; // ebx
  OLECHAR *v59; // esi
  unsigned int v60; // eax
  OLECHAR *v61; // eax
  LSTATUS v62; // esi
  int v63; // esi
  wchar_t *v64; // eax
  const wchar_t **v65; // eax
  void *v66; // esi
  wchar_t *v67; // eax
  WCHAR *v68; // eax
  WCHAR *v69; // eax
  int v70; // ebx
  int v71; // ebx
  WCHAR *v72; // eax
  char v73; // bl
  unsigned int v74; // eax
  WCHAR *v75; // eax
  WCHAR *v76; // eax
  int v77; // ebx
  int v78; // eax
  WCHAR *v79; // eax
  WCHAR *v80; // eax
  int v81; // edx
  CComBSTR *v82; // esi
  int v83; // eax
  char *i; // eax
  __m128i v85; // xmm0
  int v86; // edx
  int v87; // ST4C_4
  int v88; // esi
  OLECHAR *v89; // esi
  CComBSTR *v90; // eax
  CComBSTR *v91; // edi
  BSTR v92; // eax
  CComBSTR *v93; // eax
  CComBSTR *v94; // esi
  BSTR v95; // eax
  _bstr_t *v96; // eax
  wchar_t *v97; // ecx
  void **v98; // eax
  void *v99; // esi
  const wchar_t *v100; // [esp-14h] [ebp-1B0h]
  int v101; // [esp-10h] [ebp-1ACh]
  int v102; // [esp-Ch] [ebp-1A8h]
  wchar_t *v103; // [esp-8h] [ebp-1A4h]
  int *v104; // [esp-4h] [ebp-1A0h]
  int v105; // [esp+10h] [ebp-18Ch]
  int v106; // [esp+14h] [ebp-188h]
  int v107; // [esp+18h] [ebp-184h]
  int v108; // [esp+1Ch] [ebp-180h]
  void *v109; // [esp+20h] [ebp-17Ch]
  VARIANTARG pvarg; // [esp+24h] [ebp-178h]
  void *v111; // [esp+34h] [ebp-168h]
  int v112; // [esp+38h] [ebp-164h]
  int v113; // [esp+3Ch] [ebp-160h]
  int v114; // [esp+40h] [ebp-15Ch]
  int v115; // [esp+44h] [ebp-158h]
  void *v116; // [esp+48h] [ebp-154h]
  BSTR *v117; // [esp+4Ch] [ebp-150h]
  int v118; // [esp+50h] [ebp-14Ch]
  OLECHAR **v119; // [esp+54h] [ebp-148h]
  void *v120; // [esp+58h] [ebp-144h]
  OLECHAR **v121; // [esp+5Ch] [ebp-140h]
  OLECHAR **v122; // [esp+60h] [ebp-13Ch]
  void *v123; // [esp+64h] [ebp-138h]
  void *v124; // [esp+68h] [ebp-134h]
  void *v125; // [esp+6Ch] [ebp-130h]
  void *v126; // [esp+70h] [ebp-12Ch]
  void *v127; // [esp+74h] [ebp-128h]
  void *v128; // [esp+78h] [ebp-124h]
  CComBSTR *v129; // [esp+7Ch] [ebp-120h]
  void *v130; // [esp+80h] [ebp-11Ch]
  CComBSTR *v131; // [esp+84h] [ebp-118h]
  BSTR *v132; // [esp+88h] [ebp-114h]
  CComBSTR *v133; // [esp+8Ch] [ebp-110h]
  void *v134; // [esp+90h] [ebp-10Ch]
  void *v135; // [esp+94h] [ebp-108h]
  void *v136; // [esp+98h] [ebp-104h]
  void *v137; // [esp+9Ch] [ebp-100h]
  void *v138; // [esp+A0h] [ebp-FCh]
  void *v139; // [esp+A4h] [ebp-F8h]
  void *v140; // [esp+A8h] [ebp-F4h]
  void *v141; // [esp+ACh] [ebp-F0h]
  CComBSTR *v142; // [esp+B0h] [ebp-ECh]
  BSTR *v143; // [esp+B4h] [ebp-E8h]
  void *v144; // [esp+B8h] [ebp-E4h]
  BSTR *v145; // [esp+BCh] [ebp-E0h]
  void *v146; // [esp+C0h] [ebp-DCh]
  int v147; // [esp+C4h] [ebp-D8h]
  void *v148; // [esp+C8h] [ebp-D4h]
  void *v149; // [esp+CCh] [ebp-D0h]
  void *v150; // [esp+D0h] [ebp-CCh]
  void *v151; // [esp+D4h] [ebp-C8h]
  void *v152; // [esp+D8h] [ebp-C4h]
  void *v153; // [esp+DCh] [ebp-C0h]
  void *v154; // [esp+E0h] [ebp-BCh]
  void *v155; // [esp+E4h] [ebp-B8h]
  void *v156; // [esp+E8h] [ebp-B4h]
  void *v157; // [esp+ECh] [ebp-B0h]
  CComBSTR *v158; // [esp+F0h] [ebp-ACh]
  BSTR bstrString; // [esp+F4h] [ebp-A8h]
  int v160; // [esp+F8h] [ebp-A4h]
  void *v161; // [esp+FCh] [ebp-A0h]
  CComBSTR *v162; // [esp+100h] [ebp-9Ch]
  int v163; // [esp+104h] [ebp-98h]
  CComBSTR *ppComBSTR2; // [esp+108h] [ebp-94h]
  CComBSTR *v165; // [esp+10Ch] [ebp-90h]
  int v166; // [esp+110h] [ebp-8Ch]
  wchar_t *v167; // [esp+114h] [ebp-88h]
  CComBSTR *ppv; // [esp+118h] [ebp-84h]
  void *v169; // [esp+11Ch] [ebp-80h]
  void *v170; // [esp+120h] [ebp-7Ch]
  HKEY hKey; // [esp+124h] [ebp-78h]
  int *v172; // [esp+128h] [ebp-74h]
  wchar_t *v173; // [esp+12Ch] [ebp-70h]
  void *v174; // [esp+130h] [ebp-6Ch]
  void *v175; // [esp+134h] [ebp-68h]
  void *v176; // [esp+138h] [ebp-64h]
  int *v177; // [esp+13Ch] [ebp-60h]
  void *v178; // [esp+140h] [ebp-5Ch]
  CComBSTR *ppComBSTR1; // [esp+144h] [ebp-58h]
  int *v180; // [esp+148h] [ebp-54h]
  void *v181; // [esp+14Ch] [ebp-50h]
  void *v182; // [esp+150h] [ebp-4Ch]
  OLECHAR *psz; // [esp+154h] [ebp-48h]
  CComBSTR *v184; // [esp+158h] [ebp-44h]
  CComBSTR *v185; // [esp+15Ch] [ebp-40h]
  wchar_t *v186; // [esp+160h] [ebp-3Ch]
  wchar_t *v187; // [esp+164h] [ebp-38h]
  wchar_t *v188; // [esp+168h] [ebp-34h]
  void *v189; // [esp+16Ch] [ebp-30h]
  void *v190; // [esp+170h] [ebp-2Ch]
  OLECHAR *v191; // [esp+174h] [ebp-28h]
  CComBSTR *ppComBSTR; // [esp+178h] [ebp-24h]
  unsigned int v193; // [esp+17Ch] [ebp-20h]
  OLECHAR *v194; // [esp+180h] [ebp-1Ch]
  wchar_t *v195; // [esp+184h] [ebp-18h]
  wchar_t *v196; // [esp+188h] [ebp-14h]
  bool v197; // [esp+18Fh] [ebp-Dh]
  int v198; // [esp+198h] [ebp-4h]

  v193 = 0;
  v187 = 0;
  v5 = a5;
  v198 = 0;
  v177 = 0;
  v6 = SysFreeString;
  v7 = InterlockedDecrement;
  if ( (*(*a5 + 56))(a5, 1, &v177) < 0 )
    goto LABEL_196;
  v189 = 0;
  (*(*v177 + 28))(v177, &v189);
  v8 = 0;
  if ( v189 <= 0 )
    goto LABEL_195;
  do
  {
    v186 = 0;
    v184 = (v8 + 1);
    pvarg.vt = 3;
    pvarg.lVal = &v8->bstr + 1;
    v9 = _mm_loadu_si128(&pvarg);
    v104 = &v186;
    LOBYTE(v198) = 1;
    v10 = *v177;
    v11 = v177;
    _mm_storeu_si128(&v100, v9);
    v12 = (*(v10 + 32))(v11, v100, v101, v102, v103, v104);
    LOBYTE(v198) = 0;
    VariantClear(&pvarg);
    if ( v12 < 0 )
      goto LABEL_193;
    bstrString = 0;
    v104 = &bstrString;
    v103 = v186;
    if ( (*(*v186 + 28))(v186, &bstrString) < 0 )
      goto LABEL_192;
    bstr_t::EqualAssign(&v132, bstrString);
    LOBYTE(v198) = 2;
    bstr_t::EqualAssign(&v143, L"\\");
    LOBYTE(v198) = 3;
    v13 = CComBSTR::AppendTail(&a4, &v122, &v143);
    LOBYTE(v198) = 4;
    CComBSTR::AppendTail(v13, &ppComBSTR1, &v132);
    bstr_t::Data_t::Free(&v122);
    bstr_t::Data_t::Free(&v143);
    LOBYTE(v198) = 8;
    bstr_t::Data_t::Free(&v132);
    v147 = 1;
    v104 = &v147;
    v103 = v186;
    (*(*v186 + 40))(v186, &v147);
    v167 = 0;
    v104 = &v167;
    v14 = *v186;
    v197 = v147 != 0;
    v103 = v186;
    if ( (*(v14 + 76))(v186, &v167) < 0 )
      goto LABEL_183;
    v180 = 0;
    v104 = &v180;
    v103 = v167;
    if ( (*(*v167 + 68))(v167, &v180) < 0 )
      goto LABEL_182;
    v15 = 0;
    v104 = &v188;
    v188 = 0;
    v16 = *v180;
    v103 = 1;
    v102 = v180;
    v163 = 0;
    if ( (*(v16 + 32))(v180, 1, &v188) < 0 )
      goto LABEL_181;
    do
    {
      v166 = -1;
      v104 = &v166;
      v103 = v188;
      (*(*v188 + 36))(v188, &v166);
      if ( !v166 )
      {
        v104 = &v195;
        v195 = 0;
        v103 = dword_12C781C;
        v17 = *v188;
        v102 = v188;
        if ( (*v17)(v188, dword_12C781C, &v195) >= 0 )
        {
          v196 = 0;
          v187 = 0;
          v191 = 0;
          v18 = *v195;
          v104 = &v196;
          v103 = v195;
          if ( (*(v18 + 40))(v195, &v196) >= 0 && v196 )
          {
            v104 = &v187;
            v103 = v195;
            (*(*v195 + 48))(v195, &v187);
            v104 = &v191;
            v103 = v195;
            (*(*v195 + 56))(v195, &v191);
            v104 = *sub_11FF8D0(&v111, v196);
            LOBYTE(v198) = 9;
            bstr_t::EqualAssign(&ppv, v104);
            free(v111);
            v19 = malloc(2u);
            v194 = v19;
            *v19 = 0;
            v144 = malloc(2u);
            *v144 = 0;
            LOBYTE(v198) = 13;
            v20 = sub_1201150(a1, gEnvPathName, v196, &v144);
            v21 = ppv;
            if ( v20 || wcschr(v196, 0x5Cu) || !v191 )
            {
              if ( v21 )
                v27 = v21->bstr;
              else
                v27 = 0;
              v26 = _wcsdup(v27);
              v194 = v26;
              free(v19);
            }
            else
            {
              bstr_t::EqualAssign(&v145, L"\\");
              LOBYTE(v198) = 14;
              v22 = bstr_t::EqualAssign(&v117, v191);
              LOBYTE(v198) = 15;
              v23 = CComBSTR::AppendTail(v22, &v119, &v145);
              LOBYTE(v198) = 16;
              v24 = *CComBSTR::AppendTail(v23, &v121, &ppv);
              if ( v24 )
                v25 = *v24;
              else
                v25 = 0;
              sub_11F2280(&v194, v25);
              bstr_t::Data_t::Free(&v121);
              bstr_t::Data_t::Free(&v119);
              bstr_t::Data_t::Free(&v117);
              bstr_t::Data_t::Free(&v145);
              v26 = v194;
            }
            v175 = malloc(2u);
            *v175 = 0;
            v174 = malloc(2u);
            *v174 = 0;
            v28 = sub_120F210(&v109, L"\"", &v194);
            v29 = sub_11F22B0(&v120, v28, L"\" ");
            sub_11F22B0(&v173, v29, v187);
            free(v120);
            free(v109);
            v105 = malloc(2u);
            *v105 = 0;
            v106 = 0;
            v107 = 0;
            v108 = 0;
            LOBYTE(v198) = 20;
            sub_11F6CC0(v173, &v105);
            sub_11F4EE0(&v176, a1, &v105, 0);
            LOBYTE(v198) = 21;
            v100 = &v174;
            v160 = sub_11F4ED0();
            v170 = malloc(2u);
            *v170 = 0;
            if ( !v21 || (v30 = v21->bstr) == 0 )
              v30 = gpszTargetName;
            v140 = _wcsdup(v30);
            v31 = gpszTargetName;
            if ( a3 )
              v31 = a3;
            v123 = _wcsdup(v31);
            if ( !v21 || (v32 = v21->bstr) == 0 )
              v32 = gpszTargetName;
            v127 = _wcsdup(v32);
            LOBYTE(v198) = 25;
            v33 = sub_11F3D40(a1, &v127, &v123, &v140, &v176, &v175, &v170, &v118);
            free(v127);
            free(v123);
            free(v140);
            if ( v33 )
            {
              if ( *a2 == -1 )
              {
                v148 = _wcsdup(gpszTargetName);
                v139 = _wcsdup(gpszTargetName);
                v150 = _wcsdup(gpszTargetName);
                v141 = _wcsdup(gpszTargetName);
                v152 = _wcsdup(gpszTargetName);
                v157 = _wcsdup(gpszTargetName);
                v34 = gpszTargetName;
                if ( a3 )
                  v34 = a3;
                v154 = _wcsdup(v34);
                v35 = gpszTargetName;
                if ( a3 )
                  v35 = a3;
                v128 = _wcsdup(v35);
                v36 = a1;
                LOBYTE(v198) = 33;
                v37 = sub_11F3FF0(a1, 2, *a2, 0, &v128, &v154, &v157);
                v104 = v128;
                *a2 = v37;
                free(v104);
                free(v154);
                free(v157);
                free(v152);
                free(v141);
                free(v150);
                free(v139);
                free(v148);
              }
              else
              {
                v36 = a1;
              }
              v135 = _wcsdup(gpszTargetName);
              if ( !v21 || (v38 = v21->bstr) == 0 )
                v38 = gpszTargetName;
              v146 = _wcsdup(v38);
              if ( !ppComBSTR1 || (v39 = ppComBSTR1->bstr) == 0 )
                v39 = gpszTargetName;
              v137 = _wcsdup(v39);
              v103 = -1;
              v102 = 0;
              v101 = 0;
              LOBYTE(v198) = 36;
              v100 = &v135;
              sub_11F3FF0(v36, v160, *a2, 9, &v137, &v146, &v176);
              free(v137);
              free(v146);
              free(v135);
            }
            free(v170);
            free(v176);
            sub_11F21F0(&v105);
            free(v173);
            free(v174);
            free(v175);
            free(v144);
            free(v26);
            LOBYTE(v198) = 8;
            bstr_t::Data_t::Free(&ppv);
            v6 = SysFreeString;
            v15 = v163;
          }
          v104 = v195;
          (*(*v195 + 8))(v195);
        }
      }
      if ( v166 != 5 )
        goto LABEL_179;
      v104 = &v196;
      v196 = 0;
      v103 = &unk_12C783C;
      v40 = *v188;
      v102 = v188;
      if ( (*v40)(v188, &unk_12C783C, &v196) < 0 )
        goto LABEL_179;
      v195 = 0;
      v160 = 0;
      v104 = &v195;
      v41 = *v196;
      v103 = v196;
      (*(v41 + 40))(v196, &v195);
      v104 = &v160;
      v103 = v196;
      (*(*v196 + 48))(v196, &v160);
      v42 = malloc(2u);
      v178 = v42;
      *v42 = 0;
      v43 = 0;
      ppComBSTR = 0;
      v44 = 0;
      LOBYTE(v198) = 38;
      v191 = 0;
      while ( 1 )
      {
        bstr_t::EqualAssign(&v165, (&off_12DAA1C)[v44]);
        LOBYTE(v198) = 39;
        bstr_t::EqualAssign(&v162, L"\\");
        LOBYTE(v198) = 40;
        bstr_t::EqualAssign(&ppComBSTR2, v195);
        LOBYTE(v198) = 41;
        v45 = bstr_t::EqualAssign(&v129, L"CLSID\\");
        LOBYTE(v198) = 42;
        v46 = CComBSTR::AppendTail(v45, &v131, &ppComBSTR2);
        LOBYTE(v198) = 43;
        v47 = CComBSTR::AppendTail(v46, &v142, &v162);
        LOBYTE(v198) = 44;
        v48 = CComBSTR::AppendTail(v47, &v133, &v165);
        if ( &ppComBSTR != v48 )
        {
          bstr_t::Data_t::Free(&ppComBSTR);
          v43 = *v48;
          ppComBSTR = v43;
          if ( v43 )
            InterlockedIncrement(&v43->Length);
        }
        v49 = v133;
        if ( v133 )
        {
          if ( !InterlockedDecrement(&v133->Length) && v49 )
          {
            if ( v49->bstr )
            {
              v6(v49->bstr);
              v49->bstr = 0;
            }
            if ( v49->hKey )
            {
              j_j__free(v49->hKey);
              v49->hKey = 0;
            }
            j__free(v49);
          }
          v133 = 0;
        }
        v50 = v142;
        if ( v142 )
        {
          if ( !InterlockedDecrement(&v142->Length) && v50 )
          {
            if ( v50->bstr )
            {
              v6(v50->bstr);
              v50->bstr = 0;
            }
            if ( v50->hKey )
            {
              j_j__free(v50->hKey);
              v50->hKey = 0;
            }
            j__free(v50);
          }
          v142 = 0;
        }
        v51 = v131;
        if ( v131 )
        {
          if ( !InterlockedDecrement(&v131->Length) && v51 )
          {
            if ( v51->bstr )
            {
              v6(v51->bstr);
              v51->bstr = 0;
            }
            if ( v51->hKey )
            {
              j_j__free(v51->hKey);
              v51->hKey = 0;
            }
            j__free(v51);
          }
          v131 = 0;
        }
        v52 = v129;
        if ( v129 )
        {
          if ( !InterlockedDecrement(&v129->Length) && v52 )
          {
            if ( v52->bstr )
            {
              v6(v52->bstr);
              v52->bstr = 0;
            }
            if ( v52->hKey )
            {
              j_j__free(v52->hKey);
              v52->hKey = 0;
            }
            j__free(v52);
          }
          v129 = 0;
        }
        v53 = ppComBSTR2;
        if ( ppComBSTR2 )
        {
          if ( !InterlockedDecrement(&ppComBSTR2->Length) )
          {
            if ( v53->bstr )
            {
              v6(v53->bstr);
              v53->bstr = 0;
            }
            if ( v53->hKey )
            {
              j_j__free(v53->hKey);
              v53->hKey = 0;
            }
            j__free(v53);
          }
          ppComBSTR2 = 0;
        }
        v54 = v162;
        if ( v162 )
        {
          if ( !InterlockedDecrement(&v162->Length) )
          {
            if ( v54->bstr )
            {
              v6(v54->bstr);
              v54->bstr = 0;
            }
            if ( v54->hKey )
            {
              j_j__free(v54->hKey);
              v54->hKey = 0;
            }
            j__free(v54);
          }
          v162 = 0;
        }
        v55 = v165;
        LOBYTE(v198) = 38;
        if ( v165 )
        {
          if ( !InterlockedDecrement(&v165->Length) )
          {
            if ( v55->bstr )
            {
              v6(v55->bstr);
              v55->bstr = 0;
            }
            if ( v55->hKey )
            {
              j_j__free(v55->hKey);
              v55->hKey = 0;
            }
            j__free(v55);
          }
          v165 = 0;
        }
        v56 = _wcsdup(L"HKCR\\CLSID\\");
        v187 = v56;
        v57 = sub_11F22B0(&v116, &v187, v195);
        v58 = v178;
        v100 = *v57;
        v178 = _wcsdup(v100);
        free(v58);
        free(v116);
        free(v56);
        if ( v43 )
          v59 = v43->bstr;
        else
          v59 = 0;
        v104 = &hKey;
        v60 = TlsGetValue(gdwTlsIndex);
        if ( sub_11F67A0(HKEY_CLASSES_ROOT, v59, 0, v60 | 1, v104) )
        {
          v61 = v43 ? v43->bstr : 0;
          if ( sub_11F67A0(HKEY_CLASSES_ROOT, v61, 0, 1, &hKey) )
            goto LABEL_126;
        }
        v194 = malloc(2u);
        *v194 = 0;
        LOBYTE(v198) = 45;
        v62 = sub_1201520(hKey, gpszTargetName, 0, 0, &v194);
        if ( !v62 )
        {
          bstr_t::Assign(&ppComBSTR, v194);
          v43 = ppComBSTR;
        }
        RegCloseKey(hKey);
        v104 = v194;
        if ( !v62 )
          break;
        LOBYTE(v198) = 38;
        free(v104);
LABEL_126:
        v6 = SysFreeString;
        v44 = (v191 + 1);
        v191 = v44;
        if ( v44 >= 4 )
          goto LABEL_129;
      }
      free(v104);
LABEL_129:
      v112 = malloc(2u);
      *v112 = 0;
      v113 = 0;
      v114 = 0;
      v115 = 0;
      v181 = malloc(2u);
      *v181 = 0;
      v169 = malloc(2u);
      *v169 = 0;
      v190 = malloc(2u);
      *v190 = 0;
      v63 = -1;
      LOBYTE(v198) = 49;
      if ( v191 >= 4 )
      {
        bstr_t::Assign(&ppComBSTR, v195);
        v43 = ppComBSTR;
        if ( ppComBSTR )
          v67 = ppComBSTR->bstr;
        else
          v67 = 0;
        sub_11F7040(v67, &v112);
      }
      else
      {
        if ( v43 )
          v64 = v43->bstr;
        else
          v64 = 0;
        sub_11F7040(v64, &v112);
        v65 = sub_11F4EE0(&v125, a1, &v112, 0);
        v66 = v190;
        v190 = _wcsdup(*v65);
        free(v66);
        free(v125);
        v63 = sub_11F4ED0();
      }
      v161 = malloc(2u);
      *v161 = 0;
      if ( !wcslen(v190) )
        goto LABEL_243;
      if ( !v43 || (v68 = v43->bstr) == 0 )
        v68 = gpszTargetName;
      v130 = _wcsdup(v68);
      v69 = gpszTargetName;
      v70 = v193 | 1;
      if ( a3 )
        v69 = a3;
      v138 = _wcsdup(v69);
      v71 = v70 | 2;
      if ( !v43 || (v72 = v43->bstr) == 0 )
        v72 = gpszTargetName;
      v124 = _wcsdup(v72);
      v198 = 53;
      v193 = v71 | 4;
      v187 = (v71 | 4);
      if ( sub_11F3D40(a1, &v124, &v138, &v130, &v190, &v181, &v161, &v158) )
        v73 = 1;
      else
LABEL_243:
        v73 = 0;
      v74 = v193;
      if ( v193 & 4 )
      {
        v193 &= 0xFFFFFFFB;
        free(v124);
        v74 = v193;
      }
      if ( v74 & 2 )
      {
        v193 = v74 & 0xFFFFFFFD;
        free(v138);
        v74 = v193;
      }
      v198 = 50;
      if ( v74 & 1 )
      {
        v193 = v74 & 0xFFFFFFFE;
        free(v130);
      }
      if ( v73 )
      {
        if ( *a2 == -1 )
        {
          v149 = _wcsdup(gpszTargetName);
          v151 = _wcsdup(gpszTargetName);
          v153 = _wcsdup(gpszTargetName);
          v155 = _wcsdup(gpszTargetName);
          v156 = _wcsdup(gpszTargetName);
          v134 = _wcsdup(gpszTargetName);
          v75 = gpszTargetName;
          if ( a3 )
            v75 = a3;
          v126 = _wcsdup(v75);
          v76 = gpszTargetName;
          if ( a3 )
            v76 = a3;
          v136 = _wcsdup(v76);
          v77 = a1;
          LOBYTE(v198) = 61;
          v78 = sub_11F3FF0(a1, 2, *a2, 0, &v136, &v126, &v134);
          v104 = v136;
          *a2 = v78;
          free(v104);
          free(v126);
          free(v134);
          free(v156);
          free(v155);
          free(v153);
          free(v151);
          free(v149);
        }
        else
        {
          v77 = a1;
        }
        psz = _wcsdup(gpszTargetName);
        if ( !v43 || (v79 = v43->bstr) == 0 )
          v79 = gpszTargetName;
        v185 = _wcsdup(v79);
        if ( !ppComBSTR1 || (v80 = ppComBSTR1->bstr) == 0 )
          v80 = gpszTargetName;
        v182 = _wcsdup(v80);
        v103 = -1;
        v102 = 0;
        v101 = 0;
        LOBYTE(v198) = 64;
        v100 = &psz;
        sub_11F3FF0(v77, v63, *a2, 9, &v182, &v185, &v190);
        free(v182);
        free(v185);
        LOBYTE(v198) = 50;
        free(psz);
      }
      v104 = v196;
      (*(*v196 + 8))(v196);
      free(v161);
      free(v190);
      free(v169);
      free(v181);
      sub_11F21F0(&v112);
      if ( v43 && !InterlockedDecrement(&v43->Length) )
      {
        if ( v43->bstr )
        {
          SysFreeString(v43->bstr);
          v43->bstr = 0;
        }
        if ( v43->hKey )
        {
          j_j__free(v43->hKey);
          v43->hKey = 0;
        }
        j__free(v43);
      }
      LOBYTE(v198) = 8;
      free(v178);
      v15 = v163;
LABEL_179:
      v104 = v188;
      (*(*v188 + 8))(v188);
      ++v15;
      v188 = 0;
      v104 = &v188;
      v163 = v15;
      v81 = *v180;
      v103 = (v15 + 1);
      v102 = v180;
      v6 = SysFreeString;
    }
    while ( (*(v81 + 32))(v180, v15 + 1, &v188) >= 0 );
    v7 = InterlockedDecrement;
LABEL_181:
    v104 = v180;
    (*(*v180 + 8))(v180);
LABEL_182:
    v104 = v167;
    (*(*v167 + 8))(v167);
LABEL_183:
    v6(bstrString);
    v82 = ppComBSTR1;
    LOBYTE(v198) = 0;
    if ( ppComBSTR1 )
    {
      if ( !v7(&ppComBSTR1->Length) && v82 )
      {
        if ( v82->bstr )
        {
          v6(v82->bstr);
          v82->bstr = 0;
        }
        if ( v82->hKey )
        {
          j_j__free(v82->hKey);
          v82->hKey = 0;
        }
        j__free(v82);
      }
      ppComBSTR1 = 0;
    }
LABEL_192:
    v104 = v186;
    (*(*v186 + 8))(v186);
LABEL_193:
    v8 = v184;
  }
  while ( v184 < v189 );
  v5 = a5;
LABEL_195:
  v104 = v177;
  (*(*v177 + 8))(v177);
LABEL_196:
  v83 = *v5;
  v104 = &v172;
  v103 = 0;
  v102 = v5;
  v172 = 0;
  if ( (*(v83 + 40))(v5, 0, &v172) >= 0 )
  {
    for ( i = 1; ; i = v182 + 1 )
    {
      v182 = i;
      a5 = 0;
      pvarg.vt = 3;
      pvarg.lVal = i;
      v85 = _mm_loadu_si128(&pvarg);
      v104 = &a5;
      LOBYTE(v198) = 65;
      v86 = *v172;
      v87 = v172;
      _mm_storeu_si128(&v100, v85);
      v88 = (*(v86 + 32))(v87, v100, v101, v102, v103, v104);
      LOBYTE(v198) = 0;
      VariantClear(&pvarg);
      if ( v88 < 0 )
        break;
      psz = 0;
      v104 = &psz;
      v103 = a5;
      (*(*a5 + 28))(a5, &psz);
      v89 = psz;
      v90 = operator new(0xCu);
      v91 = v90;
      v184 = v90;
      LOBYTE(v198) = 66;
      if ( v90 )
      {
        v104 = v89;
        v90->hKey = 0;
        v90->Length = 1;
        v92 = SysAllocString(v104);
        v91->bstr = v92;
        if ( !v92 && v89 )
          goto LABEL_202;
      }
      else
      {
        v91 = 0;
      }
      LOBYTE(v198) = 0;
      v158 = v91;
      if ( !v91 )
        goto LABEL_202;
      LOBYTE(v198) = 67;
      v93 = operator new(0xCu);
      v94 = v93;
      v184 = v93;
      LOBYTE(v198) = 68;
      if ( v93 )
      {
        v104 = L"\\";
        v93->hKey = 0;
        v93->Length = 1;
        v95 = SysAllocString(v104);
        v94->bstr = v95;
        if ( !v95 )
          goto LABEL_202;
      }
      else
      {
        v94 = 0;
      }
      LOBYTE(v198) = 67;
      v184 = v94;
      if ( !v94 )
LABEL_202:
        com_error::throw(-2147024882);
      v104 = a5;
      LOBYTE(v198) = 69;
      v96 = CComBSTR::AppendTail(&a4, &v185, &v184);
      v103 = v97;
      LOBYTE(v198) = 70;
      CComBSTR::AppendTail(v96, &v103, &v158);
      sub_120F260(a1, a2, a3, v103, v104);
      v189 = v185;
      if ( v185 )
      {
        if ( !InterlockedDecrement(&v185->Length) )
        {
          v98 = v189;
          if ( v189 )
          {
            if ( *v189 )
            {
              v6(*v189);
              v98 = v189;
              *v189 = 0;
            }
            if ( v98[1] )
            {
              j_j__free(v98[1]);
              v98 = v189;
              *(v189 + 1) = 0;
            }
            j__free(v98);
          }
        }
        v185 = 0;
      }
      if ( !InterlockedDecrement(&v94->Length) )
      {
        if ( v94->bstr )
        {
          v6(v94->bstr);
          v94->bstr = 0;
        }
        if ( v94->hKey )
        {
          j_j__free(v94->hKey);
          v94->hKey = 0;
        }
        j__free(v94);
      }
      LOBYTE(v198) = 0;
      if ( !InterlockedDecrement(&v91->Length) )
      {
        if ( v91->bstr )
        {
          v6(v91->bstr);
          v91->bstr = 0;
        }
        if ( v91->hKey )
        {
          j_j__free(v91->hKey);
          v91->hKey = 0;
        }
        j__free(v91);
      }
      v104 = a5;
      (*(*a5 + 8))(a5);
    }
    v104 = v172;
    (*(*v172 + 8))(v172);
    v7 = InterlockedDecrement;
  }
  v99 = a4;
  if ( a4 && !v7(a4 + 2) && v99 )
  {
    if ( *v99 )
    {
      v6(*v99);
      *v99 = 0;
    }
    if ( *(v99 + 1) )
    {
      j_j__free(*(v99 + 1));
      *(v99 + 1) = 0;
    }
    j__free(v99);
  }
}
// 12C781C: using guessed type int dword_12C781C[8];

//----- (01210760) --------------------------------------------------------
void __cdecl sub_1210760(int a1)
{
  int v1; // ebx
  _WORD *v2; // eax
  _WORD *v3; // eax
  _WORD *v4; // eax
  WCHAR *v5; // eax
  WCHAR *v6; // ecx
  unsigned int v7; // esi
  CComBSTR *v8; // eax
  WCHAR *v9; // eax
  CComBSTR *v10; // eax
  WCHAR *v11; // eax
  int v12; // eax
  void **v13; // eax
  int v14; // eax
  WCHAR *v15; // edx
  char v16; // bl
  void *v17; // ebx
  WCHAR *v18; // ecx
  WCHAR *v19; // ecx
  void *v20; // ST30_4
  int v21; // [esp+10h] [ebp-E0h]
  int v22; // [esp+14h] [ebp-DCh]
  int v23; // [esp+18h] [ebp-D8h]
  int v24; // [esp+1Ch] [ebp-D4h]
  int v25; // [esp+20h] [ebp-D0h]
  BSTR *v26; // [esp+24h] [ebp-CCh]
  void *v27; // [esp+28h] [ebp-C8h]
  LPVOID v28; // [esp+2Ch] [ebp-C4h]
  void *v29; // [esp+30h] [ebp-C0h]
  int v30; // [esp+34h] [ebp-BCh]
  BSTR *v31; // [esp+38h] [ebp-B8h]
  int v32; // [esp+3Ch] [ebp-B4h]
  int v33; // [esp+40h] [ebp-B0h]
  void *v34; // [esp+44h] [ebp-ACh]
  void *v35; // [esp+48h] [ebp-A8h]
  void *v36; // [esp+4Ch] [ebp-A4h]
  void *v37; // [esp+50h] [ebp-A0h]
  LPVOID pv; // [esp+54h] [ebp-9Ch]
  void *v39; // [esp+58h] [ebp-98h]
  void *v40; // [esp+5Ch] [ebp-94h]
  void *v41; // [esp+60h] [ebp-90h]
  void *v42; // [esp+64h] [ebp-8Ch]
  void *v43; // [esp+68h] [ebp-88h]
  void *v44; // [esp+6Ch] [ebp-84h]
  wchar_t *v45; // [esp+70h] [ebp-80h]
  void *v46; // [esp+74h] [ebp-7Ch]
  void *v47; // [esp+78h] [ebp-78h]
  LPVOID ppv; // [esp+7Ch] [ebp-74h]
  int v49; // [esp+80h] [ebp-70h]
  void *v50; // [esp+84h] [ebp-6Ch]
  int v51; // [esp+88h] [ebp-68h]
  void *v52; // [esp+8Ch] [ebp-64h]
  void *v53; // [esp+90h] [ebp-60h]
  void *v54; // [esp+94h] [ebp-5Ch]
  void *v55; // [esp+98h] [ebp-58h]
  void *v56; // [esp+9Ch] [ebp-54h]
  wchar_t *v57; // [esp+A0h] [ebp-50h]
  LPVOID v58; // [esp+A4h] [ebp-4Ch]
  void *i; // [esp+A8h] [ebp-48h]
  void *v60; // [esp+ACh] [ebp-44h]
  int v61; // [esp+B0h] [ebp-40h]
  char v62; // [esp+B4h] [ebp-3Ch]
  int v63; // [esp+ECh] [ebp-4h]

  v1 = a1;
  v49 = a1;
  if ( !dword_12E4C34 )
  {
    if ( GetVersion() < 6u )
    {
      v2 = malloc(2u);
      v52 = v2;
      *v2 = 0;
      v63 = 0;
      v3 = malloc(2u);
      v50 = v3;
      *v3 = 0;
      v4 = malloc(2u);
      v47 = v4;
      *v4 = 0;
      v53 = _wcsdup(gpszTargetName);
      v60 = _wcsdup(gpszTargetName);
      i = _wcsdup(gpszTargetName);
      v58 = _wcsdup(gpszTargetName);
      v56 = _wcsdup(gpszTargetName);
      v57 = _wcsdup(gpszTargetName);
      v5 = gpszTargetName;
      if ( off_12DAA18 )
        v5 = off_12DAA18;
      v55 = _wcsdup(v5);
      v6 = gpszTargetName;
      if ( off_12DAA18 )
        v6 = off_12DAA18;
      v54 = _wcsdup(v6);
      LOBYTE(v63) = 10;
      v43 = sub_11F3FF0(a1, 2, 0xFFFFFFFF, 0, &v54, &v55, &v57);
      free(v54);
      free(v55);
      free(v57);
      free(v56);
      free(v58);
      free(i);
      free(v60);
      LOBYTE(v63) = 2;
      free(v53);
      if ( CoInitializeEx(0, 0) >= 0 && CoCreateInstance(&CLSID_TaskServices, 0, 1u, &CLSID_ITaskScheduler, &ppv) >= 0 )
      {
        v51 = 0;
        if ( (*(*ppv + 20))(ppv, &v51) >= 0 )
        {
          for ( i = 0; (*(*v51 + 12))(v51, 2, &v58, &i) >= 0; i = 0 )
          {
            if ( !i )
              break;
            v7 = 0;
            if ( i )
            {
              do
              {
                if ( (*(*ppv + 24))(ppv, *(v58 + v7), &CLSID_ITask, &v60) >= 0 )
                {
                  v53 = 0;
                  (*(*v60 + 20))(v60, &v53);
                  if ( v53 > 0u && (*(*v60 + 24))(v60, 0, &v33) >= 0 )
                  {
                    v61 = 48;
                    memset(&v62, 0, 0x2Cu);
                    if ( (*(*v33 + 16))(v33, &v61) >= 0 && (*(*v60 + 132))(v60, &pv) >= 0 )
                    {
                      v8 = *bstr_t::EqualAssign(&v26, pv);
                      if ( !v8 || (v9 = v8->bstr) == 0 )
                        v9 = gpszTargetName;
                      v55 = _wcsdup(v9);
                      LOBYTE(v63) = 11;
                      bstr_t::Data_t::Free(&v26);
                      v10 = *bstr_t::EqualAssign(&v31, *(v58 + v7));
                      if ( !v10 || (v11 = v10->bstr) == 0 )
                        v11 = gpszTargetName;
                      v54 = _wcsdup(v11);
                      LOBYTE(v63) = 12;
                      bstr_t::Data_t::Free(&v31);
                      (*(*v60 + 140))(v60, &v45);
                      (*(*v60 + 116))(v60, &v25);
                      (*(*v60 + 148))(v60, &v28);
                      v57 = malloc(2u);
                      *v57 = 0;
                      v12 = sub_11F22B0(&v29, &v55, L" ");
                      v13 = sub_11F22B0(&v27, v12, v45);
                      sub_11F2300(&v57, *v13, 0x7FFFFFFF, 0);
                      free(v27);
                      free(v29);
                      v21 = malloc(2u);
                      *v21 = 0;
                      v22 = 0;
                      v23 = 0;
                      v24 = 0;
                      LOBYTE(v63) = 14;
                      sub_11F6CC0(v57, &v21);
                      sub_11F4EE0(&v56, v1, &v21, 0);
                      LOBYTE(v63) = 15;
                      v14 = sub_11F4ED0();
                      v15 = gpszTargetName;
                      v30 = v14;
                      if ( off_12DAA18 )
                        v15 = off_12DAA18;
                      v35 = _wcsdup(v15);
                      LOBYTE(v63) = 16;
                      v16 = sub_11F3D40(v1, &v54, &v35, &v55, &v56, &v52, &v47, &v32);
                      free(v35);
                      if ( v16 )
                      {
                        v17 = v43;
                        if ( v43 == -1 )
                        {
                          v42 = _wcsdup(gpszTargetName);
                          v44 = _wcsdup(gpszTargetName);
                          v39 = _wcsdup(gpszTargetName);
                          v37 = _wcsdup(gpszTargetName);
                          v41 = _wcsdup(gpszTargetName);
                          v46 = _wcsdup(gpszTargetName);
                          v18 = gpszTargetName;
                          if ( off_12DAA18 )
                            v18 = off_12DAA18;
                          v34 = _wcsdup(v18);
                          v19 = gpszTargetName;
                          if ( off_12DAA18 )
                            v19 = off_12DAA18;
                          v36 = _wcsdup(v19);
                          LOBYTE(v63) = 24;
                          v17 = sub_11F3FF0(v49, 2, v17, 0, &v36, &v34, &v46);
                          v43 = v17;
                          free(v36);
                          free(v34);
                          free(v46);
                          free(v41);
                          free(v37);
                          free(v39);
                          free(v44);
                          free(v42);
                        }
                        v40 = _wcsdup(gpszTargetName);
                        LOBYTE(v63) = 25;
                        v20 = v17;
                        v1 = v49;
                        sub_11F3FF0(v49, v30, v20, 9, &v54, &v55, &v56);
                        free(v40);
                      }
                      else
                      {
                        v1 = v49;
                      }
                      CoTaskMemFree(pv);
                      CoTaskMemFree(v45);
                      CoTaskMemFree(v28);
                      free(v56);
                      sub_11F21F0(&v21);
                      free(v57);
                      free(v54);
                      LOBYTE(v63) = 2;
                      free(v55);
                    }
                  }
                }
                CoTaskMemFree(*(v58 + v7++));
              }
              while ( v7 < i );
            }
            CoTaskMemFree(v58);
          }
          (*(*v51 + 8))(v51);
          (*(*ppv + 8))(ppv);
        }
      }
      free(v47);
      free(v50);
      free(v52);
    }
    else
    {
      sub_1210EA0(a1);
    }
  }
}
// 12B2AD0: using guessed type GUID CLSID_ITask;
// 12E4C34: using guessed type int dword_12E4C34;

//----- (01210EA0) --------------------------------------------------------
void __cdecl sub_1210EA0(int a1)
{
  WCHAR *v1; // esi
  WCHAR *v2; // eax
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  LPVOID v5; // ecx
  int v6; // edx
  int v7; // edi
  CComBSTR *v8; // eax
  BSTR v9; // edx
  int v10; // eax
  int v11; // esi
  OLECHAR *v12; // ecx
  int v13; // ecx
  void **v14; // [esp-40h] [ebp-F0h]
  void **v15; // [esp-3Ch] [ebp-ECh]
  int v16; // [esp-38h] [ebp-E8h]
  signed int v17; // [esp-34h] [ebp-E4h]
  CComBSTR **v18; // [esp-30h] [ebp-E0h]
  int v19; // [esp-2Ch] [ebp-DCh]
  int v20; // [esp-28h] [ebp-D8h]
  signed int v21; // [esp-24h] [ebp-D4h]
  int v22; // [esp-20h] [ebp-D0h]
  int v23; // [esp-1Ch] [ebp-CCh]
  int v24; // [esp-18h] [ebp-C8h]
  int v25; // [esp-14h] [ebp-C4h]
  int v26; // [esp-10h] [ebp-C0h]
  LPVOID v27; // [esp-Ch] [ebp-BCh]
  BSTR v28; // [esp-8h] [ebp-B8h]
  void *v29; // [esp-4h] [ebp-B4h]
  __int128 v30; // [esp+Ch] [ebp-A4h]
  __int128 v31; // [esp+1Ch] [ebp-94h]
  __int128 v32; // [esp+2Ch] [ebp-84h]
  VARIANTARG v33; // [esp+3Ch] [ebp-74h]
  VARIANTARG v34; // [esp+4Ch] [ebp-64h]
  VARIANTARG pvarg; // [esp+5Ch] [ebp-54h]
  VARIANTARG v36; // [esp+6Ch] [ebp-44h]
  void *v37; // [esp+7Ch] [ebp-34h]
  void *v38; // [esp+80h] [ebp-30h]
  void *v39; // [esp+84h] [ebp-2Ch]
  void *v40; // [esp+88h] [ebp-28h]
  void *v41; // [esp+8Ch] [ebp-24h]
  void *v42; // [esp+90h] [ebp-20h]
  void *v43; // [esp+94h] [ebp-1Ch]
  LPVOID ppv; // [esp+98h] [ebp-18h]
  CComBSTR *ppComBSTR; // [esp+9Ch] [ebp-14h]
  void *v46; // [esp+A0h] [ebp-10h]
  int v47; // [esp+ACh] [ebp-4h]

  v42 = -1;
  ppComBSTR = _wcsdup(gpszTargetName);
  v47 = 0;
  v43 = _wcsdup(gpszTargetName);
  v40 = _wcsdup(gpszTargetName);
  v41 = _wcsdup(gpszTargetName);
  v39 = _wcsdup(gpszTargetName);
  v38 = _wcsdup(gpszTargetName);
  v1 = gpszTargetName;
  v2 = gpszTargetName;
  if ( off_12DAA2C )
    v2 = off_12DAA2C;
  v37 = _wcsdup(v2);
  if ( off_12DAA2C )
    v1 = off_12DAA2C;
  v46 = _wcsdup(v1);
  v21 = -1;
  v20 = 0;
  v19 = 0;
  LOBYTE(v47) = 7;
  v18 = &ppComBSTR;
  v17 = 1;
  v16 = 0;
  v15 = &v43;
  v14 = &v40;
  v42 = sub_11F3FF0(a1, 2, v42, 0, &v46, &v37, &v38);
  free(v46);
  free(v37);
  free(v38);
  free(v39);
  free(v41);
  free(v40);
  free(v43);
  v47 = -1;
  free(ppComBSTR);
  CoInitializeEx(0, 0);
  ppv = 0;
  if ( CoCreateInstance(&CLSID_TaskScheduler, 0, 1u, &IID_ITaskService, &ppv) >= 0 )
  {
    VariantInit(&pvarg);
    v3 = _mm_loadu_si128(&pvarg);
    v47 = 8;
    _mm_storeu_si128(&v32, v3);
    VariantInit(&v34);
    _mm_storeu_si128(&v31, _mm_loadu_si128(&v34));
    VariantInit(&v33);
    _mm_storeu_si128(&v30, _mm_loadu_si128(&v33));
    VariantInit(&v36);
    v4 = _mm_loadu_si128(&v32);
    v5 = ppv;
    LOBYTE(v47) = 11;
    v6 = *ppv;
    _mm_storeu_si128(&v26, v4);
    _mm_storeu_si128(&v22, _mm_loadu_si128(&v31));
    _mm_storeu_si128(&v18, _mm_loadu_si128(&v30));
    _mm_storeu_si128(&v14, _mm_loadu_si128(&v36));
    v7 = (*(v6 + 40))(v5, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29);
    VariantClear(&v36);
    VariantClear(&v33);
    VariantClear(&v34);
    v47 = -1;
    VariantClear(&pvarg);
    if ( v7 >= 0 )
    {
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(0);
        TlsSetValue(gdwTlsIndex, 0x100);
      }
      v46 = 0;
      v8 = *bstr_t::EqualAssign(&ppComBSTR, L"\\");
      v47 = 12;
      if ( v8 )
        v9 = v8->bstr;
      else
        v9 = 0;
      v29 = &v46;
      v28 = v9;
      v27 = ppv;
      v10 = (*(*ppv + 28))(ppv, v9, &v46);
      v47 = -1;
      v11 = v10;
      bstr_t::Data_t::Free(&ppComBSTR);
      if ( v11 >= 0 )
      {
        v29 = v46;
        v28 = v12;
        bstr_t::EqualAssign(&v28, gpszTargetName);
        sub_120F260(a1, &v42, off_12DAA2C, v28, v29);
        v13 = *v46;
        v29 = v46;
        (*(v13 + 8))(v46);
      }
      if ( Wow64EnableWow64FsRedirection )
      {
        Wow64EnableWow64FsRedirection(1);
        TlsSetValue(gdwTlsIndex, 0x200);
      }
    }
    v29 = ppv;
    (*(*ppv + 8))(ppv);
  }
  CoUninitialize();
}
// 12E31F4: using guessed type int (__stdcall *Wow64EnableWow64FsRedirection)(_DWORD);

//----- (012111B0) --------------------------------------------------------
wchar_t *__cdecl sub_12111B0(wchar_t *a1, int a2, wchar_t *a3)
{
  wchar_t **v3; // edi
  wchar_t *v4; // eax
  wchar_t *v5; // eax
  wchar_t *v6; // esi
  wchar_t *v7; // esi
  wchar_t *v8; // esi

  v3 = operator new(0x10u);
  if ( v3 )
  {
    v4 = malloc(2u);
    *v3 = v4;
    *v4 = 0;
    v5 = malloc(2u);
    v3[2] = v5;
    *v5 = 0;
  }
  else
  {
    v3 = 0;
  }
  v6 = *v3;
  *v3 = _wcsdup(a1);
  free(v6);
  v7 = v3[2];
  v3[2] = _wcsdup(a3);
  free(v7);
  if ( a2 )
    v3[1] = 1;
  else
    v3[1] = 0;
  v8 = v3[1];
  v3[3] = dword_12E4C78;
  dword_12E4C78 = v3;
  free(a1);
  free(a3);
  return v8;
}
// 12E4C78: using guessed type int dword_12E4C78;

//----- (01211290) --------------------------------------------------------
int __cdecl sub_1211290(wchar_t *a1, int a2)
{
  int v2; // esi
  int result; // eax
  void *v4; // ebx
  int v5; // esi

  v2 = dword_12E4C78;
  if ( dword_12E4C78 )
  {
    while ( _wcsicmp(a1, *v2) )
    {
      v2 = *(v2 + 12);
      if ( !v2 )
        goto LABEL_4;
    }
    v4 = *a2;
    *a2 = _wcsdup(*(v2 + 8));
    free(v4);
    LeaveCriticalSection(&stru_12E4C80);
    v5 = *(v2 + 4);
    free(a1);
    result = v5;
  }
  else
  {
LABEL_4:
    free(a1);
    result = 2;
  }
  return result;
}
// 12E4C78: using guessed type int dword_12E4C78;

//----- (01211310) --------------------------------------------------------
CSysProcItem *__thiscall sub_1211310(_DWORD *this, int *a2)
{
  CSysProcItem *result; // eax
  CSysProcItem *v3; // esi
  int *v4; // edi
  int v5; // eax

  result = CMapNode::NewNode_0(this);
  v3 = result;
  v4 = &result->dwPid;
  *&result->_Color = 0;
  if ( result != -16 )
  {
    v5 = *a2;
    *v4 = *a2;
    if ( v5 )
      InterlockedIncrement((v5 + 8));
    v4[1] = a2[1];
    result = v3;
  }
  return result;
}

//----- (01211350) --------------------------------------------------------
_DWORD *__thiscall sub_1211350(_DWORD *this)
{
  _DWORD *result; // eax

  this[2] = 0;
  result = this;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  return result;
}

//----- (012113D0) --------------------------------------------------------
void __thiscall sub_12113D0(_DWORD *this)
{
  _DWORD *v1; // edi
  _DWORD **v2; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // esi
  _DWORD **v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // esi

  v1 = this;
  v2 = this[4];
  v3 = *v2;
  *v2 = v2;
  *(v1[4] + 4) = v1[4];
  v1[5] = 0;
  if ( v3 != v1[4] )
  {
    do
    {
      v4 = *v3;
      j__free(v3);
      v3 = v4;
    }
    while ( v4 != v1[4] );
  }
  j__free(v1[4]);
  v5 = v1[2];
  v6 = *v5;
  *v5 = v5;
  *(v1[2] + 4) = v1[2];
  v1[3] = 0;
  if ( v6 != v1[2] )
  {
    do
    {
      v7 = *v6;
      j__free(v6);
      v6 = v7;
    }
    while ( v7 != v1[2] );
  }
  j__free(v1[2]);
}

//----- (01211450) --------------------------------------------------------
CSysProcItem *__thiscall sub_1211450(CSysProcItem *this)
{
  CSysProcItem *This; // edx
  CSysProcItem *Left; // eax
  CSysProcItem *iter; // ecx
  CSysProcItem *Right; // eax
  CSysProcItem *v6; // ecx

  This = this;
  Left = this->_Left;
  if ( this->_Left->_Isnil )
  {
    this->_Left = Left->_Right;
    return this;
  }
  iter = Left->_Left;
  if ( Left->_Left->_Isnil )
  {
    for ( iter = Left->_Parent; !iter->_Isnil; iter = iter->_Parent )
    {
      if ( This->_Left != iter->_Left )
        break;
      This->_Left = iter;
    }
    if ( This->_Left->_Isnil )
      return This;
    goto LABEL_11;
  }
  Right = iter->_Right;
  if ( Right->_Isnil )
  {
LABEL_11:
    This->_Left = iter;
    return This;
  }
  do
  {
    v6 = Right;
    Right = Right->_Right;
  }
  while ( !Right->_Isnil );
  This->_Left = v6;
  return This;
}

//----- (012114B0) --------------------------------------------------------
bool __stdcall sub_12114B0(void *a1, void *a2)
{
  const wchar_t *v2; // ecx
  const wchar_t *v3; // eax
  int v4; // eax
  LONG (__stdcall *v5)(volatile LONG *); // ecx
  bool v6; // bl

  if ( a2 )
    v2 = *a2;
  else
    v2 = 0;
  if ( a1 )
    v3 = *a1;
  else
    v3 = 0;
  v4 = _wcsicmp(v3, v2);
  v5 = InterlockedDecrement;
  v6 = v4 > 0;
  if ( a1 )
  {
    if ( !InterlockedDecrement(a1 + 2) && a1 )
    {
      if ( *a1 )
      {
        SysFreeString(*a1);
        *a1 = 0;
      }
      if ( *(a1 + 1) )
      {
        j_j__free(*(a1 + 1));
        *(a1 + 1) = 0;
      }
      j__free(a1);
    }
    v5 = InterlockedDecrement;
  }
  if ( a2 && !v5(a2 + 2) && a2 )
  {
    if ( *a2 )
    {
      SysFreeString(*a2);
      *a2 = 0;
    }
    if ( *(a2 + 1) )
    {
      j_j__free(*(a2 + 1));
      *(a2 + 1) = 0;
    }
    j__free(a2);
  }
  return v6;
}
// 128C4A8: using guessed type int (__stdcall *)(_DWORD);

//----- (01211590) --------------------------------------------------------
void __cdecl sub_1211590(char a1, int a2, OLECHAR *a3, OLECHAR *a4, OLECHAR *psz, int a6)
{
  _bstr_t *v6; // edi
  int *v7; // esi
  Data_t *v8; // eax
  _bstr_t **v9; // esi
  _DWORD *v10; // eax
  BSTR *v11; // [esp+10h] [ebp-24h]
  _bstr_t *v12; // [esp+14h] [ebp-20h]
  char v13; // [esp+18h] [ebp-1Ch]
  CComBSTR *ppv; // [esp+1Ch] [ebp-18h]
  _bstr_t *v15; // [esp+20h] [ebp-14h]
  char v16; // [esp+27h] [ebp-Dh]
  int v17; // [esp+30h] [ebp-4h]

  if ( !byte_12E4CCC )
    return;
  EnterCriticalSection(&stru_12E4C98);
  v6 = 0;
  v15 = 0;
  bstr_t::EqualAssign(&ppv, psz);
  v7 = *sub_1282F90(&stru_12E4CEC, &v12, &ppv);
  bstr_t::Data_t::Free(&ppv);
  v16 = 1;
  if ( a6 == 1 || v7 == stru_12E4CEC || (v6 = v7[5], v15 = v6, v8 = v6[1].m_Data, v8 == 6) || v8 == 5 )
  {
    if ( a6 != 2 )
    {
      if ( v6 )
      {
        v6->m_Data = CreateEventW(0, 1, 0, 0);
      }
      else
      {
        v10 = operator new(0x2Cu);
        if ( v10 )
          v6 = sub_1211350(v10);
        else
          v6 = 0;
        v15 = v6;
        if ( a1 )
          v6->m_Data = CreateEventW(0, 1, 0, 0);
        else
          v6->m_Data = 0;
        bstr_t::Assign(v6 + 5, psz);
        bstr_t::Assign(v6 + 2, a3);
        bstr_t::Assign(v6 + 3, a4);
        bstr_t::EqualAssign(&v11, psz);
        v12 = v6;
        v17 = 0;
        sub_1281650(&stru_12E4CEC, &v13, 0, &v11, byte_12E4CCD);
        v17 = -1;
        bstr_t::Data_t::Free(&v11);
      }
      v9 = a2;
      *a2 = v6;
      v6[1].m_Data = (3 - (a6 != 1));
      if ( a6 == 1 )
      {
        sub_1219380(&dword_12E4CFC, &v15);
        SetEvent(hEvent);
      }
      else
      {
        sub_12117F0(&dword_12E4CF4, &v15);
        SetEvent(dword_12E4CB8);
      }
      goto LABEL_8;
    }
  }
  else
  {
    v16 = 0;
  }
  v9 = a2;
LABEL_8:
  LeaveCriticalSection(&stru_12E4C98);
  if ( v16 )
  {
    if ( a1 )
    {
      WaitForSingleObject(v6->m_Data, 0xFFFFFFFF);
      CloseHandle(v6->m_Data);
    }
  }
  *v9 = v6;
}
// 12E4CCC: using guessed type char byte_12E4CCC;
// 12E4CCD: using guessed type char byte_12E4CCD;

//----- (01211780) --------------------------------------------------------
CSysProcItem *__cdecl std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>()
{
  CMapNode *result; // eax

  result = operator new(0x18u);
  JUMPOUT(result, 0, std::bad_alloc::bad_alloc);
  result->_Left = result;
  if ( result != -4 )
    result->_Parent = result;
  if ( result != -8 )
    result->_Right = result;
  *&result->_Color = 0x101;
  return result;
}

//----- (012117B0) --------------------------------------------------------
CMapNode *__thiscall CMapNode::NewNode_0(CMapNode *this)
{
  CMapNode *pthis; // esi
  CMapNode *v2; // edx

  pthis = this;
  v2 = operator new(0x18u);
  if ( !v2 )
    std::bad_alloc::bad_alloc();
  v2->_Left = pthis->_Left;
  if ( v2 != -4 )
    v2->_Parent = pthis->_Left;
  if ( v2 != -8 )
    v2->_Right = pthis->_Left;
  return v2;
}

//----- (012117F0) --------------------------------------------------------
_DWORD *__thiscall sub_12117F0(int **this, _DWORD *a2)
{
  int **v2; // esi
  int v3; // edi
  _DWORD *v4; // edx
  int *v5; // eax
  _DWORD *result; // eax

  v2 = this;
  v3 = **this;
  v4 = sub_1281420(**this, *(v3 + 4), a2);
  v5 = v2[1];
  if ( (357913940 - v5) < 1 )
    std::_Xlength_error("list<T> too long");
  v2[1] = (v5 + 1);
  *(v3 + 4) = v4;
  result = v4[1];
  *result = v4;
  return result;
}

//----- (01211840) --------------------------------------------------------
void *__cdecl sub_1211840(int a1)
{
  void *v1; // eax

  v1 = sub_1211860(a1, 0xFFFFFFFF, 1);
  return sub_1211860(a1, v1, 0);
}

//----- (01211860) --------------------------------------------------------
void *__cdecl sub_1211860(int a1, void *a2, char a3)
{
  BOOL v3; // esi
  __int16 *v4; // edi
  __int16 v5; // ax
  __int16 *v6; // ecx
  __int16 v7; // ax
  FILE *v8; // eax
  FILE *v9; // edi
  int v10; // eax
  wchar_t *v11; // ebx
  wchar_t *i; // esi
  int v13; // eax
  int v14; // edx
  char *v15; // ecx
  int v16; // edi
  const wchar_t *v17; // ST60_4
  void *v18; // esi
  int v19; // edi
  int v20; // ST54_4
  int v21; // edi
  const wchar_t **v22; // eax
  void *v23; // esi
  int v24; // esi
  char v25; // bl
  int v27; // [esp+10h] [ebp-C9Ch]
  void *v28; // [esp+14h] [ebp-C98h]
  int v29; // [esp+18h] [ebp-C94h]
  void *v30; // [esp+1Ch] [ebp-C90h]
  unsigned int v31; // [esp+20h] [ebp-C8Ch]
  void *v32; // [esp+24h] [ebp-C88h]
  void *v33; // [esp+28h] [ebp-C84h]
  FILE *v34; // [esp+2Ch] [ebp-C80h]
  void *v35; // [esp+30h] [ebp-C7Ch]
  void *v36; // [esp+34h] [ebp-C78h]
  void *v37; // [esp+38h] [ebp-C74h]
  int v38; // [esp+3Ch] [ebp-C70h]
  void *v39; // [esp+40h] [ebp-C6Ch]
  void *v40; // [esp+44h] [ebp-C68h]
  void *v41; // [esp+48h] [ebp-C64h]
  void *v42; // [esp+4Ch] [ebp-C60h]
  int v43; // [esp+50h] [ebp-C5Ch]
  int v44; // [esp+54h] [ebp-C58h]
  BOOL v45; // [esp+5Ch] [ebp-C50h]
  void *v46; // [esp+60h] [ebp-C4Ch]
  void *v47; // [esp+64h] [ebp-C48h]
  void *v48; // [esp+68h] [ebp-C44h]
  void *v49; // [esp+6Ch] [ebp-C40h]
  void *v50; // [esp+70h] [ebp-C3Ch]
  void *v51; // [esp+74h] [ebp-C38h]
  void *v52; // [esp+78h] [ebp-C34h]
  void *v53; // [esp+7Ch] [ebp-C30h]
  void *v54; // [esp+80h] [ebp-C2Ch]
  wchar_t *v55; // [esp+84h] [ebp-C28h]
  void *v56; // [esp+88h] [ebp-C24h]
  wchar_t v57; // [esp+8Ch] [ebp-C20h]
  char v58; // [esp+94h] [ebp-C18h]
  wchar_t v59; // [esp+96h] [ebp-C16h]
  __int16 v60; // [esp+88Ah] [ebp-422h]
  WCHAR Buffer; // [esp+88Ch] [ebp-420h]
  int v62; // [esp+CA8h] [ebp-4h]

  v29 = a1;
  v46 = malloc(2u);
  *v46 = 0;
  v62 = 0;
  v41 = malloc(2u);
  *v41 = 0;
  v56 = malloc(2u);
  *v56 = 0;
  v47 = malloc(2u);
  *v47 = 0;
  v3 = 0;
  v45 = 0;
  v40 = malloc(2u);
  *v40 = 0;
  LOBYTE(v62) = 4;
  GetWindowsDirectoryW(&Buffer, 0x208u);
  if ( a3 )
  {
    v6 = &v60;
    do
    {
      v7 = v6[1];
      ++v6;
    }
    while ( v7 );
    *v6 = *L"\\win.ini";
    *(v6 + 1) = *L"in.ini";
    *(v6 + 2) = *L".ini";
    *(v6 + 3) = *L"ni";
    v6[8] = aWinIni[8];
  }
  else
  {
    v4 = &v60;
    do
    {
      v5 = v4[1];
      ++v4;
    }
    while ( v5 );
    qmemcpy(v4, L"\\AutorunsDisabled.ini", 0x2Cu);
    v3 = 0;
  }
  if ( a2 == -1 )
  {
    v49 = _wcsdup(gpszTargetName);
    v48 = _wcsdup(gpszTargetName);
    v50 = _wcsdup(gpszTargetName);
    v53 = _wcsdup(gpszTargetName);
    v52 = _wcsdup(gpszTargetName);
    v51 = _wcsdup(gpszTargetName);
    v54 = _wcsdup(&Buffer);
    v55 = _wcsdup(&Buffer);
    LOBYTE(v62) = 12;
    a2 = sub_11F3FF0(a1, 2, 0xFFFFFFFF, 0, &v55, &v54, &v51);
    free(v55);
    free(v54);
    free(v51);
    free(v52);
    free(v53);
    free(v50);
    free(v48);
    LOBYTE(v62) = 4;
    free(v49);
  }
  v8 = _wfopen(&Buffer, L"rt");
  v9 = v8;
  v34 = v8;
  if ( v8 )
  {
    if ( fgetws(&v57, 1024, v8) )
    {
      do
      {
        if ( v57 == 91 )
        {
          v10 = _wcsnicmp(&v57, L"[windows]", 9u);
          v3 = v10 == 0;
          v45 = v10 == 0;
        }
        else if ( v3 )
        {
          if ( !_wcsnicmp(&v57, L"load=", 5u) )
          {
            v11 = &v59;
LABEL_19:
            v55 = v11;
            for ( i = wcschr(v11, 0); i > v11; *i = 0 )
            {
              v13 = *(i - 1);
              --i;
              if ( !isspace(v13) )
                break;
            }
            v42 = 0;
            v43 = 0;
            v44 = 0;
            LOBYTE(v62) = 13;
            sub_11F6DD0(v11, 44, &v42, 0);
            v14 = v43;
            v15 = v42;
            v31 = 0;
            if ( (v43 - v42) >> 4 )
            {
              v16 = 0;
              v38 = 0;
              do
              {
                v17 = *&v15[v16];
                v18 = v47;
                v19 = &v15[v16];
                v47 = _wcsdup(v17);
                free(v18);
                v20 = v19;
                v21 = v29;
                v22 = sub_11F4EE0(&v28, v29, v20, 0);
                v23 = v56;
                v56 = _wcsdup(*v22);
                free(v23);
                free(v28);
                if ( *v56 )
                {
                  v24 = sub_11F4ED0();
                  v50 = _wcsdup(&Buffer);
                  v48 = _wcsdup(&Buffer);
                  v49 = _wcsdup(v11);
                  LOBYTE(v62) = 16;
                  v25 = sub_11F3D40(v21, &v49, &v48, &v50, &v56, &v46, &v40, &v27);
                  free(v49);
                  free(v48);
                  LOBYTE(v62) = 13;
                  free(v50);
                  if ( v25 )
                  {
                    if ( a2 == -1 )
                    {
                      v37 = _wcsdup(gpszTargetName);
                      v30 = _wcsdup(gpszTargetName);
                      v32 = _wcsdup(gpszTargetName);
                      v39 = _wcsdup(gpszTargetName);
                      v54 = _wcsdup(gpszTargetName);
                      v51 = _wcsdup(gpszTargetName);
                      v52 = _wcsdup(&Buffer);
                      v53 = _wcsdup(&Buffer);
                      LOBYTE(v62) = 24;
                      a2 = sub_11F3FF0(v21, 2, 0xFFFFFFFF, 0, &v53, &v52, &v51);
                      free(v53);
                      free(v52);
                      free(v51);
                      free(v54);
                      free(v39);
                      free(v32);
                      free(v30);
                      free(v37);
                    }
                    v35 = _wcsdup(gpszTargetName);
                    v33 = _wcsdup(&Buffer);
                    v11 = v55;
                    v36 = _wcsdup(v55);
                    LOBYTE(v62) = 27;
                    sub_11F3FF0(v21, v24, a2, 4, &v36, &v33, &v56);
                    free(v36);
                    free(v33);
                    LOBYTE(v62) = 13;
                    free(v35);
                  }
                  else
                  {
                    v11 = v55;
                  }
                }
                v14 = v43;
                v15 = v42;
                v16 = v38 + 16;
                ++v31;
                v38 += 16;
              }
              while ( v31 < (v43 - v42) >> 4 );
              v9 = v34;
            }
            LOBYTE(v62) = 4;
            if ( v15 )
            {
              sub_11F2BF0(v15, v14);
              j__free(v42);
              v42 = 0;
              v43 = 0;
              v44 = 0;
            }
            v3 = v45;
            continue;
          }
          if ( !_wcsnicmp(&v57, L"run=", 4u) )
          {
            v11 = &v58;
            goto LABEL_19;
          }
        }
      }
      while ( fgetws(&v57, 1024, v9) );
    }
    fclose(v9);
  }
  free(v40);
  free(v47);
  free(v56);
  free(v41);
  free(v46);
  return a2;
}
// 12B2C50: using guessed type wchar_t aAutorunsdisabl_1[22];
// 12B2C7C: using guessed type wchar_t aWinIni[9];

//----- (01212060) --------------------------------------------------------
void __cdecl sub_1212060(int a1, void *a2, void *a3)
{
  _WORD *v3; // ST50_4
  void *v4; // esi
  void *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // ST54_4

  v3 = malloc(2u);
  *v3 = 0;
  v4 = a3;
  v5 = sub_1212110(a1, a2, *a3, 0xFFFFFFFF);
  v6 = sub_11F22B0(&a3, v4, L"\\AutorunsDisabled");
  v7 = _wcsdup(*v6);
  free(v3);
  free(a3);
  sub_1212110(a1, a2, v7, v5);
  free(v7);
}

//----- (01212110) --------------------------------------------------------
void *__cdecl sub_1212110(int a1, void *a2, wchar_t *psz, void *a4)
{
  DWORD v4; // ebx
  WCHAR *v5; // eax
  WCHAR *v6; // eax
  unsigned __int16 **v7; // esi
  unsigned __int16 **v8; // eax
  unsigned int v9; // eax
  OLECHAR *v10; // esi
  unsigned int v11; // eax
  void *v12; // esi
  const wchar_t **v13; // eax
  void *v14; // esi
  WCHAR *v15; // ecx
  WCHAR *v16; // eax
  unsigned __int16 **v17; // esi
  unsigned __int16 **v18; // eax
  char v19; // bl
  WCHAR *v20; // eax
  WCHAR *v21; // eax
  void *v22; // ebx
  unsigned __int16 **v23; // esi
  unsigned __int16 **v24; // eax
  WCHAR *v25; // eax
  unsigned __int16 **v26; // eax
  int v28; // [esp+10h] [ebp-A0h]
  int v29; // [esp+14h] [ebp-9Ch]
  int v30; // [esp+18h] [ebp-98h]
  int v31; // [esp+1Ch] [ebp-94h]
  void *v32; // [esp+20h] [ebp-90h]
  void *v33; // [esp+24h] [ebp-8Ch]
  void *v34; // [esp+28h] [ebp-88h]
  int v35; // [esp+2Ch] [ebp-84h]
  void *v36; // [esp+30h] [ebp-80h]
  int v37; // [esp+34h] [ebp-7Ch]
  void *v38; // [esp+38h] [ebp-78h]
  void *v39; // [esp+3Ch] [ebp-74h]
  DWORD v40; // [esp+40h] [ebp-70h]
  void *v41; // [esp+44h] [ebp-6Ch]
  HKEY hKey; // [esp+48h] [ebp-68h]
  void *v43; // [esp+4Ch] [ebp-64h]
  void *v44; // [esp+50h] [ebp-60h]
  void *v45; // [esp+54h] [ebp-5Ch]
  void *v46; // [esp+58h] [ebp-58h]
  void *v47; // [esp+5Ch] [ebp-54h]
  void *v48; // [esp+60h] [ebp-50h]
  wchar_t *v49; // [esp+64h] [ebp-4Ch]
  void *v50; // [esp+68h] [ebp-48h]
  HKEY v51; // [esp+6Ch] [ebp-44h]
  void *v52; // [esp+70h] [ebp-40h]
  void *v53; // [esp+74h] [ebp-3Ch]
  void *v54; // [esp+78h] [ebp-38h]
  void *v55; // [esp+7Ch] [ebp-34h]
  void *v56; // [esp+80h] [ebp-30h]
  void *v57; // [esp+84h] [ebp-2Ch]
  void *v58; // [esp+88h] [ebp-28h]
  void *v59; // [esp+8Ch] [ebp-24h]
  void *v60; // [esp+90h] [ebp-20h]
  void *v61; // [esp+94h] [ebp-1Ch]
  void *v62; // [esp+98h] [ebp-18h]
  void *v63; // [esp+9Ch] [ebp-14h]
  OLECHAR *v64; // [esp+A0h] [ebp-10h]
  int v65; // [esp+ACh] [ebp-4h]

  v4 = 0;
  v40 = 0;
  v49 = malloc(2u);
  *v49 = 0;
  v65 = 0;
  v63 = malloc(2u);
  *v63 = 0;
  v50 = malloc(2u);
  *v50 = 0;
  v47 = malloc(2u);
  *v47 = 0;
  v45 = malloc(2u);
  *v45 = 0;
  v46 = malloc(2u);
  *v46 = 0;
  LOBYTE(v65) = 5;
  if ( a4 == -1 )
  {
    v56 = _wcsdup(gpszTargetName);
    v62 = _wcsdup(gpszTargetName);
    v53 = _wcsdup(gpszTargetName);
    v55 = _wcsdup(gpszTargetName);
    v57 = _wcsdup(gpszTargetName);
    v59 = _wcsdup(gpszTargetName);
    v61 = _wcsdup(gpszTargetName);
    v5 = gpszTargetName;
    if ( psz )
      v5 = psz;
    v60 = _wcsdup(v5);
    v54 = _wcsdup(gpszTargetName);
    v6 = gpszTargetName;
    if ( psz )
      v6 = psz;
    v58 = _wcsdup(v6);
    LOBYTE(v65) = 15;
    v7 = sub_11F7BE0(&v48, a2, &v60, &v61);
    LOBYTE(v65) = 16;
    v8 = sub_11F7BE0(&v52, a2, &v58, &v54);
    LOBYTE(v65) = 17;
    a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v8, v7, &v59);
    free(v52);
    free(v48);
    free(v58);
    free(v54);
    free(v60);
    free(v61);
    free(v59);
    free(v57);
    free(v55);
    free(v53);
    free(v62);
    LOBYTE(v65) = 5;
    free(v56);
  }
  v9 = TlsGetValue(gdwTlsIndex);
  if ( !sub_11F67A0(ghKLM, psz, 0, v9 | 0x20019, &v51) )
  {
    v64 = malloc(2u);
    *v64 = 0;
    LOBYTE(v65) = 18;
    if ( !sub_12013D0(v51, 0, &v64) )
    {
      do
      {
        v10 = v64;
        v11 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v51, v10, 0, v11 | 0x20019, &hKey) )
        {
          if ( !sub_1201520(hKey, L"Dllname", 0, 0, &v49) )
          {
            v28 = malloc(2u);
            *v28 = 0;
            v29 = 0;
            v30 = 0;
            v31 = 0;
            LOBYTE(v65) = 19;
            sub_11F7040(v49, &v28);
            v12 = v50;
            v50 = _wcsdup(v49);
            free(v12);
            v13 = sub_11F4EE0(&v36, a1, &v28, 0);
            v14 = v63;
            v63 = _wcsdup(*v13);
            free(v14);
            free(v36);
            v35 = sub_11F4ED0();
            v15 = gpszTargetName;
            if ( psz )
              v15 = psz;
            v53 = _wcsdup(v15);
            v62 = _wcsdup(gpszTargetName);
            v16 = gpszTargetName;
            if ( psz )
              v16 = psz;
            v56 = _wcsdup(v16);
            LOBYTE(v65) = 22;
            v17 = sub_11F7BE0(&v39, a2, &v53, &v64);
            LOBYTE(v65) = 23;
            v18 = sub_11F7BE0(&v34, a2, &v56, &v62);
            LOBYTE(v65) = 24;
            v19 = sub_11F3D40(a1, &v64, v18, v17, &v63, &v47, &v46, &v37);
            free(v34);
            free(v39);
            free(v56);
            free(v62);
            free(v53);
            if ( v19 )
            {
              if ( a4 == -1 )
              {
                v43 = _wcsdup(gpszTargetName);
                v41 = _wcsdup(gpszTargetName);
                v44 = _wcsdup(gpszTargetName);
                v58 = _wcsdup(gpszTargetName);
                v54 = _wcsdup(gpszTargetName);
                v60 = _wcsdup(gpszTargetName);
                v61 = _wcsdup(gpszTargetName);
                v20 = gpszTargetName;
                if ( psz )
                  v20 = psz;
                v59 = _wcsdup(v20);
                v57 = _wcsdup(gpszTargetName);
                v21 = gpszTargetName;
                if ( psz )
                  v21 = psz;
                v55 = _wcsdup(v21);
                v22 = a2;
                LOBYTE(v65) = 34;
                v23 = sub_11F7BE0(&v38, a2, &v59, &v61);
                LOBYTE(v65) = 35;
                v24 = sub_11F7BE0(&v32, a2, &v55, &v57);
                LOBYTE(v65) = 36;
                a4 = sub_11F3FF0(a1, 0, 0xFFFFFFFF, 0, v24, v23, &v60);
                free(v32);
                free(v38);
                free(v55);
                free(v57);
                free(v59);
                free(v61);
                free(v60);
                free(v54);
                free(v58);
                free(v44);
                free(v41);
                free(v43);
              }
              else
              {
                v22 = a2;
              }
              v52 = _wcsdup(gpszTargetName);
              v25 = gpszTargetName;
              if ( psz )
                v25 = psz;
              v48 = _wcsdup(v25);
              LOBYTE(v65) = 38;
              v26 = sub_11F7BE0(&v33, v22, &v48, &v64);
              LOBYTE(v65) = 39;
              sub_11F3FF0(a1, v35, a4, 3, &v64, v26, &v63);
              free(v33);
              free(v48);
              free(v52);
            }
            LOBYTE(v65) = 18;
            sub_11F21F0(&v28);
            v4 = v40;
          }
          RegCloseKey(hKey);
        }
        v40 = ++v4;
      }
      while ( !sub_12013D0(v51, v4, &v64) );
    }
    RegCloseKey(v51);
    free(v64);
  }
  free(v46);
  free(v45);
  free(v47);
  free(v50);
  free(v63);
  free(v49);
  return a4;
}

//----- (012127D0) --------------------------------------------------------
void __cdecl sub_12127D0(int a1, OLECHAR *psz)
{
  _WORD *v2; // edi
  _WORD *v3; // ebx
  _WORD *v4; // esi
  unsigned __int16 **v5; // eax
  int v6; // edi
  DWORD v7; // ebx
  const WCHAR *v8; // esi
  unsigned int v9; // eax
  const wchar_t **v10; // eax
  void *v11; // esi
  wchar_t *v12; // esi
  wchar_t *v13; // eax
  const wchar_t **v14; // eax
  wchar_t *v15; // esi
  HINSTANCE v16; // eax
  unsigned __int16 **v17; // esi
  unsigned __int16 **v18; // eax
  unsigned __int16 **v19; // esi
  unsigned __int16 **v20; // eax
  unsigned __int16 **v21; // eax
  int v22; // [esp+10h] [ebp-2D4h]
  int v23; // [esp+14h] [ebp-2D0h]
  int v24; // [esp+18h] [ebp-2CCh]
  int v25; // [esp+1Ch] [ebp-2C8h]
  void *v26; // [esp+20h] [ebp-2C4h]
  HMODULE hLibModule; // [esp+24h] [ebp-2C0h]
  LPWSTR ppsz; // [esp+28h] [ebp-2BCh]
  void *v29; // [esp+2Ch] [ebp-2B8h]
  void *v30; // [esp+30h] [ebp-2B4h]
  _WORD *v31; // [esp+34h] [ebp-2B0h]
  int v32; // [esp+38h] [ebp-2ACh]
  _WORD *v33; // [esp+3Ch] [ebp-2A8h]
  void *v34; // [esp+40h] [ebp-2A4h]
  _WORD *v35; // [esp+44h] [ebp-2A0h]
  void *v36; // [esp+48h] [ebp-29Ch]
  void *v37; // [esp+4Ch] [ebp-298h]
  int v38; // [esp+50h] [ebp-294h]
  BYTE Data[4]; // [esp+54h] [ebp-290h]
  void *v40; // [esp+58h] [ebp-28Ch]
  void *v41; // [esp+5Ch] [ebp-288h]
  void *v42; // [esp+60h] [ebp-284h]
  HKEY hKey; // [esp+64h] [ebp-280h]
  void *v44; // [esp+68h] [ebp-27Ch]
  void *v45; // [esp+6Ch] [ebp-278h]
  void *v46; // [esp+70h] [ebp-274h]
  void *v47; // [esp+74h] [ebp-270h]
  void *v48; // [esp+78h] [ebp-26Ch]
  DWORD cbData; // [esp+7Ch] [ebp-268h]
  wchar_t *v50; // [esp+80h] [ebp-264h]
  void *v51; // [esp+84h] [ebp-260h]
  UINT uID; // [esp+88h] [ebp-25Ch]
  HKEY phkResult; // [esp+8Ch] [ebp-258h]
  void *v54; // [esp+90h] [ebp-254h]
  void *v55; // [esp+94h] [ebp-250h]
  void *v56; // [esp+98h] [ebp-24Ch]
  void *v57; // [esp+9Ch] [ebp-248h]
  void *v58; // [esp+A0h] [ebp-244h]
  void *v59; // [esp+A4h] [ebp-240h]
  void *v60; // [esp+A8h] [ebp-23Ch]
  char v61; // [esp+AFh] [ebp-235h]
  void *v62; // [esp+B0h] [ebp-234h]
  LPCWSTR lpSubKey; // [esp+B4h] [ebp-230h]
  wchar_t *v64; // [esp+B8h] [ebp-22Ch]
  BYTE v65; // [esp+BCh] [ebp-228h]
  WCHAR Buffer; // [esp+CCh] [ebp-218h]
  int v67; // [esp+2E0h] [ebp-4h]

  uID = a1;
  v67 = 0;
  v62 = malloc(2u);
  *v62 = 0;
  v2 = malloc(2u);
  v35 = v2;
  *v2 = 0;
  v3 = malloc(2u);
  v33 = v3;
  *v3 = 0;
  v57 = malloc(2u);
  *v57 = 0;
  v44 = malloc(2u);
  *v44 = 0;
  v46 = malloc(2u);
  *v46 = 0;
  v4 = malloc(2u);
  v31 = v4;
  *v4 = 0;
  v50 = malloc(2u);
  *v50 = 0;
  v54 = _wcsdup(gpszTargetName);
  v56 = _wcsdup(gpszTargetName);
  v59 = _wcsdup(gpszTargetName);
  v58 = _wcsdup(gpszTargetName);
  v51 = _wcsdup(gpszTargetName);
  v55 = _wcsdup(gpszTargetName);
  v60 = _wcsdup(gpszTargetName);
  v64 = _wcsdup(gpszTargetName);
  LOBYTE(v67) = 16;
  v45 = sub_11F7BE0(&v48, 0x80000002, &psz, &v60);
  LOBYTE(v67) = 17;
  v5 = sub_11F7BE0(&v47, 0x80000002, &psz, &v64);
  LOBYTE(v67) = 18;
  v42 = sub_11F3FF0(uID, 0, 0xFFFFFFFF, 0, v5, v45, &v55);
  free(v47);
  free(v48);
  free(v64);
  free(v60);
  free(v55);
  free(v51);
  free(v58);
  free(v59);
  free(v56);
  LOBYTE(v67) = 8;
  free(v54);
  if ( sub_11F67A0(ghKLM, psz, 0, 131097, &hKey) )
  {
    free(v50);
    free(v4);
    free(v46);
    free(v44);
    free(v57);
    free(v3);
    free(v2);
    free(v62);
  }
  else
  {
    lpSubKey = malloc(2u);
    *lpSubKey = 0;
    LOBYTE(v67) = 19;
    if ( !sub_12013D0(hKey, 0, &lpSubKey) )
    {
      v6 = uID;
      v7 = 0;
      do
      {
        v8 = lpSubKey;
        v9 = TlsGetValue(gdwTlsIndex);
        if ( !RegOpenKeyExW(hKey, v8, 0, v9 | 0x20019, &phkResult) )
        {
          cbData = 0;
          if ( !sub_1201520(phkResult, L"LibraryPath", 0, 0, &v50) )
          {
            v45 = _wcsdup(v50);
            v22 = malloc(2u);
            *v22 = 0;
            v23 = 0;
            v24 = 0;
            v25 = 0;
            LOBYTE(v67) = 21;
            sub_11F7040(v50, &v22);
            v10 = sub_11F4EE0(&v26, v6, &v22, 0);
            v11 = v62;
            v62 = _wcsdup(*v10);
            free(v11);
            free(v26);
            v38 = sub_11F4ED0();
            v64 = _wcsdup(lpSubKey);
            LOBYTE(v67) = 22;
            if ( !sub_1201520(phkResult, L"DisplayString", 0, 0, &v64) && *v64 == 64 )
            {
              v12 = _wcsdup(v64);
              v41 = v12;
              LOBYTE(v67) = 23;
              uID = 0;
              if ( wcschr(v12, 0x2Cu) )
              {
                v13 = wcschr(v12, 0x2Cu);
                *v13 = 0;
                uID = abs(_wtoi(v13 + 1));
              }
              v14 = GetEnvironmentPathInfo(&ppsz, v12 + 1);
              v15 = _wcsdup(*v14);
              free(v41);
              free(ppsz);
              v16 = LoadLibraryExW(v15, 0, 2u);
              hLibModule = v16;
              if ( v16 )
              {
                if ( LoadStringW(v16, uID, &Buffer, 260) )
                {
                  v41 = v64;
                  v64 = _wcsdup(&Buffer);
                  free(v41);
                }
                FreeLibrary(hLibModule);
              }
              free(v15);
            }
            cbData = 4;
            RegQueryValueExW(phkResult, L"Enabled", 0, 0, Data, &cbData);
            cbData = 16;
            if ( !RegQueryValueExW(phkResult, L"ProviderId", 0, 0, &v65, &cbData) )
            {
              v54 = _wcsdup(gpszTargetName);
              LOBYTE(v67) = 24;
              v17 = sub_11F7BE0(&v30, 0x80000002, &psz, &lpSubKey);
              LOBYTE(v67) = 25;
              v18 = sub_11F7BE0(&v36, 0x80000002, &psz, &v54);
              LOBYTE(v67) = 26;
              v61 = sub_11F3D40(v6, &lpSubKey, v18, v17, &v62, &v57, &v46, &v32);
              free(v36);
              free(v30);
              free(v54);
              if ( v61 )
              {
                if ( v42 == -1 )
                {
                  v48 = _wcsdup(gpszTargetName);
                  v40 = _wcsdup(gpszTargetName);
                  v60 = _wcsdup(gpszTargetName);
                  v55 = _wcsdup(gpszTargetName);
                  v51 = _wcsdup(gpszTargetName);
                  v58 = _wcsdup(gpszTargetName);
                  v59 = _wcsdup(gpszTargetName);
                  v56 = _wcsdup(gpszTargetName);
                  LOBYTE(v67) = 34;
                  v19 = sub_11F7BE0(&v29, 0x80000002, &psz, &v59);
                  LOBYTE(v67) = 35;
                  v20 = sub_11F7BE0(&v34, 0x80000002, &psz, &v56);
                  LOBYTE(v67) = 36;
                  v42 = sub_11F3FF0(v6, 0, 0xFFFFFFFF, 0, v20, v19, &v58);
                  free(v34);
                  free(v29);
                  free(v56);
                  free(v59);
                  free(v58);
                  free(v51);
                  free(v55);
                  free(v60);
                  free(v40);
                  free(v48);
                }
                v47 = _wcsdup(gpszTargetName);
                LOBYTE(v67) = 37;
                v21 = sub_11F7BE0(&v37, 0x80000002, &psz, &lpSubKey);
                LOBYTE(v67) = 38;
                sub_11F3FF0(v6, v38, v42, 16, &v64, v21, &v62);
                free(v37);
                free(v47);
              }
            }
            free(v64);
            sub_11F21F0(&v22);
            LOBYTE(v67) = 19;
            free(v45);
          }
          RegCloseKey(phkResult);
        }
        ++v7;
      }
      while ( !sub_12013D0(hKey, v7, &lpSubKey) );
      v2 = v35;
      v3 = v33;
      v4 = v31;
    }
    RegCloseKey(hKey);
    free(lpSubKey);
    free(v50);
    free(v4);
    free(v46);
    free(v44);
    free(v57);
    free(v3);
    free(v2);
    free(v62);
  }
  free(psz);
}

//----- (01213190) --------------------------------------------------------
void __cdecl sub_1213190(int a1, OLECHAR *psz)
{
  _WORD *v2; // edi
  _WORD *v3; // ebx
  _WORD *v4; // esi
  unsigned __int16 **v5; // eax
  void *v6; // edi
  DWORD v7; // ebx
  OLECHAR *v8; // esi
  unsigned int v9; // eax
  BSTR *v10; // eax
  WCHAR *v11; // eax
  void *v12; // esi
  const wchar_t **v13; // eax
  void *v14; // esi
  wchar_t *v15; // esi
  wchar_t *v16; // eax
  const wchar_t **v17; // eax
  wchar_t *v18; // esi
  HINSTANCE v19; // eax
  unsigned __int16 **v20; // esi
  unsigned __int16 **v21; // eax
  unsigned __int16 **v22; // esi
  unsigned __int16 **v23; // eax
  unsigned __int16 **v24; // eax
  int v25; // [esp+10h] [ebp-63Ch]
  int v26; // [esp+14h] [ebp-638h]
  int v27; // [esp+18h] [ebp-634h]
  int v28; // [esp+1Ch] [ebp-630h]
  DWORD cbData; // [esp+20h] [ebp-62Ch]
  LPWSTR ppsz; // [esp+24h] [ebp-628h]
  void *v31; // [esp+28h] [ebp-624h]
  void *v32; // [esp+2Ch] [ebp-620h]
  void *v33; // [esp+30h] [ebp-61Ch]
  _WORD *v34; // [esp+34h] [ebp-618h]
  int v35; // [esp+38h] [ebp-614h]
  _WORD *v36; // [esp+3Ch] [ebp-610h]
  void *v37; // [esp+40h] [ebp-60Ch]
  _WORD *v38; // [esp+44h] [ebp-608h]
  void *v39; // [esp+48h] [ebp-604h]
  void *v40; // [esp+4Ch] [ebp-600h]
  int v41; // [esp+50h] [ebp-5FCh]
  HMODULE hLibModule; // [esp+54h] [ebp-5F8h]
  void *v43; // [esp+58h] [ebp-5F4h]
  void *v44; // [esp+5Ch] [ebp-5F0h]
  void *v45; // [esp+60h] [ebp-5ECh]
  void *v46; // [esp+64h] [ebp-5E8h]
  void *v47; // [esp+68h] [ebp-5E4h]
  HKEY hKey; // [esp+6Ch] [ebp-5E0h]
  void *v49; // [esp+70h] [ebp-5DCh]
  HKEY v50; // [esp+74h] [ebp-5D8h]
  void *v51; // [esp+78h] [ebp-5D4h]
  void *v52; // [esp+7Ch] [ebp-5D0h]
  void *v53; // [esp+80h] [ebp-5CCh]
  void *v54; // [esp+84h] [ebp-5C8h]
  void *v55; // [esp+88h] [ebp-5C4h]
  void *v56; // [esp+8Ch] [ebp-5C0h]
  void *v57; // [esp+90h] [ebp-5BCh]
  void *v58; // [esp+94h] [ebp-5B8h]
  void *v59; // [esp+98h] [ebp-5B4h]
  void *v60; // [esp+9Ch] [ebp-5B0h]
  UINT uID; // [esp+A0h] [ebp-5ACh]
  void *v62; // [esp+A4h] [ebp-5A8h]
  wchar_t *v63; // [esp+A8h] [ebp-5A4h]
  void *v64; // [esp+ACh] [ebp-5A0h]
  char v65; // [esp+B3h] [ebp-599h]
  wchar_t *v66; // [esp+B4h] [ebp-598h]
  wchar_t *v67; // [esp+B8h] [ebp-594h]
  BYTE Data; // [esp+BCh] [ebp-590h]
  WCHAR Buffer; // [esp+434h] [ebp-218h]
  int v70; // [esp+648h] [ebp-4h]

  v59 = a1;
  v70 = 0;
  v64 = malloc(2u);
  *v64 = 0;
  v2 = malloc(2u);
  v38 = v2;
  *v2 = 0;
  v3 = malloc(2u);
  v36 = v3;
  *v3 = 0;
  v55 = malloc(2u);
  *v55 = 0;
  v52 = malloc(2u);
  *v52 = 0;
  v49 = malloc(2u);
  *v49 = 0;
  v4 = malloc(2u);
  v34 = v4;
  *v4 = 0;
  v44 = malloc(2u);
  *v44 = 0;
  uID = _wcsdup(gpszTargetName);
  v58 = _wcsdup(gpszTargetName);
  v56 = _wcsdup(gpszTargetName);
  v60 = _wcsdup(gpszTargetName);
  v62 = _wcsdup(gpszTargetName);
  v57 = _wcsdup(gpszTargetName);
  v67 = _wcsdup(gpszTargetName);
  v63 = _wcsdup(gpszTargetName);
  LOBYTE(v70) = 16;
  v51 = sub_11F7BE0(&v54, 0x80000002, &psz, &v67);
  LOBYTE(v70) = 17;
  v5 = sub_11F7BE0(&v53, 0x80000002, &psz, &v63);
  LOBYTE(v70) = 18;
  v46 = sub_11F3FF0(v59, 0, 0xFFFFFFFF, 0, v5, v51, &v57);
  free(v53);
  free(v54);
  free(v63);
  free(v67);
  free(v57);
  free(v62);
  free(v60);
  free(v56);
  free(v58);
  LOBYTE(v70) = 8;
  free(uID);
  if ( sub_11F67A0(ghKLM, psz, 0, 131097, &v50) )
  {
    free(v44);
    free(v4);
    free(v49);
    free(v52);
    free(v55);
    free(v3);
    free(v2);
    free(v64);
  }
  else
  {
    v66 = malloc(2u);
    *v66 = 0;
    LOBYTE(v70) = 19;
    if ( !sub_12013D0(v50, 0, &v66) )
    {
      v6 = v59;
      v7 = 0;
      do
      {
        v8 = v66;
        v9 = TlsGetValue(gdwTlsIndex);
        if ( !sub_11F67A0(v50, v8, 0, v9 | 0x20019, &hKey) )
        {
          cbData = 888;
          if ( !RegQueryValueExW(hKey, L"PackedCatalogItem", 0, 0, &Data, &cbData) )
          {
            v10 = *CComBSTR::AssignA(&v59, &Data);
            if ( !v10 || (v11 = *v10) == 0 )
              v11 = gpszTargetName;
            v63 = _wcsdup(v11);
            v12 = v59;
            if ( v59 )
            {
              if ( !InterlockedDecrement(v59 + 2) && v12 )
              {
                if ( *v12 )
                {
                  SysFreeString(*v12);
                  *v12 = 0;
                }
                if ( *(v12 + 1) )
                {
                  j_j__free(*(v12 + 1));
                  *(v12 + 1) = 0;
                }
                j__free(v12);
              }
              v59 = 0;
            }
            v25 = malloc(2u);
            *v25 = 0;
            v26 = 0;
            v27 = 0;
            v28 = 0;
            LOBYTE(v70) = 21;
            sub_11F6CC0(v63, &v25);
            v13 = sub_11F4EE0(&v31, v6, &v25, 0);
            v14 = v64;
            v64 = _wcsdup(*v13);
            free(v14);
            free(v31);
            v41 = sub_11F4ED0();
            v67 = _wcsdup(v66);
            LOBYTE(v70) = 22;
            if ( !sub_1201520(hKey, L"ProtocolName", 0, 0, &v67) && *v67 == 64 )
            {
              v15 = _wcsdup(v67);
              v47 = v15;
              LOBYTE(v70) = 23;
              uID = 0;
              if ( wcschr(v15, 0x2Cu) )
              {
                v16 = wcschr(v15, 0x2Cu);
                *v16 = 0;
                uID = abs(_wtoi(v16 + 1));
              }
              v17 = GetEnvironmentPathInfo(&ppsz, v15 + 1);
              v18 = _wcsdup(*v17);
              free(v47);
              free(ppsz);
              v19 = LoadLibraryExW(v18, 0, 2u);
              hLibModule = v19;
              if ( v19 )
              {
                if ( LoadStringW(v19, uID, &Buffer, 260) )
                {
                  v47 = v67;
                  v67 = _wcsdup(&Buffer);
                  free(v47);
                }
                FreeLibrary(hLibModule);
              }
              free(v18);
            }
            v58 = _wcsdup(gpszTargetName);
            LOBYTE(v70) = 24;
            v20 = sub_11F7BE0(&v33, 0x80000002, &psz, &v66);
            LOBYTE(v70) = 25;
            v21 = sub_11F7BE0(&v39, 0x80000002, &psz, &v58);
            LOBYTE(v70) = 26;
            v65 = sub_11F3D40(v6, &v66, v21, v20, &v64, &v55, &v49, &v35);
            free(v39);
            free(v33);
            free(v58);
            if ( v65 )
            {
              if ( v46 == -1 )
              {
                v53 = _wcsdup(gpszTargetName);
                v54 = _wcsdup(gpszTargetName);
                v45 = _wcsdup(gpszTargetName);
                v43 = _wcsdup(gpszTargetName);
                v57 = _wcsdup(gpszTargetName);
                v62 = _wcsdup(gpszTargetName);
                v60 = _wcsdup(gpszTargetName);
                v56 = _wcsdup(gpszTargetName);
                LOBYTE(v70) = 34;
                v22 = sub_11F7BE0(&v32, 0x80000002, &psz, &v60);
                LOBYTE(v70) = 35;
                v23 = sub_11F7BE0(&v37, 0x80000002, &psz, &v56);
                LOBYTE(v70) = 36;
                v46 = sub_11F3FF0(v6, 0, 0xFFFFFFFF, 0, v23, v22, &v62);
                free(v37);
                free(v32);
                free(v56);
                free(v60);
                free(v62);
                free(v57);
                free(v43);
                free(v45);
                free(v54);
                free(v53);
              }
              v51 = _wcsdup(gpszTargetName);
              LOBYTE(v70) = 37;
              v24 = sub_11F7BE0(&v40, 0x80000002, &psz, &v66);
              LOBYTE(v70) = 38;
              sub_11F3FF0(v6, v41, v46, 11, &v67, v24, &v64);
              free(v40);
              free(v51);
            }
            free(v67);
            sub_11F21F0(&v25);
            LOBYTE(v70) = 19;
            free(v63);
          }
          RegCloseKey(hKey);
        }
        ++v7;
      }
      while ( !sub_12013D0(v50, v7, &v66) );
      v2 = v38;
      v3 = v36;
      v4 = v34;
    }
    RegCloseKey(v50);
    free(v66);
    free(v44);
    free(v4);
    free(v49);
    free(v52);
    free(v55);
    free(v3);
    free(v2);
    free(v64);
  }
  free(psz);
}

//----- (01213B60) --------------------------------------------------------
_DWORD *__thiscall sub_1213B60(_DWORD *this, int a2, _DWORD **a3, int a4)
{
  _DWORD *result; // eax

  result = sub_1216B70(this);
  *(result + 6) = 0;
  if ( result != -16 )
  {
    result[4] = **a3;
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
  }
  return result;
}

//----- (01213BA0) --------------------------------------------------------
CSysProcItem *__thiscall sub_1213BA0(_DWORD *this, int a2, const wchar_t ***a3, int a4)
{
  CSysProcItem *result; // eax
  CSysProcItem *v5; // esi
  _DWORD *v6; // edi

  result = CMapNode::NewNode_0(this);
  v5 = result;
  v6 = &result->dwPid;
  *&result->_Color = 0;
  if ( result != -16 )
  {
    *v6 = _wcsdup(**a3);
    v6[1] = 0;
    result = v5;
  }
  return result;
}

//----- (01213BE0) --------------------------------------------------------
int __thiscall sub_1213BE0(_DWORD *this, int a2, char a3, int a4, int a5, void *a6)
{
  _DWORD *v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // eax
  int *v9; // ecx
  int *v10; // esi
  int *v11; // edx
  _DWORD *v12; // edx
  void **v13; // ecx
  _DWORD *v14; // edx
  _DWORD *v15; // esi
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // edx
  int v19; // ecx
  _DWORD *v20; // ecx
  _DWORD *v21; // ecx
  int result; // eax

  v6 = this;
  v7 = this[1];
  if ( v7 >= 0xAAAAAA9 )
  {
    free(*(a6 + 4));
    j__free(a6);
    std::_Xlength_error("map/set<T> too long");
  }
  this[1] = v7 + 1;
  *(a6 + 1) = a4;
  if ( a4 == *this )
  {
    *(*this + 4) = a6;
    **this = a6;
    *(*this + 8) = a6;
  }
  else if ( a3 )
  {
    *a4 = a6;
    if ( a4 == **this )
      **this = a6;
  }
  else
  {
    *(a4 + 8) = a6;
    if ( a4 == *(*this + 8) )
      *(*this + 8) = a6;
  }
  v8 = a6;
  if ( !*(*(a6 + 1) + 12) )
  {
    do
    {
      v9 = v8[1];
      v10 = v9[1];
      v11 = *v10;
      if ( v9 == *v10 )
      {
        v11 = v10[2];
        if ( *(v11 + 12) )
        {
          if ( v8 == v9[2] )
          {
            v8 = v8[1];
            v12 = v9[2];
            v9[2] = *v12;
            if ( !*(*v12 + 13) )
              *(*v12 + 4) = v9;
            v12[1] = v9[1];
            if ( v9 == *(*v6 + 4) )
            {
              *(*v6 + 4) = v12;
            }
            else
            {
              v13 = v9[1];
              if ( v8 == *v13 )
                *v13 = v12;
              else
                v13[2] = v12;
            }
            *v12 = v8;
            v8[1] = v12;
          }
          *(v8[1] + 12) = 1;
          *(*(v8[1] + 4) + 12) = 0;
          v14 = *(v8[1] + 4);
          v15 = *v14;
          *v14 = *(*v14 + 8);
          v16 = v15[2];
          if ( !*(v16 + 13) )
            *(v16 + 4) = v14;
          v15[1] = v14[1];
          if ( v14 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v15;
            v15[2] = v14;
          }
          else
          {
            v17 = v14[1];
            if ( v14 == v17[2] )
              v17[2] = v15;
            else
              *v17 = v15;
            v15[2] = v14;
          }
LABEL_48:
          v14[1] = v15;
          continue;
        }
      }
      else if ( *(v11 + 12) )
      {
        if ( v8 == *v9 )
        {
          v8 = v8[1];
          v18 = *v9;
          *v9 = *(*v9 + 8);
          v19 = *(v18 + 8);
          if ( !*(v19 + 13) )
            *(v19 + 4) = v8;
          *(v18 + 4) = v8[1];
          if ( v8 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v18;
          }
          else
          {
            v20 = v8[1];
            if ( v8 == v20[2] )
              v20[2] = v18;
            else
              *v20 = v18;
          }
          *(v18 + 8) = v8;
          v8[1] = v18;
        }
        *(v8[1] + 12) = 1;
        *(*(v8[1] + 4) + 12) = 0;
        v14 = *(v8[1] + 4);
        v15 = v14[2];
        v14[2] = *v15;
        if ( !*(*v15 + 13) )
          *(*v15 + 4) = v14;
        v15[1] = v14[1];
        if ( v14 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v15;
        }
        else
        {
          v21 = v14[1];
          if ( v14 == *v21 )
            *v21 = v15;
          else
            v21[2] = v15;
        }
        *v15 = v14;
        goto LABEL_48;
      }
      *(v9 + 12) = 1;
      *(v11 + 12) = 1;
      *(*(v8[1] + 4) + 12) = 0;
      v8 = *(v8[1] + 4);
    }
    while ( !*(v8[1] + 12) );
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = a6;
  return result;
}

//----- (01213E00) --------------------------------------------------------
int __thiscall sub_1213E00(_DWORD *this, int a2, char a3, int a4, int a5, void *a6)
{
  _DWORD *v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // eax
  int *v9; // ecx
  int *v10; // esi
  int *v11; // edx
  _DWORD *v12; // edx
  void **v13; // ecx
  _DWORD *v14; // edx
  _DWORD *v15; // esi
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // edx
  int v19; // ecx
  _DWORD *v20; // ecx
  _DWORD *v21; // ecx
  int result; // eax

  v6 = this;
  v7 = this[1];
  if ( v7 >= 0x7FFFFFE )
  {
    if ( *(a6 + 5) )
    {
      j__free(*(a6 + 5));
      *(a6 + 5) = 0;
      *(a6 + 6) = 0;
      *(a6 + 7) = 0;
    }
    j__free(a6);
    std::_Xlength_error("map/set<T> too long");
  }
  this[1] = v7 + 1;
  *(a6 + 1) = a4;
  if ( a4 == *this )
  {
    *(*this + 4) = a6;
    **this = a6;
    *(*this + 8) = a6;
  }
  else if ( a3 )
  {
    *a4 = a6;
    if ( a4 == **this )
      **this = a6;
  }
  else
  {
    *(a4 + 8) = a6;
    if ( a4 == *(*this + 8) )
      *(*this + 8) = a6;
  }
  v8 = a6;
  if ( !*(*(a6 + 1) + 12) )
  {
    do
    {
      v9 = v8[1];
      v10 = v9[1];
      v11 = *v10;
      if ( v9 == *v10 )
      {
        v11 = v10[2];
        if ( *(v11 + 12) )
        {
          if ( v8 == v9[2] )
          {
            v8 = v8[1];
            v12 = v9[2];
            v9[2] = *v12;
            if ( !*(*v12 + 13) )
              *(*v12 + 4) = v9;
            v12[1] = v9[1];
            if ( v9 == *(*v6 + 4) )
            {
              *(*v6 + 4) = v12;
            }
            else
            {
              v13 = v9[1];
              if ( v8 == *v13 )
                *v13 = v12;
              else
                v13[2] = v12;
            }
            *v12 = v8;
            v8[1] = v12;
          }
          *(v8[1] + 12) = 1;
          *(*(v8[1] + 4) + 12) = 0;
          v14 = *(v8[1] + 4);
          v15 = *v14;
          *v14 = *(*v14 + 8);
          v16 = v15[2];
          if ( !*(v16 + 13) )
            *(v16 + 4) = v14;
          v15[1] = v14[1];
          if ( v14 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v15;
            v15[2] = v14;
          }
          else
          {
            v17 = v14[1];
            if ( v14 == v17[2] )
              v17[2] = v15;
            else
              *v17 = v15;
            v15[2] = v14;
          }
LABEL_50:
          v14[1] = v15;
          continue;
        }
      }
      else if ( *(v11 + 12) )
      {
        if ( v8 == *v9 )
        {
          v8 = v8[1];
          v18 = *v9;
          *v9 = *(*v9 + 8);
          v19 = *(v18 + 8);
          if ( !*(v19 + 13) )
            *(v19 + 4) = v8;
          *(v18 + 4) = v8[1];
          if ( v8 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v18;
          }
          else
          {
            v20 = v8[1];
            if ( v8 == v20[2] )
              v20[2] = v18;
            else
              *v20 = v18;
          }
          *(v18 + 8) = v8;
          v8[1] = v18;
        }
        *(v8[1] + 12) = 1;
        *(*(v8[1] + 4) + 12) = 0;
        v14 = *(v8[1] + 4);
        v15 = v14[2];
        v14[2] = *v15;
        if ( !*(*v15 + 13) )
          *(*v15 + 4) = v14;
        v15[1] = v14[1];
        if ( v14 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v15;
        }
        else
        {
          v21 = v14[1];
          if ( v14 == *v21 )
            *v21 = v15;
          else
            v21[2] = v15;
        }
        *v15 = v14;
        goto LABEL_50;
      }
      *(v9 + 12) = 1;
      *(v11 + 12) = 1;
      *(*(v8[1] + 4) + 12) = 0;
      v8 = *(v8[1] + 4);
    }
    while ( !*(v8[1] + 12) );
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = a6;
  return result;
}

//----- (01214040) --------------------------------------------------------
int __thiscall sub_1214040(_DWORD *this, int a2, int a3, int a4, void *a5)
{
  _DWORD *v5; // ebx
  bool v6; // zf
  int result; // eax
  CSysProcItem *v8; // edi
  int v9; // edx
  unsigned int v10; // ecx
  bool v11; // cf
  int v12; // ecx
  int v13; // [esp+0h] [ebp-30h]
  int v14; // [esp+10h] [ebp-20h]
  _DWORD *v15; // [esp+14h] [ebp-1Ch]
  unsigned int v16; // [esp+18h] [ebp-18h]
  CSysProcItem var14; // [esp+1Ch] [ebp-14h]

  var14._Parent = &v13;
  v5 = this;
  v15 = this;
  v6 = this[1] == 0;
  var14.dwPid = 0;
  if ( v6 )
  {
    sub_1213BE0(this, a2, 1, *this, a4, a5);
    return a2;
  }
  v8 = *this;
  if ( a3 == **this )
  {
    if ( *a4 < *(a3 + 16) )
    {
      sub_1213BE0(this, a2, 1, a3, a4, a5);
      return a2;
    }
    goto LABEL_23;
  }
  if ( a3 == v8 )
  {
    v9 = v8->_Right;
    if ( *(v9 + 16) < *a4 )
    {
      sub_1213BE0(this, a2, 0, v9, a4, a5);
      return a2;
    }
    goto LABEL_23;
  }
  v10 = *(a3 + 16);
  v16 = *a4;
  v11 = v10 < v16;
  if ( v10 > v16 )
  {
    var14._Left = a3;
    sub_1211450(&var14);
    if ( var14._Left->dwPid < v16 )
    {
      if ( var14._Left->_Right->_Isnil )
        sub_1213BE0(v5, a2, 0, var14._Left, a4, a5);
      else
        sub_1213BE0(v5, a2, 1, a3, a4, a5);
      return a2;
    }
    v11 = *(a3 + 16) < v16;
  }
  if ( !v11 || (var14._Left = a3, sub_1214CE0(&var14), var14._Left != v8) && v16 >= var14._Left->dwPid )
  {
LABEL_23:
    var14.dwPid = -1;
    v12 = *sub_12144A0(v5, &v14, 0, a4, a5);
    result = a2;
    *a2 = v12;
    return result;
  }
  if ( *(*(a3 + 8) + 13) )
    sub_1213BE0(v5, a2, 0, a3, a4, a5);
  else
    sub_1213BE0(v5, a2, 1, var14._Left, a4, a5);
  return a2;
}

//----- (01214270) --------------------------------------------------------
int __thiscall sub_1214270(_DWORD *this, int a2, int a3, int a4, void *a5)
{
  _DWORD *v5; // ebx
  bool v6; // zf
  int result; // eax
  CSysProcItem *v8; // edi
  int v9; // edx
  unsigned int v10; // ecx
  bool v11; // cf
  int v12; // ecx
  int v13; // [esp+0h] [ebp-30h]
  int v14; // [esp+10h] [ebp-20h]
  _DWORD *v15; // [esp+14h] [ebp-1Ch]
  unsigned int v16; // [esp+18h] [ebp-18h]
  CSysProcItem var14; // [esp+1Ch] [ebp-14h]

  var14._Parent = &v13;
  v5 = this;
  v15 = this;
  v6 = this[1] == 0;
  var14.dwPid = 0;
  if ( v6 )
  {
    sub_1213E00(this, a2, 1, *this, a4, a5);
    return a2;
  }
  v8 = *this;
  if ( a3 == **this )
  {
    if ( *a4 < *(a3 + 16) )
    {
      sub_1213E00(this, a2, 1, a3, a4, a5);
      return a2;
    }
    goto LABEL_23;
  }
  if ( a3 == v8 )
  {
    v9 = v8->_Right;
    if ( *(v9 + 16) < *a4 )
    {
      sub_1213E00(this, a2, 0, v9, a4, a5);
      return a2;
    }
    goto LABEL_23;
  }
  v10 = *(a3 + 16);
  v16 = *a4;
  v11 = v10 < v16;
  if ( v10 > v16 )
  {
    var14._Left = a3;
    sub_1211450(&var14);
    if ( var14._Left->dwPid < v16 )
    {
      if ( var14._Left->_Right->_Isnil )
        sub_1213E00(v5, a2, 0, var14._Left, a4, a5);
      else
        sub_1213E00(v5, a2, 1, a3, a4, a5);
      return a2;
    }
    v11 = *(a3 + 16) < v16;
  }
  if ( !v11 || (var14._Left = a3, sub_1214CE0(&var14), var14._Left != v8) && v16 >= var14._Left->dwPid )
  {
LABEL_23:
    var14.dwPid = -1;
    v12 = *sub_12145C0(v5, &v14, 0, a4, a5);
    result = a2;
    *a2 = v12;
    return result;
  }
  if ( *(*(a3 + 8) + 13) )
    sub_1213E00(v5, a2, 0, a3, a4, a5);
  else
    sub_1213E00(v5, a2, 1, var14._Left, a4, a5);
  return a2;
}

//----- (012144A0) --------------------------------------------------------
int __thiscall sub_12144A0(_DWORD *this, int a2, int a3, int a4, void *a5)
{
  int v5; // edx
  int v6; // edi
  _DWORD *v7; // ebx
  int v8; // eax
  bool v9; // dl
  unsigned int v10; // ecx
  int v11; // esi
  int *v12; // eax
  int v13; // ecx
  int result; // eax
  void *v15; // edi
  int v16; // [esp+0h] [ebp-28h]
  _DWORD *v17; // [esp+10h] [ebp-18h]
  int v18; // [esp+14h] [ebp-14h]
  int *v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+24h] [ebp-4h]

  v19 = &v16;
  v17 = this;
  v5 = *this;
  v6 = v5;
  v7 = a4;
  v20 = 0;
  v8 = *(v5 + 4);
  v9 = 1;
  LOBYTE(v18) = 1;
  if ( !*(v8 + 13) )
  {
    v10 = *a4;
    do
    {
      v6 = v8;
      if ( a3 )
        v9 = *(v8 + 16) >= v10;
      else
        v9 = v10 < *(v8 + 16);
      LOBYTE(v18) = v9;
      if ( v9 )
        v8 = *v8;
      else
        v8 = *(v8 + 8);
    }
    while ( !*(v8 + 13) );
    this = v17;
  }
  v11 = v6;
  a3 = v6;
  if ( v9 )
  {
    if ( v6 == **this )
    {
      v12 = sub_1213BE0(this, &a3, 1, v6, a4, a5);
LABEL_14:
      v13 = *v12;
      result = a2;
      *a2 = v13;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v11 = a3;
  }
  if ( *(v11 + 16) < *v7 )
  {
    v12 = sub_1213BE0(v17, &a3, v18, v6, v7, a5);
    goto LABEL_14;
  }
  v15 = a5;
  free(*(a5 + 4));
  j__free(v15);
  result = a2;
  *a2 = v11;
  *(a2 + 4) = 0;
  return result;
}

//----- (012145C0) --------------------------------------------------------
int __thiscall sub_12145C0(_DWORD *this, int a2, int a3, int a4, void *a5)
{
  int v5; // edx
  int v6; // edi
  _DWORD *v7; // ebx
  int v8; // eax
  bool v9; // dl
  unsigned int v10; // ecx
  int v11; // esi
  int *v12; // eax
  int v13; // ecx
  int result; // eax
  _DWORD *v15; // edi
  int v16; // [esp+0h] [ebp-28h]
  _DWORD *v17; // [esp+10h] [ebp-18h]
  int v18; // [esp+14h] [ebp-14h]
  int *v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+24h] [ebp-4h]

  v19 = &v16;
  v17 = this;
  v5 = *this;
  v6 = v5;
  v7 = a4;
  v20 = 0;
  v8 = *(v5 + 4);
  v9 = 1;
  LOBYTE(v18) = 1;
  if ( !*(v8 + 13) )
  {
    v10 = *a4;
    do
    {
      v6 = v8;
      if ( a3 )
        v9 = *(v8 + 16) >= v10;
      else
        v9 = v10 < *(v8 + 16);
      LOBYTE(v18) = v9;
      if ( v9 )
        v8 = *v8;
      else
        v8 = *(v8 + 8);
    }
    while ( !*(v8 + 13) );
    this = v17;
  }
  v11 = v6;
  a3 = v6;
  if ( v9 )
  {
    if ( v6 == **this )
    {
      v12 = sub_1213E00(this, &a3, 1, v6, a4, a5);
LABEL_14:
      v13 = *v12;
      result = a2;
      *a2 = v13;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v11 = a3;
  }
  if ( *(v11 + 16) < *v7 )
  {
    v12 = sub_1213E00(v17, &a3, v18, v6, v7, a5);
    goto LABEL_14;
  }
  v15 = a5;
  if ( *(a5 + 5) )
  {
    j__free(*(a5 + 5));
    v15[5] = 0;
    v15[6] = 0;
    v15[7] = 0;
  }
  j__free(v15);
  result = a2;
  *a2 = v11;
  *(a2 + 4) = 0;
  return result;
}

//----- (01214700) --------------------------------------------------------
void **__cdecl sub_1214700(const wchar_t **a1, const wchar_t **a2, void **a3)
{
  const wchar_t **v3; // edi
  void **v4; // ebx
  void *v5; // esi

  v3 = a1;
  if ( a1 == a2 )
    return a3;
  v4 = a3;
  do
  {
    v5 = *v4;
    *v4 = _wcsdup(*v3);
    free(v5);
    ++v3;
    ++v4;
  }
  while ( v3 != a2 );
  return v4;
}

//----- (01214740) --------------------------------------------------------
void *__thiscall sub_1214740(void *this)
{
  void *v1; // ebx
  _WORD *v2; // eax
  _WORD *v3; // eax
  void *v4; // esi
  void *v5; // esi
  void *v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+20h] [ebp-4h]

  v1 = this;
  v7 = _wcsdup(L"ActiveScriptEventConsumer");
  v8 = 0;
  *v1 = &EventConsumerDescBase::`vftable';
  v2 = malloc(2u);
  *(v1 + 1) = v2;
  *v2 = 0;
  v3 = malloc(2u);
  *(v1 + 2) = v3;
  *v3 = 0;
  LOBYTE(v8) = 2;
  *sub_1214C50(&dword_12E4D14, &v7) = v1;
  free(v7);
  *v1 = &ActiveScriptEventConsumer::`vftable';
  v4 = *(v1 + 1);
  *(v1 + 1) = _wcsdup(L"The ActiveScriptEventConsumer class runs a predefined script in an arbitrary scripting ");
  free(v4);
  sub_11F2300(
    v1 + 1,
    L"language when an event is delivered to it. This class is one of the standard event consumers that WMI provides.",
    0x7FFFFFFF,
    0);
  v5 = *(v1 + 2);
  *(v1 + 2) = _wcsdup(L"http://msdn.microsoft.com/en-us/library/aa384749(v=vs.85).aspx");
  free(v5);
  return v1;
}
// 12B2E48: using guessed type void *EventConsumerDescBase::`vftable';
// 12B3110: using guessed type void *ActiveScriptEventConsumer::`vftable';
// 12B3208: using guessed type wchar_t aLanguageWhenAn[112];

//----- (01214830) --------------------------------------------------------
void *__thiscall sub_1214830(void *this)
{
  void *v1; // ebx
  _WORD *v2; // eax
  _WORD *v3; // eax
  void *v4; // esi
  void *v5; // esi
  void *v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+20h] [ebp-4h]

  v1 = this;
  v7 = _wcsdup(L"CommandLineEventConsumer");
  v8 = 0;
  *v1 = &EventConsumerDescBase::`vftable';
  v2 = malloc(2u);
  *(v1 + 1) = v2;
  *v2 = 0;
  v3 = malloc(2u);
  *(v1 + 2) = v3;
  *v3 = 0;
  LOBYTE(v8) = 2;
  *sub_1214C50(&dword_12E4D14, &v7) = v1;
  free(v7);
  *v1 = &CommandLineEventConsumer::`vftable';
  v4 = *(v1 + 1);
  *(v1 + 1) = _wcsdup(L"The CommandLineEventConsumer class starts an arbitrary process in the local system ");
  free(v4);
  sub_11F2300(
    v1 + 1,
    L"when an event is delivered to it. This class is one of the standard event consumers that WMI provides.",
    0x7FFFFFFF,
    0);
  v5 = *(v1 + 2);
  *(v1 + 2) = _wcsdup(L"http://msdn.microsoft.com/en-us/library/aa389231(v=vs.85).aspx");
  free(v5);
  return v1;
}
// 12B2E48: using guessed type void *EventConsumerDescBase::`vftable';
// 12B2E60: using guessed type void *CommandLineEventConsumer::`vftable';
// 12B2F50: using guessed type wchar_t aWhenAnEventIsD[103];

//----- (01214920) --------------------------------------------------------
_DWORD *__thiscall sub_1214920(_DWORD *this, int a2, OLECHAR *psz)
{
  _DWORD *v3; // edi
  CComBSTR **v4; // esi
  CComBSTR **v5; // eax
  CComBSTR *v6; // esi
  BSTR v7; // esi
  CComBSTR *v8; // eax
  BSTR v9; // edx
  int v10; // eax
  OLECHAR *v11; // esi
  LONG (__stdcall *v12)(volatile LONG *); // edx
  CComBSTR *v13; // esi
  _DWORD *result; // eax
  CComBSTR *ppv; // [esp+10h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-4h]
  int v17; // [esp+28h] [ebp+8h]

  v3 = this;
  *this = 0;
  v16 = 0;
  v4 = bstr_t::EqualAssign(&ppv, psz);
  LOBYTE(v16) = 1;
  v5 = bstr_t::EqualAssign(&psz, L"WQL");
  v6 = *v4;
  LOBYTE(v16) = 2;
  if ( v6 )
    v7 = v6->bstr;
  else
    v7 = 0;
  v8 = *v5;
  if ( v8 )
    v9 = v8->bstr;
  else
    v9 = 0;
  v10 = (*(*a2 + 80))(a2, v9, v7, 0, 0, v3);
  v11 = psz;
  v12 = InterlockedDecrement;
  v17 = v10;
  if ( psz )
  {
    if ( !InterlockedDecrement(psz + 2) && v11 )
    {
      if ( *v11 )
      {
        SysFreeString(*v11);
        *v11 = 0;
      }
      if ( *(v11 + 1) )
      {
        j_j__free(*(v11 + 1));
        *(v11 + 1) = 0;
      }
      j__free(v11);
    }
    v12 = InterlockedDecrement;
    psz = 0;
  }
  v13 = ppv;
  if ( ppv && !v12(&ppv->Length) && v13 )
  {
    if ( v13->bstr )
    {
      SysFreeString(v13->bstr);
      v13->bstr = 0;
    }
    if ( v13->hKey )
    {
      j_j__free(v13->hKey);
      v13->hKey = 0;
    }
    j__free(v13);
  }
  result = v3;
  if ( v17 < 0 )
    *v3 = 0;
  return result;
}

//----- (01214A70) --------------------------------------------------------
volatile LONG *__thiscall sub_1214A70(volatile LONG *this, volatile LONG a2)
{
  volatile LONG *v2; // esi

  v2 = this;
  *this = a2;
  *(this + 3) = 0;
  *(this + 4) = 0;
  *(this + 5) = 0;
  *(this + 6) = 0;
  *(this + 7) = 0;
  *(this + 8) = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  InterlockedIncrement(this + 1);
  return v2;
}

//----- (01214B00) --------------------------------------------------------
void __thiscall sub_1214B00(void **this)
{
  void **v1; // esi
  int v2; // [esp+4h] [ebp-4h]

  v1 = this;
  sub_12171F0(this, &v2, **this, *this);
  j__free(*v1);
}

//----- (01214B60) --------------------------------------------------------
void **__thiscall sub_1214B60(void **this, void **a2)
{
  void **v2; // esi

  v2 = this;
  if ( this != a2 )
  {
    if ( *this )
    {
      j__free(*this);
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
    }
    *v2 = *a2;
    v2[1] = a2[1];
    v2[2] = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return v2;
}

//----- (01214BC0) --------------------------------------------------------
_DWORD *__thiscall sub_1214BC0(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // esi
  int v4; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // [esp+Ch] [ebp-4h]

  v2 = this;
  v3 = *this;
  v4 = *(*this + 4);
  while ( !*(v4 + 13) )
  {
    if ( *(v4 + 16) >= *a2 )
    {
      v3 = v4;
      v4 = *v4;
    }
    else
    {
      v4 = *(v4 + 8);
    }
  }
  if ( v3 != *this && *a2 >= *(v3 + 16) )
    return (v3 + 20);
  v7 = a2;
  v6 = sub_1213B60(this, dword_12E4D34, &v7, &a2 + 3);
  sub_1214270(v2, &a2, v3, (v6 + 4), v6);
  return a2 + 5;
}
// 12E4D34: using guessed type int dword_12E4D34[5];

//----- (01214C50) --------------------------------------------------------
_DWORD *__thiscall sub_1214C50(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // esi
  int v4; // eax
  CSysProcItem *v6; // eax
  _DWORD *v7; // [esp+Ch] [ebp-4h]

  v2 = this;
  v3 = *this;
  v4 = *(*this + 4);
  while ( !*(v4 + 13) )
  {
    if ( *(v4 + 16) >= *a2 )
    {
      v3 = v4;
      v4 = *v4;
    }
    else
    {
      v4 = *(v4 + 8);
    }
  }
  if ( v3 != *this && *a2 >= *(v3 + 16) )
    return (v3 + 20);
  v7 = a2;
  v6 = sub_1213BA0(this, dword_12E4D34, &v7, &a2 + 3);
  sub_1214040(v2, &a2, v3, &v6->dwPid, v6);
  return a2 + 5;
}
// 12E4D34: using guessed type int dword_12E4D34[5];

//----- (01214CE0) --------------------------------------------------------
CMapNode *__thiscall sub_1214CE0(CMapNode *this)
{
  CMapNode *pThis; // edx
  CMapNode *Left; // eax
  CMapNode *Right; // ecx
  CMapNode *p; // eax
  CMapNode *iter; // eax

  pThis = this;
  Left = this->_Left;
  if ( this->_Left->_isnil )
    return pThis;
  Right = Left->_Right;
  if ( Right->_isnil )
  {
    for ( iter = Left->_Parent; !iter->_isnil; iter = iter->_Parent )
    {
      if ( pThis->_Left != iter->_Right )
        break;
      pThis->_Left = iter;
    }
    pThis->_Left = iter;
    return pThis;
  }
  p = Right->_Left;
  if ( !Right->_Left->_isnil )
  {
    do
    {
      Right = p;
      p = p->_Left;
    }
    while ( !p->_isnil );
  }
  pThis->_Left = Right;
  return pThis;
}

//----- (01214D30) --------------------------------------------------------
void *__thiscall sub_1214D30(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::error_category::`vftable';
  if ( a2 & 1 )
    j__free(this);
  return v2;
}
// 12B2D74: using guessed type void *std::error_category::`vftable';

//----- (01214D60) --------------------------------------------------------
void sub_1214D60()
{
  void *v0; // esi
  void *v1; // eax

  v0 = dword_12E4D10;
  if ( dword_12E4D10 )
  {
    v1 = *(dword_12E4D10 + 5);
    *(dword_12E4D10 + 8) = 1;
    if ( v1 )
      SetEvent(v1);
    sub_1215CB0(v0);
    dword_12E4D10 = 0;
  }
}

//----- (01214DA0) --------------------------------------------------------
int __cdecl sub_1214DA0(int a1, LPVOID *ppv)
{
  volatile LONG *v2; // esi
  volatile LONG *v3; // eax
  int result; // eax
  int v5; // edi
  void *v6; // eax

  v2 = dword_12E4D10;
  if ( dword_12E4D10 )
  {
    *dword_12E4D10 = a1;
  }
  else
  {
    v3 = operator new(0x24u);
    if ( v3 )
      v2 = sub_1214A70(v3, a1);
    else
      v2 = 0;
  }
  result = sub_1214E20(v2, ppv);
  v5 = result;
  if ( result >= 0 )
  {
    dword_12E4D10 = v2;
  }
  else
  {
    v6 = *(v2 + 5);
    *(v2 + 8) = 1;
    if ( v6 )
      SetEvent(v6);
    sub_1215CB0(v2);
    result = v5;
    dword_12E4D10 = 0;
  }
  return result;
}

//----- (01214E20) --------------------------------------------------------
int __thiscall sub_1214E20(LPVOID lpParameter, LPVOID *ppv)
{
  DWORD v2; // ebx
  LPVOID v3; // esi
  void *v4; // eax
  HANDLE v5; // eax
  int result; // eax
  HANDLE v7; // eax
  HANDLE v8; // eax
  HANDLE v9; // eax
  DWORD v10; // eax
  DWORD v11; // eax
  HANDLE Handles; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  DWORD ThreadId; // [esp+14h] [ebp-8h]
  DWORD ExitCode; // [esp+18h] [ebp-4h]

  v2 = dwMilliseconds;
  v3 = lpParameter;
  if ( byte_12DAA38 && dwMilliseconds == 5000 )
    v2 = 20000;
  byte_12DAA38 = 0;
  v4 = *(lpParameter + 6);
  if ( v4 )
  {
    if ( !GetExitCodeThread(v4, &ExitCode) || ExitCode != 259 || !SetEvent(*(v3 + 5)) )
    {
      CloseHandle(*(v3 + 6));
      *(v3 + 6) = 0;
    }
    if ( *(v3 + 6) )
      goto LABEL_22;
    if ( *(v3 + 3) )
    {
      CloseHandle(*(v3 + 3));
      *(v3 + 3) = 0;
    }
    if ( *(v3 + 4) )
    {
      CloseHandle(*(v3 + 4));
      *(v3 + 4) = 0;
    }
    if ( *(v3 + 5) )
    {
      CloseHandle(*(v3 + 5));
      *(v3 + 5) = 0;
    }
  }
  if ( !*(v3 + 6) )
  {
    v5 = CreateEventW(0, 0, 0, 0);
    *(v3 + 3) = v5;
    if ( !v5 )
      return -2147467259;
    v7 = CreateEventW(0, 0, 0, 0);
    *(v3 + 4) = v7;
    if ( !v7 )
      return -2147467259;
    v8 = CreateEventW(0, 0, 0, 0);
    *(v3 + 5) = v8;
    if ( !v8 )
      return -2147467259;
    v9 = CreateThread(0, 0, StartAddress, v3, 0, &ThreadId);
    *(v3 + 6) = v9;
    if ( !v9 )
      return -2147467259;
  }
LABEL_22:
  Handles = *(v3 + 6);
  v13 = *(v3 + 3);
  v10 = WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF);
  if ( !v10 )
  {
    result = *(v3 + 2);
    if ( result >= 0 )
      result = -2147467259;
    return result;
  }
  if ( v10 != 1 )
    return -2147467259;
  v13 = *(v3 + 4);
  v11 = WaitForMultipleObjects(2u, &Handles, 0, v2);
  if ( v11 == 1 )
  {
    result = CoGetInterfaceAndReleaseStream(*(v3 + 7), &CLSID_IWbemServices, ppv);
    *(v3 + 2) = result;
    if ( result >= 0 )
      *(v3 + 7) = 0;
  }
  else if ( v11 == -1 )
  {
    result = GetLastError();
    if ( result > 0 )
      result = result | 0x80070000;
  }
  else
  {
    result = -2147024638;
  }
  return result;
}
// 12DAA38: using guessed type char byte_12DAA38;

//----- (01214FE0) --------------------------------------------------------
void *__cdecl sub_1214FE0(int a1, void *a2)
{
  void *result; // eax
  void *v3; // esi
  void *v4; // [esp+8h] [ebp-24h]
  void *v5; // [esp+Ch] [ebp-20h]
  void *v6; // [esp+10h] [ebp-1Ch]
  void *v7; // [esp+14h] [ebp-18h]
  void *v8; // [esp+18h] [ebp-14h]
  void *v9; // [esp+1Ch] [ebp-10h]
  int v10; // [esp+28h] [ebp-4h]

  result = a2;
  if ( a2 == -1 )
  {
    a2 = _wcsdup(L"WMI Database Entries");
    v10 = 0;
    if ( !IsBuiltinAndAnministrative() )
      sub_11F2300(&a2, L" - run as Administrator for complete scan", 0x7FFFFFFF, 0);
    v4 = _wcsdup(gpszTargetName);
    v5 = _wcsdup(gpszTargetName);
    v6 = _wcsdup(gpszTargetName);
    v7 = _wcsdup(gpszTargetName);
    v8 = _wcsdup(gpszTargetName);
    v9 = _wcsdup(gpszTargetName);
    LOBYTE(v10) = 6;
    v3 = sub_11F3FF0(a1, 2, 0xFFFFFFFF, 0, &a2, &a2, &v9);
    free(v9);
    free(v8);
    free(v7);
    free(v6);
    free(v5);
    free(v4);
    free(a2);
    result = v3;
  }
  return result;
}
// 12B34B0: using guessed type wchar_t aRunAsAdministr[42];

//----- (01215120) --------------------------------------------------------
int __cdecl sub_1215120(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // ebx
  const wchar_t *v5; // ecx
  wchar_t *v6; // eax
  wchar_t *v7; // esi
  unsigned int v8; // eax
  int v9; // edx
  int v10; // ebx
  int v11; // eax
  unsigned int v12; // edx
  unsigned int v13; // edx
  const wchar_t **v14; // eax
  wchar_t **v15; // ebx
  wchar_t *v16; // eax
  int v17; // edx
  int v18; // eax
  unsigned int v19; // edx
  unsigned int v20; // edx
  VARIANTARG pvarg; // [esp+10h] [ebp-34h]
  unsigned int v23; // [esp+20h] [ebp-24h]
  int v24; // [esp+24h] [ebp-20h]
  int v25; // [esp+28h] [ebp-1Ch]
  wchar_t *v26; // [esp+2Ch] [ebp-18h]
  int v27; // [esp+30h] [ebp-14h]
  int v28; // [esp+34h] [ebp-10h]
  int v29; // [esp+40h] [ebp-4h]

  v28 = 0;
  v27 = 0;
  sub_1214920(&v25, a1, L"SELECT * FROM __NAMESPACE");
  v29 = 0;
  while ( 1 )
  {
    v2 = v25;
    if ( !v25 )
    {
      v4 = v28;
      goto LABEL_41;
    }
    v3 = (*(*v25 + 16))(v25, -1, 1, &v27, &v24);
    if ( v3 < 0 || v3 || v24 != 1 )
      break;
    v4 = (*(*v27 + 16))(v27, L"Name", 0, &pvarg, 0, 0);
    v28 = v4;
    (*(*v27 + 8))(v27);
    if ( v4 < 0 )
      goto LABEL_39;
    if ( pvarg.vt != 8 )
    {
      v2 = v25;
      v4 = -2147024809;
      goto LABEL_41;
    }
    v5 = gpszTargetName;
    if ( pvarg.lVal )
      v5 = pvarg.bstrVal;
    v6 = _wcsdup(v5);
    v7 = v6;
    v26 = v6;
    v8 = *(a2 + 4);
    LOBYTE(v29) = 1;
    if ( &v26 >= v8 || *a2 > &v26 )
    {
      v17 = *(a2 + 8);
      if ( v8 == v17 && ((v17 - v8) >> 2) < 1 )
      {
        v18 = (v8 - *a2) >> 2;
        if ( (0x3FFFFFFF - v18) < 1 )
LABEL_36:
          std::_Xlength_error("vector<T> too long");
        v19 = (v17 - *a2) >> 2;
        v23 = v18 + 1;
        if ( 0x3FFFFFFF - (v19 >> 1) >= v19 )
          v20 = (v19 >> 1) + v19;
        else
          v20 = 0;
        if ( v20 < v23 )
          v20 = v23;
        sub_11FFDF0(a2, v20);
      }
      v15 = *(a2 + 4);
      if ( v15 )
      {
        v16 = _wcsdup(v7);
        goto LABEL_34;
      }
    }
    else
    {
      v9 = *(a2 + 8);
      v10 = (&v26 - *a2) >> 2;
      if ( v8 == v9 && ((v9 - v8) >> 2) < 1 )
      {
        v11 = (v8 - *a2) >> 2;
        if ( (0x3FFFFFFF - v11) < 1 )
          goto LABEL_36;
        v12 = (v9 - *a2) >> 2;
        v23 = v11 + 1;
        if ( 0x3FFFFFFF - (v12 >> 1) >= v12 )
          v13 = (v12 >> 1) + v12;
        else
          v13 = 0;
        if ( v13 < v23 )
          v13 = v23;
        sub_11FFDF0(a2, v13);
      }
      v14 = (*a2 + 4 * v10);
      v15 = *(a2 + 4);
      if ( v15 )
      {
        v16 = _wcsdup(*v14);
LABEL_34:
        *v15 = v16;
        goto LABEL_35;
      }
    }
LABEL_35:
    *(a2 + 4) += 4;
    LOBYTE(v29) = 0;
    free(v7);
    VariantClear(&pvarg);
  }
  v4 = v28;
LABEL_39:
  v2 = v25;
LABEL_41:
  v29 = -1;
  if ( v2 )
    (*(*v2 + 8))(v2);
  return v4;
}

//----- (01215350) --------------------------------------------------------
char __stdcall sub_1215350(int a1, void *a2, int a3)
{
  void *v3; // edi
  const wchar_t **v4; // eax
  wchar_t **v5; // ebx
  void *v6; // edi
  wchar_t *v7; // edi
  wchar_t *v8; // ecx
  wchar_t v9; // ax
  char v10; // bl
  wchar_t **v11; // edi
  void *v12; // ebx
  void *v14; // [esp+Ch] [ebp-10h]
  int v15; // [esp+18h] [ebp-4h]

  v3 = a2;
  sub_1215AB0(&a2, a2, L"ScriptText");
  v15 = 0;
  if ( wcslen(a2) )
  {
    v11 = a3;
    v12 = *a3;
    *v11 = _wcsdup(L"Script embedded in WMI database");
    free(v12);
    goto LABEL_8;
  }
  v4 = sub_1215AB0(&v14, v3, L"ScriptFileName");
  v5 = a3;
  v6 = *a3;
  *v5 = _wcsdup(*v4);
  free(v6);
  free(v14);
  v7 = *v5;
  v8 = *v5;
  do
  {
    v9 = *v8;
    ++v8;
  }
  while ( v9 );
  if ( !(v8 - (*v5 + 1)) )
  {
    *v5 = _wcsdup(L"Incorrectly created script entry");
    free(v7);
LABEL_8:
    v10 = 0;
    goto LABEL_9;
  }
  v10 = 1;
LABEL_9:
  free(a2);
  return v10;
}

//----- (01215440) --------------------------------------------------------
bool __stdcall sub_1215440(int a1, void *a2, void *a3)
{
  const wchar_t **v3; // eax
  wchar_t **v4; // edi
  void *v5; // esi
  wchar_t *v6; // ecx
  wchar_t v7; // ax
  const wchar_t **v8; // eax
  wchar_t *v9; // esi
  wchar_t *v10; // ecx
  wchar_t v11; // ax
  const wchar_t **v12; // eax
  wchar_t *v13; // esi
  wchar_t *v14; // esi
  wchar_t v15; // ax
  int v16; // esi
  int v18; // [esp+Ch] [ebp-20h]
  int v19; // [esp+10h] [ebp-1Ch]
  int v20; // [esp+14h] [ebp-18h]
  int v21; // [esp+18h] [ebp-14h]
  void *v22; // [esp+1Ch] [ebp-10h]
  int v23; // [esp+28h] [ebp-4h]

  v3 = sub_1215AB0(&v22, a2, L"ExecutablePath");
  v4 = a3;
  v5 = *a3;
  *v4 = _wcsdup(*v3);
  free(v5);
  free(v22);
  v6 = *v4;
  do
  {
    v7 = *v6;
    ++v6;
  }
  while ( v7 );
  if ( v6 - (*v4 + 1) )
    return 0;
  v8 = sub_1215AB0(&a2, a2, L"CommandLineTemplate");
  v9 = *v4;
  *v4 = _wcsdup(*v8);
  free(v9);
  free(a2);
  v10 = *v4;
  do
  {
    v11 = *v10;
    ++v10;
  }
  while ( v11 );
  if ( !(v10 - (*v4 + 1)) )
    return 0;
  v18 = malloc(2u);
  *v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v23 = 0;
  if ( !sub_11F6CC0(*v4, &v18) )
  {
    sub_11F21F0(&v18);
    return 0;
  }
  v12 = sub_11F4EE0(&a3, a1, &v18, 0);
  v13 = *v4;
  *v4 = _wcsdup(*v12);
  free(v13);
  free(a3);
  v14 = *v4;
  do
  {
    v15 = *v14;
    ++v14;
  }
  while ( v15 );
  v16 = v14 - (*v4 + 1);
  sub_11F21F0(&v18);
  return v16 >> 1 != 0;
}

//----- (012155B0) --------------------------------------------------------
int __cdecl sub_12155B0(const wchar_t **a1)
{
  int *v1; // edi
  int *v2; // esi
  int **v3; // eax
  int *j; // eax
  int *i; // eax

  v1 = dword_12E4D14;
  v2 = *dword_12E4D14;
  if ( *dword_12E4D14 == dword_12E4D14 )
    return 0;
  while ( _wcsicmp(v2[4], *a1) )
  {
    if ( !*(v2 + 13) )
    {
      v3 = v2[2];
      if ( *(v3 + 13) )
      {
        for ( i = v2[1]; !*(i + 13); i = i[1] )
        {
          if ( v2 != i[2] )
            break;
          v2 = i;
        }
        v2 = i;
      }
      else
      {
        v2 = v2[2];
        for ( j = *v3; !*(j + 13); j = *j )
          v2 = j;
      }
    }
    if ( v2 == v1 )
      return 0;
  }
  return v2[5];
}

//----- (01215630) --------------------------------------------------------
char __thiscall sub_1215630(void *this, int a2, int a3, void **a4)
{
  void *v4; // ebx
  const wchar_t **v5; // eax
  void *v6; // esi
  char *v7; // eax
  __int16 v8; // cx
  char result; // al
  void *v10; // [esp+Ch] [ebp-4h]

  v4 = this;
  v5 = sub_1215AB0(&v10, a3, L"ScriptFileName");
  v6 = *a4;
  *a4 = _wcsdup(*v5);
  free(v6);
  free(v10);
  v7 = *a4;
  do
  {
    v8 = *v7;
    v7 += 2;
  }
  while ( v8 );
  if ( (v7 - (*a4 + 2)) >> 1 )
    result = 1;
  else
    result = (*(*v4 + 4))(v4, a2, a3, a4);
  return result;
}

//----- (012156B0) --------------------------------------------------------
char __thiscall sub_12156B0(void *this, int a2, int a3, void **a4)
{
  void *v4; // ebx
  const wchar_t **v5; // eax
  void *v6; // esi
  char *v7; // eax
  __int16 v8; // cx
  char result; // al
  void *v10; // [esp+Ch] [ebp-4h]

  v4 = this;
  v5 = sub_1215AB0(&v10, a3, L"CommandLineTemplate");
  v6 = *a4;
  *a4 = _wcsdup(*v5);
  free(v6);
  free(v10);
  v7 = *a4;
  do
  {
    v8 = *v7;
    v7 += 2;
  }
  while ( v8 );
  if ( (v7 - (*a4 + 2)) >> 1 )
    result = 1;
  else
    result = (*(*v4 + 4))(v4, a2, a3, a4);
  return result;
}

//----- (01215730) --------------------------------------------------------
int __cdecl sub_1215730(LPVOID ppv, int a2, OLECHAR *psz, void *a4)
{
  int v4; // ebx
  wchar_t *v5; // edi
  const wchar_t **v6; // eax
  wchar_t *v7; // esi
  char v8; // bl
  unsigned int v9; // ecx
  int v10; // eax
  void *v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  wchar_t *v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+24h] [ebp-4h]

  v4 = 0;
  v13 = 0;
  v5 = malloc(2u);
  v14 = v5;
  *v5 = 0;
  v15 = 0;
  v6 = sub_1215AB0(&v12, a2, psz);
  v7 = _wcsdup(*v6);
  v14 = v7;
  free(v5);
  free(v12);
  if ( wcslen(v7) )
  {
    if ( a4 )
    {
      v8 = 0;
      v9 = wcslen(v7);
      if ( v7[v9 - 1] == 34 )
      {
        v8 = 1;
        v7[v9 - 1] = 0;
      }
      sub_11F2300(&v14, a4, 0x7FFFFFFF, 0);
      if ( v8 )
        sub_11F2300(&v14, L"\"", 0x7FFFFFFF, 0);
      v7 = v14;
    }
    v10 = sub_1215850(ppv, v7, &v13);
    v4 = v13;
    if ( v10 < 0 )
      v4 = 0;
  }
  free(v7);
  return v4;
}

//----- (01215850) --------------------------------------------------------
int __cdecl sub_1215850(LPVOID ppv, wchar_t *psz, int ppComBSTR)
{
  _DWORD *v3; // esi
  OLECHAR *v4; // edi
  wchar_t *v5; // ST14_4
  int result; // eax
  bool v7; // bl
  CComBSTR *v8; // edx
  BSTR v9; // edx
  int v10; // eax
  int v11; // edi
  int v12; // [esp+10h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-4h]

  v3 = ppComBSTR;
  v4 = psz;
  v5 = psz;
  *ppComBSTR = 0;
  result = sub_1215BE0(&ppv, v5);
  if ( result >= 0 )
  {
    v7 = result == 0;
    v8 = *bstr_t::EqualAssign(&ppComBSTR, v4);
    v13 = 0;
    if ( v8 )
      v9 = v8->bstr;
    else
      v9 = 0;
    v10 = (*(*ppv + 24))(ppv, v9, 0, 0, &v12, 0);
    v13 = -1;
    v11 = v10;
    bstr_t::Data_t::Free(&ppComBSTR);
    if ( v11 >= 0 )
      *v3 = v12;
    if ( v7 )
      (*(*ppv + 8))(ppv);
    result = v11;
  }
  return result;
}

//----- (01215910) --------------------------------------------------------
wchar_t **__stdcall sub_1215910(wchar_t **a1, int a2)
{
  *a1 = _wcsdup(gpszTargetName);
  return a1;
}

//----- (01215940) --------------------------------------------------------
int __stdcall sub_1215940(int a1, void *a2)
{
  void *v2; // esi
  __int16 *v3; // eax
  __int16 v4; // cx
  const wchar_t **v5; // eax
  __int16 *v6; // esi

  v2 = a2;
  sub_1215AB0(a1, a2, L"CommandLineTemplate");
  v3 = *a1;
  do
  {
    v4 = *v3;
    ++v3;
  }
  while ( v4 );
  if ( !((v3 - *a1 - 2) >> 1) )
  {
    v5 = sub_1215AB0(&a2, v2, L"ExecutablePath");
    v6 = *a1;
    *a1 = _wcsdup(*v5);
    free(v6);
    free(a2);
  }
  return a1;
}

//----- (01215A00) --------------------------------------------------------
char __stdcall sub_1215A00(void *a1, int a2, int a3)
{
  const wchar_t **v3; // eax
  wchar_t **v4; // edi
  void *v5; // esi
  wchar_t *v6; // eax
  wchar_t v7; // cx
  const wchar_t **v8; // eax
  wchar_t **v9; // esi
  void *v10; // edi
  void *v12; // [esp+8h] [ebp-4h]

  v3 = sub_1215AB0(&v12, a1, L"ScriptText");
  v4 = a3;
  v5 = *a3;
  *v4 = _wcsdup(*v3);
  free(v5);
  free(v12);
  v6 = *v4;
  do
  {
    v7 = *v6;
    ++v6;
  }
  while ( v7 );
  if ( !(v6 - (*v4 + 1)) )
    return 0;
  v8 = sub_1215AB0(&a1, a1, L"ScriptingEngine");
  v9 = a2;
  v10 = *a2;
  *v9 = _wcsdup(*v8);
  free(v10);
  free(a1);
  return 1;
}

//----- (01215AA0) --------------------------------------------------------
char __stdcall sub_1215AA0(int a1, int a2, int a3)
{
  return 0;
}

//----- (01215AB0) --------------------------------------------------------
int __cdecl sub_1215AB0(int a1, int a2, OLECHAR *psz)
{
  CComBSTR *v3; // edx
  BSTR v4; // edx
  int v5; // eax
  CComBSTR *v6; // esi
  int v7; // edi
  const wchar_t *v8; // ecx
  wchar_t *v9; // esi
  int result; // eax
  VARIANTARG pvarg; // [esp+Ch] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-14h]
  CComBSTR *ppv; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v12 = 0;
  v3 = *bstr_t::EqualAssign(&ppv, psz);
  v14 = 0;
  if ( v3 )
    v4 = v3->bstr;
  else
    v4 = 0;
  v5 = (*(*a2 + 16))(a2, v4, 0, &pvarg, 0, 0);
  v6 = ppv;
  v7 = v5;
  if ( ppv && !InterlockedDecrement(&ppv->Length) && v6 )
  {
    if ( v6->bstr )
    {
      SysFreeString(v6->bstr);
      v6->bstr = 0;
    }
    if ( v6->hKey )
    {
      j_j__free(v6->hKey);
      v6->hKey = 0;
    }
    j__free(v6);
  }
  if ( v7 < 0 || pvarg.vt != 8 )
  {
    *a1 = _wcsdup(gpszTargetName);
    result = a1;
  }
  else
  {
    v8 = gpszTargetName;
    if ( pvarg.lVal )
      v8 = pvarg.bstrVal;
    v9 = _wcsdup(v8);
    VariantClear(&pvarg);
    *a1 = _wcsdup(v9);
    free(v9);
    result = a1;
  }
  return result;
}

//----- (01215BE0) --------------------------------------------------------
int __cdecl sub_1215BE0(LPVOID *ppv, wchar_t *a2)
{
  wchar_t *v2; // eax
  wchar_t *v3; // edi
  int result; // eax
  wchar_t *v5; // eax
  int v6; // esi

  if ( *a2 != 92 )
    return 1;
  v2 = _wcsdup(a2);
  v3 = v2;
  if ( !v2 )
    return -2147024882;
  v5 = wcschr(v2, 0x3Au);
  if ( !v5 )
  {
    free(v3);
    return 1;
  }
  *v5 = 0;
  v6 = sub_1214DA0(v3, ppv);
  free(v3);
  result = 0;
  if ( v6 < 0 )
    result = v6;
  return result;
}

//----- (01215C50) --------------------------------------------------------
bool __stdcall sub_1215C50(void *a1, int a2)
{
  const wchar_t **v2; // eax
  wchar_t **v3; // edi
  void *v4; // esi
  wchar_t *v5; // eax
  wchar_t v6; // cx

  v2 = sub_1215AB0(&a1, a1, L"WorkingDirectory");
  v3 = a2;
  v4 = *a2;
  *v3 = _wcsdup(*v2);
  free(v4);
  free(a1);
  v5 = *v3;
  do
  {
    v6 = *v5;
    ++v5;
  }
  while ( v6 );
  return v5 - (*v3 + 1) != 0;
}

//----- (01215CB0) --------------------------------------------------------
void __thiscall sub_1215CB0(void *this)
{
  void *v1; // esi
  void *v2; // eax
  int v3; // ecx

  v1 = this;
  if ( !InterlockedDecrement(this + 1) && v1 )
  {
    v2 = *(v1 + 3);
    if ( v2 )
      CloseHandle(v2);
    if ( *(v1 + 4) )
      CloseHandle(*(v1 + 4));
    if ( *(v1 + 5) )
      CloseHandle(*(v1 + 5));
    if ( *(v1 + 6) )
      CloseHandle(*(v1 + 6));
    v3 = *(v1 + 7);
    if ( v3 )
      (*(*v3 + 8))(*(v1 + 7));
    j__free(v1);
  }
}

//----- (01215D10) --------------------------------------------------------
void __cdecl sub_1215D10(int a1)
{
  int v1; // ebx
  void **v2; // edi
  int v3; // eax
  int v4; // eax
  const wchar_t **v5; // eax
  bool v6; // bl
  void **v7; // eax
  const wchar_t **v8; // ebx
  const wchar_t **i; // esi
  void *v10; // edi
  void **v11; // esi
  int v12; // edi
  int v13; // eax
  void *v14; // ebx
  void **v15; // esi
  int v16; // eax
  void *v17; // edi
  int v18; // eax
  void *v19; // eax
  void *v20; // esi
  void *v21; // eax
  void *v22; // ebx
  void *v23; // esi
  int v24; // edi
  const wchar_t **v25; // eax
  const wchar_t **v26; // eax
  void *v27; // edi
  const wchar_t **v28; // eax
  void *v29; // edi
  wchar_t *v30; // edi
  int v31; // edi
  const wchar_t **v32; // eax
  void *v33; // edi
  wchar_t *v34; // edi
  wchar_t *v35; // edi
  void *v36; // edi
  wchar_t *v37; // edi
  _WORD *v38; // eax
  _WORD *v39; // eax
  _WORD *v40; // eax
  int v41; // ecx
  int v42; // eax
  void *v43; // edi
  wchar_t *v44; // eax
  int *v45; // ebx
  int v46; // ecx
  int v47; // ecx
  unsigned __int16 **v48; // esi
  void *v49; // edi
  unsigned __int16 *v50; // eax
  unsigned __int16 v51; // cx
  void *v52; // edi
  wchar_t *v53; // eax
  void *v54; // edi
  wchar_t *v55; // eax
  _DWORD *v56; // edi
  unsigned int v57; // ecx
  int v58; // ebx
  unsigned int v59; // esi
  _BYTE *v60; // eax
  _BYTE *k; // eax
  int j; // eax
  void **l; // esi
  void *v64; // [esp+10h] [ebp-B4h]
  void *v65; // [esp+14h] [ebp-B0h]
  void *v66; // [esp+18h] [ebp-ACh]
  void *v67; // [esp+1Ch] [ebp-A8h]
  void *v68; // [esp+20h] [ebp-A4h]
  void *v69; // [esp+24h] [ebp-A0h]
  int v70; // [esp+28h] [ebp-9Ch]
  int v71; // [esp+2Ch] [ebp-98h]
  void *v72; // [esp+30h] [ebp-94h]
  void *v73; // [esp+34h] [ebp-90h]
  void *v74; // [esp+38h] [ebp-8Ch]
  wchar_t *v75; // [esp+3Ch] [ebp-88h]
  wchar_t *v76; // [esp+40h] [ebp-84h]
  int v77; // [esp+44h] [ebp-80h]
  wchar_t *v78; // [esp+48h] [ebp-7Ch]
  void *v79; // [esp+4Ch] [ebp-78h]
  void *v80; // [esp+50h] [ebp-74h]
  void *v81; // [esp+54h] [ebp-70h]
  void *v82; // [esp+58h] [ebp-6Ch]
  int v83; // [esp+5Ch] [ebp-68h]
  const wchar_t **v84; // [esp+60h] [ebp-64h]
  const wchar_t **v85; // [esp+64h] [ebp-60h]
  int v86; // [esp+68h] [ebp-5Ch]
  void *v87; // [esp+6Ch] [ebp-58h]
  unsigned __int16 **v88; // [esp+70h] [ebp-54h]
  int v89; // [esp+74h] [ebp-50h]
  void *v90; // [esp+78h] [ebp-4Ch]
  void *v91; // [esp+7Ch] [ebp-48h]
  int v92; // [esp+80h] [ebp-44h]
  void *v93; // [esp+84h] [ebp-40h]
  void *v94; // [esp+88h] [ebp-3Ch]
  int v95; // [esp+8Ch] [ebp-38h]
  int v96; // [esp+90h] [ebp-34h]
  char v97; // [esp+97h] [ebp-2Dh]
  LPVOID ppv; // [esp+98h] [ebp-2Ch]
  int v99; // [esp+9Ch] [ebp-28h]
  void *v100; // [esp+A0h] [ebp-24h]
  int v101; // [esp+A4h] [ebp-20h]
  void *v102; // [esp+A8h] [ebp-1Ch]
  void *v103; // [esp+ACh] [ebp-18h]
  wchar_t *psz; // [esp+B0h] [ebp-14h]
  wchar_t *v105; // [esp+B4h] [ebp-10h]
  int v106; // [esp+C0h] [ebp-4h]

  v1 = 0;
  ppv = 0;
  v2 = 0;
  v85 = 0;
  v84 = 0;
  v86 = 0;
  v106 = 0;
  v99 = 0;
  v83 = 0;
  v82 = sub_11FF9A0();
  v100 = malloc(2u);
  *v100 = 0;
  v87 = malloc(2u);
  *v87 = 0;
  v90 = malloc(2u);
  *v90 = 0;
  v79 = malloc(2u);
  *v79 = 0;
  v74 = malloc(2u);
  *v74 = 0;
  v73 = malloc(2u);
  *v73 = 0;
  psz = malloc(2u);
  *psz = 0;
  v78 = malloc(2u);
  *v78 = 0;
  v76 = malloc(2u);
  *v76 = 0;
  v75 = malloc(2u);
  *v75 = 0;
  LOBYTE(v106) = 11;
  v81 = sub_1214FE0(a1, 0xFFFFFFFF);
  if ( CoInitializeEx(0, 0) >= 0 )
  {
    if ( IsBuiltinAndAnministrative() )
      dwMilliseconds *= 4;
    if ( sub_1214DA0(L"ROOT\\subscription", &ppv) >= 0 )
    {
      sub_1214920(&v89, ppv, L"SELECT * FROM __EventConsumer");
      v3 = v89;
      LOBYTE(v106) = 12;
      if ( v89 )
      {
        while ( v3 )
        {
          v4 = (*(*v3 + 16))(v3, -1, 1, &v99, &v91);
          if ( v4 < 0 || v4 || v91 != 1 )
            break;
          v5 = sub_1215AB0(&v80, v99, L"__CLASS");
          v6 = sub_12155B0(v5) != 0;
          free(v80);
          if ( v6 )
          {
            v93 = 0;
            v94 = 0;
            v95 = 0;
            LOBYTE(v106) = 13;
            v7 = sub_1214BC0(&v82, &v99);
            sub_1214B60(v7, &v93);
            LOBYTE(v106) = 12;
            if ( v93 )
            {
              j__free(v93);
              v3 = v89;
              v93 = 0;
              v94 = 0;
              v95 = 0;
            }
            else
            {
              v3 = v89;
            }
          }
          else
          {
            (*(*v99 + 8))(v99);
            v3 = v89;
          }
        }
        v1 = v85;
      }
      if ( v83 )
      {
        v102 = _wcsdup(L"ROOT");
        LOBYTE(v106) = 14;
        sub_1200530(&v84, &v102);
        LOBYTE(v106) = 12;
        free(v102);
        v8 = v85;
        for ( i = v84; (v8 - v84) & 0xFFFFFFFC; i = v84 )
        {
          v10 = _wcsdup(*i);
          v102 = v10;
          LOBYTE(v106) = 15;
          sub_1214700(i + 1, v8, i);
          --v8;
          v11 = v8;
          if ( v8 != v85 )
          {
            v12 = v85;
            do
            {
              free(*v11);
              ++v11;
            }
            while ( v11 != v12 );
            v10 = v102;
          }
          v85 = v8;
          if ( sub_1214DA0(v10, &ppv) >= 0 )
          {
            v93 = 0;
            v94 = 0;
            v95 = 0;
            LOBYTE(v106) = 16;
            v13 = sub_1215120(ppv, &v93);
            v14 = v94;
            v15 = v93;
            if ( v13 >= 0 )
            {
              if ( v93 != v94 )
              {
                do
                {
                  v103 = _wcsdup(v10);
                  LOBYTE(v106) = 17;
                  sub_11F2300(&v103, L"\\", 0x7FFFFFFF, 0);
                  sub_11F2300(&v103, *v15, 0x7FFFFFFF, 0);
                  sub_1200530(&v84, &v103);
                  LOBYTE(v106) = 16;
                  free(v103);
                  ++v15;
                }
                while ( v15 != v14 );
              }
              v15 = v93;
            }
            sub_1214920(&v101, ppv, L"SELECT * FROM __FilterToConsumerBinding");
            v16 = v101;
            LOBYTE(v106) = 18;
            if ( v101 )
            {
              v17 = v81;
              while ( v16 )
              {
                v18 = (*(*v16 + 16))(v16, -1, 1, &v99, &v91);
                if ( v18 < 0 || v18 || v91 != 1 )
                  break;
                sub_1216830(a1, v17, ppv, v99, &v82);
                (*(*v99 + 8))(v99);
                v16 = v101;
              }
              v10 = v102;
            }
            (*(*ppv + 8))(ppv);
            LOBYTE(v106) = 16;
            if ( v101 )
              (*(*v101 + 8))(v101);
            if ( v15 )
            {
              v19 = v93;
              if ( v93 != v14 )
              {
                do
                {
                  free(*v15);
                  ++v15;
                }
                while ( v15 != v14 );
                v19 = v93;
              }
              j__free(v19);
              v93 = 0;
              v94 = 0;
              v95 = 0;
            }
            LOBYTE(v106) = 12;
            free(v10);
            v8 = v85;
          }
          else
          {
            LOBYTE(v106) = 12;
            free(v10);
          }
        }
        v20 = dword_12E4D10;
        if ( dword_12E4D10 )
        {
          v21 = *(dword_12E4D10 + 5);
          *(dword_12E4D10 + 8) = 1;
          if ( v21 )
            SetEvent(v21);
          sub_1215CB0(v20);
          dword_12E4D10 = 0;
        }
        v22 = v82;
        v102 = v82;
        v23 = *v82;
        v103 = v23;
        if ( v23 != v82 )
        {
          do
          {
            v96 = *(v23 + 4);
            v24 = v96;
            v25 = sub_1215AB0(&v65, v96, L"__CLASS");
            v101 = sub_12155B0(v25);
            free(v65);
            v80 = 4;
            v77 = 1;
            v26 = sub_1215AB0(&v67, v24, L"Name");
            v27 = v100;
            v100 = _wcsdup(*v26);
            free(v27);
            free(v67);
            if ( wcslen(v100) )
            {
              if ( wcslen(v100) >= 9 )
              {
                v30 = (v100 + 2 * wcslen(v100) - 18);
                if ( !_wcsicmp(v30, L"_disabled") )
                {
                  v77 = 0;
                  *v30 = 0;
                }
              }
            }
            else
            {
              v28 = sub_1215AB0(&v64, v96, L"__PATH");
              v29 = v100;
              v100 = _wcsdup(*v28);
              free(v29);
              free(v64);
            }
            v31 = v96;
            if ( (*(*v101 + 4))(a1, v96, &psz) )
            {
              v32 = (**v101)(&v68, v31);
              v33 = v87;
              v87 = _wcsdup(*v32);
              free(v33);
              free(v68);
              if ( (*(*v101 + 12))(v96, &v75) )
              {
                v105 = malloc(2u);
                *v105 = 0;
                LOBYTE(v106) = 19;
                if ( sub_1201150(a1, v75, psz, &v105) )
                {
                  v34 = psz;
                  psz = _wcsdup(v105);
                  free(v34);
                }
                LOBYTE(v106) = 12;
                free(v105);
              }
              v80 = sub_11F4ED0();
            }
            else
            {
              v35 = psz;
              if ( wcslen(psz) )
              {
                psz = _wcsdup(gpszTargetName);
                free(v35);
                v36 = v90;
                v90 = _wcsdup(psz);
                free(v36);
              }
            }
            (*(*v101 + 8))(a1, v96, &v73);
            v72 = _wcsdup(L"WMI Database Entries");
            v69 = _wcsdup(gpszTargetName);
            LOBYTE(v106) = 21;
            v97 = sub_11F3D40(a1, &v69, &v72, &v87, &psz, &v79, &v74, &v70);
            free(v69);
            LOBYTE(v106) = 12;
            free(v72);
            if ( v97 )
            {
              v37 = operator new(0x18u);
              v105 = v37;
              if ( v37 )
              {
                v38 = malloc(2u);
                *(v37 + 3) = v38;
                *v38 = 0;
                v39 = malloc(2u);
                *(v37 + 4) = v39;
                *v39 = 0;
                v40 = malloc(2u);
                *(v37 + 5) = v40;
                *v40 = 0;
                *(v37 + 8) = 0;
                *v37 = 0;
                *(v37 + 1) = 0;
              }
              else
              {
                v37 = 0;
                v105 = 0;
              }
              v41 = v96;
              *(v37 + 1) = v96;
              (*(*v41 + 4))(v41);
              v42 = (v37 + 6);
              v43 = *(v37 + 3);
              v88 = v42;
              v44 = _wcsdup(gpszTargetName);
              *(v105 + 3) = v44;
              free(v43);
              if ( (*(v23 + 6) - *(v23 + 5)) & 0xFFFFFFFC )
              {
                v45 = *(v23 + 5);
                v46 = *(v23 + 6) - v45;
                v71 = 0;
                v47 = (v46 + 3) >> 2;
                if ( v45 > *(v23 + 6) )
                  v47 = 0;
                v92 = v47;
                if ( v47 )
                {
                  v48 = v88;
                  do
                  {
                    sub_1215AB0(&v66, *v45, L"Query");
                    v49 = v66;
                    if ( wcslen(v66) )
                    {
                      v50 = *v48;
                      do
                      {
                        v51 = *v50;
                        ++v50;
                      }
                      while ( v51 );
                      if ( v50 - (*v48 + 1) )
                        sub_11F2300(v48, L"; ", 0x7FFFFFFF, 0);
                      sub_11F2300(v48, v49, 0x7FFFFFFF, 0);
                    }
                    free(v49);
                    ++v45;
                    ++v71;
                  }
                  while ( v71 != v92 );
                  v23 = v103;
                }
                v22 = v102;
              }
              else
              {
                v77 = 0;
              }
              if ( (*(*v101 + 16))(v96, &v78, &v76) )
              {
                v52 = *(v105 + 4);
                v53 = _wcsdup(v78);
                *(v105 + 4) = v53;
                free(v52);
                v54 = *(v105 + 5);
                v55 = _wcsdup(v76);
                *(v105 + 5) = v55;
                free(v54);
                *(v105 + 8) = 1;
              }
              v81 = sub_1214FE0(a1, v81);
              v91 = _wcsdup(gpszTargetName);
              LOBYTE(v106) = 22;
              sub_11F3FF0(a1, v80, v81, 17, &v100, &v87, &psz);
              LOBYTE(v106) = 12;
              free(v91);
            }
            (*(*v96 + 8))(v96);
            v56 = *(v23 + 5);
            v57 = (*(v23 + 6) - v56 + 3) >> 2;
            if ( v56 > *(v23 + 6) )
              v57 = 0;
            v88 = v57;
            if ( v57 )
            {
              v58 = 0;
              v59 = v57;
              do
              {
                (*(**v56 + 8))(*v56);
                ++v58;
                ++v56;
              }
              while ( v58 != v59 );
              v23 = v103;
              v22 = v102;
            }
            if ( !*(v23 + 13) )
            {
              v60 = *(v23 + 2);
              if ( v60[13] )
              {
                for ( j = *(v23 + 1); !*(j + 13); j = *(j + 4) )
                {
                  if ( v23 != *(j + 8) )
                    break;
                  v23 = j;
                }
                v23 = j;
                v103 = j;
              }
              else
              {
                v23 = *(v23 + 2);
                v103 = v60;
                for ( k = *v60; !k[13]; k = *k )
                {
                  v23 = k;
                  v103 = k;
                }
              }
            }
          }
          while ( v23 != v22 );
        }
        v2 = v84;
        v1 = v85;
      }
      else
      {
        sub_1214D60();
      }
      LOBYTE(v106) = 11;
      if ( v89 )
        (*(*v89 + 8))(v89);
    }
  }
  free(v75);
  free(v76);
  free(v78);
  free(psz);
  free(v73);
  free(v74);
  free(v79);
  free(v90);
  free(v87);
  free(v100);
  LOBYTE(v106) = 0;
  sub_12171F0(&v82, &v92, *v82, v82);
  j__free(v82);
  if ( v2 )
  {
    for ( l = v2; l != v1; ++l )
      free(*l);
    j__free(v2);
  }
}
// 12B355C: using guessed type wchar_t aRootSubscripti[18];
// 12B3624: using guessed type wchar_t asc_12B3624[3];

//----- (01216830) --------------------------------------------------------
CMapNode *__cdecl sub_1216830(int a1, int a2, LPVOID ppv, int a4, int a5)
{
  int v5; // eax
  int v6; // esi
  int v7; // ebx
  CMapNode *v8; // ebx
  CMapNode *v9; // esi
  wchar_t *v10; // edi
  int v12; // [esp+10h] [ebp-2Ch]
  wchar_t *v13; // [esp+14h] [ebp-28h]
  void *v14; // [esp+18h] [ebp-24h]
  int v15; // [esp+1Ch] [ebp-20h]
  wchar_t *v16; // [esp+20h] [ebp-1Ch]
  int v17; // [esp+24h] [ebp-18h]
  CMapNode var14; // [esp+28h] [ebp-14h]

  var14._Parent = 0;
  v15 = sub_1215730(ppv, a4, L"Consumer", 0);
  v5 = sub_1215730(ppv, a4, L"Filter", 0);
  v6 = v15;
  v7 = v5;
  v17 = v5;
  v12 = v5;
  if ( v15 )
  {
    if ( v5 )
    {
      sub_1215AB0(&v14, v15, L"__CLASS");
      var14._KeyValue.Key = 0;
      if ( sub_12155B0(&v14) )
      {
        sub_1215AB0(&v16, v6, L"__PATH");
        LOBYTE(var14._KeyValue.Key) = 1;
        v8 = *a5;
        v9 = **a5;
        var14._Left = v9;
        if ( v9 == v8 )
        {
LABEL_7:
          v7 = v17;
        }
        else
        {
          while ( 1 )
          {
            sub_1215AB0(&v13, v9->_KeyValue.Key, L"__PATH");
            v10 = v13;
            LOBYTE(var14._KeyValue.Key) = 2;
            if ( !_wcsicmp(v16, v13) )
              break;
            LOBYTE(var14._KeyValue.Key) = 1;
            free(v10);
            sub_1214CE0(&var14);
            v9 = var14._Left;
            if ( var14._Left == v8 )
              goto LABEL_7;
          }
          sub_12308F0(&v9->_KeyValue.Value, &v12);
          v7 = 0;
          var14._Parent = 1;
          free(v10);
        }
        free(v16);
        v6 = v15;
      }
      var14._KeyValue.Key = -1;
      free(v14);
    }
    (*(*v6 + 8))(v6);
  }
  if ( v7 )
    (*(*v7 + 8))(v7);
  return var14._Parent;
}

//----- (012169A0) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  LPVOID v1; // esi
  HRESULT v2; // eax
  HRESULT v3; // eax
  CComBSTR *v4; // edx
  BSTR v5; // edx
  int v6; // eax
  CComBSTR *v7; // edi
  HRESULT v8; // eax
  LPUNKNOWN pUnk; // [esp+10h] [ebp-14h]
  CComBSTR *ppv; // [esp+14h] [ebp-10h]
  int v12; // [esp+20h] [ebp-4h]

  v1 = lpThreadParameter;
  InterlockedIncrement(lpThreadParameter + 1);
  v2 = CoInitializeEx(0, 0);
  *(v1 + 2) = v2;
  if ( v2 >= 0 )
  {
    v3 = CoCreateInstance(&stru_12C7A7C, 0, 1u, &stru_12B2E34, &lpThreadParameter);
    *(v1 + 2) = v3;
    if ( v3 >= 0 )
    {
      while ( SetEvent(*(v1 + 3)) )
      {
        v4 = *bstr_t::EqualAssign(&ppv, *v1);
        v12 = 0;
        if ( v4 )
          v5 = v4->bstr;
        else
          v5 = 0;
        v6 = (*(*lpThreadParameter + 12))(lpThreadParameter, v5, 0, 0, 0, 128, 0, 0, &pUnk);
        v7 = ppv;
        *(v1 + 2) = v6;
        v12 = -1;
        if ( v7 )
        {
          if ( !InterlockedDecrement(&v7->Length) && v7 )
          {
            if ( v7->bstr )
            {
              SysFreeString(v7->bstr);
              v7->bstr = 0;
            }
            if ( v7->hKey )
            {
              j_j__free(v7->hKey);
              v7->hKey = 0;
            }
            j__free(v7);
          }
          ppv = 0;
        }
        if ( *(v1 + 2) < 0 )
          break;
        v8 = CoMarshalInterThreadInterfaceInStream(&CLSID_IWbemServices, pUnk, v1 + 7);
        *(v1 + 2) = v8;
        if ( v8 < 0 )
          goto LABEL_21;
        if ( !SetEvent(*(v1 + 4)) )
        {
          (*(*lpThreadParameter + 8))(lpThreadParameter);
          *(v1 + 2) = -2147467259;
          return 0;
        }
        if ( WaitForSingleObject(*(v1 + 5), 0xFFFFFFFF) )
        {
          *(v1 + 2) = -2147467259;
LABEL_21:
          (*(*lpThreadParameter + 8))(lpThreadParameter);
          sub_1215CB0(v1);
          return 1;
        }
        if ( *(v1 + 8) )
          goto LABEL_21;
      }
      (*(*lpThreadParameter + 8))(lpThreadParameter);
    }
  }
  sub_1215CB0(v1);
  return 0;
}

//----- (01216B70) --------------------------------------------------------
_DWORD *__thiscall sub_1216B70(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edx

  v1 = this;
  v2 = operator new(0x20u);
  if ( !v2 )
    std::bad_alloc::bad_alloc();
  *v2 = *v1;
  if ( v2 != -4 )
    v2[1] = *v1;
  if ( v2 != -8 )
    v2[2] = *v1;
  return v2;
}

//----- (01216BB0) --------------------------------------------------------
_DWORD *__thiscall sub_1216BB0(_DWORD *this, int a2, size_t a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // ecx
  _DWORD *result; // eax
  int v10; // [esp+0h] [ebp-28h]
  _DWORD *v11; // [esp+10h] [ebp-18h]
  _DWORD *v12; // [esp+14h] [ebp-14h]
  int *v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+24h] [ebp-4h]

  v13 = &v10;
  v3 = this;
  v11 = this;
  v4 = a2 | 0xF;
  if ( (a2 | 0xFu) <= 0xFFFFFFFE )
  {
    v5 = this[5];
    v6 = this[5] >> 1;
    if ( v6 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > -2 - v6 )
        v4 = -2;
    }
  }
  else
  {
    v4 = a2;
  }
  v14 = 0;
  v7 = 0;
  v12 = 0;
  if ( v4 != -1 )
  {
    if ( v4 + 1 > 0xFFFFFFFF || (v7 = operator new(v4 + 1), (v12 = v7) == 0) )
      std::bad_alloc::bad_alloc();
  }
  if ( a3 )
  {
    v8 = v3[5] < 0x10u ? v3 : *v3;
    if ( a3 )
      memmove_0(v7, v8, a3);
  }
  if ( v3[5] >= 0x10u )
    j__free(*v3);
  result = v12;
  *v3 = 0;
  *v3 = result;
  v3[5] = v4;
  v3[4] = a3;
  if ( v4 >= 0x10 )
    v3 = result;
  *(v3 + a3) = 0;
  return result;
}

//----- (01216D00) --------------------------------------------------------
void __stdcall sub_1216D00(void *a1)
{
  if ( *(a1 + 5) )
  {
    j__free(*(a1 + 5));
    *(a1 + 5) = 0;
    *(a1 + 6) = 0;
    *(a1 + 7) = 0;
  }
  j__free(a1);
}

//----- (01216D40) --------------------------------------------------------
void __stdcall sub_1216D40(void *a1)
{
  free(*(a1 + 4));
  j__free(a1);
}

//----- (01216D60) --------------------------------------------------------
void __stdcall sub_1216D60(void *a1)
{
  void **v1; // esi
  void **v2; // edi

  v1 = a1;
  v2 = a1;
  if ( !*(a1 + 13) )
  {
    do
    {
      sub_1216D60(v2[2]);
      v2 = *v2;
      if ( v1[5] )
      {
        j__free(v1[5]);
        v1[5] = 0;
        v1[6] = 0;
        v1[7] = 0;
      }
      j__free(v1);
      v1 = v2;
    }
    while ( !*(v2 + 13) );
  }
}

//----- (01216DC0) --------------------------------------------------------
void __stdcall sub_1216DC0(void *a1)
{
  void **v1; // edi
  void **v2; // esi

  v1 = a1;
  v2 = a1;
  if ( !*(a1 + 13) )
  {
    do
    {
      sub_1216DC0(v2[2]);
      v2 = *v2;
      free(v1[4]);
      j__free(v1);
      v1 = v2;
    }
    while ( !*(v2 + 13) );
  }
}

//----- (01216E00) --------------------------------------------------------
BOOL __thiscall sub_1216E00(void *this, size_t a2, int a3)
{
  _DWORD *v3; // esi
  size_t v4; // eax
  BOOL result; // eax
  size_t v6; // ebx
  void *v7; // eax
  int v8; // [esp+14h] [ebp+Ch]

  v3 = this;
  if ( a2 > 0xFFFFFFFE )
    std::_Xlength_error("string too long");
  v4 = *(this + 5);
  if ( v4 >= a2 )
  {
    if ( a3 && a2 < 0x10 )
    {
      v6 = *(this + 4);
      if ( a2 < v6 )
        v6 = a2;
      if ( v4 >= 0x10 )
      {
        v7 = *this;
        v8 = *this;
        if ( v6 )
        {
          memmove_0(this, v7, v6);
          v7 = v8;
        }
        j__free(v7);
      }
      v3[4] = v6;
      v3[5] = 15;
      *(v3 + v6) = 0;
      result = a2 > 0;
    }
    else
    {
      if ( !a2 )
      {
        *(this + 4) = 0;
        if ( v4 >= 0x10 )
          v3 = *this;
        *v3 = 0;
      }
      result = a2 > 0;
    }
  }
  else
  {
    sub_1216BB0(this, a2, *(this + 4));
    result = a2 > 0;
  }
  return result;
}

//----- (01216EC0) --------------------------------------------------------
void *__stdcall sub_1216EC0(size_t a1)
{
  void *v1; // ecx

  v1 = 0;
  if ( a1 )
  {
    if ( a1 > 0xFFFFFFFF || (v1 = operator new(a1)) == 0 )
      std::bad_alloc::bad_alloc();
  }
  return v1;
}

//----- (01216F00) --------------------------------------------------------
_DWORD *__thiscall sub_1216F00(_DWORD *this, int a2, int a3, size_t a4)
{
  int v4; // ebx
  _DWORD *v5; // esi
  int v6; // ecx
  unsigned int v7; // edi
  unsigned int v8; // edi
  int v9; // eax
  bool v10; // cf
  _DWORD *result; // eax
  unsigned int v12; // eax
  void *v13; // edx

  v4 = a2;
  v5 = this;
  v6 = a3;
  v7 = *(a2 + 16);
  if ( v7 < a3 )
    std::_Xout_of_range("invalid string position");
  v8 = v7 - a3;
  if ( a4 < v8 )
    v8 = a4;
  if ( v5 != a2 )
  {
    if ( v8 > 0xFFFFFFFE )
      std::_Xlength_error("string too long");
    v12 = v5[5];
    if ( v12 >= v8 )
    {
      if ( !v8 )
      {
        v5[4] = 0;
        if ( v12 < 0x10 )
        {
          result = v5;
          *v5 = 0;
        }
        else
        {
          **v5 = 0;
          result = v5;
        }
        return result;
      }
    }
    else
    {
      sub_1216BB0(v5, v8, v5[4]);
      v6 = a3;
      if ( !v8 )
        return v5;
    }
    if ( *(a2 + 20) >= 0x10u )
      v4 = *a2;
    if ( v5[5] < 0x10u )
      v13 = v5;
    else
      v13 = *v5;
    if ( v8 )
      memmove_0(v13, (v4 + v6), v8);
    v10 = v5[5] < 0x10u;
    v5[4] = v8;
    if ( !v10 )
    {
      *(*v5 + v8) = 0;
      return v5;
    }
    *(v5 + v8) = 0;
    return v5;
  }
  v9 = v8 + a3;
  if ( v5[4] < v8 + a3 )
    std::_Xout_of_range("invalid string position");
  v10 = v5[5] < 0x10u;
  v5[4] = v9;
  if ( v10 )
    *(v5 + v9) = 0;
  else
    *(*v5 + v9) = 0;
  sub_1217890(v5, 0, a3);
  return v5;
}

//----- (01217030) --------------------------------------------------------
_DWORD *__thiscall sub_1217030(int this, void *a2, size_t a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // eax
  _DWORD *v6; // edx
  _DWORD *result; // eax
  size_t v8; // eax
  void *v9; // eax
  bool v10; // cf

  v3 = this;
  if ( a2 )
  {
    v4 = *(this + 20);
    v5 = (v4 < 0x10 ? v3 : *v3);
    if ( a2 >= v5 )
    {
      v6 = v4 < 0x10 ? v3 : *v3;
      if ( v6 + v3[4] > a2 )
      {
        if ( v4 < 0x10 )
          result = sub_1216F00(v3, v3, a2 - v3, a3);
        else
          result = sub_1216F00(v3, v3, a2 - *v3, a3);
        return result;
      }
    }
  }
  if ( a3 > 0xFFFFFFFE )
    std::_Xlength_error("string too long");
  v8 = v3[5];
  if ( v8 < a3 )
  {
    sub_1216BB0(v3, a3, v3[4]);
    if ( !a3 )
      return v3;
LABEL_16:
    if ( v3[5] < 0x10u )
      v9 = v3;
    else
      v9 = *v3;
    if ( a3 )
      memmove_0(v9, a2, a3);
    v10 = v3[5] < 0x10u;
    v3[4] = a3;
    if ( !v10 )
    {
      *(*v3 + a3) = 0;
      return v3;
    }
    *(v3 + a3) = 0;
    return v3;
  }
  if ( a3 )
    goto LABEL_16;
  v3[4] = 0;
  if ( v8 < 0x10 )
  {
    result = v3;
    *v3 = 0;
  }
  else
  {
    **v3 = 0;
    result = v3;
  }
  return result;
}

//----- (01217130) --------------------------------------------------------
int *__stdcall sub_1217130(int *a1, int a2)
{
  bool v2; // zf
  int *result; // eax

  v2 = sub_128465F(a2) == 0;
  result = a1;
  *a1 = a2;
  if ( v2 )
    a1[1] = &off_12DAA44;
  else
    a1[1] = off_12DAA3C;
  return result;
}
// 12DAA3C: using guessed type int (__thiscall **off_12DAA3C[3])(void *, char);
// 12DAA44: using guessed type int (__thiscall **off_12DAA44)(void *, char);

//----- (01217190) --------------------------------------------------------
bool __thiscall sub_1217190(void *this, _DWORD *a2, int a3)
{
  return this == a2[1] && *a2 == a3;
}

//----- (012171B0) --------------------------------------------------------
bool __thiscall sub_12171B0(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5; // [esp+0h] [ebp-8h]

  v3 = (*(*this + 12))(&v5, a2);
  return v3[1] == a3[1] && *v3 == *a3;
}

//----- (012171F0) --------------------------------------------------------
int __thiscall sub_12171F0(_DWORD *this, int a2, void *a3, int a4)
{
  void *v4; // eax
  _DWORD *v5; // esi
  void **v6; // ecx
  int *v7; // eax
  int v8; // ecx
  int result; // eax
  void *v10; // ecx
  _DWORD *i; // edx
  _BYTE *j; // eax
  int v13; // [esp+4h] [ebp-4h]

  v4 = a3;
  v5 = this;
  v6 = *this;
  if ( a3 != *v6 || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v10 = v4;
      if ( !*(v4 + 13) )
      {
        i = *(v4 + 2);
        if ( *(i + 13) )
        {
          for ( i = *(v4 + 1); !*(i + 13); i = i[1] )
          {
            if ( v4 != i[2] )
              break;
            v4 = i;
          }
        }
        else
        {
          for ( j = *i; !j[13]; j = *j )
            i = j;
        }
        a3 = i;
      }
      sub_12172B0(v5, &v13, v10);
    }
    *a2 = v4;
    result = a2;
  }
  else
  {
    sub_1216D60(v6[1]);
    *(*v5 + 4) = *v5;
    **v5 = *v5;
    *(*v5 + 8) = *v5;
    v7 = *v5;
    v5[1] = 0;
    v8 = *v7;
    result = a2;
    *a2 = v8;
  }
  return result;
}

//----- (012172B0) --------------------------------------------------------
int __thiscall sub_12172B0(void *this, int a2, void *a3)
{
  CMapNode **v3; // ebx
  CMapNode *v4; // edi
  CMapNode *v5; // ecx
  CMapNode *v6; // esi
  CMapNode *v7; // edx
  CMapNode *v8; // eax
  CMapNode *v9; // ecx
  CMapNode *v10; // eax
  CMapNode *v11; // eax
  CMapNode *i; // ecx
  CMapNode **v13; // eax
  char v14; // cl
  CMapNode *v15; // ecx
  CMapNode *v16; // ST00_4
  CMapNode *v17; // esi
  CMapNode *v18; // ST00_4
  CMapNode *v19; // eax
  void *v20; // ecx
  int result; // eax
  _BYTE *v22; // [esp+Ch] [ebp-8h]
  CMapNode *v23; // [esp+10h] [ebp-4h]

  v3 = a3;
  v23 = this;
  sub_1214CE0(&a3);
  if ( (*v3)->_isnil )
  {
    v4 = v3[2];
LABEL_6:
    v6 = v3[1];
    if ( !v4->_isnil )
      v4->_Parent = v6;
    v7 = v23;
    if ( v23->_Left->_Parent == v3 )
    {
      v23->_Left->_Parent = v4;
    }
    else if ( v6->_Left == v3 )
    {
      v6->_Left = v4;
    }
    else
    {
      v6->_Right = v4;
    }
    v8 = v23->_Left;
    if ( v23->_Left->_Left == v3 )
    {
      if ( v4->_isnil )
      {
        v9 = v6;
      }
      else
      {
        v10 = v4->_Left;
        v9 = v4;
        if ( !v4->_Left->_isnil )
        {
          do
          {
            v9 = v10;
            v10 = v10->_Left;
          }
          while ( !v10->_isnil );
        }
        v8 = v23->_Left;
      }
      v8->_Left = v9;
    }
    if ( v23->_Left->_Right == v3 )
    {
      if ( v4->_isnil )
      {
        v23->_Left->_Right = v6;
      }
      else
      {
        v11 = v4->_Right;
        for ( i = v4; !v11->_isnil; v11 = v11->_Right )
          i = v11;
        v23->_Left->_Right = i;
      }
    }
    goto LABEL_37;
  }
  if ( v3[2]->_isnil )
  {
    v4 = *v3;
    goto LABEL_6;
  }
  v5 = a3;
  v22 = a3;
  v4 = *(a3 + 2);
  if ( a3 == v3 )
    goto LABEL_6;
  (*v3)->_Parent = a3;
  v5->_Left = *v3;
  if ( v5 == v3[2] )
  {
    v6 = v5;
  }
  else
  {
    v6 = v5->_Parent;
    if ( !v4->_isnil )
      v4->_Parent = v6;
    v6->_Left = v4;
    v5->_Right = v3[2];
    v3[2]->_Parent = v5;
  }
  if ( v23->_Left->_Parent == v3 )
  {
    v23->_Left->_Parent = v5;
  }
  else
  {
    v13 = v3[1];
    if ( *v13 == v3 )
      *v13 = v5;
    else
      v13[2] = v5;
  }
  v5->_Parent = v3[1];
  v14 = v5->_Color;
  v22[12] = *(v3 + 12);
  v7 = v23;
  *(v3 + 12) = v14;
LABEL_37:
  if ( *(v3 + 12) == 1 )
  {
    for ( ; v4 != v7->_Left->_Parent; v6 = v6->_Parent )
    {
      if ( v4->_Color != 1 )
        break;
      v15 = v6->_Left;
      if ( v4 == v6->_Left )
      {
        v15 = v6->_Right;
        if ( !v15->_Color )
        {
          v15->_Color = 1;
          v6->_Color = 0;
          sub_12754B0(v7, v6);
          v15 = v6->_Right;
          v7 = v23;
        }
        if ( v15->_isnil )
          goto LABEL_55;
        if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
        {
          if ( v15->_Right->_Color == 1 )
          {
            v15->_Left->_Color = 1;
            v15->_Color = 0;
            sub_1282BB0(v7, v15);
            v15 = v6->_Right;
          }
          v15->_Color = v6->_Color;
          v6->_Color = 1;
          v16 = v6;
          v17 = v23;
          v15->_Right->_Color = 1;
          sub_12754B0(v23, v16);
          v4->_Color = 1;
          goto LABEL_61;
        }
      }
      else
      {
        if ( !v15->_Color )
        {
          v15->_Color = 1;
          v6->_Color = 0;
          sub_1282BB0(v7, v6);
          v15 = v6->_Left;
          v7 = v23;
        }
        if ( v15->_isnil )
          goto LABEL_55;
        if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
        {
          if ( v15->_Left->_Color == 1 )
          {
            v15->_Right->_Color = 1;
            v15->_Color = 0;
            sub_12754B0(v7, v15);
            v15 = v6->_Left;
          }
          v15->_Color = v6->_Color;
          v6->_Color = 1;
          v18 = v6;
          v17 = v23;
          v15->_Left->_Color = 1;
          sub_1282BB0(v23, v18);
          v4->_Color = 1;
          goto LABEL_61;
        }
      }
      v15->_Color = 0;
LABEL_55:
      v4 = v6;
    }
    v17 = v23;
    v4->_Color = 1;
  }
  else
  {
    v17 = v23;
  }
LABEL_61:
  if ( v3[5] )
  {
    j__free(v3[5]);
    v3[5] = 0;
    v3[6] = 0;
    v3[7] = 0;
  }
  j__free(v3);
  v19 = v17->_Parent;
  v20 = a3;
  if ( v19 )
    v17->_Parent = (v19 - 1);
  result = a2;
  *a2 = v20;
  return result;
}

//----- (01217560) --------------------------------------------------------
int *__thiscall sub_1217560(int **this, int *a2, int **a3, int **a4)
{
  int **v4; // eax
  int **v5; // esi
  int *v6; // ecx
  int *v7; // eax
  int v8; // ecx
  int *result; // eax
  int **v10; // ecx
  int *i; // edx
  int *v12; // eax
  char v13; // [esp+4h] [ebp-4h]

  v4 = a3;
  v5 = this;
  v6 = *this;
  if ( a3 != *v6 || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v10 = v4;
      if ( !*(v4 + 13) )
      {
        i = v4[2];
        if ( *(i + 13) )
        {
          for ( i = v4[1]; !*(i + 13); i = i[1] )
          {
            if ( v4 != i[2] )
              break;
            v4 = i;
          }
        }
        else
        {
          v12 = *i;
          if ( !*(*i + 13) )
          {
            do
            {
              i = v12;
              v12 = *v12;
            }
            while ( !*(v12 + 13) );
          }
        }
        a3 = i;
      }
      sub_1217620(v5, &v13, v10);
    }
    *a2 = v4;
    result = a2;
  }
  else
  {
    sub_1216DC0(v6[1]);
    (*v5)[1] = *v5;
    **v5 = *v5;
    (*v5)[2] = *v5;
    v7 = *v5;
    v5[1] = 0;
    v8 = *v7;
    result = a2;
    *a2 = v8;
  }
  return result;
}

//----- (01217620) --------------------------------------------------------
_DWORD *__thiscall sub_1217620(int **this, _DWORD *a2, _DWORD *a3)
{
  CMapNode *v3; // ebx
  CMapNode *v4; // ecx
  CMapNode *v5; // edi
  CMapNode *v6; // edx
  CMapNode *v7; // esi
  CMapNode *v8; // eax
  CMapNode *v9; // edx
  CMapNode *v10; // eax
  CMapNode *v11; // eax
  CMapNode *i; // edx
  CMapNode *v13; // eax
  char v14; // cl
  CMapNode *v15; // ecx
  CMapNode *v16; // eax
  _DWORD *v17; // ecx
  _DWORD *result; // eax
  CMapNode *v19; // [esp+10h] [ebp-4h]

  v3 = this;
  v19 = a3;
  sub_1214CE0(&a3);
  v4 = v19;
  if ( v19->_Left->_isnil )
  {
    v5 = v19->_Right;
  }
  else if ( v19->_Right->_isnil )
  {
    v5 = v19->_Left;
  }
  else
  {
    v6 = a3;
    v5 = a3[2];
    if ( a3 != v19 )
    {
      v19->_Left->_Parent = a3;
      v6->_Left = v19->_Left;
      if ( v6 == v19->_Right )
      {
        v7 = v6;
      }
      else
      {
        v7 = v6->_Parent;
        if ( !v5->_isnil )
          v5->_Parent = v7;
        v7->_Left = v5;
        v6->_Right = v19->_Right;
        v19->_Right->_Parent = v6;
      }
      if ( v3->_Left->_Parent == v19 )
      {
        v3->_Left->_Parent = v6;
      }
      else
      {
        v13 = v19->_Parent;
        if ( v13->_Left == v19 )
          v13->_Left = v6;
        else
          v13->_Right = v6;
      }
      v6->_Parent = v19->_Parent;
      v14 = v6->_Color;
      v6->_Color = v19->_Color;
      v19->_Color = v14;
      v4 = v19;
      goto LABEL_37;
    }
  }
  v7 = v19->_Parent;
  if ( !v5->_isnil )
    v5->_Parent = v7;
  if ( v3->_Left->_Parent == v19 )
  {
    v3->_Left->_Parent = v5;
  }
  else if ( v7->_Left == v19 )
  {
    v7->_Left = v5;
  }
  else
  {
    v7->_Right = v5;
  }
  v8 = v3->_Left;
  if ( v3->_Left->_Left == v19 )
  {
    if ( v5->_isnil )
    {
      v9 = v7;
    }
    else
    {
      v10 = v5->_Left;
      v9 = v5;
      if ( !v5->_Left->_isnil )
      {
        do
        {
          v9 = v10;
          v10 = v10->_Left;
        }
        while ( !v10->_isnil );
      }
      v8 = v3->_Left;
    }
    v8->_Left = v9;
  }
  if ( v3->_Left->_Right == v19 )
  {
    if ( v5->_isnil )
    {
      v3->_Left->_Right = v7;
    }
    else
    {
      v11 = v5->_Right;
      for ( i = v5; !v11->_isnil; v11 = v11->_Right )
        i = v11;
      v3->_Left->_Right = i;
    }
  }
LABEL_37:
  if ( v4->_Color != 1 )
    goto LABEL_62;
  if ( v5 == v3->_Left->_Parent )
    goto LABEL_61;
  while ( v5->_Color == 1 )
  {
    v15 = v7->_Left;
    if ( v5 == v7->_Left )
    {
      v15 = v7->_Right;
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_12754B0(v3, v7);
        v15 = v7->_Right;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
      {
        if ( v15->_Right->_Color == 1 )
        {
          v15->_Left->_Color = 1;
          v15->_Color = 0;
          sub_1282BB0(v3, v15);
          v15 = v7->_Right;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Right->_Color = 1;
        sub_12754B0(v3, v7);
        break;
      }
    }
    else
    {
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_1282BB0(v3, v7);
        v15 = v7->_Left;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
      {
        if ( v15->_Left->_Color == 1 )
        {
          v15->_Right->_Color = 1;
          v15->_Color = 0;
          sub_12754B0(v3, v15);
          v15 = v7->_Left;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Left->_Color = 1;
        sub_1282BB0(v3, v7);
        break;
      }
    }
    v15->_Color = 0;
LABEL_55:
    v5 = v7;
    v7 = v7->_Parent;
    if ( v5 == v3->_Left->_Parent )
      break;
  }
  v4 = v19;
LABEL_61:
  v5->_Color = 1;
LABEL_62:
  free(v4->_KeyValue.Key);
  j__free(v19);
  v16 = v3->_Parent;
  v17 = a3;
  if ( v16 )
    v3->_Parent = (v16 - 1);
  result = a2;
  *a2 = v17;
  return result;
}

//----- (01217890) --------------------------------------------------------
_DWORD *__thiscall sub_1217890(_DWORD *this, unsigned int a2, unsigned int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // edi
  bool v5; // cf
  _DWORD *result; // eax
  _DWORD *v7; // eax
  unsigned int v8; // edi

  v3 = this;
  v4 = this[4];
  if ( v4 < a2 )
    std::_Xout_of_range("invalid string position");
  if ( v4 - a2 > a3 )
  {
    if ( a3 )
    {
      if ( this[5] < 0x10u )
        v7 = this;
      else
        v7 = *this;
      v8 = v4 - a3;
      if ( v8 != a2 )
        memmove(v7 + a2, v7 + a2 + a3, v8 - a2);
      v5 = v3[5] < 0x10u;
      v3[4] = v8;
      if ( !v5 )
      {
        *(*v3 + v8) = 0;
        return v3;
      }
      *(v3 + v8) = 0;
    }
    result = v3;
  }
  else
  {
    v5 = this[5] < 0x10u;
    this[4] = a2;
    if ( v5 )
    {
      result = this;
      *(this + a2) = 0;
    }
    else
    {
      *(*this + a2) = 0;
      result = this;
    }
  }
  return result;
}

//----- (01217930) --------------------------------------------------------
int __stdcall sub_1217930(int a1, int a2)
{
  int v2; // eax
  char *v3; // edx

  v2 = sub_128465F(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = v2;
  *(a1 + 20) = 15;
  *(a1 + 16) = 0;
  *a1 = 0;
  if ( *v3 )
    sub_1217030(a1, v3, strlen(v3));
  else
    sub_1217030(a1, v3, 0);
  return a1;
}

//----- (012179A0) --------------------------------------------------------
int __stdcall sub_12179A0(int a1, int a2)
{
  if ( a2 == 1 )
  {
    *(a1 + 20) = 15;
    *(a1 + 16) = 0;
    *a1 = 0;
    sub_1217030(a1, "iostream stream error", 0x15u);
  }
  else
  {
    sub_1217930(a1, a2);
  }
  return a1;
}

//----- (012179F0) --------------------------------------------------------
int __stdcall sub_12179F0(int a1, int a2)
{
  int v2; // eax
  char *v3; // edx

  v2 = sub_1284689(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = v2;
  *(a1 + 20) = 15;
  *(a1 + 16) = 0;
  *a1 = 0;
  if ( *v3 )
    sub_1217030(a1, v3, strlen(v3));
  else
    sub_1217030(a1, v3, 0);
  return a1;
}

//----- (01217A60) --------------------------------------------------------
const char *sub_1217A60()
{
  return "generic";
}

//----- (01217A70) --------------------------------------------------------
const char *sub_1217A70()
{
  return "iostream";
}

//----- (01217A80) --------------------------------------------------------
const char *sub_1217A80()
{
  return "system";
}

//----- (01217AA0) --------------------------------------------------------
int stprintf(wchar_t *szLog, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(szLog, _MAX_PATH, Format, ArgList);
}

//----- (01217AC0) --------------------------------------------------------
_DWORD *__thiscall sub_1217AC0(_DWORD *this, const __m128i *a2, __int16 a3, __int16 a4, char a5)
{
  _DWORD *v5; // edi
  __m128i v6; // xmm0
  _DWORD *result; // eax

  v5 = this;
  *this = 0;
  this[6] = 0;
  this[7] = 0;
  this[6] = sub_1282A70(0, 0);
  v5[8] = 0;
  v6 = _mm_loadu_si128(a2);
  *(v5 + 18) = a3;
  *(v5 + 40) = a5;
  *(v5 + 19) = a4;
  result = v5;
  _mm_storeu_si128((v5 + 2), v6);
  v5[1] = 0;
  return result;
}

//----- (01217B60) --------------------------------------------------------
_DWORD **__cdecl sub_1217B60(int a1, OLECHAR *psz, int a3, int a4)
{
  _DWORD **result; // eax
  _DWORD *i; // esi
  int v6; // ebx
  _bstr_t *v7; // eax
  _bstr_t *v8; // edi
  int v9; // edi
  int v10; // ebx
  _DWORD *v11; // edx
  int v12; // eax
  void *v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-4h]

  result = *a1;
  for ( i = **a1; i != *a1; i = *i )
  {
    v6 = i[2];
    v7 = operator new(0x10u);
    v8 = v7;
    v13 = v7;
    v14 = 0;
    if ( v7 )
    {
      bstr_t::EqualAssign(v7, psz);
      v8[2].m_Data = a3;
      v8[1].m_Data = -1;
      v8[3].m_Data = a4;
    }
    else
    {
      v8 = 0;
    }
    v13 = v8;
    v9 = v6 + 24;
    v14 = -1;
    v10 = *(v6 + 24);
    v11 = sub_1281420(v10, *(v10 + 4), &v13);
    v12 = *(v9 + 4);
    if ( (357913940 - v12) < 1 )
      std::_Xlength_error("list<T> too long");
    *(v9 + 4) = v12 + 1;
    *(v10 + 4) = v11;
    *v11[1] = v11;
    result = a1;
  }
  return result;
}

//----- (01217C40) --------------------------------------------------------
int *__thiscall sub_1217C40(_DWORD *this, _DWORD **a2)
{
  int **v2; // edi
  int v3; // esi
  _DWORD *v4; // ebx
  _DWORD *v5; // edx
  int v6; // eax
  int *result; // eax
  int *v8; // esi
  _DWORD *v9; // [esp+8h] [ebp-4h]

  v2 = a2;
  v3 = **a2;
  if ( v3 != *a2 )
  {
    v4 = this + 1;
    do
    {
      a2 = *(v3 + 8);
      v9 = *v4;
      v5 = sub_1281420(*v4, *(*v4 + 4), &a2);
      v6 = v4[1];
      if ( (357913940 - v6) < 1 )
        std::_Xlength_error("list<T> too long");
      v4[1] = v6 + 1;
      v9[1] = v5;
      *v5[1] = v5;
      v3 = *v3;
    }
    while ( v3 != *v2 );
  }
  result = **v2;
  **v2 = *v2;
  (*v2)[1] = *v2;
  v2[1] = 0;
  if ( result != *v2 )
  {
    do
    {
      v8 = *result;
      j__free(result);
      result = v8;
    }
    while ( v8 != *v2 );
  }
  return result;
}

//----- (01217CE0) --------------------------------------------------------
LONG __cdecl sub_1217CE0(int a1)
{
  LONG v1; // ebx
  OLECHAR *v2; // edi
  int v3; // esi
  VARIANTARG pvarg; // [esp+8h] [ebp-10h]

  v1 = 1;
  if ( a1 )
  {
    v2 = SysAllocString(L"MAX");
    VariantInit(&pvarg);
    v3 = (*(*a1 + 12))(a1, v2, 0, &pvarg, 0);
    SysFreeString(v2);
    if ( !v3 && pvarg.vt == 3 )
      v1 = pvarg.lVal;
    VariantClear(&pvarg);
  }
  return v1;
}

//----- (01217D50) --------------------------------------------------------
int *__thiscall sub_1217D50(_DWORD *this, const __m128i *a2, unsigned __int16 a3, char a4, __int16 a5)
{
  _DWORD *v5; // ebx
  OLECHAR *v6; // edi
  IUnknown **v7; // esi
  OLECHAR *v8; // edi
  OLECHAR *v9; // eax
  IUnknown *v10; // ecx
  int v11; // esi
  BSTR v12; // edi
  OLECHAR *v13; // esi
  int v14; // ecx
  int v15; // esi
  SHORT v16; // si
  int *v17; // eax
  VARIANTARG v19; // [esp+Ch] [ebp-480h]
  VARIANTARG pvarg; // [esp+1Ch] [ebp-470h]
  int v21; // [esp+2Ch] [ebp-460h]
  VARIANTARG pvargDest; // [esp+30h] [ebp-45Ch]
  int v23; // [esp+40h] [ebp-44Ch]
  BSTR v24; // [esp+44h] [ebp-448h]
  const __m128i *v25; // [esp+48h] [ebp-444h]
  BSTR bstrString; // [esp+4Ch] [ebp-440h]
  int v27; // [esp+50h] [ebp-43Ch]
  BSTR v28; // [esp+54h] [ebp-438h]
  int *v29; // [esp+58h] [ebp-434h]
  int v30; // [esp+5Ch] [ebp-430h]
  int v31; // [esp+60h] [ebp-42Ch]
  IUnknown **v32; // [esp+64h] [ebp-428h]
  int v33; // [esp+68h] [ebp-424h]
  int v34; // [esp+6Ch] [ebp-420h]
  int v35; // [esp+70h] [ebp-41Ch]
  int v36; // [esp+74h] [ebp-418h]
  wchar_t v37; // [esp+78h] [ebp-414h]
  wchar_t Dst; // [esp+280h] [ebp-20Ch]

  v25 = a2;
  v5 = this;
  v21 = a3;
  LOBYTE(v23) = a4;
  v6 = 0;
  v32 = this;
  v35 = 0;
  v36 = 0;
  v31 = 0;
  v34 = 0;
  v33 = 0;
  bstrString = 0;
  v24 = 0;
  v29 = 0;
  VariantInit(&pvarg);
  VariantInit(&v19);
  VariantInit(&pvargDest);
  v7 = v32;
  if ( !*v5 && sub_12192F0(v32) )
    goto LABEL_34;
  swprintf_s(
    &v37,
    0x104u,
    L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
    v25->m128i_i32[0],
    LOWORD(v25->m128i_i32[1]),
    HIWORD(v25->m128i_i32[1]),
    LOBYTE(v25->m128i_i32[2]),
    BYTE1(v25->m128i_i32[2]),
    BYTE2(v25->m128i_i32[2]),
    HIBYTE(v25->m128i_i32[2]),
    LOBYTE(v25->m128i_i32[3]),
    BYTE1(v25->m128i_i32[3]),
    BYTE2(v25->m128i_i32[3]),
    HIBYTE(v25->m128i_i32[3]));
  v8 = SysAllocString(L"EventTrace");
  v28 = SysAllocString(L"__CLASS");
  bstrString = SysAllocString(L"Guid");
  v9 = SysAllocString(L"EventVersion");
  v10 = *v7;
  v24 = v9;
  v35 = 0;
  v11 = (v10->lpVtbl[4].QueryInterface)(v10, v8, 131073, 0, &v35);
  SysFreeString(v8);
  if ( v11 )
    goto LABEL_33;
  v27 = 1;
  do
  {
    v31 = 0;
    if ( (*(*v35 + 16))(v35, 5000, 1, &v31, &v27) )
      continue;
    if ( v27 != 1 )
      break;
    v12 = v28;
    if ( (*(*v31 + 16))(v31, v28, 0, &pvarg, 0, 0) )
      continue;
    v13 = SysAllocString(pvarg.bstrVal);
    v36 = 0;
    ((*v32)->lpVtbl[4].QueryInterface)(*v32, v13, 131073, 0, &v36);
    SysFreeString(v13);
    VariantClear(&pvarg);
    v30 = 1;
    do
    {
      v34 = 0;
      if ( v36 )
      {
        if ( (*(*v36 + 16))(v36, 5000, 1, &v34, &v30) )
          continue;
        if ( v30 != 1 )
          break;
        v14 = v34;
      }
      else
      {
        v14 = v31;
        v30 = 1;
        v34 = v31;
      }
      v15 = (*(*v14 + 16))(v14, v12, 0, &pvarg, 0, 0);
      VariantClear(&pvarg);
      if ( !v15 )
      {
        if ( v33 )
        {
          (*(*v33 + 8))(v33);
          v33 = 0;
        }
        (*(*v34 + 12))(v34, &v33);
        if ( !(*(*v33 + 12))(v33, bstrString, 0, &v19, 0) )
        {
          tcscpy_s(&Dst, 0x104u, v19.bstrVal);
          VariantClear(&v19);
          if ( !wcsstr(&Dst, L"{") )
            stprintf(&Dst, L"{%s}", &Dst);
          if ( !_wcsicmp(&v37, &Dst) )
          {
            if ( (*(*v33 + 12))(v33, v24, 0, &pvargDest, 0) )
            {
              v17 = sub_1218970(v32, v34, v25, 0xFFFFu, v23, a5);
            }
            else
            {
              VariantChangeType(&pvargDest, &pvargDest, 0, 2u);
              v16 = pvargDest.iVal;
              VariantClear(&pvargDest);
              if ( v21 != v16 )
                continue;
              v17 = sub_1218970(v32, v34, v25, v21, v23, a5);
            }
            v29 = v17;
            goto LABEL_31;
          }
        }
      }
    }
    while ( v30 == 1 );
    if ( v36 )
    {
      (*(*v36 + 8))(v36);
      v36 = 0;
    }
  }
  while ( v27 == 1 );
LABEL_31:
  if ( v35 )
  {
    (*(*v35 + 8))(v35);
    v35 = 0;
  }
LABEL_33:
  v6 = v28;
LABEL_34:
  VariantClear(&v19);
  VariantClear(&pvargDest);
  SysFreeString(bstrString);
  SysFreeString(v6);
  SysFreeString(v24);
  if ( v35 )
  {
    (*(*v35 + 8))(v35);
    v35 = 0;
  }
  if ( v36 )
  {
    (*(*v36 + 8))(v36);
    v36 = 0;
  }
  if ( v33 )
    (*(*v33 + 8))(v33);
  return v29;
}

//----- (01218250) --------------------------------------------------------
signed int __usercall sub_1218250@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4)
{
  signed int result; // eax
  int v5; // ST14_4
  OLECHAR *v6; // edi
  int v7; // esi
  OLECHAR *v8; // edi
  int v9; // esi
  OLECHAR *v10; // edi
  int v11; // esi
  signed int v12; // eax
  OLECHAR *v13; // edi
  int v14; // esi
  signed int v15; // esi
  signed int v16; // [esp+4h] [ebp-A8h]
  VARIANTARG pvarg; // [esp+8h] [ebp-A4h]
  unsigned __int8 v18; // [esp+1Bh] [ebp-91h]
  wchar_t v19; // [esp+1Ch] [ebp-90h]
  wchar_t v20; // [esp+58h] [ebp-54h]
  wchar_t Dst; // [esp+94h] [ebp-18h]

  v18 = 0;
  Dst = 0;
  v19 = 0;
  v20 = 0;
  if ( !a4 )
    return 29;
  v5 = a1;
  v6 = SysAllocString(L"format");
  VariantInit(&pvarg);
  v7 = (*(*a4 + 12))(a4, v6, 0, &pvarg, 0, v5, a2);
  SysFreeString(v6);
  if ( !v7 && pvarg.lVal )
    tcscpy_s(&Dst, 0xAu, pvarg.bstrVal);
  v8 = SysAllocString(L"StringTermination");
  VariantClear(&pvarg);
  v9 = (*(*a4 + 12))(a4, v8, 0, &pvarg, 0);
  SysFreeString(v8);
  if ( !v9 && pvarg.lVal )
    tcscpy_s(&v19, 0x1Eu, pvarg.bstrVal);
  v10 = SysAllocString(L"pointer");
  VariantClear(&pvarg);
  v11 = (*(*a4 + 12))(a4, v10, 0);
  SysFreeString(v10);
  v12 = v18;
  if ( !v11 )
    v12 = 1;
  v16 = v12;
  v13 = SysAllocString(L"extension");
  VariantClear(&pvarg);
  v14 = (*(*a4 + 12))(a4, v13, 0, &pvarg, 0);
  SysFreeString(v13);
  if ( !v14 && pvarg.lVal )
    tcscpy_s(&v20, 0x1Eu, pvarg.bstrVal);
  VariantClear(&pvarg);
  switch ( a3 & 0xFFFFDFFF )
  {
    case 2u:
      v15 = 4;
      goto LABEL_52;
    case 3u:
      goto LABEL_20;
    case 4u:
      v15 = 11;
      goto LABEL_52;
    case 5u:
      v15 = 12;
      goto LABEL_52;
    case 8u:
      if ( _wcsicmp(&v19, L"NullTerminated") )
      {
        if ( _wcsicmp(&v19, L"Counted") )
        {
          if ( _wcsicmp(&v19, L"ReverseCounted") )
            v15 = _wcsicmp(&v19, L"NotCounted") != 0 ? 13 : 23;
          else
            v15 = 18 - (_wcsicmp(&Dst, L"w") != 0);
        }
        else
        {
          v15 = 16 - (_wcsicmp(&Dst, L"w") != 0);
        }
      }
      else
      {
        v15 = 14 - (_wcsicmp(&Dst, L"w") != 0);
      }
      goto LABEL_52;
    case 0xBu:
      v15 = 26;
      goto LABEL_52;
    case 0xDu:
      if ( !_wcsicmp(&v20, L"Port") )
      {
        v15 = 21;
        goto LABEL_52;
      }
      if ( !_wcsicmp(&v20, L"IPAddr") )
        goto LABEL_47;
      if ( _wcsicmp(&v20, L"Sid") )
      {
        if ( _wcsicmp(&v20, L"Guid") )
        {
          if ( !_wcsicmp(&v20, L"SizeT") )
          {
LABEL_20:
            v15 = 6;
            goto LABEL_52;
          }
          if ( _wcsicmp(&v20, L"IPAddrV6") )
          {
            if ( _wcsicmp(&v20, L"IPAddrV4") )
            {
              if ( _wcsicmp(&v20, L"WmiTime") )
                v15 = v16;
              else
                v15 = 28;
            }
            else
            {
LABEL_47:
              v15 = 20;
            }
          }
          else
          {
            v15 = 27;
          }
        }
        else
        {
          v15 = 25;
        }
      }
      else
      {
        v15 = 19;
      }
LABEL_52:
      if ( v16 )
        v15 = 24;
      result = v15;
      break;
    case 0x10u:
      v15 = 3;
      if ( !_wcsicmp(&Dst, L"c") )
        v15 = 0;
      goto LABEL_52;
    case 0x11u:
      v15 = 2;
      goto LABEL_52;
    case 0x12u:
      v15 = 5;
      goto LABEL_52;
    case 0x13u:
      v15 = 7;
      if ( !_wcsicmp(&Dst, L"x") )
        v15 = 8;
      goto LABEL_52;
    case 0x14u:
      v15 = 9;
      goto LABEL_52;
    case 0x15u:
      v15 = 10;
      goto LABEL_52;
    case 0x67u:
      v15 = 1;
      goto LABEL_52;
    default:
      v15 = 29;
      goto LABEL_52;
  }
  return result;
}
// 1218250: could not find valid save-restore pair for edi
// 1218250: could not find valid save-restore pair for esi

//----- (01218730) --------------------------------------------------------
int *__thiscall sub_1218730(_DWORD *this, const __m128i *a2, __int16 a3, __int16 a4, char a5)
{
  _DWORD *v5; // ebx
  _DWORD *v6; // eax
  _bstr_t *v7; // esi
  int v8; // edi
  _DWORD *v9; // eax
  int v10; // edx
  _DWORD *v11; // ecx
  const __m128i *v12; // ebx
  _DWORD *v13; // eax
  int v14; // esi
  int *v15; // edi
  _DWORD *v16; // esi
  unsigned int v17; // ebx
  bool v18; // cf
  int v19; // ebx
  signed __int16 v20; // dx
  __int16 v21; // si
  int *v22; // edx
  int *result; // eax
  _DWORD *v24; // eax
  _bstr_t *v25; // esi
  int v26; // edi
  _DWORD *v27; // ecx
  int v28; // eax
  _DWORD *v29; // [esp+10h] [ebp-1Ch]
  signed __int16 v30; // [esp+14h] [ebp-18h]
  void *v31; // [esp+18h] [ebp-14h]
  int *v32; // [esp+1Ch] [ebp-10h]
  int v33; // [esp+28h] [ebp-4h]

  v5 = this;
  v29 = this;
  v32 = 0;
  v30 = 0;
  if ( !this[2] )
  {
    v6 = operator new(0x2Cu);
    v31 = v6;
    v33 = 0;
    v7 = (v6 ? sub_1217AC0(v6, &unk_12B362C, -1, 0, 0) : 0);
    v33 = -1;
    v31 = v7;
    if ( v7 )
    {
      bstr_t::Assign(v7, L"EventTrace");
      bstr_t::Assign(v7 + 8, L"Header");
      v8 = v5[1];
      v9 = sub_1281420(v5[1], *(v8 + 4), &v31);
      v10 = v5[2];
      if ( (357913940 - v10) < 1 )
        std::_Xlength_error("list<T> too long");
      v5[2] = v10 + 1;
      *(v8 + 4) = v9;
      *v9[1] = v9;
    }
  }
  v11 = v5[1];
  v12 = a2;
  v13 = *v11;
  if ( *v11 == v11 )
    goto LABEL_30;
  while ( 2 )
  {
    v14 = v13[2];
    v15 = v12;
    v31 = 0;
    v16 = (v14 + 8);
    v17 = 12;
    while ( *v16 == *v15 )
    {
      ++v16;
      ++v15;
      v18 = v17 < 4;
      v17 -= 4;
      if ( v18 )
      {
        v19 = v13[2];
        v20 = v31;
        v21 = *(v19 + 36);
        if ( v21 == a3 )
          v20 = 1;
        if ( *(v19 + 38) == a4 )
          ++v20;
        if ( v20 == 2 )
          return v13[2];
        if ( v20 <= v30 )
        {
          v22 = v32;
        }
        else
        {
          v30 = v20;
          v22 = v13[2];
          v32 = v13[2];
        }
        if ( v21 == -1 )
        {
          if ( !v22 )
            v22 = v19;
          v32 = v22;
        }
        break;
      }
    }
    v13 = *v13;
    if ( v13 != v11 )
    {
      v12 = a2;
      continue;
    }
    break;
  }
  result = v32;
  if ( !v32 )
  {
    v12 = a2;
LABEL_30:
    result = sub_1217D50(v29, v12, a4, a5, a3);
    if ( !result )
    {
      v24 = operator new(0x2Cu);
      v33 = 1;
      if ( v24 )
        v25 = sub_1217AC0(v24, v12, a3, a4, a5);
      else
        v25 = 0;
      v33 = -1;
      v31 = v25;
      if ( v25 )
      {
        bstr_t::Assign(v25, L"Unknown");
        v26 = v29[1];
        v27 = sub_1281420(v29[1], *(v26 + 4), &v31);
        v28 = v29[2];
        if ( (357913940 - v28) < 1 )
          std::_Xlength_error("list<T> too long");
        v29[2] = v28 + 1;
        *(v26 + 4) = v27;
        *v27[1] = v27;
      }
      result = v25;
    }
  }
  return result;
}

//----- (01218970) --------------------------------------------------------
int *__thiscall sub_1218970(_DWORD *this, int a2, const __m128i *a3, unsigned __int16 a4, char a5, __int16 a6)
{
  int *v6; // ebx
  _DWORD *v7; // edi
  _DWORD *v8; // eax
  _bstr_t *v9; // eax
  _DWORD *v10; // STE4_4
  _DWORD *v11; // eax
  OLECHAR *v12; // edi
  int v13; // esi
  HRESULT (__stdcall *v14)(SAFEARRAY *); // esi
  HRESULT (__stdcall *v15)(SAFEARRAY *, LONG *, void *); // ebx
  SAFEARRAY *v16; // ebx
  SAFEARRAY *v17; // esi
  int v18; // ecx
  int v19; // edi
  _DWORD *v20; // eax
  _bstr_t *v21; // esi
  int *v22; // eax
  LONG v23; // ecx
  SAFEARRAY *v24; // STE8_4
  __int16 v25; // di
  _DWORD *v26; // eax
  _bstr_t *v27; // esi
  int *v28; // ebx
  int *v29; // eax
  int v30; // edi
  int v31; // eax
  _DWORD *v32; // edi
  _DWORD *v33; // eax
  _DWORD *v34; // esi
  VARIANTARG v36; // [esp+10h] [ebp-4E0h]
  LONG v37; // [esp+20h] [ebp-4D0h]
  LONG plLbound; // [esp+24h] [ebp-4CCh]
  void *ppvData; // [esp+28h] [ebp-4C8h]
  LONG v40; // [esp+2Ch] [ebp-4C4h]
  void *v41; // [esp+30h] [ebp-4C0h]
  VARIANTARG v42; // [esp+34h] [ebp-4BCh]
  VARIANTARG pvargDest; // [esp+44h] [ebp-4ACh]
  VARIANTARG pvarg; // [esp+54h] [ebp-49Ch]
  int v45; // [esp+64h] [ebp-48Ch]
  int v46; // [esp+68h] [ebp-488h]
  BSTR v47; // [esp+6Ch] [ebp-484h]
  BSTR bstrString; // [esp+70h] [ebp-480h]
  BSTR v49; // [esp+74h] [ebp-47Ch]
  int v50; // [esp+78h] [ebp-478h]
  int v51; // [esp+7Ch] [ebp-474h]
  LONG v52; // [esp+80h] [ebp-470h]
  LONG v53; // [esp+84h] [ebp-46Ch]
  int v54; // [esp+88h] [ebp-468h]
  BSTR v55; // [esp+8Ch] [ebp-464h]
  BSTR v56; // [esp+90h] [ebp-460h]
  const __m128i *v57; // [esp+94h] [ebp-45Ch]
  _DWORD *v58; // [esp+98h] [ebp-458h]
  void *v59; // [esp+9Ch] [ebp-454h]
  LONG plUbound; // [esp+A0h] [ebp-450h]
  int v61; // [esp+A4h] [ebp-44Ch]
  OLECHAR *pv; // [esp+A8h] [ebp-448h]
  void *v63; // [esp+ACh] [ebp-444h]
  int v64; // [esp+B0h] [ebp-440h]
  int *v65; // [esp+B4h] [ebp-43Ch]
  int *v66; // [esp+B8h] [ebp-438h]
  void *v67; // [esp+BCh] [ebp-434h]
  LONG rgIndices; // [esp+C0h] [ebp-430h]
  int v69; // [esp+C4h] [ebp-42Ch]
  SAFEARRAY *psa; // [esp+C8h] [ebp-428h]
  int v71; // [esp+CCh] [ebp-424h]
  wchar_t psz; // [esp+D0h] [ebp-420h]
  wchar_t Dst; // [esp+2D8h] [ebp-218h]
  int v74; // [esp+4ECh] [ebp-4h]

  v58 = this;
  v61 = a2;
  v6 = 0;
  v57 = a3;
  v46 = a4;
  LOBYTE(v50) = a5;
  v45 = 0;
  v69 = 0;
  v71 = 0;
  pv = 0;
  v64 = 0;
  v7 = sub_1282A70(0, 0);
  v63 = v7;
  v74 = 0;
  psa = 0;
  VariantInit(&pvarg);
  VariantInit(&pvargDest);
  VariantInit(&v42);
  VariantInit(&v36);
  bstrString = SysAllocString(L"__CLASS");
  v55 = SysAllocString(L"WmiDataId");
  v49 = SysAllocString(L"EventType");
  v56 = SysAllocString(L"EventTypeName");
  v47 = SysAllocString(L"DisplayName");
  if ( !(*(*v61 + 16))(v61, bstrString, 0, &pvarg, 0, 0) )
  {
    tcscpy_s(&Dst, 0x104u, pvarg.bstrVal);
    if ( v71 )
    {
      (*(*v71 + 8))(v71);
      v71 = 0;
    }
    (*(*v61 + 12))(v61, &v71);
    if ( !(*(*v71 + 12))(v71, v47, 0, &v36, 0) && v36.lVal )
      tcscpy_s(&Dst, 0x104u, v36.bstrVal);
    v8 = operator new(0x2Cu);
    v59 = v8;
    LOBYTE(v74) = 1;
    v9 = (v8 ? sub_1217AC0(v8, v57, -1, -1, -1) : 0);
    v66 = v9;
    LOBYTE(v74) = 0;
    v67 = v9;
    if ( v9 )
    {
      bstr_t::Assign(v9, &Dst);
      v6 = v66;
      v10 = v7[1];
      v65 = v66;
      v11 = sub_1281420(v7, v10, &v67);
      v64 = 1;
      v7[1] = v11;
      *v11[1] = v11;
      v12 = SysAllocString(pvarg.bstrVal);
      v13 = (*(**v58 + 48))(*v58, v12, 131073, 0, &v45);
      SysFreeString(v12);
      if ( !v13 )
      {
        v14 = SafeArrayDestroy;
        v15 = SafeArrayGetElement;
        v51 = 1;
        while ( 1 )
        {
          v69 = 0;
          if ( (*(*v45 + 16))(v45, 5000, 1, &v69, &v51) )
          {
            v69 = v61;
            (*(*v61 + 4))(v61);
          }
          if ( v71 )
          {
            (*(*v71 + 8))(v71);
            v71 = 0;
          }
          (*(*v69 + 12))(v69, &v71);
          VariantClear(&pvargDest);
          if ( !(*(*v71 + 12))(v71, v49, 0, &pvargDest, 0) )
          {
            v16 = 0;
            if ( pvargDest.vt & 0x2000 )
            {
              v17 = pvargDest.parray;
              v59 = pvargDest.bstrVal;
              VariantClear(&v42);
              if ( !(*(*v71 + 12))(v71, v56, 0, &v42, 0) && v42.vt & 0x2000 )
                v16 = v42.parray;
              if ( !v17
                || SafeArrayGetLBound(v17, 1u, &plLbound)
                || SafeArrayGetUBound(v17, 1u, &plUbound)
                || plUbound < 0 )
              {
LABEL_80:
                v6 = v65;
                break;
              }
              SafeArrayAccessData(v17, &ppvData);
              if ( v16 )
              {
                if ( SafeArrayGetLBound(v16, 1u, &v37) || SafeArrayGetUBound(v16, 1u, &v52) || v52 < 0 )
                  goto LABEL_80;
                SafeArrayAccessData(v16, &v41);
              }
              v18 = plLbound;
              rgIndices = plLbound;
              if ( plLbound <= plUbound )
              {
                while ( 1 )
                {
                  v19 = *(ppvData + v18);
                  v20 = operator new(0x2Cu);
                  v67 = v20;
                  LOBYTE(v74) = 2;
                  if ( v20 )
                    v21 = sub_1217AC0(v20, v57, v19, v46, v50);
                  else
                    v21 = 0;
                  LOBYTE(v74) = 0;
                  v67 = v21;
                  if ( v21 )
                  {
                    sub_1219380(&v63, &v67);
                    if ( sub_1200440(v66) )
                      sub_11F3A50(v21, v66);
                    v22 = v65;
                    if ( a6 == v19 )
                      v22 = v21;
                    v65 = v22;
                    if ( v16 )
                    {
                      v23 = rgIndices;
                      if ( rgIndices < v37 || rgIndices > v52 )
                        goto LABEL_45;
                      bstr_t::Assign(v21 + 8, *(v41 + rgIndices));
                    }
                  }
                  v23 = rgIndices;
LABEL_45:
                  v18 = v23 + 1;
                  rgIndices = v18;
                  if ( v18 > plUbound )
                  {
                    v17 = v59;
                    break;
                  }
                }
              }
              SafeArrayUnaccessData(v17);
              v24 = v17;
              v14 = SafeArrayDestroy;
              SafeArrayDestroy(v24);
              VariantInit(&pvargDest);
              if ( v16 )
              {
                SafeArrayUnaccessData(v16);
                SafeArrayDestroy(v16);
                VariantInit(&v42);
              }
            }
            else
            {
              VariantChangeType(&pvargDest, &pvargDest, 0, 2u);
              v25 = pvargDest.iVal;
              VariantClear(&v42);
              if ( (*(*v71 + 12))(v71, v56, 0, &v42, 0) )
                psz = 0;
              else
                tcscpy_s(&psz, 0x104u, v42.bstrVal);
              v26 = operator new(0x2Cu);
              v59 = v26;
              LOBYTE(v74) = 3;
              if ( v26 )
                v27 = sub_1217AC0(v26, v57, v25, v46, v50);
              else
                v27 = 0;
              LOBYTE(v74) = 0;
              v67 = v27;
              if ( v27 )
              {
                sub_1219380(&v63, &v67);
                v28 = v66;
                if ( sub_1200440(v66) )
                  sub_11F3A50(v27, v28);
                v29 = v65;
                if ( a6 == v25 )
                  v29 = v27;
                v65 = v29;
                bstr_t::Assign(v27 + 8, &psz);
              }
              v14 = SafeArrayDestroy;
            }
            v15 = SafeArrayGetElement;
          }
          VariantClear(&pvarg);
          psa = 0;
          pvarg.vt = 3;
          v30 = 1;
          for ( pvarg.lVal = 1; !(*(*v69 + 28))(v69, v55, 3, &pvarg, &psa); pvarg.lVal = ++v30 )
          {
            if ( SafeArrayGetLBound(psa, 1u, &v40) || SafeArrayGetUBound(psa, 1u, &v53) || v53 < 0 )
              break;
            rgIndices = v40;
            if ( v40 <= v53 )
            {
              do
              {
                if ( v15(psa, &rgIndices, &pv) || (*(*v69 + 16))(v69, pv, 0, 0, &v54, 0) )
                  break;
                if ( v71 )
                {
                  (*(*v71 + 8))(v71);
                  v71 = 0;
                }
                if ( (*(*v69 + 44))(v69, pv, &v71) )
                  break;
                v14 = sub_1218250(v30, v14, v54, v71);
                v31 = v54 & 0x2000 ? sub_1217CE0(v71) : 1;
                sub_1217B60(&v63, pv, v14, v31);
                ++rgIndices;
              }
              while ( rgIndices <= v53 );
              v14 = SafeArrayDestroy;
            }
            v14(psa);
            psa = 0;
          }
          sub_1217C40(v58, &v63);
          if ( v51 != 1 )
            goto LABEL_80;
        }
      }
    }
  }
  VariantClear(&pvarg);
  VariantClear(&pvargDest);
  VariantClear(&v36);
  SysFreeString(bstrString);
  SysFreeString(v55);
  SysFreeString(v49);
  SysFreeString(v56);
  SysFreeString(v47);
  sub_1217C40(v58, &v63);
  v32 = v63;
  v33 = *v63;
  *v32 = v32;
  v32[1] = v32;
  if ( v33 != v32 )
  {
    do
    {
      v34 = *v33;
      j__free(v33);
      v33 = v34;
    }
    while ( v34 != v32 );
  }
  j__free(v32);
  return v6;
}

//----- (012192A0) --------------------------------------------------------
int __cdecl sub_12192A0(wchar_t *Dst, size_t SizeInWords, int a3)
{
  return swprintf_s(
           Dst,
           SizeInWords,
           L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
           *a3,
           *(a3 + 4),
           *(a3 + 6),
           *(a3 + 8),
           *(a3 + 9),
           *(a3 + 10),
           *(a3 + 11),
           *(a3 + 12),
           *(a3 + 13),
           *(a3 + 14),
           *(a3 + 15));
}

//----- (012192F0) --------------------------------------------------------
HRESULT __cdecl sub_12192F0(IUnknown **a1)
{
  OLECHAR *v1; // edi
  HRESULT v2; // esi
  LPVOID ppv; // [esp+8h] [ebp-4h]

  ppv = 0;
  v1 = SysAllocString(L"root\\wmi");
  CoInitialize(0);
  v2 = CoCreateInstance(&stru_12C7A7C, 0, 1u, &stru_12C79AC, &ppv);
  if ( !v2 )
  {
    v2 = (*(*ppv + 12))(ppv, v1, 0, 0, 0, 0, 0, 0, a1);
    if ( !v2 )
      v2 = CoSetProxyBlanket(*a1, 0xAu, 0, 0, 4u, 3u, 0, 0);
  }
  SysFreeString(v1);
  if ( ppv )
    (*(*ppv + 8))(ppv);
  return v2;
}

//----- (01219380) --------------------------------------------------------
_DWORD *__thiscall sub_1219380(_DWORD **this, _DWORD *a2)
{
  _DWORD **v2; // esi
  _DWORD *v3; // edi
  _DWORD *v4; // edx
  _DWORD *v5; // eax
  _DWORD *result; // eax

  v2 = this;
  v3 = *this;
  v4 = sub_1281420(*this, (*this)[1], a2);
  v5 = v2[1];
  if ( (357913940 - v5) < 1 )
    std::_Xlength_error("list<T> too long");
  v2[1] = (v5 + 1);
  v3[1] = v4;
  result = v4[1];
  *result = v4;
  return result;
}

//----- (012193D0) --------------------------------------------------------
_WORD *__thiscall sub_12193D0(_WORD *this, OLECHAR *psz)
{
  _WORD *v2; // esi
  BSTR v3; // eax

  v2 = this;
  *this = 8;
  v3 = SysAllocString(psz);
  *(v2 + 2) = v3;
  if ( !v3 && psz )
    com_error::throw(-2147024882);
  return v2;
}

//----- (01219410) --------------------------------------------------------
int __usercall sub_1219410@<eax>(int a1@<esi>, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int result; // eax
  int v7; // esi
  int v8; // [esp+4h] [ebp-4h]

  v4 = a2;
  v5 = a4;
  *a4 = 0;
  result = (*(*v4 + 60))(v4, 0, &CLSID_IDispatch, &v8);
  if ( result >= 0 )
  {
    v7 = (**v8)(v8, &CLSID_IShellFolderViewDual, &a2, a1);
    if ( v7 >= 0 )
    {
      v7 = (*(*a2 + 28))(a2, &a4);
      if ( v7 >= 0 )
      {
        v7 = (**a4)(a4, a3, v5);
        (*(*a4 + 8))(a4);
      }
      (*(*a2 + 8))(a2);
    }
    (*(*v8 + 8))(v8);
    result = v7;
  }
  return result;
}
// 12B38D0: using guessed type GUID CLSID_IDispatch;
// 12B38F0: using guessed type GUID CLSID_IShellFolderViewDual;

//----- (012194A0) --------------------------------------------------------
HRESULT __usercall sub_12194A0@<eax>(int a1@<esi>, int a2, int a3)
{
  int v3; // edi
  HRESULT result; // eax
  LPVOID v5; // eax
  HRESULT v6; // esi
  __int128 v7; // [esp+4h] [ebp-20h]
  char v8; // [esp+14h] [ebp-10h]
  LPVOID ppv; // [esp+18h] [ebp-Ch]
  IUnknown *punk; // [esp+1Ch] [ebp-8h]
  void *ppvOut; // [esp+20h] [ebp-4h]

  v3 = a3;
  *a3 = 0;
  result = CoCreateInstance(&stru_12C7B9C, 0, 4u, &stru_12B3910, &ppv);
  if ( result >= 0 )
  {
    v5 = ppv;
    _mm_storeu_si128(&v7, 0i64);
    if ( (*(*v5 + 60))(v5, &v7, &v7, 8, &v8, 1, &punk, a1) )
    {
      (*(*ppv + 8))(ppv);
      result = -2147467259;
    }
    else
    {
      v6 = IUnknown_QueryService(punk, &CLSID_SID_STopLevelBrowser, &CLSID_IShellBrowser, &ppvOut);
      if ( v6 >= 0 )
      {
        v6 = (*(*ppvOut + 60))(ppvOut, &a3);
        if ( v6 >= 0 )
        {
          v6 = (**a3)(a3, a2, v3);
          (*(*a3 + 8))(a3);
        }
        (*(*ppvOut + 8))(ppvOut);
      }
      (punk->lpVtbl->Release)(punk);
      (*(*ppv + 8))(ppv);
      result = v6;
    }
  }
  return result;
}

//----- (01219580) --------------------------------------------------------
int __usercall sub_1219580@<eax>(int a1@<esi>, OLECHAR *psz, LPCWSTR lpParameters, OLECHAR *a4)
{
  HRESULT v4; // eax
  const WCHAR *v5; // esi
  int v6; // edi
  bool v7; // zf
  int v8; // ecx
  OLECHAR *v9; // esi
  int v10; // edx
  int v12; // [esp-40h] [ebp-84h]
  int v13; // [esp-3Ch] [ebp-80h]
  int v14; // [esp-38h] [ebp-7Ch]
  int v15; // [esp-34h] [ebp-78h]
  int v16; // [esp-30h] [ebp-74h]
  int v17; // [esp-2Ch] [ebp-70h]
  int v18; // [esp-28h] [ebp-6Ch]
  int v19; // [esp-24h] [ebp-68h]
  int v20; // [esp-20h] [ebp-64h]
  int v21; // [esp-1Ch] [ebp-60h]
  int v22; // [esp-18h] [ebp-5Ch]
  int v23; // [esp-14h] [ebp-58h]
  int v24; // [esp-10h] [ebp-54h]
  int v25; // [esp-Ch] [ebp-50h]
  int v26; // [esp-8h] [ebp-4Ch]
  int v27; // [esp-4h] [ebp-48h]
  VARIANTARG v28; // [esp+Ch] [ebp-38h]
  VARIANTARG pvarg; // [esp+1Ch] [ebp-28h]
  BSTR bstrString; // [esp+2Ch] [ebp-18h]
  int v31; // [esp+30h] [ebp-14h]
  int *v32; // [esp+34h] [ebp-10h]
  int v33; // [esp+40h] [ebp-4h]

  v4 = sub_12194A0(a1, &CLSID_IShellView, &v31);
  v5 = lpParameters;
  v6 = v4;
  v7 = v4 == 0;
  if ( v4 >= 0 )
  {
    v6 = sub_1219410(lpParameters, v31, &CLSID_IShellDispatch2, &v32);
    if ( v6 >= 0 )
    {
      bstrString = SysAllocString(psz);
      v6 = -2147024882;
      if ( bstrString )
        v6 = 0;
      if ( v6 >= 0 )
      {
        v28.vt = 8;
        v28.lVal = SysAllocString(lpParameters);
        if ( !v28.lVal && lpParameters )
          com_error::throw(-2147024882);
        v33 = 0;
        pvarg.vt = 8;
        pvarg.lVal = SysAllocString(a4);
        if ( !pvarg.lVal && a4 )
          com_error::throw(-2147024882);
        v8 = v32;
        v9 = bstrString;
        LOBYTE(v33) = 1;
        v10 = *v32;
        _mm_storeu_si128(&v24, 0i64);
        _mm_storeu_si128(&v20, 0i64);
        _mm_storeu_si128(&v16, _mm_loadu_si128(&pvarg));
        _mm_storeu_si128(&v12, _mm_loadu_si128(&v28));
        v6 = (*(v10 + 124))(v8, v9, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
        SysFreeString(v9);
        VariantClear(&pvarg);
        v33 = -1;
        VariantClear(&v28);
        v5 = lpParameters;
      }
      v27 = v32;
      (*(*v32 + 8))(v32);
    }
    v27 = v31;
    (*(*v31 + 8))(v31);
    v7 = v6 == 0;
  }
  if ( !v7 && ShellExecuteW(0, 0, psz, v5, 0, 1) > 0x20 )
    v6 = 0;
  return v6;
}
// 12B3900: using guessed type GUID CLSID_IShellView;
// 12B3920: using guessed type GUID CLSID_IShellDispatch2;

//----- (01219700) --------------------------------------------------------
_DWORD *__cdecl sub_1219700(_DWORD *a1, char a2, _DWORD *a3, unsigned int *a4, int a5, int a6)
{
  _DWORD *result; // eax
  int v7; // ebx
  unsigned int v8; // edi
  WCHAR *v9; // esi
  wchar_t *v10; // edi
  const wchar_t *i; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // eax
  DWORD v14; // [esp+0h] [ebp-820h]
  unsigned int v15; // [esp+8h] [ebp-818h]
  unsigned int v16; // [esp+14h] [ebp-80Ch]
  _DWORD *v17; // [esp+18h] [ebp-808h]
  WCHAR pszNameString; // [esp+1Ch] [ebp-804h]

  result = a1;
  v15 = *a4;
  *a4 = 0;
  if ( !a1 )
    return result;
  result = WTHelperProvDataFromStateData(a1, v14);
  if ( !result )
    return result;
  result = WTHelperGetProvSignerFromChain(result);
  if ( !result )
    return result;
  if ( a3 )
  {
    *a3 = result[1];
    a3[1] = result[2];
  }
  if ( !a2 )
    goto LABEL_9;
  if ( result[8] )
  {
    result = result[9];
LABEL_9:
    v7 = result[4];
    result = result[3];
    goto LABEL_10;
  }
  v7 = a5;
  result = 0;
LABEL_10:
  v8 = 0;
  v17 = result;
  v16 = 0;
  if ( result )
  {
    while ( 1 )
    {
      if ( v8 >= v15 )
        return result;
      result = CertGetNameStringW(*(v7 + 4), 5u, 0, 0, &pszNameString, 0x400u);
      if ( result )
        break;
LABEL_29:
      v16 = ++v8;
      if ( v8 >= v17 )
        return result;
    }
    if ( wcsstr(&pszNameString, L"CN=") )
    {
      v9 = wcsstr(&pszNameString, L"CN=") + 3;
    }
    else if ( wcsstr(&pszNameString, L"OU=") )
    {
      v10 = wcsstr(&pszNameString, L"OU=");
      for ( i = v10 + 1; wcsstr(v10 + 1, L"OU="); i = v10 + 1 )
        v10 = wcsstr(i, L"OU=");
      v12 = wcsstr(v10, L"OU=");
      v8 = v16;
      v9 = v12 + 3;
    }
    else
    {
      v9 = &pszNameString;
    }
    if ( *v9 == 34 )
    {
      ++v9;
      v13 = wcschr(v9, 0x22u);
    }
    else
    {
      if ( !wcschr(v9, 0x2Cu) )
      {
LABEL_26:
        result = _wcsdup(v9);
        *(a5 + 4 * *a4) = result;
        if ( a6 )
        {
          result = CertDuplicateCertificateContext(*(v7 + 4));
          *(a6 + 4 * *a4) = result;
        }
        v7 += *v7;
        ++*a4;
        goto LABEL_29;
      }
      v13 = wcschr(v9, 0x2Cu);
    }
    *v13 = 0;
    goto LABEL_26;
  }
  return result;
}

//----- (01219930) --------------------------------------------------------
CRYPT_PROVIDER_SGNR *__cdecl sub_1219930(void *a1, int a2, char a3, BYTE *a4, DWORD a5, void *a6, int a7, int a8)
{
  CATALOG_INFO *v8; // edi
  CRYPT_PROVIDER_SGNR *v10; // esi
  CATALOG_INFO psCatInfo; // [esp+18h] [ebp-210h]

  v8 = CryptCATAdminEnumCatalogFromHash(a1, a4, a5, 0, 0);
  if ( !v8 )
    return -2146762496;
  while ( 1 )
  {
    memset(&psCatInfo, 0, 0x20Cu);
    psCatInfo.cbStruct = 524;
    if ( CryptCATCatalogInfoFromContext(v8, &psCatInfo, 0) )
      break;
    CryptCATAdminReleaseCatalogContext(a1, v8, 0);
    v8 = CryptCATAdminEnumCatalogFromHash(a1, a4, a5, 0, 0);
    if ( !v8 )
      return -2146762496;
  }
  v10 = sub_1219A40(a2, a3, a4, a5, a6, psCatInfo.wszCatalogFile, a7, a8);
  CryptCATAdminReleaseCatalogContext(a1, v8, 0);
  return v10;
}

//----- (01219A40) --------------------------------------------------------
CRYPT_PROVIDER_SGNR *__cdecl sub_1219A40(int a1, char a2, int a3, int a4, void *a5, int a6, int a7, int a8)
{
  int v8; // eax
  _DWORD *v9; // edi
  unsigned int v10; // esi
  wchar_t *v11; // edi
  wchar_t *v12; // eax
  CRYPT_PROVIDER_SGNR *v13; // esi
  wchar_t **v14; // edi
  DWORD v16; // [esp+0h] [ebp-B0h]
  __int128 v17; // [esp+Ch] [ebp-A4h]
  __int64 v18; // [esp+1Ch] [ebp-94h]
  __int128 v19; // [esp+24h] [ebp-8Ch]
  __int128 v20; // [esp+34h] [ebp-7Ch]
  int v21; // [esp+44h] [ebp-6Ch]
  _DWORD *v22; // [esp+48h] [ebp-68h]
  wchar_t **v23; // [esp+4Ch] [ebp-64h]
  int v24; // [esp+50h] [ebp-60h]
  wchar_t *v25; // [esp+54h] [ebp-5Ch]
  wchar_t Dst; // [esp+58h] [ebp-58h]

  v8 = a3;
  v9 = a5;
  v10 = 0;
  v25 = a6;
  v24 = a3;
  v22 = a5;
  v23 = a7;
  if ( a4 )
  {
    v11 = &Dst;
    do
    {
      swprintf_s(v11, 3u, L"%02X", *(v8 + v10));
      v8 = v24;
      ++v10;
      v11 += 2;
    }
    while ( v10 < a4 );
    v9 = v22;
  }
  v12 = v25;
  _mm_storeu_si128(&v19, 0i64);
  *(&v19 + 1) = __PAIR__(&Dst, v12);
  _mm_storeu_si128(&v20, 0i64);
  LODWORD(v20) = a1;
  v21 = 0;
  LODWORD(v19) = 36;
  *(&v20 + 1) = __PAIR__(a4, v24);
  memset(v9, 0, 0x34u);
  v9[3] = 2;
  v9[5] = 2;
  v9[7] = 1;
  *v9 = 4 * (a8 != -1) + 48;
  v9[4] = a2 != 0;
  v9[6] = &v19;
  if ( a8 != -1 )
  {
    _mm_storeu_si128(&v17, 0i64);
    LODWORD(v17) = 24;
    v18 = 0i64;
    *(&v17 + 4) = __PAIR__(1, a8);
    v9[12] = &v17;
  }
  v13 = WinVerifyTrust(0, &stru_12DC318, v9, v16);
  if ( !v13 )
  {
    v14 = v23;
    if ( v23 )
      *v14 = _wcsdup(v25);
  }
  return v13;
}
// 12DC318: using guessed type GUID stru_12DC318;

//----- (01219BB0) --------------------------------------------------------
CRYPT_PROVIDER_SGNR *__cdecl sub_1219BB0(const WCHAR *a1, int a2, void **a3, char a4, _DWORD *a5, unsigned int *a6, int a7, int a8, int a9, int a10, int a11, wchar_t **a12, int a13)
{
  unsigned int *v13; // ebx
  LPCWSTR v14; // eax
  signed int v15; // eax
  CRYPT_PROVIDER_SGNR *result; // eax
  CRYPT_PROVIDER_SGNR *v17; // ecx
  wchar_t *v18; // eax
  HANDLE v19; // ebx
  CRYPT_PROVIDER_SGNR *v20; // eax
  DWORD v21; // [esp+0h] [ebp-BCh]
  DWORD v22; // [esp+0h] [ebp-BCh]
  __int128 v23; // [esp+Ch] [ebp-B0h]
  __int64 v24; // [esp+1Ch] [ebp-A0h]
  __int128 v25; // [esp+24h] [ebp-98h]
  void **v26; // [esp+34h] [ebp-88h]
  int v27; // [esp+38h] [ebp-84h]
  _DWORD *v28; // [esp+3Ch] [ebp-80h]
  BOOL fCounterSigner; // [esp+40h] [ebp-7Ch]
  int v30; // [esp+4Ch] [ebp-70h]
  CRYPT_PROVIDER_SGNR *v31; // [esp+50h] [ebp-6Ch]
  int v32; // [esp+54h] [ebp-68h]
  __int128 *v33; // [esp+58h] [ebp-64h]
  int v34; // [esp+5Ch] [ebp-60h]
  _DWORD *v35; // [esp+60h] [ebp-5Ch]
  int v36; // [esp+68h] [ebp-54h]
  __int128 *v37; // [esp+70h] [ebp-4Ch]
  int v38; // [esp+74h] [ebp-48h]
  int v39; // [esp+78h] [ebp-44h]
  int v40; // [esp+7Ch] [ebp-40h]
  int v41; // [esp+80h] [ebp-3Ch]
  int v42; // [esp+84h] [ebp-38h]
  HCATADMIN phCatAdmin; // [esp+88h] [ebp-34h]
  CRYPT_PROVIDER_SGNR *v44; // [esp+8Ch] [ebp-30h]
  CRYPT_PROVIDER_SGNR *v45; // [esp+90h] [ebp-2Ch]
  DWORD pcbHash; // [esp+94h] [ebp-28h]
  unsigned int *v47; // [esp+98h] [ebp-24h]
  LPCWSTR lpFileName; // [esp+9Ch] [ebp-20h]
  CRYPT_PROVIDER_SGNR *v49; // [esp+A0h] [ebp-1Ch]
  BYTE pbHash[4]; // [esp+A4h] [ebp-18h]

  lpFileName = a1;
  v42 = a2;
  v26 = a3;
  v28 = a5;
  v38 = a7;
  v13 = a9;
  v39 = a8;
  v40 = a10;
  v47 = a9;
  v41 = a11;
  pcbHash = 20;
  v45 = -2146762496;
  LoadWintrust();
  if ( a12 )
    *a12 = 0;
  v14 = lpFileName;
  _mm_storeu_si128(&v25, 0i64);
  DWORD1(v25) = v14;
  LODWORD(v25) = 16;
  memset(&fCounterSigner, 0, 0x34u);
  v30 = 2;
  v32 = 1;
  v34 = 1;
  v27 = 4 * (a13 != -1) + 48;
  fCounterSigner = 4 * (a13 != -1) + 48;
  v15 = 0;
  if ( a4 )
    v15 = 64;
  v44 = v15;
  v31 = v15;
  v33 = &v25;
  if ( a13 != -1 )
  {
    _mm_storeu_si128(&v23, 0i64);
    LODWORD(v23) = 24;
    v24 = 0i64;
    *(&v23 + 4) = __PAIR__(1, a13);
    v37 = &v23;
  }
  result = WinVerifyTrust(0, &stru_12DC328, &fCounterSigner, v21);
  v49 = result;
  if ( !result || result == -2146762484 )
  {
    if ( a12 )
    {
      *a12 = _wcsdup(lpFileName);
      result = v49;
    }
    goto LABEL_15;
  }
  if ( !a6 )
  {
LABEL_15:
    v17 = -2146762496;
    goto LABEL_16;
  }
  memset(&fCounterSigner, 0, 0x34u);
  fCounterSigner = v27;
  v31 = v44;
  v33 = &v25;
  v37 = &v23;
  v30 = 2;
  v32 = 1;
  v34 = 1;
  v36 = 512;
  v17 = WinVerifyTrust(0, &stru_12DC328, &fCounterSigner, v22);
  v44 = v17;
  if ( v17 || !a12 )
  {
    result = v49;
  }
  else
  {
    v18 = _wcsdup(lpFileName);
    v17 = v44;
    *a12 = v18;
    result = v49;
  }
LABEL_16:
  if ( !result || !v17 )
    goto LABEL_36;
  if ( *CryptCATAdminAcquireContext )
  {
    v19 = CreateFile(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
    if ( v19 == -1 )
    {
LABEL_30:
      v13 = v47;
      result = v49;
      goto LABEL_31;
    }
    if ( !CryptCATAdminCalcHashFromFileHandle(v19, &pcbHash, pbHash, 0) )
    {
      CloseHandle(v19);
      goto LABEL_30;
    }
    CloseHandle(v19);
    if ( v26 )
    {
      v20 = sub_1219930(*v26, lpFileName, a4, pbHash, pcbHash, &fCounterSigner, a12, a13);
    }
    else
    {
      if ( !v42 )
        goto LABEL_28;
      v20 = sub_1219A40(lpFileName, a4, pbHash, pcbHash, &fCounterSigner, v42, a12, a13);
    }
    v45 = v20;
    if ( !v20 )
      goto LABEL_30;
LABEL_28:
    CryptCATAdminAcquireContext(&phCatAdmin, 0, 0);
    v45 = sub_1219930(phCatAdmin, lpFileName, a4, pbHash, pcbHash, &fCounterSigner, a12, a13);
    if ( phCatAdmin )
      CryptCATAdminReleaseContext(phCatAdmin, 0, v22);
    goto LABEL_30;
  }
LABEL_31:
  if ( v45 )
  {
    if ( a6 )
      *a6 = 0;
    if ( v13 )
      *v13 = 0;
    return result;
  }
LABEL_36:
  if ( a6 )
    sub_1219700(v35, 0, v28, a6, v38, v39);
  if ( v13 )
    sub_1219700(v35, 1, 0, v13, v40, v41);
  v34 = 2;
  WinVerifyTrust(0, &stru_12DC328, &fCounterSigner, v22);
  return 0;
}
// 12DC328: using guessed type GUID stru_12DC328;

//----- (01219F40) --------------------------------------------------------
bool LoadWintrust()
{
  HMODULE hMod; // eax
  HMODULE hModule; // edi
  HMODULE hInst; // eax

  if ( !byte_12E4D7C )
  {
    byte_12E4D7C = 1;
    hMod = LoadLibraryW(L"Wintrust.dll");
    hModule = hMod;
    if ( !hMod )
      return 0;
    *WinVerifyTrust = GetProcAddress(hMod, "WinVerifyTrust");
    *WTHelperGetProvSignerFromChain = GetProcAddress(hModule, "WTHelperGetProvSignerFromChain");
    *WTHelperProvDataFromStateData = GetProcAddress(hModule, "WTHelperProvDataFromStateData");
    *CryptCATAdminReleaseContext = GetProcAddress(hModule, "CryptCATAdminReleaseContext");
    *CryptCATAdminReleaseCatalogContext = GetProcAddress(hModule, "CryptCATAdminReleaseCatalogContext");
    *CryptCATCatalogInfoFromContext = GetProcAddress(hModule, "CryptCATCatalogInfoFromContext");
    *CryptCATAdminEnumCatalogFromHash = GetProcAddress(hModule, "CryptCATAdminEnumCatalogFromHash");
    *CryptCATAdminCalcHashFromFileHandle = GetProcAddress(hModule, "CryptCATAdminCalcHashFromFileHandle");
    *CryptCATAdminAcquireContext = GetProcAddress(hModule, "CryptCATAdminAcquireContext");
    *CryptCATAdminAddCatalog = GetProcAddress(hModule, "CryptCATAdminAddCatalog");
    *CryptCATAdminRemoveCatalog = GetProcAddress(hModule, "CryptCATAdminRemoveCatalog");
    *IsCatalogFile = GetProcAddress(hModule, "IsCatalogFile");
    hInst = LoadLibraryW(L"crypt32.dll");
    *CertNameToStrW = GetProcAddress(hInst, "CertNameToStrW");
  }
  return *CryptCATAdminAcquireContext != 0;
}
// 12E4D7C: using guessed type char byte_12E4D7C;

//----- (0121A040) --------------------------------------------------------
CTreeList *__thiscall CTreeList::CTreeList(CTreeList *this)
{
  CTreeList *result; // eax

  this->m_ThemeData = 0;
  result = this;
  this->vtptr = &CTreeList::`vftable';
  this->m_hWnd = 0;
  this->m_hWndHeaderLeft = 0;
  this->m_hWndHeaderRight = 0;
  this->m_hWndScrollBarRightRight = 0;
  this->m_hWndScrollBarLeftHorz = 0;
  this->m_hWndScrollBarRightBottom = 0;
  this->m_hWndStatic = 0;
  this->m_hWndTooltipOfTreeList = 0;
  this->m_Font = 0;
  this->m_hSplitterCursor = 0;
  this->m_ImageList = 0;
  LOBYTE(this->m_ImageFlag) = 0;
  this->field_40 = 0;
  this->field_44 = 0;
  this->field_48 = 0;
  this->m_RowInfo = 0;
  this->field_58 = 0;
  this->m_bValid = 0;
  this->field_60 = 0;
  this->field_64 = 0;
  this->m_Height = 1;
  this->field_6C = 2;
  this->field_70 = 3;
  this->field_74 = 0;
  this->field_78 = 16;
  this->field_7C = 0;
  this->m_posVertScrollLast = 0;
  this->m_Point.x = 0;
  this->m_Point.y = 0;
  this->field_8C = 0;
  this->m_rcHeader.left = 0;
  this->m_rcHeader.top = 20;
  this->m_rcHeader.right = 0;
  LOWORD(this->m_rcHeader.bottom) = 1;
  this->m_nHeaderItem = -1;
  this->field_A8 = -1;
  this->field_AC = 0;
  this->m_AscendImage = -1;
  this->m_DescendImage = -1;
  LOBYTE(this->field_BC) = 1;
  LOBYTE(this->m_posLast.y) = 0;
  this->field_D0 = 0;
  this->DisplayCallback = 0;
  this->m_HandCursor = 0;
  this->m_HeaderFormat = 0x8820;
  this->field_50 = 0;
  this->field_4C = 0;
  return result;
}
// 12B4188: using guessed type void *CTreeList::`vftable';

//----- (0121A1F0) --------------------------------------------------------
void *__thiscall sub_121A1F0(_DWORD *this)
{
  _DWORD *v1; // edi
  int v2; // esi
  void *result; // eax

  v1 = this;
  *this = &CTreeList::`vftable';
  v2 = this[52];
  if ( v2 )
  {
    if ( !InterlockedDecrement((v2 + 8)) && v2 )
    {
      if ( *v2 )
      {
        SysFreeString(*v2);
        *v2 = 0;
      }
      if ( *(v2 + 4) )
      {
        j_j__free(*(v2 + 4));
        *(v2 + 4) = 0;
      }
      j__free(v2);
    }
    v1[52] = 0;
  }
  sub_121A2C0(v1 + 16);
  result = v1[1];
  *v1 = &CThemedWindow::`vftable';
  if ( result )
    result = CloseThemeData(result);
  return result;
}
// 12B4130: using guessed type void *CThemedWindow::`vftable';
// 12B4188: using guessed type void *CTreeList::`vftable';

//----- (0121A2C0) --------------------------------------------------------
void __thiscall sub_121A2C0(_DWORD *this)
{
  int v1; // edx
  int v2; // edx
  int v3; // edx
  int v4; // edx
  int v5; // eax
  int v6; // edx

  v1 = this[3];
  if ( v1 )
    *(v1 + 16) = this[4];
  v2 = this[4];
  if ( v2 )
    *(v2 + 12) = this[3];
  v3 = this[2];
  if ( v3 )
  {
    if ( *(v3 + 20) == this )
      *(v3 + 20) = this[4];
    v4 = this[2];
    if ( *(v4 + 24) == this )
      *(v4 + 24) = this[3];
    --*(this[2] + 28);
    v5 = this[2];
    if ( !*(v5 + 28) )
      *(v5 + 32) &= 0xFFFFFFBF;
  }
  v6 = this[1];
  if ( v6 )
    (*(*v6 + 20))(v6, this);
}

//----- (0121A320) --------------------------------------------------------
BSTR **__thiscall sub_121A320(BSTR **this, LPCSTR lpString)
{
  BSTR **v2; // edi
  BSTR *v3; // esi
  const CHAR *v4; // eax
  BSTR *v5; // eax
  BSTR *v6; // esi

  v2 = this;
  if ( !lpString )
    goto LABEL_16;
  v3 = *this;
  if ( *this )
  {
    if ( !v3[1] )
      v3[1] = UTFToAscii(*v3);
    v4 = v3[1];
  }
  else
  {
    v4 = 0;
  }
  if ( v4 != lpString )
  {
LABEL_16:
    bstr_t::Data_t::Free(v2);
    v5 = operator new(0xCu);
    v6 = v5;
    if ( v5 )
    {
      v5[1] = 0;
      v5[2] = 1;
      *v5 = AsciiToUTF(lpString);
    }
    else
    {
      v6 = 0;
    }
    *v2 = v6;
    if ( !v6 )
      com_error::throw(-2147024882);
  }
  return v2;
}

//----- (0121A3E0) --------------------------------------------------------
BOOL __thiscall sub_121A3E0(BSTR **this, BSTR **a2)
{
  BSTR *v2; // ecx
  BSTR *v3; // eax
  OLECHAR *v5; // eax

  v2 = *this;
  v3 = *a2;
  if ( v2 == *a2 )
    return 1;
  if ( !v2 )
  {
    if ( v3 )
    {
      v5 = *v3;
      if ( v5 )
      {
        if ( SysStringLen(v5) )
          return 0;
      }
    }
    return 1;
  }
  if ( v3 )
    return sub_11F4730(v2, *a2) == 0;
  if ( !*v2 || !SysStringLen(*v2) )
    return 1;
  return 0;
}

//----- (0121A460) --------------------------------------------------------
void *__thiscall sub_121A460(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &CTreeListData::`vftable';
  if ( a2 & 1 )
    j__free(this);
  return v2;
}
// 12B414C: using guessed type void *CTreeListData::`vftable';

//----- (0121A490) --------------------------------------------------------
HWND __cdecl CreateTreeListView(HWND hWndParent, HINSTANCE hInstance, HMENU hMenu, int dwStyle, LPRECT rc)
{
  CTreeList *v5; // eax
  CTreeList *pTreeList; // ebx

  v5 = operator new(0xDCu);
  if ( v5 )
    pTreeList = CTreeList::CTreeList(v5);
  else
    pTreeList = 0;
  pTreeList->m_hWnd = CreateWindowExW(
                        0,
                        gAtomTreeListAtom,
                        gpszTargetName,
                        dwStyle | WS_CLIPCHILDREN,
                        rc->left,
                        rc->top,
                        rc->right - rc->left,
                        rc->bottom - rc->top,
                        hWndParent,
                        hMenu,
                        hInstance,
                        pTreeList);
  CTreeList::Init(pTreeList);
  return pTreeList->m_hWnd;
}
// 12E4D9C: using guessed type __int16 gAtomTreeListAtom;

//----- (0121A510) --------------------------------------------------------
HWND __stdcall CTreeList::CreateTooltip(HINSTANCE hInstance, HWND hWndParent)
{
  HWND hWndTooltip; // esi
  TTTOOLINFOW ToolInfo; // [esp+8h] [ebp-34h]

  // WS_POPUP|TTS_NOPREFIX|TTS_ALWAYSTIP|TTS_NOANIMATE|TTS_NOFADE
  hWndTooltip = CreateWindowExW(NULL, L"tooltips_class32", NULL, 0x80000033, 0, 0, 0, 0, hWndParent, 0, hInstance, NULL);
  ToolInfo.cbSize = 48;
  ToolInfo.uFlags = TTF_TRANSPARENT;
  *&ToolInfo.lParam = 0i64;
  _mm_storeu_si128(&ToolInfo.hwnd, 0i64);
  _mm_storeu_si128(&ToolInfo.rect.right, 0i64);
  ToolInfo.hwnd = hWndParent;
  ToolInfo.lpszText = -1;
  GetClientRect(hWndParent, &ToolInfo.rect);
  SendMessageW(hWndTooltip, TTM_ADDTOOLW, 0, &ToolInfo);
  return hWndTooltip;
}

//----- (0121A5B0) --------------------------------------------------------
int __cdecl CThemedWindow::GetWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  JUMPOUT(&DefWindowProcW);
}

//----- (0121A5C0) --------------------------------------------------------
LRESULT __thiscall sub_121A5C0(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // edi
  int v3; // esi
  signed int v4; // eax
  int v5; // eax
  HWND v6; // eax
  LPARAM lParam; // [esp+8h] [ebp-2Ch]
  __int128 v9; // [esp+Ch] [ebp-28h]
  __int128 v10; // [esp+1Ch] [ebp-18h]
  __int64 v11; // [esp+2Ch] [ebp-8h]

  v2 = this;
  v3 = *a2;
  v4 = sub_121BFE0(*a2, a2);
  lParam = 0;
  _mm_storeu_si128(&v9, 0i64);
  DWORD2(v9) = v4;
  v5 = v2[1];
  v11 = 0i64;
  HIDWORD(v11) = v5;
  _mm_storeu_si128(&v10, 0i64);
  v6 = GetParent(*(v3 + 8));
  return SendMessageW(v6, 0xFFFFFF99, 0, &lParam);
}

//----- (0121A620) --------------------------------------------------------
LRESULT __thiscall CTreeList::Close(CTreeList *pTreeList)
{
  CTreeList *this; // esi
  bool v2; // zf
  HWND hWnd; // ST00_4

  this = pTreeList;
  v2 = pTreeList->m_RowInfo == 0;
  BYTE1(pTreeList->m_rcHeader.bottom) = 1;
  if ( !v2 )
  {
    do
      sub_121A7D0(this, this->m_RowInfo);
    while ( this->m_RowInfo );
  }
  hWnd = this->m_hWnd;
  BYTE1(this->m_rcHeader.bottom) = 0;
  InvalidateRect(hWnd, NULL, FALSE);
  InvalidateRect(this->m_hWndHeaderLeft, NULL, FALSE);
  InvalidateRect(this->m_hWndHeaderRight, NULL, FALSE);
  this->m_rcHeader.right = sub_121C080(this, 0);
  sub_121EF00(this);
  sub_121EFD0(this);
  return sub_121EC50(this);
}

//----- (0121A690) --------------------------------------------------------
bool __thiscall CTreeList::DeleteColumn(CTreeList *this, WPARAM wParam)
{
  CTreeList *pTreeList; // edi
  LRESULT nColumnCountLeft; // esi
  LRESULT nColumnCountRight; // eax
  BOOL ret; // eax
  HWND v6; // ST00_4
  HDITEMW hditem; // [esp+4h] [ebp-238h]
  __int16 szText[260]; // [esp+30h] [ebp-20Ch]

  pTreeList = this;
  if ( wParam )
  {
    ret = SendMessageW(this->m_hWndHeaderRight, HDM_DELETEITEM, wParam - 1, 0) != 0;
  }
  else
  {
    nColumnCountLeft = SendMessageW(this->m_hWndHeaderLeft, HDM_GETITEMCOUNT, 0, 0);
    nColumnCountRight = SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0);
    if ( nColumnCountLeft )
    {
      if ( nColumnCountRight )
      {
        hditem.mask = 7;
        hditem.pszText = szText;
        v6 = pTreeList->m_hWndHeaderRight;
        hditem.cchTextMax = 260;
        SendMessageW(v6, HDM_GETITEMW, 0, &hditem);
        SendMessageW(pTreeList->m_hWndHeaderLeft, HDM_DELETEITEM, 0, 0);
        SendMessageW(pTreeList->m_hWndHeaderRight, HDM_DELETEITEM, 0, 0);
        SendMessageW(pTreeList->m_hWndHeaderLeft, HDM_INSERTITEMW, 0, &hditem);
        CTreeList::SetHeaderWidth(pTreeList, hditem.cxy);
        LOBYTE(ret) = 1;
      }
      else
      {
        ret = SendMessageW(pTreeList->m_hWndHeaderLeft, HDM_DELETEITEM, 0, 0) != 0;
      }
    }
    else
    {
      LOBYTE(ret) = 0;
    }
  }
  return ret;
}

//----- (0121A7D0) --------------------------------------------------------
void __thiscall sub_121A7D0(CTreeList *pTreeList, void *a2)
{
  _DWORD *v2; // edi
  CTreeList *this; // esi
  void *i; // eax
  HWND hWnd; // eax
  UINT nID; // eax
  bool v7; // zf
  HWND v8; // eax
  WPARAM v9; // ST10_4
  HWND hWndParent; // eax
  int v11; // ebx
  NMHDR lParam; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-10h]
  void *v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]
  CTreeList *a2a; // [esp+30h] [ebp+8h]

  v2 = a2;
  this = pTreeList;
  for ( i = *(a2 + 5); i; i = *(a2 + 5) )
    sub_121A7D0(this, i);
  hWnd = this->m_hWnd;
  lParam.code = 2006;
  lParam.hwndFrom = hWnd;
  nID = GetWindowLongW(hWnd, GWL_ID);
  v7 = LOBYTE(this->m_posLast.y) == 0;
  lParam.idFrom = nID;
  v15 = 0;
  v13 = 0;
  v14 = a2;
  v16 = 0;
  if ( v7 )
  {
    v9 = nID;
    hWndParent = GetParent(this->m_hWnd);
    SendMessageW(hWndParent, WM_NOTIFY, v9, &lParam);
  }
  else
  {
    v8 = GetParent(this->m_hWnd);
    sub_121E690(this, v8, &lParam);
  }
  if ( this->field_7C == a2 )
  {
    sub_121AE40(this, this->m_hWnd, 2000, 0, 0, a2, 0);
    this->field_7C = 0;
  }
  if ( this->field_AC == a2 )
    this->field_AC = 0;
  a2a = sub_121BFE0(this, a2);
  sub_121D830(this, a2a, -1);
  v11 = v2[2];
  sub_121A2C0(v2);
  j__free(v2);
  if ( v11 )
  {
    if ( !(*(v11 + 32) & 0x40) )
      CTreeList::RedrawItems(this, &a2a[-1].m_HandCursor + 3, &a2a[-1].m_HandCursor + 3);
  }
}

//----- (0121A8E0) --------------------------------------------------------
signed int __thiscall sub_121A8E0(_DWORD *this)
{
  int v1; // ecx
  signed int result; // eax

  v1 = this[2];
  for ( result = -1; v1; ++result )
    v1 = *(v1 + 8);
  return result;
}

//----- (0121A900) --------------------------------------------------------
void __thiscall CTreeList::DrawHeaderItem(CTreeList *pTreeList, int a2, HDC hDCInit, RECT rect)
{
  CTreeList *this; // esi
  HDC hWindowDC; // edi
  UINT ItemCount; // ebx
  HBRUSH hBrush; // eax
  DWORD *pOrderArray; // eax
  UINT nIndex; // edi
  HWND hWndScrollbar; // ST08_4
  RECT *Rect; // ecx
  int xxx; // eax
  UINT nItem; // ecx
  COLORREF clrPen; // eax
  HDC hDC; // edi
  UINT nItemCount; // eax
  LPRECT v17; // eax
  HGDIOBJ hOldPen; // [esp+0h] [ebp-2B8h]
  HPEN hPen; // [esp+4h] [ebp-2B4h]
  HGDIOBJ hOldFont; // [esp+8h] [ebp-2B0h]
  int v21; // [esp+Ch] [ebp-2ACh]
  COLORREF clrBack; // [esp+10h] [ebp-2A8h]
  DWORD *pItemIndex; // [esp+14h] [ebp-2A4h]
  RECT *pRect; // [esp+18h] [ebp-2A0h]
  HDC hdc; // [esp+1Ch] [ebp-29Ch]
  int iItem; // [esp+20h] [ebp-298h]
  DWORD *pdwFormat; // [esp+24h] [ebp-294h]
  HWND hWnd; // [esp+28h] [ebp-290h]
  LPRECT lprc; // [esp+2Ch] [ebp-28Ch]
  RECT *nCount; // [esp+30h] [ebp-288h]
  TEXTMETRICW tm; // [esp+34h] [ebp-284h]
  RECT rc; // [esp+70h] [ebp-248h]
  SCROLLINFO ScrollInfo; // [esp+80h] [ebp-238h]
  RECT rcText; // [esp+9Ch] [ebp-21Ch]
  __int16 szText[260]; // [esp+ACh] [ebp-20Ch]

  this = pTreeList;
  hWnd = a2;
  hdc = hDCInit;
  _mm_storeu_si128(&rc, _mm_loadu_si128(&rect));
  hWindowDC = GetDC(pTreeList->m_hWnd);
  SelectObject(hWindowDC, this->m_Font);
  GetTextMetricsW(hWindowDC, &tm);
  ReleaseDC(this->m_hWnd, hWindowDC);
  if ( this->m_ImageList )
    GetSystemMetrics(SM_CYSMICON);
  GetWindowRect(this->m_hWndHeaderLeft, &ScrollInfo.nMax);
  if ( hWnd == this->m_hWndHeaderLeft )
  {
    ItemCount = 1;
    nCount = 1;
  }
  else
  {
    nCount = SendMessageW(this->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0);
    if ( !nCount )
    {
      hBrush = GetSysColorBrush(COLOR_WINDOW);
      FillRect(hDCInit, &rc, hBrush);
      return;
    }
    ItemCount = nCount;
  }
  pOrderArray = operator new[](4 * ItemCount);
  pItemIndex = pOrderArray;
  if ( hWnd == this->m_hWndHeaderLeft )
    *pOrderArray = NULL;
  else
    SendMessageW(this->m_hWndHeaderRight, HDM_GETORDERARRAY, ItemCount, pOrderArray);
  pRect = operator new[](16 * ItemCount);
  nIndex = 0;
  pdwFormat = operator new[](4 * ItemCount);
  iItem = 0;
  if ( nCount > 0 )
  {
    do
    {
      lprc = &pRect[nIndex];
      SendMessageW(hWnd, HDM_GETITEMRECT, pItemIndex[nIndex], &pRect[nIndex]);
      InflateRect(lprc, -2, -2);
      if ( hWnd == this->m_hWndHeaderLeft && !nIndex )
      {
        if ( LOBYTE(this->m_rcHeader.bottom) )
        {
          ScrollInfo.cbSize = 28;
          hWndScrollbar = this->m_hWndScrollBarLeftHorz;
          ScrollInfo.nTrackPos = 0;
          _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
          ScrollInfo.fMask = SIF_POS;
          GetScrollInfo(hWndScrollbar, SB_CTL, &ScrollInfo);
          Rect = pRect;
          Rect->left -= ScrollInfo.nPos;
          xxx = Rect->left + this->m_rcHeader.right;
          if ( Rect->right < xxx )
            Rect->right = xxx;
        }
      }
      pdwFormat[nIndex] = this->m_HeaderFormat;
      if ( hWnd != this->m_hWndHeaderLeft )
      {
        tm.tmExternalLeading = 4;
        SendMessageW(this->m_hWndHeaderRight, HDM_GETITEMW, pItemIndex[nIndex], &tm.tmExternalLeading);
        if ( tm.tmDigitizedAspectX & 1 )
          pdwFormat[nIndex] |= HDF_CENTER;
      }
      if ( ItemCount > nIndex && lprc->right > rc.left )
        ItemCount = nIndex;
      nItem = iItem;
      if ( lprc->left < rc.right )
        nItem = nIndex;
      ++nIndex;
      iItem = nItem;
    }
    while ( nIndex < nCount );
  }
  clrPen = GetSysColor(COLOR_3DDKSHADOW);
  hDC = hdc;
  hPen = CreatePen(PS_SOLID, 1, clrPen);
  hOldPen = SelectObject(hdc, hPen);
  hOldFont = SelectObject(hdc, this->m_Font);
  if ( ItemCount <= iItem )
  {
    lprc = &pdwFormat[ItemCount];
    nCount = &pRect[ItemCount];
    v21 = pItemIndex - pdwFormat;
    do
    {
      clrBack = GetBkColor(hDC);
      if ( hWnd == this->m_hWndHeaderLeft )
        nItemCount = ItemCount;
      else
        nItemCount = *(&lprc->left + v21) + 1;
      if ( (this->DisplayCallback)(nItemCount, hDC, &clrBack) )
      {
        ValidateRect(hWnd, nCount);
        hdc = CreateSolidBrush(clrBack);
        GetBkMode(hDC);
        tm.tmMaxCharWidth = szText;
        tm.tmExternalLeading = 2;
        v17 = lprc;
        _mm_storeu_si128(&ScrollInfo.nMax, 0i64);
        tm.tmOverhang = 260;
        SendMessageW(hWnd, HDM_GETITEMW, *(&v17->left + v21), &tm.tmExternalLeading);
        rcText.left = this->field_6C + nCount->left;
        rcText.top = this->field_70 + nCount->top;
        rcText.right = nCount->right - this->field_6C;
        rcText.bottom = nCount->bottom;
        DrawTextW(hDC, szText, -1, &ScrollInfo.nMax, lprc->left | DT_CALCRECT);
        if ( rcText.bottom - rcText.top < ScrollInfo.nTrackPos )
          rcText.top = rcText.bottom - ScrollInfo.nTrackPos;
        SetBkColor(hDC, clrBack);
        FillRect(hDC, nCount, hdc);
        DrawTextW(hDC, szText, -1, &rcText, lprc->left);
        DeleteObject(hdc);
      }
      ++nCount;
      ++ItemCount;
      lprc = (lprc + 4);
    }
    while ( ItemCount <= iItem );
  }
  SelectObject(hDC, hOldFont);
  SelectObject(hDC, hOldPen);
  DeleteObject(hPen);
  j_j__free(pRect);
  j_j__free(pItemIndex);
  j_j__free(pdwFormat);
}

//----- (0121AE40) --------------------------------------------------------
LRESULT __thiscall sub_121AE40(_DWORD *this, HWND hWnd, int a3, int a4, int a5, int a6, int a7)
{
  _DWORD *v7; // esi
  LONG v8; // eax
  bool v9; // zf
  HWND v10; // eax
  LRESULT result; // eax
  WPARAM v12; // ST08_4
  HWND v13; // eax
  LPARAM lParam; // [esp+4h] [ebp-1Ch]
  LONG v15; // [esp+8h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-14h]
  int v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ch] [ebp-4h]

  v16 = a3;
  v7 = this;
  lParam = hWnd;
  v8 = GetWindowLongW(hWnd, -12);
  v9 = *(v7 + 196) == 0;
  v19 = a4;
  v17 = a6;
  v18 = a5;
  v15 = v8;
  v20 = a7;
  if ( v9 )
  {
    v12 = v8;
    v13 = GetParent(v7[2]);
    result = SendMessageW(v13, 0x4Eu, v12, &lParam);
  }
  else
  {
    v10 = GetParent(v7[2]);
    result = sub_121E690(v7, v10, &lParam);
  }
  return result;
}

//----- (0121AEC0) --------------------------------------------------------
void __thiscall sub_121AEC0(CTreeList *this, HDC *hdc, HRGN hRgn)
{
  CTreeList *pTreeList; // ebx
  HDC hdcWindow; // edi
  HWND v5; // ST20_4
  int v6; // eax
  LONG v7; // ecx
  int v8; // edi
  int nColumnCount; // ebx
  signed int v10; // eax
  int v11; // ecx
  int v12; // eax
  _DWORD *v13; // eax
  CTreeList *v14; // edi
  WPARAM v15; // ecx
  const __m128i *v16; // ebx
  int v17; // edx
  signed int v18; // eax
  int v19; // ecx
  __m128i v20; // xmm1
  int v21; // ecx
  __m128i v22; // xmm0
  _DWORD *v23; // ecx
  int v24; // eax
  int v25; // ebx
  int v26; // ecx
  HWND v27; // ST1C_4
  _DWORD *v28; // ecx
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  LONG *v32; // eax
  signed int v33; // eax
  HBRUSH v34; // eax
  COLORREF v35; // eax
  HPEN v36; // eax
  HDC v37; // ST20_4
  HGDIOBJ v38; // eax
  void *v39; // ST24_4
  LVITEMUSERDATA2 *v40; // eax
  struct tagPOINT *v41; // eax
  int v42; // ecx
  LPPOINT v43; // ebx
  int v44; // eax
  COLORREF v45; // eax
  COLORREF v46; // eax
  COLORREF v47; // eax
  COLORREF v48; // eax
  int v49; // edx
  LONG *v50; // edx
  LONG v51; // eax
  LONG v52; // ecx
  LONG v53; // edx
  __m128i v54; // xmm0
  int v55; // eax
  HBRUSH v56; // ebx
  LONG v57; // eax
  LONG v58; // ST20_4
  int v59; // eax
  char v60; // al
  COLORREF v61; // eax
  HBRUSH v62; // eax
  HDC v63; // ST24_4
  int v64; // ebx
  int v65; // eax
  int v66; // edi
  HDC v67; // ST1C_4
  HBITMAP v68; // eax
  HDC v69; // ST24_4
  HDC v70; // ebx
  HBRUSH v71; // eax
  signed int v72; // eax
  LPPOINT v73; // edx
  int v74; // ebx
  LONG v75; // eax
  LONG v76; // ebx
  bool v77; // zf
  LONG v78; // ecx
  int i; // ST34_4
  UINT v80; // ST24_4
  int v81; // edi
  COLORREF v82; // eax
  CTreeList *v83; // ebx
  int v84; // ST10_4
  HDC v85; // edi
  int v86; // eax
  int v87; // ebx
  const WCHAR *v88; // edi
  int v89; // ST24_4
  HDC v90; // ST14_4
  HGDIOBJ v91; // edi
  LONG v92; // ecx
  LONG v93; // edx
  LONG v94; // ebx
  int v95; // eax
  HBRUSH v96; // eax
  struct tagPOINT *v97; // eax
  LONG v98; // eax
  int v99; // ecx
  void *v100; // ebx
  int v101; // ecx
  LONG v102; // eax
  HBRUSH v103; // eax
  HDC v104; // ST20_4
  HGDIOBJ v105; // edi
  void *v106; // ST24_4
  void (__stdcall *v107)(HDC, HGDIOBJ); // edi
  HBRUSH v108; // eax
  char *v109; // [esp-4h] [ebp-364h]
  LONG *v110; // [esp+10h] [ebp-350h]
  int v111; // [esp+18h] [ebp-348h]
  HGDIOBJ v112; // [esp+1Ch] [ebp-344h]
  HGDIOBJ v113; // [esp+20h] [ebp-340h]
  HGDIOBJ h; // [esp+24h] [ebp-33Ch]
  int v115; // [esp+28h] [ebp-338h]
  int v116; // [esp+2Ch] [ebp-334h]
  int v117; // [esp+30h] [ebp-330h]
  HDC hdcDst; // [esp+34h] [ebp-32Ch]
  HGDIOBJ ho; // [esp+38h] [ebp-328h]
  HBRUSH hbr; // [esp+3Ch] [ebp-324h]
  HGDIOBJ v121; // [esp+40h] [ebp-320h]
  int dy; // [esp+44h] [ebp-31Ch]
  int v123; // [esp+48h] [ebp-318h]
  unsigned int v124; // [esp+4Ch] [ebp-314h]
  int j; // [esp+50h] [ebp-310h]
  void *v126; // [esp+54h] [ebp-30Ch]
  int v127; // [esp+58h] [ebp-308h]
  CTreeList *pTreeListCtrl; // [esp+5Ch] [ebp-304h]
  int v129; // [esp+60h] [ebp-300h]
  void *v130; // [esp+64h] [ebp-2FCh]
  LONG v131; // [esp+68h] [ebp-2F8h]
  void *v132; // [esp+6Ch] [ebp-2F4h]
  int v133; // [esp+70h] [ebp-2F0h]
  LPPOINT lpPoints; // [esp+74h] [ebp-2ECh]
  RECT rc; // [esp+78h] [ebp-2E8h]
  struct tagRECT v136; // [esp+88h] [ebp-2D8h]
  struct tagTEXTMETRICW tm; // [esp+98h] [ebp-2C8h]
  int x[4]; // [esp+D4h] [ebp-28Ch]
  struct tagRECT rcDst; // [esp+E4h] [ebp-27Ch]
  RECT rcSrc1; // [esp+F4h] [ebp-26Ch]
  struct tagRECT v141; // [esp+104h] [ebp-25Ch]
  RECT v142; // [esp+114h] [ebp-24Ch]
  RECT rect; // [esp+124h] [ebp-23Ch]
  RECT rcSrc2; // [esp+134h] [ebp-22Ch]
  RECT v145; // [esp+144h] [ebp-21Ch]
  char v146; // [esp+154h] [ebp-20Ch]

  pTreeList = this;
  pTreeListCtrl = this;
  hdcWindow = GetDC(this->m_hWnd);
  SelectObject(hdcWindow, pTreeList->m_Font);
  GetTextMetricsW(hdcWindow, &tm);
  v5 = pTreeList->m_hWnd;
  v131 = tm.tmHeight;
  ReleaseDC(v5, hdcWindow);
  if ( pTreeList->m_ImageList )
  {
    v6 = GetSystemMetrics(SM_CYSMICON);
    v7 = v131;
    if ( v131 < v6 )
      v7 = v6;
  }
  else
  {
    v7 = v131;
  }
  v127 = v7 + pTreeList->m_Height;
  GetWindowRect(pTreeList->m_hWndHeaderLeft, &tm.tmFirstChar);
  v8 = *&tm.tmCharSet - *&tm.tmDefaultChar;
  nColumnCount = SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0) + 1;
  v10 = hdc[3] - v8;
  v133 = nColumnCount;
  v129 = v10 / v127;
  v11 = (hdc[5] - v8) / v127;
  v12 = v10 / v127;
  v116 = (hdc[5] - v8) / v127;
  if ( v12 < 0 )
    v12 = 0;
  v129 = v12;
  if ( !nColumnCount || v12 > v11 )
  {
    v108 = GetSysColorBrush(5);
    FillRect(*hdc, (hdc + 2), v108);
    return;
  }
  v13 = operator new[](4 * nColumnCount);
  v14 = pTreeListCtrl;
  v15 = v133 - 1;
  v132 = v13;
  v16 = (v13 + 1);
  *v13 = 0;
  SendMessageW(v14->m_hWndHeaderRight, HDM_GETORDERARRAY, v15, (v13 + 1));
  v17 = v133;
  v18 = 1;
  v19 = v133 - 1;
  if ( v133 > 1 )
  {
    if ( v19 >= 8 )
    {
      v20 = _mm_load_si128(&xmmword_12B4280);
      v121 = (v19 % 8);
      v21 = v133 - v19 % 8;
      do
      {
        v22 = _mm_loadu_si128(v16);
        v18 += 8;
        v16 += 2;
        _mm_storeu_si128(&v16[-2], _mm_add_epi32(v22, v20));
        _mm_storeu_si128(&v16[-1], _mm_add_epi32(_mm_loadu_si128(v16 - 1), v20));
      }
      while ( v18 < v21 );
    }
    if ( v18 < v133 )
    {
      v23 = v132;
      do
        ++v23[v18++];
      while ( v18 < v17 );
    }
  }
  v126 = operator new[](16 * v17);
  v130 = operator new[](4 * v133);
  v24 = v133;
  v25 = 0;
  v117 = v133;
  for ( j = 0; v25 < v133; j = v31 )
  {
    lpPoints = (v126 + 16 * v25);
    v26 = *(v132 + v25);
    v109 = v126 + 16 * v25;
    if ( v26 )
    {
      SendMessageW(v14->m_hWndHeaderRight, HDM_GETITEMRECT, v26 - 1, v109);
      MapWindowPoints(v14->m_hWndHeaderRight, v14->m_hWnd, lpPoints, 2u);
    }
    else
    {
      SendMessageW(v14->m_hWndHeaderLeft, HDM_GETITEMRECT, 0, v109);
      MapWindowPoints(v14->m_hWndHeaderLeft, v14->m_hWnd, lpPoints, 2u);
    }
    if ( !v25 )
    {
      if ( LOBYTE(v14->m_rcHeader.bottom) )
      {
        tm.tmOverhang = 28;
        v27 = v14->m_hWndScrollBarLeftHorz;
        *&tm.tmCharSet = 0;
        _mm_storeu_si128(&tm.tmDigitizedAspectY, 0i64);
        tm.tmDigitizedAspectX = 4;
        GetScrollInfo(v27, 2, &tm.tmOverhang);
        v28 = v126;
        *v28 -= *&tm.tmItalic;
        v29 = *v28 + v14->m_rcHeader.right;
        if ( v28[2] < v29 )
          v28[2] = v29;
      }
    }
    *(v130 + v25) = v14->m_HeaderFormat;
    if ( v25 )
    {
      tm.tmExternalLeading = 4;
      SendMessageW(v14->m_hWndHeaderRight, 0x120Bu, *(v132 + v25) - 1, &tm.tmExternalLeading);
      if ( tm.tmDigitizedAspectX & 1 )
        *(v130 + v25) |= 2u;
    }
    v30 = v117;
    if ( v117 > v25 )
    {
      if ( lpPoints[1].x > hdc[2] )
        v30 = v25;
      v117 = v30;
    }
    v31 = j;
    v24 = v133;
    if ( lpPoints->x < hdc[4] )
      v31 = v25;
    ++v25;
  }
  v32 = (v126 + 16 * v24 - 8);
  v110 = v32;
  v33 = *v32;
  if ( hdc[4] > v33 )
  {
    _mm_storeu_si128(&tm.tmFirstChar, _mm_loadu_si128((hdc + 2)));
    *&tm.tmFirstChar = v33;
    v34 = GetSysColorBrush(5);
    FillRect(*hdc, &tm.tmFirstChar, v34);
  }
  v35 = GetSysColor(21);
  v36 = CreatePen(0, 1, v35);
  v37 = *hdc;
  v121 = v36;
  v38 = SelectObject(v37, v36);
  v39 = v14->m_Font;
  v113 = v38;
  v112 = SelectObject(*hdc, v39);
  v123 = GetSystemMetrics(49);
  dy = GetSystemMetrics(50);
  v40 = sub_121F6C0(v14);
  v41 = sub_121DA70(v40, v129);
  v42 = v129;
  v43 = v41;
  lpPoints = v41;
  v131 = v127 * v129;
  v44 = v127;
  while ( v43 )
  {
    if ( v43[4].x & 1 )
    {
      if ( GetFocus() == v14->m_hWnd )
      {
        v45 = GetSysColor(14);
        SetTextColor(*hdc, v45);
        v46 = GetSysColor(13);
      }
      else
      {
        v47 = GetSysColor(8);
        SetTextColor(*hdc, v47);
        v46 = GetSysColor(10);
      }
    }
    else
    {
      v48 = GetSysColor(8);
      SetTextColor(*hdc, v48);
      v46 = GetSysColor(5);
    }
    SetBkColor(*hdc, v46);
    SetBkMode(*hdc, 2);
    v49 = v117;
    v133 = v117;
    if ( v117 <= j )
    {
      while ( 1 )
      {
        v50 = (v126 + 16 * v49);
        v51 = *v50;
        v52 = v131 + v50[3];
        v53 = v50[2];
        rect.left = v51;
        rect.top = v52;
        rect.bottom = v52 + v127;
        rect.right = v53;
        if ( v133 > 0 && v53 <= v14->m_rcHeader.left || !RectInRegion(hRgn, &rect) )
          goto LABEL_93;
        v54 = _mm_loadu_si128(&rect);
        v55 = v133;
        v56 = 0;
        ho = 0;
        _mm_storeu_si128(&rcSrc2, v54);
        if ( v55 )
        {
          if ( v55 > 0 && rect.left < v14->m_rcHeader.left )
          {
            rcSrc2.left = v14->m_rcHeader.left;
            goto LABEL_51;
          }
        }
        else
        {
          v57 = v14->m_rcHeader.left;
          if ( rect.right >= v57 )
          {
            rcSrc2.right = v57 - 1;
LABEL_51:
            v56 = CreateRectRgnIndirect(&rcSrc2);
            ho = v56;
            SelectClipRgn(*hdc, v56);
            goto LABEL_56;
          }
        }
        SelectClipRgn(*hdc, 0);
LABEL_56:
        SelectObject(*hdc, v14->m_Font);
        v58 = lpPoints[4].x;
        v59 = *lpPoints->y;
        v115 = 4 * v133;
        v60 = (*(v59 + 16))(lpPoints, *hdc, *(v132 + v133), v58, &rect);
        v14 = pTreeListCtrl;
        if ( !v60 )
        {
          v61 = GetBkColor(*hdc);
          v62 = CreateSolidBrush(v61);
          v63 = *hdc;
          hbr = v62;
          GetBkMode(v63);
          v64 = v14->field_6C + rect.left;
          x[1] = rect.top + v14->field_74;
          v65 = rect.right - v14->field_6C;
          x[0] = v64;
          x[2] = v65;
          x[3] = rect.bottom;
          v66 = pTreeListCtrl;
          if ( !*(v132 + v115) )
          {
            v67 = *hdc;
            rc.left = 0;
            rc.top = 0;
            rc.right = v65 - v64;
            rc.bottom = rect.bottom - rect.top;
            v68 = CreateCompatibleBitmap(v67, v65 - v64, rect.bottom - rect.top);
            v69 = *hdc;
            h = v68;
            v70 = CreateCompatibleDC(v69);
            hdcDst = v70;
            SelectObject(v70, h);
            v71 = GetSysColorBrush(5);
            FillRect(v70, &rc, v71);
            v72 = sub_121A8E0(lpPoints);
            v73 = lpPoints;
            v74 = *(v66 + 120) * v72 + rc.left;
            v75 = lpPoints[4].x;
            rc.left = v74;
            v124 = v75;
            if ( v75 & 0x40 )
            {
              v136.top = rc.top + (rc.bottom - rc.top - dy) / 2;
              v136.bottom = dy + v136.top;
              v136.right = v74 + v123;
              v136.left = v74;
              sub_121BC20(v66, *(v66 + 8), hdcDst, ~(v124 >> 4) & 1, &v136);
              v74 = rc.left;
              v73 = lpPoints;
            }
            v76 = v123 + v74;
            v77 = *(v66 + 56) == 0;
            rc.left = v76;
            if ( v77 )
            {
              v85 = hdcDst;
            }
            else
            {
              v78 = v73->y;
              v124 = 0;
              i = (*(*v78 + 12))(v73, &v124);
              v80 = v124 << 8;
              v81 = rc.top + (rc.bottom - rc.top - dy) / 2;
              v82 = GetSysColor(5);
              v83 = pTreeListCtrl;
              v84 = v81;
              v85 = hdcDst;
              ImageList_DrawEx(pTreeListCtrl->m_ImageList, i, hdcDst, rc.left, v84, v123, dy, v82, 0xFFFFFFFF, v80);
              v86 = v123 + v83->field_6C;
              v76 = v86 + rc.left;
              rc.left += v86;
            }
            BitBlt(*hdc, x[0], rect.top, v76, x[3], v85, 0, 0, 0xCC0020u);
            x[0] += rc.left;
            DeleteObject(h);
            DeleteDC(v85);
          }
          v87 = v115;
          v111 = 260;
          v88 = (*(*lpPoints->y + 8))(lpPoints, *(v132 + v115), &v146, &v111);
          DrawTextW(*hdc, v88, -1, x, *(v130 + v87));
          v89 = *(v130 + v87) | 0x400;
          v90 = *hdc;
          _mm_storeu_si128(&v141, _mm_loadu_si128(x));
          DrawTextW(v90, v88, -1, &v141, v89);
          if ( *(v130 + v87) & 2 )
            OffsetRect(&v141, x[2] - v141.right, 0);
          v91 = ho;
          if ( ho )
          {
            SelectClipRgn(*hdc, 0);
            DeleteObject(v91);
            v92 = v141.right;
            v93 = v141.left;
            if ( v141.right > rcSrc2.right )
              v92 = rcSrc2.right;
            v94 = rcSrc2.left;
            v141.right = v92;
            if ( v141.left < rcSrc2.left )
              v93 = rcSrc2.left;
            v141.left = v93;
          }
          else
          {
            v94 = rcSrc2.left;
            v92 = v141.right;
            v93 = v141.left;
          }
          v142.top = rcSrc2.top;
          v145.top = rcSrc2.top;
          rcDst.top = rcSrc2.top;
          v142.left = v94;
          rcDst.bottom = v141.top;
          v142.bottom = rcSrc2.bottom;
          v145.right = rcSrc2.right;
          v145.bottom = rcSrc2.bottom;
          rcSrc1.bottom = rcSrc2.bottom;
          v14 = pTreeListCtrl;
          v142.right = v93;
          v145.left = v92;
          rcDst.left = v93;
          rcDst.right = v92;
          rcSrc1.left = v93;
          rcSrc1.top = v141.bottom;
          rcSrc1.right = v92;
          if ( !v133 )
          {
            v142.right = rcSrc2.left + pTreeListCtrl->field_6C;
            v95 = pTreeListCtrl->m_rcHeader.left - 1;
            *&tm.tmDefaultChar = rcSrc2.top;
            *&tm.tmFirstChar = v95;
            *&tm.tmItalic = v95;
            *&tm.tmCharSet = rcSrc2.bottom;
            Polyline(*hdc, &tm.tmFirstChar, 2);
          }
          IntersectRect(&rcDst, &rcDst, &rcSrc2);
          IntersectRect(&rcSrc1, &rcSrc1, &rcSrc2);
          IntersectRect(&v142, &v142, &rcSrc2);
          IntersectRect(&v145, &v145, &rcSrc2);
          v56 = hbr;
          if ( rcDst.left < rcDst.right && rcDst.top < rcDst.bottom )
            FillRect(*hdc, &rcDst, hbr);
          if ( rcSrc1.left < rcSrc1.right && rcSrc1.top < rcSrc1.bottom )
            FillRect(*hdc, &rcSrc1, v56);
          if ( v133 )
            v96 = v56;
          else
            v96 = GetSysColorBrush(5);
          if ( v142.left < v142.right && v142.top < v142.bottom )
            FillRect(*hdc, &v142, v96);
          if ( v145.left < v145.right && v145.top < v145.bottom )
            FillRect(*hdc, &v145, v56);
LABEL_92:
          DeleteObject(v56);
          goto LABEL_93;
        }
        if ( v56 )
          goto LABEL_92;
LABEL_93:
        v49 = v133 + 1;
        v133 = v49;
        if ( v49 > j )
        {
          v43 = lpPoints;
          break;
        }
      }
    }
    if ( v43[2].y && (v43[4].x >> 4) & 1 )
    {
      v43 = v43[2].y;
LABEL_104:
      lpPoints = v43;
      goto LABEL_105;
    }
    v97 = v43[2].x;
    if ( !v97 )
    {
      v98 = v43[1].x;
      if ( v98 )
      {
        while ( !*(v98 + 16) )
        {
          v98 = *(v98 + 8);
          if ( !v98 )
            goto LABEL_103;
        }
        v43 = *(v98 + 16);
      }
      else
      {
LABEL_103:
        v43 = 0;
      }
      goto LABEL_104;
    }
    v43 = v43[2].x;
    lpPoints = v97;
LABEL_105:
    v44 = v127;
    v42 = v129 + 1;
    v131 += v127;
    v129 = v42;
    if ( v42 > v116 )
    {
      v99 = v116;
      goto LABEL_109;
    }
  }
  v99 = v42 - 1;
LABEL_109:
  v100 = v126;
  v101 = v44 * (v99 + 1);
  if ( hdc[5] <= v101 + *(v126 + 3) - 1 )
  {
    v107 = SelectObject;
  }
  else
  {
    v102 = v101 + *(v126 + 3);
    _mm_storeu_si128(&v145, _mm_loadu_si128((hdc + 2)));
    v145.top = v102;
    v145.right = *v110;
    v103 = GetSysColorBrush(5);
    FillRect(*hdc, &v145, v103);
    v104 = *hdc;
    v145.left = v14->m_rcHeader.left - 1;
    v145.right = v145.left;
    v105 = SelectObject(v104, v121);
    Polyline(*hdc, &v145, 2);
    v106 = v105;
    v107 = SelectObject;
    SelectObject(*hdc, v106);
  }
  v107(*hdc, v112);
  v107(*hdc, v113);
  DeleteObject(v121);
  j_j__free(v100);
  j_j__free(v132);
  j_j__free(v130);
}
// 12B4280: using guessed type __int128 xmmword_12B4280;

//----- (0121BC20) --------------------------------------------------------
HGDIOBJ __thiscall sub_121BC20(CTreeList *this, int a2, HDC hdc, char a4, LPRECT lprc)
{
  int v5; // eax
  CTreeList *pTreeList; // esi
  COLORREF v7; // eax
  void *v8; // ecx
  HGDIOBJ v10; // eax
  LONG left; // esi
  LONG top; // edx
  LONG right; // ecx
  LONG v14; // edi
  LONG v15; // ebx
  LONG v16; // esi
  LONG v17; // eax
  LONG v18; // ecx
  LONG v19; // eax
  HDC v20; // esi
  POINT v21[2]; // [esp+Ch] [ebp-58h]
  POINT v22[2]; // [esp+1Ch] [ebp-48h]
  LPRECT v23; // [esp+2Ch] [ebp-38h]
  HDC v24; // [esp+30h] [ebp-34h]
  HGDIOBJ h; // [esp+34h] [ebp-30h]
  POINT apt[5]; // [esp+38h] [ebp-2Ch]

  v5 = sbInited1;
  v24 = hdc;
  pTreeList = this;
  v23 = lprc;
  if ( !(sbInited1 & 1) )
  {
    sbInited1 |= 1u;
    v7 = GetSysColor(COLOR_3DDKSHADOW);
    ghPenDkShadow = CreatePen(0, 1, v7);
    v5 = sbInited1;
  }
  if ( !(v5 & 2) )
  {
    sbInited1 = v5 | 2;
    ghPenBlack = GetStockObject(BLACK_PEN);
  }
  v8 = pTreeList->m_ThemeData;
  if ( v8 )
    return DrawThemeBackground(v8, hdc, 2, (a4 == 0) + 1, lprc, 0);
  InflateRect(lprc, -4, -4);
  v10 = SelectObject(hdc, ghPenDkShadow);
  left = lprc->left;
  top = lprc->top;
  right = lprc->right;
  h = v10;
  apt[2].y = lprc->bottom;
  apt[3].y = apt[2].y;
  apt[0].x = left;
  apt[0].y = top;
  apt[1].x = right;
  apt[1].y = top;
  apt[2].x = right;
  apt[3].x = left;
  apt[4].x = left;
  apt[4].y = top;
  Polyline(hdc, apt, 5);
  SelectObject(hdc, ghPenBlack);
  v14 = lprc->left;
  v15 = v23->bottom;
  v16 = v23->top;
  v22[0].x = lprc->left + 2;
  v17 = v23->right;
  v22[0].y = (v15 - v16) / 2 + v16;
  v22[1].y = (v15 - v16) / 2 + v16;
  v22[1].x = v17 - 1;
  v18 = (v17 - v14) / 2 + v14;
  v19 = v16 + 2;
  v21[0].x = v18;
  v20 = v24;
  v21[0].y = v19;
  v21[1].y = v15 - 1;
  v21[1].x = v18;
  Polyline(v24, v22, 2);
  if ( a4 )
    Polyline(v20, v21, 2);
  return SelectObject(v20, h);
}
// 12E4DA8: using guessed type int sbInited1;

//----- (0121BDA0) --------------------------------------------------------
char __thiscall sub_121BDA0(CTreeList *this, char a2)
{
  char result; // al

  result = a2;
  LOBYTE(this->m_posLast.y) = a2;
  return result;
}

//----- (0121BDB0) --------------------------------------------------------
void __thiscall CTreeList::RestoreScrollbars(CTreeList *this, char yyy)
{
  CTreeList *pTreeList; // edi
  HWND hWndScrollBar; // esi
  SCROLLINFO ScrollInfo; // [esp+4h] [ebp-20h]

  pTreeList = this;
  LOBYTE(this->m_rcHeader.bottom) = yyy;
  if ( !yyy )
  {
    // set the scrollbar size and reposition
    CTreeList::AutoSize(this, this->m_hWndScrollBarLeftHorz, 0, 1);
    hWndScrollBar = pTreeList->m_hWndScrollBarLeftHorz;
    ScrollInfo.cbSize = 28;
    _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
    ScrollInfo.nTrackPos = 0;
    ScrollInfo.fMask = SB_THUMBPOSITION;
    ScrollInfo.nPos = 0;
    SetScrollInfo(hWndScrollBar, SB_CTL, &ScrollInfo, TRUE);
    CTreeList::Scroll(pTreeList, hWndScrollBar, 0);
  }
}

//----- (0121BE30) --------------------------------------------------------
UINT __thiscall CTreeList::EnsureVisible(HWND *this, signed int a2)
{
  CTreeList *v2; // esi
  UINT result; // eax
  HWND v4; // ST04_4
  int v5; // edx
  UINT v6; // ecx
  HWND v7; // ST00_4
  SCROLLINFO v8; // [esp+4h] [ebp-3Ch]
  struct tagSCROLLINFO v9; // [esp+20h] [ebp-20h]

  v2 = this;
  result = GetWindowLongW(this[7], -16) >> 28;
  if ( result & 1 )
  {
    v9.cbSize = 28;
    v4 = v2->m_hWndScrollBarRightRight;
    v9.nTrackPos = 0;
    _mm_storeu_si128(&v9.nMin, 0i64);
    v9.fMask = 7;
    result = GetScrollInfo(v4, 2, &v9);
    v5 = v9.nPos;
    if ( a2 >= v9.nPos )
    {
      result = v9.nPage + v9.nPos;
      if ( a2 < (v9.nPage + v9.nPos) )
        return result;
      v6 = a2 - v9.nPage - v9.nPos + 1;
    }
    else
    {
      v6 = a2 - v9.nPos;
    }
    if ( v6 )
    {
      v8.cbSize = 28;
      v8.nTrackPos = 0;
      _mm_storeu_si128(&v8.nMin, 0i64);
      v8.nPos = v5 + v6;
      v7 = v2->m_hWndScrollBarRightRight;
      v8.fMask = 4;
      SetScrollInfo(v7, 2, &v8, 1);
      result = CTreeList::VScroll(v2, 0);
    }
  }
  return result;
}

//----- (0121BF00) --------------------------------------------------------
char __thiscall sub_121BF00(int this, _DWORD *a2, char a3)
{
  CTreeList *v3; // esi
  int v4; // edi
  char v6; // bl
  int v7; // eax
  int v8; // eax
  CTreeList *v9; // eax
  int v10; // [esp+8h] [ebp-4h]
  signed int a2a; // [esp+14h] [ebp+8h]

  v3 = a2;
  v4 = this;
  if ( !a2 )
    return 1;
  v6 = (a2[8] >> 4) & 1;
  if ( a3 != v6 )
  {
    if ( a3 )
    {
      if ( !sub_121AE40(this, *(this + 8), 2001, 0, a2, 0, 0) )
      {
        a2[8] |= 0x30u;
        v7 = sub_121CA60(a2);
LABEL_9:
        a2a = v7;
        if ( v7 )
        {
          v10 = sub_121BFE0(v4, v3);
          CTreeList::RedrawItems(v4, v10, v10);
          v8 = a2a;
          if ( !a3 )
            v8 = -a2a;
          sub_121D830(v4, v10 + 1, v8);
          if ( !a3 )
          {
            v9 = *(v4 + 124);
            if ( v9 )
            {
              while ( v9 != v3 )
              {
                v9 = v9->m_hWnd;
                if ( !v9 )
                  return v6;
              }
              sub_121F090(v4, v3);
            }
          }
        }
        return v6;
      }
    }
    else if ( !sub_121AE40(this, *(this + 8), 2002, 0, a2, 0, 0) )
    {
      v7 = sub_121CA60(a2);
      a2[8] &= 0xFFFFFFEF;
      goto LABEL_9;
    }
  }
  return v6;
}

//----- (0121BFE0) --------------------------------------------------------
signed int __thiscall sub_121BFE0(CTreeList **this, CTreeList *a2)
{
  CTreeList *v3; // ecx
  int v4; // esi
  HWND v5; // eax

  if ( !a2 )
    return -1;
  v3 = this[21];
  v4 = 0;
  if ( !v3 )
    return -1;
  while ( v3 != a2 )
  {
    ++v4;
    if ( v3->m_hWndHeaderRight && (v3->m_hWndScrollBarLeftHorz >> 4) & 1 )
    {
      v3 = v3->m_hWndHeaderRight;
    }
    else if ( v3->m_hWndTooltipOfLeftHeader )
    {
      v3 = v3->m_hWndTooltipOfLeftHeader;
    }
    else
    {
      v5 = v3->m_hWnd;
      if ( !v5 )
        return -1;
      while ( !*(v5 + 4) )
      {
        v5 = *(v5 + 2);
        if ( !v5 )
          return -1;
      }
      v3 = *(v5 + 4);
    }
    if ( !v3 )
      return -1;
  }
  return v4;
}

//----- (0121C060) --------------------------------------------------------
HANDLE __cdecl GetTreeListCtrl(HWND hWnd)
{
  return GetPropW(hWnd, gAtomTreeListProperty);
}

//----- (0121C080) --------------------------------------------------------
int __thiscall sub_121C080(_DWORD *this, int a2)
{
  _DWORD *v2; // edi
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  HWND v6; // ST10_4
  HDC v7; // eax
  void *v8; // ST10_4
  HGDIOBJ v9; // eax
  _DWORD *v10; // esi
  int v11; // ecx
  const WCHAR *v12; // eax
  int v13; // ST10_4
  HDC v14; // ST00_4
  int v15; // edx
  int v16; // eax
  signed int i; // ecx
  int v18; // eax
  HDC v19; // esi
  int v21; // [esp+Ch] [ebp-230h]
  int v22; // [esp+10h] [ebp-22Ch]
  HDC hdc; // [esp+14h] [ebp-228h]
  HGDIOBJ h; // [esp+18h] [ebp-224h]
  int v25; // [esp+1Ch] [ebp-220h]
  struct tagRECT rc; // [esp+20h] [ebp-21Ch]
  char v27; // [esp+30h] [ebp-20Ch]

  v2 = this;
  v25 = a2;
  v3 = 0;
  v4 = this[24];
  v5 = GetSystemMetrics(49);
  v6 = v2[2];
  v22 = v5;
  v7 = GetDC(v6);
  v8 = v2[12];
  hdc = v7;
  v9 = SelectObject(v7, v8);
  v10 = v2[21];
  h = v9;
  while ( v10 )
  {
    v11 = v10[1];
    v21 = 260;
    v12 = (*(*v11 + 8))(v10, v25, &v27, &v21);
    v13 = v2[40] | 0x400;
    v14 = hdc;
    _mm_storeu_si128(&rc, _mm_load_si128(&xmmword_12B4290));
    DrawTextW(v14, v12, -1, &rc, v13);
    v15 = rc.right - rc.left;
    if ( !v25 )
    {
      v16 = v10[2];
      for ( i = -1; v16; ++i )
        v16 = *(v16 + 8);
      v15 += v22 + i * v2[30];
      if ( v2[14] )
        v15 += v22 + v2[27];
    }
    if ( v15 > v3 )
      v3 = v15;
    if ( v10[5] && (v10[8] >> 4) & 1 )
    {
      v10 = v10[5];
    }
    else if ( v10[4] )
    {
      v10 = v10[4];
    }
    else
    {
      v18 = v10[2];
      if ( v18 )
      {
        while ( !*(v18 + 16) )
        {
          v18 = *(v18 + 8);
          if ( !v18 )
            goto LABEL_17;
        }
        v10 = *(v18 + 16);
      }
      else
      {
LABEL_17:
        v10 = 0;
      }
    }
  }
  v19 = hdc;
  ReleaseDC(v2[2], hdc);
  SelectObject(v19, h);
  return v3 + 2 * v2[27];
}
// 12B4290: using guessed type __int128 xmmword_12B4290;

//----- (0121C210) --------------------------------------------------------
char __thiscall CTreeList::GetSubItemRect(CTreeList *pTreeList, int a2, int iItem, char a4, char a5, int a6, RECT *lprc)
{
  CTreeList *this; // ebx
  HWND hWndScrollBarLeftHorz; // ST04_4
  int right; // eax
  HWND hWndScrollBarRightRight; // ST04_4
  HDC hDC; // esi
  int nIconHeight; // eax
  LONG nHeight; // ecx
  int nHeaderHeight; // esi
  LONG v15; // ecx
  int v16; // eax
  signed int i; // ecx
  LONG v18; // eax
  LONG nTextHeight; // [esp+Ch] [ebp-7Ch]
  TEXTMETRICW tm; // [esp+10h] [ebp-78h]
  SCROLLINFO ScrollInfo; // [esp+4Ch] [ebp-3Ch]
  SCROLLINFO ScrollInfo1; // [esp+68h] [ebp-20h]

  this = pTreeList;
  if ( iItem )
  {
    SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMRECT, iItem - 1, lprc);
    MapWindowPoints(this->m_hWndHeaderRight, this->m_hWnd, lprc, 2u);
  }
  else
  {
    SendMessageW(pTreeList->m_hWndHeaderLeft, HDM_GETITEMRECT, 0, lprc);
    MapWindowPoints(this->m_hWndHeaderLeft, this->m_hWnd, lprc, 2u);
    ScrollInfo1.cbSize = 28;
    hWndScrollBarLeftHorz = this->m_hWndScrollBarLeftHorz;
    ScrollInfo1.nTrackPos = 0;
    _mm_storeu_si128(&ScrollInfo1.nMin, 0i64);
    ScrollInfo1.fMask = SIF_POS;
    GetScrollInfo(hWndScrollBarLeftHorz, SB_CTL, &ScrollInfo1);
    right = ScrollInfo1.nPos;
    lprc->left -= ScrollInfo1.nPos;
    lprc->right -= right;
  }
  ScrollInfo.cbSize = 28;
  hWndScrollBarRightRight = this->m_hWndScrollBarRightRight;
  ScrollInfo.nTrackPos = 0;
  _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
  ScrollInfo.fMask = SIF_POS;
  GetScrollInfo(hWndScrollBarRightRight, SB_CTL, &ScrollInfo);
  hDC = GetDC(this->m_hWnd);
  SelectObject(hDC, this->m_Font);
  GetTextMetricsW(hDC, &tm);
  nTextHeight = tm.tmHeight;
  ReleaseDC(this->m_hWnd, hDC);
  if ( this->m_ImageList )
  {
    nIconHeight = GetSystemMetrics(SM_CYSMICON);
    nHeight = nTextHeight;
    if ( nTextHeight < nIconHeight )
      nHeight = nIconHeight;
  }
  else
  {
    nHeight = nTextHeight;
  }
  nHeaderHeight = nHeight + this->m_Height;
  GetWindowRect(this->m_hWndHeaderLeft, &ScrollInfo1.nMax);
  v15 = ScrollInfo1.nTrackPos + nHeaderHeight * (a2 - ScrollInfo.nPos) - ScrollInfo1.nPage;
  lprc->top = v15;
  lprc->bottom = v15 + nHeaderHeight;
  if ( a5 )
  {
    lprc->top = v15 + this->field_74;
    lprc->left += this->field_6C;
    lprc->right -= this->field_6C;
    if ( !iItem )
    {
      if ( a6 )
      {
        v16 = *(a6 + 8);
        for ( i = -1; v16; ++i )
          v16 = *(v16 + 8);
        lprc->left += i * this->field_78;
      }
      lprc->left += GetSystemMetrics(SM_CXSMICON);
      if ( this->m_ImageList )
        lprc->left += GetSystemMetrics(SM_CXSMICON);
      lprc->left += this->field_6C;
    }
  }
  if ( a4 )
  {
    GetClientRect(this->m_hWnd, &ScrollInfo1.nMax);
    v18 = this->m_rcHeader.left;
    if ( iItem )
    {
      if ( lprc->left < v18 )
        lprc->left = v18;
    }
    else if ( lprc->right > v18 )
    {
      lprc->right = v18;
    }
    if ( lprc->left < 0 )
      lprc->left = 0;
    if ( lprc->right > ScrollInfo1.nPos )
      lprc->right = ScrollInfo1.nPos;
    if ( lprc->left > lprc->right )
      lprc->right = lprc->left;
  }
  return 1;
}

//----- (0121C420) --------------------------------------------------------
int __thiscall sub_121C420(_DWORD *this)
{
  return this[1];
}

//----- (0121C430) --------------------------------------------------------
BOOL __thiscall CTreeList::GetItemWidth(CTreeList *this, WPARAM nItem, RECT *lprc)
{
  CTreeList *pTreeList; // edi
  LRESULT v4; // eax
  LRESULT v5; // ebx
  HWND hWndHeader; // [esp-10h] [ebp-1Ch]
  HWND hWnd; // [esp-Ch] [ebp-18h]
  RECT *rc; // [esp-8h] [ebp-14h]

  pTreeList = this;
  if ( nItem )
  {
    v4 = SendMessageW(this->m_hWndHeaderRight, HDM_GETITEMRECT, nItem - 1, lprc);
    rc = lprc;
    hWnd = pTreeList->m_hWnd;
    hWndHeader = pTreeList->m_hWndHeaderRight;
  }
  else
  {
    v4 = SendMessageW(this->m_hWndHeaderLeft, HDM_GETITEMRECT, 0, lprc);
    rc = lprc;
    hWnd = pTreeList->m_hWnd;
    hWndHeader = pTreeList->m_hWndHeaderLeft;
  }
  v5 = v4;
  MapWindowPoints(hWndHeader, hWnd, rc, 2u);
  return v5 != 0;
}

//----- (0121C490) --------------------------------------------------------
int __thiscall CTreeList::GetTooltipRightHeader(CTreeList *this)
{
  return this->m_hWndTooltipOfRightHeader;
}

//----- (0121C4A0) --------------------------------------------------------
int __thiscall sub_121C4A0(_DWORD *this, _DWORD *a2, int *a3)
{
  int v3; // edi
  _DWORD *v4; // ebx
  signed int v5; // esi
  LONG v6; // eax
  WPARAM v7; // ST08_4
  HWND v8; // eax
  LPARAM lParam; // [esp+Ch] [ebp-40h]
  LONG v11; // [esp+10h] [ebp-3Ch]
  int v12; // [esp+14h] [ebp-38h]
  int v13; // [esp+18h] [ebp-34h]
  int v14; // [esp+1Ch] [ebp-30h]
  int v15; // [esp+24h] [ebp-28h]
  int v16; // [esp+34h] [ebp-18h]
  int v17; // [esp+38h] [ebp-14h]

  v3 = *a2;
  v4 = this;
  v5 = sub_121BFE0(*a2, a2);
  lParam = 0;
  memset(&v11, 0, 0x3Cu);
  lParam = *(v3 + 8);
  v6 = GetWindowLongW(*(v3 + 8), -12);
  v17 = v4[1];
  v7 = v6;
  v11 = v6;
  v12 = -177;
  v13 = 10;
  v14 = v5;
  v8 = GetParent(*(v3 + 8));
  SendMessageW(v8, 0x4Eu, v7, &lParam);
  *a3 = v15 >> 8;
  return v16;
}

//----- (0121C530) --------------------------------------------------------
int __stdcall sub_121C530(int a1, int a2)
{
  return 0;
}

//----- (0121C540) --------------------------------------------------------
int __thiscall CTreeList::GetImageIcon(CTreeList *this)
{
  return this->m_ImageList;
}

//----- (0121C550) --------------------------------------------------------
char __thiscall CTreeList::GetItemRect(CTreeList *pTreeList, int nPos, RECT *lprc)
{
  CTreeList *this; // ebx
  HWND hWndSB; // ST00_4
  HDC hDC; // esi
  LONG nTextHeight; // edi
  int nIconHeight; // eax
  int nHeaderHeight; // esi
  LONG top; // eax
  TEXTMETRICW tm; // [esp+4h] [ebp-6Ch]
  RECT Rect; // [esp+40h] [ebp-30h]
  SCROLLINFO ScrollInfo; // [esp+50h] [ebp-20h]

  this = pTreeList;
  ScrollInfo.cbSize = 28;
  hWndSB = pTreeList->m_hWndScrollBarRightRight;
  _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
  ScrollInfo.nTrackPos = 0;
  ScrollInfo.fMask = SIF_POS;
  GetScrollInfo(hWndSB, SB_CTL, &ScrollInfo);
  hDC = GetDC(this->m_hWnd);
  SelectObject(hDC, this->m_Font);
  GetTextMetricsW(hDC, &tm);
  nTextHeight = tm.tmHeight;
  ReleaseDC(this->m_hWnd, hDC);
  if ( this->m_ImageList )
  {
    nIconHeight = GetSystemMetrics(SM_CYSMICON);
    if ( nTextHeight < nIconHeight )
      nTextHeight = nIconHeight;
  }
  nHeaderHeight = nTextHeight + this->m_Height;
  GetClientRect(this->m_hWnd, lprc);
  GetWindowRect(this->m_hWndHeaderLeft, &Rect);
  top = nHeaderHeight * (nPos - ScrollInfo.nPos) - Rect.top + Rect.bottom;
  lprc->top = top;
  lprc->bottom = nHeaderHeight + top;
  return 1;
}

//----- (0121C630) --------------------------------------------------------
int __thiscall CTreeList::GetItemCount(CTreeList *this)
{
  LVITEMUSERDATA2 *v2; // esi
  int i; // edi
  int v4; // eax

  if ( !((this->field_60 >> 4) & 1) )
    return 0;
  v2 = this->m_RowInfo;
  for ( i = this->m_bValid; v2; i += v4 )
  {
    v4 = sub_121CA60(v2);
    v2 = v2->isHandlesList;
  }
  return i;
}

//----- (0121C670) --------------------------------------------------------
int __thiscall CTreeList::GetScrollInfo(CTreeList *this, SCROLLINFO *pScrollInfo1, SCROLLINFO *pScrollInfo2)
{
  CTreeList *pListCtrl; // edi
  LRESULT nColumnCountRight; // esi
  LRESULT idx1; // edi
  LRESULT idx2; // esi
  HDC hDC; // esi
  LONG v8; // edi
  int v9; // eax
  int v10; // esi
  int v11; // edi
  int v12; // ebx
  LVITEMUSERDATA2 *i; // esi
  int v14; // eax
  UINT v15; // ecx
  int v16; // eax
  int result; // eax
  int v18; // [esp+Ch] [ebp-A0h]
  int v19; // [esp+14h] [ebp-98h]
  int cxxx; // [esp+1Ch] [ebp-90h]
  int cyHScroll; // [esp+20h] [ebp-8Ch]
  int cxVScroll; // [esp+24h] [ebp-88h]
  CTreeList *pTreeList; // [esp+28h] [ebp-84h]
  TEXTMETRICW tm; // [esp+2Ch] [ebp-80h]
  RECT rcItem2; // [esp+68h] [ebp-44h]
  RECT rcItem1; // [esp+78h] [ebp-34h]
  RECT Rect; // [esp+88h] [ebp-24h]
  RECT rcClient; // [esp+98h] [ebp-14h]

  pListCtrl = this;
  pTreeList = this;
  GetClientRect(this->m_hWnd, &rcClient);
  cxVScroll = GetSystemMetrics(SM_CXVSCROLL);
  cyHScroll = GetSystemMetrics(SM_CYHSCROLL);
  nColumnCountRight = SendMessageW(pListCtrl->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0);
  idx1 = SendMessageW(pListCtrl->m_hWndHeaderRight, HDM_ORDERTOINDEX, 0, 0);
  idx2 = SendMessageW(pTreeList->m_hWndHeaderRight, HDM_ORDERTOINDEX, nColumnCountRight - 1, 0);
  SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMRECT, idx1, &rcItem1);
  SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMRECT, idx2, &rcItem2);
  cxxx = rcItem2.right - rcItem1.left;
  v19 = rcClient.right - pTreeList->m_rcHeader.left - rcClient.left;
  hDC = GetDC(pTreeList->m_hWnd);
  SelectObject(hDC, pTreeList->m_Font);
  GetTextMetricsW(hDC, &tm);
  v8 = tm.tmHeight;
  ReleaseDC(pTreeList->m_hWnd, hDC);
  if ( pTreeList->m_ImageList )
  {
    v9 = GetSystemMetrics(SM_CYSMICON);
    if ( v8 < v9 )
      v8 = v9;
  }
  v10 = v8 + pTreeList->m_Height;
  v18 = v8 + pTreeList->m_Height;
  GetWindowRect(pTreeList->m_hWndHeaderLeft, &Rect);
  v11 = rcClient.bottom + Rect.top - Rect.bottom - rcClient.top;
  if ( (pTreeList->field_60 >> 4) & 1 )
  {
    v12 = pTreeList->m_bValid;
    for ( i = pTreeList->m_RowInfo; i; v12 += v14 )
    {
      v14 = sub_121CA60(i);
      i = i->isHandlesList;
    }
    v10 = v18;
  }
  else
  {
    v12 = 0;
  }
  v15 = v19;
  v16 = v10 * (v12 + 1) - 1;
  if ( cxxx <= v19 )
  {
    if ( v16 > v11 )
    {
      v15 = v19 - cxVScroll;
      if ( cxxx > v19 - cxVScroll )
        goto LABEL_16;
    }
  }
  else
  {
    if ( v16 > v11 )
    {
      v15 = v19 - cxVScroll;
LABEL_16:
      v11 -= cyHScroll;
      goto LABEL_17;
    }
    v11 -= cyHScroll;
    if ( v16 > v11 )
      v15 = v19 - cxVScroll;
  }
LABEL_17:
  pScrollInfo1->nMax = v16 / v10;
  pScrollInfo1->nPage = v11 / v10;
  pScrollInfo1->cbSize = 28;
  result = cxxx - 1;
  pScrollInfo1->fMask = 3;
  pScrollInfo1->nMin = 0;
  pScrollInfo2->nPage = v15;
  pScrollInfo2->cbSize = 28;
  pScrollInfo2->fMask = 3;
  pScrollInfo2->nMin = 0;
  pScrollInfo2->nMax = cxxx - 1;
  return result;
}

//----- (0121C8A0) --------------------------------------------------------
signed int __thiscall CTreeList::FindFirstSortableColumn(CTreeList *this, bool *Sortable)
{
  CTreeList *TreeList; // edi
  int count; // eax
  signed int nItemFound; // edx
  signed int bDescending; // ebx
  int item; // esi
  bool hasDescendImage; // zf
  HDITEMW lParam; // [esp+Ch] [ebp-34h]
  int number; // [esp+38h] [ebp-8h]
  int i; // [esp+3Ch] [ebp-4h]

  TreeList = this;
  count = SendMessageW(this->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0);
  nItemFound = -1;
  bDescending = 0;
  number = count + 1;
  item = 0;
  for ( i = -1; item < number; ++item )
  {
    // HDI_STATE|HDI_FORMAT
    lParam.mask = 0x24;
    if ( item )
      SendMessageW(TreeList->m_hWndHeaderRight, HDM_GETITEMW, item - 1, &lParam);
    else
      SendMessageW(TreeList->m_hWndHeaderLeft, HDM_GETITEMW, 0, &lParam);
    if ( gbTreeListSortable )
    {
      // No Sortable Column
      if ( !(lParam.fmt & 0x600) )              // HDF_SORTDOWN|HDF_SORTUP|HDF_LEFT
        goto __next;
      nItemFound = item;
      i = item;
      bDescending = (lParam.fmt & HDF_SORTDOWN) != 0 ? -1 : 1;
    }
    else
    {
      if ( !(lParam.fmt & HDF_IMAGE) )
      {
__next:
        nItemFound = i;
        continue;
      }
      hasDescendImage = lParam.iImage == TreeList->m_DescendImage;
      nItemFound = item;
      i = item;
      bDescending = 2 * !hasDescendImage - 1;
    }
  }
  if ( Sortable )
    *Sortable = bDescending < 0;
  return nItemFound;
}
// 12EA8F8: using guessed type char gbTreeListSortable;

//----- (0121C980) --------------------------------------------------------
LPWSTR __thiscall sub_121C980(CListViewData *this, CTreeList **ppTreeList, int nColumn, TCHAR *szText, int *cbText)
{
  CTreeList *pTreeList; // ebx
  CListViewData *v6; // edi
  int v7; // esi
  UINT IdFrom; // eax
  WPARAM wIdFrom; // ST08_4
  HWND hWndParent; // eax
  NMHDR nmhdr; // [esp+Ch] [ebp-40h]
  LVITEMW item; // [esp+18h] [ebp-34h]

  pTreeList = *ppTreeList;
  v6 = this;
  v7 = sub_121BFE0(*ppTreeList, ppTreeList);
  nmhdr.hwndFrom = 0;
  memset(&nmhdr.idFrom, 0, 0x3Cu);
  nmhdr.hwndFrom = pTreeList->m_hWnd;
  IdFrom = GetWindowLongW(pTreeList->m_hWnd, GWL_ID);
  item.iSubItem = nColumn;
  item.lParam = v6->field_4;
  item.cchTextMax = *cbText;
  wIdFrom = IdFrom;
  nmhdr.idFrom = IdFrom;
  nmhdr.code = LVN_GETDISPINFOW;
  item.mask = 1;
  item.iItem = v7;
  item.pszText = szText;
  hWndParent = GetParent(pTreeList->m_hWnd);
  SendMessageW(hWndParent, WM_NOTIFY, wIdFrom, &nmhdr);
  return item.pszText;
}

//----- (0121CA20) --------------------------------------------------------
const wchar_t *__stdcall sub_121CA20(int a1, int a2, int a3, int a4)
{
  return L"not implemented";
}
// 12B4164: using guessed type wchar_t aNotImplemented[16];

//----- (0121CA30) --------------------------------------------------------
const wchar_t *CTreeList::GetTitle()
{
  return L"treeview";
}
// 12B4190: using guessed type wchar_t aTreeview[9];

//----- (0121CA40) --------------------------------------------------------
int __thiscall CTreeList::GetTooltipTreeList(CTreeList *this)
{
  return this->m_hWndTooltipOfTreeList;
}

//----- (0121CA50) --------------------------------------------------------
int __thiscall sub_121CA50(void *this)
{
  return *this;
}

//----- (0121CA60) --------------------------------------------------------
int __thiscall sub_121CA60(_DWORD *this)
{
  _DWORD *v2; // esi
  int i; // edi
  int v4; // eax

  if ( !((this[8] >> 4) & 1) )
    return 0;
  v2 = this[5];
  for ( i = this[7]; v2; i += v4 )
  {
    v4 = sub_121CA60(v2);
    v2 = v2[4];
  }
  return i;
}

//----- (0121CAA0) --------------------------------------------------------
LRESULT __thiscall CTreeList::HeaderCtrlWndProc(CTreeList *this, HWND hWnd, UINT msg, WPARAM wParam, NMTTDISPINFOW *lParam)
{
  HWND v5; // ebx
  NMTTDISPINFOW *v6; // esi
  CTreeList *pTreeList; // edi
  UINT v8; // edx
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ecx
  HWND hWnd3; // eax
  UINT v11; // edx
  WPARAM nHeaderItem; // eax
  LONG left; // eax
  WPARAM iItem; // edx
  LONG v16; // eax
  WPARAM nItem; // ecx
  LONG nHeaderHeight; // eax
  int Format; // ebx
  HDC hdc; // eax
  HGDIOBJ v21; // eax
  HDC hdc1; // ebx
  void *hObject; // esi
  WCHAR *v24; // ecx
  HDC hDC; // esi
  RECT v26; // [esp-10h] [ebp-9Ch]
  HWND v27; // [esp-Ch] [ebp-98h]
  POINT *v28; // [esp-8h] [ebp-94h]
  HWND m_hWnd; // [esp-4h] [ebp-90h]
  HDITEMW hdItem; // [esp+Ch] [ebp-80h]
  __int64 v31; // [esp+30h] [ebp-5Ch]
  HWND hWndHeader; // [esp+38h] [ebp-54h]
  CTreeList *TreeList; // [esp+3Ch] [ebp-50h]
  LPCWSTR lpszText; // [esp+40h] [ebp-4Ch]
  NMTTDISPINFOW *lParam3; // [esp+44h] [ebp-48h]
  HWND hWndTooltip; // [esp+48h] [ebp-44h]
  RECT rc; // [esp+4Ch] [ebp-40h]
  LPARAM lParam1; // [esp+5Ch] [ebp-30h]
  UINT uMsg; // [esp+60h] [ebp-2Ch]
  WPARAM v40; // [esp+64h] [ebp-28h]
  RECT rcItem; // [esp+68h] [ebp-24h]
  tagRECT rcHeaderItem; // [esp+78h] [ebp-14h]

  v5 = hWnd;
  v6 = lParam;
  pTreeList = this;
  hWndHeader = hWnd;
  TreeList = this;
  lParam3 = lParam;
  if ( hWnd == this->m_hWndHeaderLeft )
    hWndTooltip = this->m_hWndTooltipOfLeftHeader;
  else
    hWndTooltip = this->m_hWndTooltipOfRightHeader;
  v8 = msg;
  SendMessageW = ::SendMessageW;
  if ( msg - 0x200 <= 0xD )
  {
    rcHeaderItem.right = lParam;
    rcHeaderItem.bottom = SHIWORD(lParam);
    m_hWnd = 1;
    v40 = wParam;
    v28 = &rcHeaderItem.right;
    v27 = pTreeList->m_hWnd;
    lParam1 = hWnd;
    uMsg = msg;
    rcItem.left = lParam;
    *&rcItem.top = 0i64;
    rcItem.bottom = 0;
    MapWindowPoints(hWnd, v27, &rcHeaderItem.right, 1u);
    sub_121F8F0(pTreeList, hWndTooltip, &rcHeaderItem.right);
    ::SendMessageW(hWndTooltip, RB_SETPARENT, 0, &lParam1);
    SendMessageW = ::SendMessageW;
    v8 = msg;
  }
  if ( v8 == WM_PAINT )
  {
    if ( pTreeList->DisplayCallback )
    {
      hDC = GetDC(hWnd);
      GetUpdateRect(hWnd, &rcItem, 0);
      _mm_storeu_si128(&v26, _mm_loadu_si128(&rcItem));
      CTreeList::DrawHeaderItem(pTreeList, hWnd, hDC, v26);
      ReleaseDC(hWnd, hDC);
      v6 = lParam3;
    }
    goto __default;
  }
  if ( v8 != WM_NOTIFY )
    goto __default;
  hWnd3 = hWndTooltip;
  if ( lParam->hdr.hwndFrom != hWndTooltip )
    goto __default;
  v11 = lParam->hdr.code;
  // #define TTN_FIRST               (0U-520U)       // tooltips
  // #define TTN_LAST                (0U-549U)
  if ( v11 == -530 )                            // TTN_GETDISPINFOW
  {
    hdItem.mask = 7;
    v31 = 0i64;
    _mm_storeu_si128(&hdItem.cxy, 0i64);
    lpszText = lParam->szText;
    hdItem.pszText = lParam->szText;
    iItem = pTreeList->m_nHeaderItem;
    hdItem.cchTextMax = 80;
    _mm_storeu_si128(&hdItem.fmt, 0i64);
    if ( iItem == -1 )
      goto LABEL_30;
    if ( hWnd3 != pTreeList->m_hWndTooltipOfLeftHeader )
      --iItem;
    if ( !SendMessageW(hWnd, HDM_GETITEMW, iItem, &hdItem) )
      goto LABEL_30;
    v16 = ::SendMessageW(hWnd, HDM_GETORDERARRAY|0x4, 0, 0);// HDM_GETBITMAPMARGIN
    nItem = pTreeList->m_nHeaderItem;
    rcHeaderItem.bottom = v16;
    if ( hWndTooltip != pTreeList->m_hWndTooltipOfLeftHeader )
      --nItem;
    ::SendMessageW(hWnd, HDM_GETITEMRECT, nItem, &rcItem);
    if ( rcItem.left >= 0 )
    {
      rc.left = 0;
      rc.top = 0;
      rcItem.right -= 2 * rcHeaderItem.bottom;
      rc.right = GetSystemMetrics(SM_CXVIRTUALSCREEN);
      nHeaderHeight = CTreeList::GetHeaderHeight(pTreeList);
      Format = pTreeList->m_HeaderFormat;
      m_hWnd = pTreeList->m_hWnd;
      rc.bottom = nHeaderHeight;
      hdc = GetDC(m_hWnd);
      m_hWnd = pTreeList->m_Font;
      rcHeaderItem.bottom = hdc;
      v21 = SelectObject(hdc, m_hWnd);
      m_hWnd = (Format & ~0x4C000u | HDF_SORTUP);
      hdc1 = rcHeaderItem.bottom;
      hObject = v21;
      DrawTextW(rcHeaderItem.bottom, lpszText, -1, &rc, m_hWnd);
      SelectObject(hdc1, hObject);
      pTreeList = TreeList;
      ReleaseDC(TreeList->m_hWnd, hdc1);
      v24 = gpszTargetName;
      v6 = lParam3;
      v5 = hWndHeader;
      if ( rc.right - rc.left > rcItem.right - rcItem.left )
        v24 = lpszText;
      lParam3->lpszText = v24;
    }
    else
    {
LABEL_30:
      lParam->lpszText = gpszTargetName;
    }
    goto __default;
  }
  if ( v11 != -521 )                            // TTN_SHOW
  {
__default:
    m_hWnd = v6;
    v28 = wParam;
    v27 = msg;
    v26.left = v5;
    return CallWindowProcW(pTreeList->m_OldHeaderWndProc, v5, msg, wParam, v6);
  }
  // TTN_SHOW
  nHeaderItem = pTreeList->m_nHeaderItem;
  if ( hWndTooltip != pTreeList->m_hWndTooltipOfLeftHeader )
    --nHeaderItem;
  SendMessageW(hWnd, HDM_GETITEMRECT, nHeaderItem, &rcHeaderItem);
  MapWindowPoints(hWnd, 0, &rcHeaderItem, 2u);
  left = rcHeaderItem.bottom - rcHeaderItem.top + rcHeaderItem.left;
  rcHeaderItem.top = rcHeaderItem.bottom + rcHeaderItem.bottom - rcHeaderItem.top;
  rcHeaderItem.left = left;
  SetWindowPos(hWndTooltip, 0, left, rcHeaderItem.top, 0, 0, 0x15u);
  ::SendMessageW(hWndTooltip, WM_SETFONT, pTreeList->m_Font, 0);
  return 1;
}

//----- (0121CDB0) --------------------------------------------------------
signed int __thiscall sub_121CDB0(CTreeList *this, LONG xx, LONG yy, POINT *pt1, POINT *pt2, _DWORD *a6)
{
  CTreeList *pTreeList; // ebx
  signed int result; // eax
  int dxOffset; // edi
  WPARAM nCol; // esi
  int v10; // esi
  _DWORD *v11; // esi
  int v12; // edi
  int v13; // eax
  int v14; // edi
  int v15; // edi
  signed int nSubItem; // [esp+10h] [ebp-34h]
  int nCount; // [esp+18h] [ebp-2Ch]
  LVITEMUSERDATA2 *columncounta; // [esp+18h] [ebp-2Ch]
  int nHeight; // [esp+1Ch] [ebp-28h]
  LONG nHeighta; // [esp+1Ch] [ebp-28h]
  RECT Rect; // [esp+20h] [ebp-24h]
  RECT rcWnd; // [esp+30h] [ebp-14h]

  pTreeList = this;
  GetClientRect(this->m_hWnd, &Rect);
  if ( pt1 )
    pt1->x = -1;
  if ( pt2 )
    pt2->x = -1;
  if ( a6 )
    *a6 = 0;
  if ( xx < Rect.left )
    return 4;
  if ( xx >= Rect.right )
    return 8;
  if ( yy < Rect.top )
    return 1;
  if ( yy >= Rect.bottom )
    return 2;
  dxOffset = 0;
  nSubItem = -1;
  nCol = 0;
  nCount = SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0) + 1;
  if ( nCount > 0 )
  {
    while ( 1 )
    {
      CTreeList::GetItemWidth(pTreeList, nCol, &rcWnd);
      if ( xx >= rcWnd.left && xx < rcWnd.right )
        break;
      if ( ++nCol >= nCount )
        goto LABEL_22;
    }
    nSubItem = nCol;
    dxOffset = xx - rcWnd.left;
    if ( pt2 )
      pt2->x = nCol;
  }
LABEL_22:
  GetWindowRect(pTreeList->m_hWndHeaderLeft, &rcWnd);
  nHeight = rcWnd.bottom - rcWnd.top;
  if ( yy < rcWnd.bottom - rcWnd.top )
    return 0x200;
  columncounta = sub_121F6C0(pTreeList);
  if ( !columncounta )
    return 16;
  v10 = CTreeList::GetVertScrollPosition(pTreeList);
  nHeighta = v10 + (yy - nHeight) / CTreeList::GetHeaderHeight(pTreeList);
  v11 = sub_121DA70(columncounta, nHeighta - v10);
  if ( !v11 )
    return 16;
  if ( pt1 )
    pt1->x = nHeighta;
  if ( a6 )
    *a6 = v11;
  if ( nSubItem )
    return 128;
  v12 = dxOffset - pTreeList->field_78 * sub_121A8E0(v11);
  if ( v12 < 0 )
    return 256;
  v13 = GetSystemMetrics(SM_CXSMICON);
  v14 = v12 - v13;
  if ( v14 < 0 )
  {
    result = 256;
    if ( (v11[8] >> 6) & 1 )
      result = 64;
    return result;
  }
  if ( !pTreeList->m_ImageList )
    return 128;
  v15 = v14 - v13;
  result = 32;
  if ( v15 >= 0 )
    return 128;
  return result;
}

//----- (0121D000) --------------------------------------------------------
void __thiscall CTreeList::Scroll(CTreeList *this, HWND hWnd, int delta)
{
  CTreeList *pTreeList; // esi
  HWND hWndScrollBar; // eax
  HWND *WndHeader; // ecx
  POINT *point; // ebx
  void (__stdcall *GetScrollInfo)(HWND, int, LPSCROLLINFO); // eax
  RECT rect; // rax
  int dyy; // eax
  LONG right; // ecx
  RECT *lprc; // eax
  int cxvscroll; // eax
  LONG dxx; // ecx
  HWND *pWndHeader; // [esp+Ch] [ebp-5Ch]
  POINT *point1; // [esp+10h] [ebp-58h]
  int nScrollPos; // [esp+14h] [ebp-54h]
  LONG left2; // [esp+14h] [ebp-54h]
  SCROLLINFO ScrollInfo; // [esp+18h] [ebp-50h]
  RECT rwLeftHeader; // [esp+34h] [ebp-34h]
  RECT rcClient; // [esp+44h] [ebp-24h]
  RECT rcScroll; // [esp+54h] [ebp-14h]

  pTreeList = this;
  hWndScrollBar = this->m_hWndScrollBarLeftHorz;
  WndHeader = &this->m_hWndHeaderLeft;
  if ( hWnd != hWndScrollBar )
    WndHeader = &pTreeList->m_hWndHeaderRight;
  pWndHeader = WndHeader;
  point = &pTreeList->m_Point;
  if ( hWnd != hWndScrollBar )
    point = (&pTreeList->m_Point + 4);
  point1 = point;
  // IsMaximzed()
  if ( (GetWindowLongW(hWnd, GWL_STYLE) >> 28) & 1 )
  {
    GetScrollInfo = ::GetScrollInfo;
    ScrollInfo.cbSize = 28;
    _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
    ScrollInfo.nTrackPos = 0;
    ScrollInfo.fMask = SIF_POS;
    if ( delta )
    {
      ::GetScrollInfo(hWnd, SB_CTL, &ScrollInfo);
      ScrollInfo.nPos += delta;
      SetScrollInfo(hWnd, SB_CTL, &ScrollInfo, TRUE);
      GetScrollInfo = ::GetScrollInfo;
    }
    GetScrollInfo(hWnd, SB_CTL, &ScrollInfo);
    nScrollPos = ScrollInfo.nPos;
    if ( ScrollInfo.nPos != point->x )
    {
      GetClientRect(pTreeList->m_hWnd, &rcClient);
      rect.bottom = point->x - nScrollPos;
      point1->x = nScrollPos;
      rect.left = pTreeList->m_rcHeader.left;
      if ( hWnd == pTreeList->m_hWndScrollBarLeftHorz )
      {
        rcClient.right = rect.left - 1;
        rect.left = rcClient.left;
      }
      else
      {
        rcClient.left = pTreeList->m_rcHeader.left;
      }
      if ( rect.bottom >= 0 )
      {
        rcScroll.left = rect.left;
        GetWindowRect(pTreeList->m_hWndHeaderLeft, &rwLeftHeader);
        rcScroll.top = rwLeftHeader.bottom - rwLeftHeader.top;
        rcScroll.right = rcClient.right - rect.bottom;
        rcScroll.bottom = rcClient.bottom - GetSystemMetrics(SM_CYHSCROLL);
        if ( hWnd == pTreeList->m_hWndScrollBarRightBottom
          && (GetWindowLongW(pTreeList->m_hWndScrollBarRightRight, GWL_STYLE) >> 28) & 1 )
        {
          cxvscroll = GetSystemMetrics(SM_CXVSCROLL);
          dxx = rcScroll.right - cxvscroll;
          rcScroll.right -= cxvscroll;
        }
        else
        {
          dxx = rcScroll.right;
        }
        if ( dxx > rcScroll.left )
        {
          ScrollWindowEx(pTreeList->m_hWnd, rect.bottom, 0, &rcScroll, NULL, NULL, NULL, 2u);
          rect.top = rcScroll.left;
          if ( rect.bottom <= rcScroll.right - rcScroll.left )
            goto __SetWindowPos;
          rcScroll.left = rcScroll.right;
          rcScroll.right = rect.top + rect.bottom;
          lprc = &rcScroll;
__RedrawWindow:
          InvalidateRect(pTreeList->m_hWnd, lprc, FALSE);
__SetWindowPos:
          if ( hWnd == pTreeList->m_hWndScrollBarRightBottom )
          {
            GetWindowRect(*pWndHeader, &rcScroll);
            MapWindowPoints(NULL, pTreeList->m_hWnd, &rcScroll, 2u);
            SetWindowPos(
              *pWndHeader,
              HWND_TOP,
              rect.bottom + rcScroll.left,
              rcScroll.top,
              rcScroll.right - (rect.bottom + rcScroll.left),
              rcScroll.bottom - rcScroll.top,
              SWP_NOZORDER);
          }
          return;
        }
      }
      else
      {
        rcScroll.left = rect.left - rect.bottom;
        GetWindowRect(pTreeList->m_hWndHeaderLeft, &rwLeftHeader);
        rcScroll.top = rwLeftHeader.bottom - rwLeftHeader.top;
        rcScroll.right = rcClient.right;
        rcScroll.bottom = rcClient.bottom - GetSystemMetrics(SM_CYHSCROLL);
        if ( hWnd == pTreeList->m_hWndScrollBarRightBottom
          // IsMaximized()  WS_MAXIMIZE
          && (GetWindowLongW(pTreeList->m_hWndScrollBarRightRight, GWL_STYLE) >> 28) & 1 )
        {
          dyy = GetSystemMetrics(SM_CXVSCROLL);
          right = rcScroll.right - dyy;
          rcScroll.right -= dyy;
        }
        else
        {
          right = rcScroll.right;
        }
        if ( right > rcScroll.left )
        {
          ScrollWindowEx(pTreeList->m_hWnd, rect.bottom, 0, &rcScroll, 0, 0, 0, SW_INVALIDATE);
          left2 = rcScroll.left;
          if ( -rect.bottom <= rcScroll.right - rcScroll.left )
            goto __SetWindowPos;
          rcScroll.left = rcScroll.right + rect.bottom;
          rcScroll.right = left2;
          lprc = &rcScroll;
          goto __RedrawWindow;
        }
      }
      lprc = &rcClient;
      goto __RedrawWindow;
    }
  }
}

//----- (0121D2A0) --------------------------------------------------------
void __thiscall sub_121D2A0(_DWORD *this, HWND hwnd, int a3)
{
  CTreeList *v3; // edi
  SCROLLINFO v4; // [esp+0h] [ebp-20h]

  _mm_storeu_si128(&v4.nMin, 0i64);
  v4.nPos = a3;
  v3 = this;
  v4.cbSize = 28;
  v4.nTrackPos = 0;
  v4.fMask = SIF_POS;
  SetScrollInfo(hwnd, SB_CTL, &v4, 1);
  CTreeList::Scroll(v3, hwnd, 0);
}

//----- (0121D310) --------------------------------------------------------
void __thiscall sub_121D310(void *this, int a2, int a3)
{
  int v3; // esi
  HWND *i; // ebx
  int v5; // edi
  int v6; // ST04_4
  int v7; // eax
  bool v8; // zf
  signed int v9; // eax
  LPARAM lParam; // [esp+8h] [ebp-2Ch]
  int width; // [esp+Ch] [ebp-28h]
  int v12; // [esp+10h] [ebp-24h]
  int v13; // [esp+1Ch] [ebp-18h]

  v3 = 0;
  for ( i = this; v3 < a3; ++v3 )
  {
    v5 = a2 + 12 * v3;
    lParam = 7;
    v6 = *(v5 + 4);
    v12 = *v5;
    v7 = MulDiv(v6, gLogPixelsX, 96);
    v8 = *(v5 + 8) == 0;
    width = v7;
    v9 = 0x4000;
    if ( !v8 )
      v9 = 16385;
    v13 = v9;
    if ( v3 )
    {
      SendMessageW(i[5], 0x120Au, v3 - 1, &lParam);
    }
    else
    {
      SendMessageW(i[3], 0x120Au, 0, &lParam);
      CTreeList::SetHeaderWidth(i, width);
    }
  }
}

//----- (0121D3B0) --------------------------------------------------------
char __thiscall CTreeList::Init(CTreeList *pTreeList)
{
  CTreeList *pTreeListCtrl; // ebx
  HWND hListCtrl; // esi
  const WCHAR *szThemeClass; // eax
  HWND hWndHeaderLeft; // eax
  LONG OldHeaderWndProc; // eax
  HINSTANCE hInsta; // ST28_4
  HWND hWndHeader2; // eax
  HWND v8; // eax
  HINSTANCE hinst; // ST28_4
  HWND v10; // eax
  HINSTANCE hhinst; // ST28_4
  HWND v12; // eax
  HINSTANCE hInst; // ST28_4
  HINSTANCE hInstn; // esi
  HWND hToolTips; // eax
  LONG hWndTooltip; // eax
  HWND hWndTree; // ST20_4
  HWND hToolTipsOfHeadder; // eax
  HWND hHeaderRight; // ST2C_4
  HGDIOBJ hDefaultGuiFont; // eax
  HCURSOR v21; // eax
  HWND hListTree; // ST24_4
  INITCOMMONCONTROLSEX picce; // [esp+Ch] [ebp-20h]
  HINSTANCE hInstance; // [esp+14h] [ebp-18h]
  RECT Rect; // [esp+18h] [ebp-14h]

  pTreeListCtrl = pTreeList;
  hInstance = GetModuleHandle(NULL);
  GetClientRect(pTreeListCtrl->m_hWnd, &Rect);
  SetPropW(pTreeListCtrl->m_hWnd, gAtomTreeListProperty, pTreeListCtrl);
  hListCtrl = pTreeListCtrl->m_hWnd;
  if ( pTreeListCtrl->m_ThemeData )
    CloseThemeData(pTreeListCtrl->m_ThemeData);
  pTreeListCtrl->m_ThemeData = NULL;
  if ( *IsThemeActive && IsThemeActive() )
  {
    szThemeClass = (pTreeListCtrl->vtptr->GetThemeName)(pTreeListCtrl);
    pTreeListCtrl->m_ThemeData = OpenThemeData(hListCtrl, szThemeClass);
  }
  hWndHeaderLeft = CreateWindowExW(
                     0,
                     L"SysHeader32",
                     gpszTargetName,
                     0x44000082u,               // WS_CHILD|WS_CLIPSIBLINGS|HDS_FULLDRAG|HDS_BUTTONS
                     0,
                     0,
                     0,
                     0,
                     pTreeListCtrl->m_hWnd,
                     IDW_HEADERCTRL_LEFT,
                     hInstance,
                     NULL);
  pTreeListCtrl->m_hWndHeaderLeft = hWndHeaderLeft;
  SetPropW(hWndHeaderLeft, gAtomTreeListProperty, pTreeListCtrl);
  OldHeaderWndProc = SetWindowLongW(pTreeListCtrl->m_hWndHeaderLeft, GWL_WNDPROC, TreeListHeaderWndProc);
  hInsta = hInstance;
  pTreeListCtrl->m_OldHeaderWndProc = OldHeaderWndProc;
  hWndHeader2 = CreateWindowExW(
                  0,
                  L"SysHeader32",
                  gpszTargetName,
                  // WS_CHILD|WS_CLIPSIBLINGS|HDS_FULLDRAG|HDS_BUTTONS
                  0x440000C2u,
                  0,
                  0,
                  0,
                  0,
                  pTreeListCtrl->m_hWnd,
                  IDW_HEADERCTRL_RIGHT,
                  hInsta,
                  NULL);
  pTreeListCtrl->m_hWndHeaderRight = hWndHeader2;
  SetPropW(hWndHeader2, gAtomTreeListProperty, pTreeListCtrl);
  SetWindowLongW(pTreeListCtrl->m_hWndHeaderRight, GWL_WNDPROC, TreeListHeaderWndProc);
  v8 = CreateWindowExW(
         0,
         L"ScrollBar",
         gpszTargetName,
         // WS_CHILD|WS_CLIPSIBLINGS|SBS_BOTTOMALIGN|SBS_VERT
         0x44000005u,
         0,
         0,
         0,
         0,
         pTreeListCtrl->m_hWnd,
         IDW_SCROLLBAR_RIGHT_RIGHT,
         hInstance,
         NULL);
  hinst = hInstance;
  pTreeListCtrl->m_hWndScrollBarRightRight = v8;
  v10 = CreateWindowExW(
          0,
          L"ScrollBar",
          gpszTargetName,
          // WS_CHILD|WS_CLIPSIBLINGS|SBS_BOTTOMALIGN
          0x44000004u,
          0,
          0,
          0,
          0,
          pTreeListCtrl->m_hWnd,
          IDW_SCROLLBAR2,
          hinst,
          NULL);
  hhinst = hInstance;
  pTreeListCtrl->m_hWndScrollBarLeftHorz = v10;
  v12 = CreateWindowExW(
          0,
          L"ScrollBar",
          gpszTargetName,
          // WS_CHILD|WS_CLIPSIBLINGS|SBS_BOTTOMALIGN
          0x44000004u,
          0,
          0,
          0,
          0,
          pTreeListCtrl->m_hWnd,
          IDW_SCROLLBAR_RIGHT_BOTTOM,
          hhinst,
          NULL);
  hInst = hInstance;
  pTreeListCtrl->m_hWndScrollBarRightBottom = v12;
  pTreeListCtrl->m_hWndStatic = CreateWindowExW(
                                  0,
                                  L"Static",
                                  gpszTargetName,
                                  // WS_CHILD|WS_CLIPSIBLINGS
                                  0x44000000u,
                                  0,
                                  0,
                                  0,
                                  0,
                                  pTreeListCtrl->m_hWnd,
                                  1110,
                                  hInst,
                                  NULL);
  picce.dwSize = 8;
  picce.dwICC = ICC_BAR_CLASSES;
  InitCommonControlsEx(&picce);
  hInstn = hInstance;
  hToolTips = CTreeList::CreateTooltip(hInstance, pTreeListCtrl->m_hWnd);
  pTreeListCtrl->m_hWndTooltipOfTreeList = hToolTips;
  SetPropW(hToolTips, gAtomTreeListProperty, pTreeListCtrl);
  hWndTooltip = SetWindowLongW(pTreeListCtrl->m_hWndTooltipOfTreeList, GWL_WNDPROC, TreeListTooltipWndProc);
  hWndTree = pTreeListCtrl->m_hWnd;
  pTreeListCtrl->m_OldTooltipWndProc = hWndTooltip;
  SetTimer(hWndTree, TIMERID_AUTOREFRESHREBAR, 500u, 0);
  hToolTipsOfHeadder = CTreeList::CreateTooltip(hInstn, pTreeListCtrl->m_hWndHeaderLeft);
  hHeaderRight = pTreeListCtrl->m_hWndHeaderRight;
  pTreeListCtrl->m_hWndTooltipOfLeftHeader = hToolTipsOfHeadder;
  pTreeListCtrl->m_hWndTooltipOfRightHeader = CTreeList::CreateTooltip(hInstn, hHeaderRight);
  hDefaultGuiFont = GetStockObject(DEFAULT_GUI_FONT);
  SendMessageW(pTreeListCtrl->m_hWnd, WM_SETFONT, hDefaultGuiFont, 0);
  v21 = LoadCursorW(hInstn, L"SPLITTER_CURSOR");
  hListTree = pTreeListCtrl->m_hWnd;
  pTreeListCtrl->m_hSplitterCursor = v21;
  pTreeListCtrl->field_60 = 16;
  InvalidateRect(hListTree, NULL, TRUE);
  return 1;
}

//----- (0121D640) --------------------------------------------------------
CTreeData *__thiscall sub_121D640(void *this, CTreeList *pTreeList, CTreeListData *pTreeListData, BOOL fFlags, int uID)
{
  _DWORD *v5; // ebx
  CTreeData *pObject; // eax
  CTreeData *v7; // esi
  CTreeData **v8; // eax
  CTreeData *result; // eax
  int (__cdecl *v10)(CTreeListData *, int, int, _DWORD); // edx
  CTreeData *v11; // edi
  CTreeList *v12; // ecx
  CTreeList *v13; // eax
  int v14; // eax
  CTreeData **v15; // [esp+8h] [ebp-4h]
  CTreeList *pTreeLista; // [esp+14h] [ebp+8h]

  v5 = this;
  pObject = operator new(0x28u);
  v7 = pObject;
  if ( pObject )
  {
    pObject->m_TreeList = pTreeList;
    pObject->m_TreeListData = pTreeListData;
    pObject->field_8 = v5;
    pObject->field_14 = 0;
    pObject->field_18 = 0;
    pObject->field_1C = 0;
    pObject->field_20 = 0;
    pObject->field_24 = 0;
  }
  else
  {
    v7 = 0;
  }
  v5[8] |= 0x40u;
  v8 = (v5 + 5);
  ++v5[7];
  v15 = (v5 + 5);
  if ( !v5[5] )
  {
    v5[6] = v7;
    *v8 = v7;
    result = v7;
    v7->field_10 = 0;
    v7->field_C = 0;
    return result;
  }
  v10 = fFlags;
  if ( fFlags )
  {
    v11 = *v8;
    v12 = 0;
    pTreeLista = 0;
    do
    {
      if ( v10 == 1 )
      {
        v13 = v12;
        v12 = (v12 + 1);
        pTreeLista = v12;
        if ( v13 == uID )
          goto LABEL_10;
      }
      else
      {
        if ( v10(pTreeListData, v11->m_TreeListData, uID, 0) < 0 )
        {
LABEL_10:
          *v15 = v7;
          v7->field_C = v11->field_C;
          result = v7;
          v7->field_10 = v11;
          v11->field_C = v7;
          return result;
        }
        v12 = pTreeLista;
        v10 = fFlags;
      }
      v14 = &v11->field_10;
      v11 = v11->field_10;
      v15 = v14;
    }
    while ( v11 );
  }
  *(v5[6] + 16) = v7;
  v7->field_C = v5[6];
  result = v7;
  v7->field_10 = 0;
  v5[6] = v7;
  return result;
}

//----- (0121D750) --------------------------------------------------------
char __thiscall sub_121D750(void *this, int a2, int a3)
{
  int v3; // eax
  HWND *v4; // edi
  int v5; // ST04_4
  int v6; // eax
  bool v7; // zf
  signed int v8; // eax
  LPARAM lParam; // [esp+8h] [ebp-2Ch]
  int width; // [esp+Ch] [ebp-28h]
  int v12; // [esp+10h] [ebp-24h]
  int v13; // [esp+1Ch] [ebp-18h]

  v3 = *a2;
  v4 = this;
  v5 = *(a2 + 4);
  lParam = 7;
  v12 = v3;
  v6 = MulDiv(v5, gLogPixelsX, 96);
  v7 = *(a2 + 8) == 0;
  width = v6;
  v8 = 0x4000;
  if ( !v7 )
    v8 = 16385;
  v13 = v8;
  if ( a3 )
  {
    SendMessageW(v4[5], 0x120Au, a3 - 1, &lParam);
  }
  else
  {
    SendMessageW(v4[3], 0x120Au, 0, &lParam);
    CTreeList::SetHeaderWidth(v4, width);
  }
  return 1;
}

//----- (0121D7E0) --------------------------------------------------------
CTreeList *__thiscall sub_121D7E0(CTreeList *pTreeList, int a2, void *pTreeListData, BOOL fFlags, int uID)
{
  int *v5; // esi
  CTreeList **v6; // edi
  CTreeList *v7; // eax
  CTreeList *v8; // ebx
  int v9; // eax

  v5 = a2;
  v6 = pTreeList;
  if ( !a2 )
    v5 = &pTreeList->field_40;
  v7 = sub_121D640(v5, pTreeList, pTreeListData, fFlags, uID);
  v8 = v7;
  if ( v5[8] & 0x10 )
  {
    v9 = sub_121BFE0(v6, v7);
    sub_121D830(v6, v9, 1);
  }
  return v8;
}

//----- (0121D830) --------------------------------------------------------
void __thiscall sub_121D830(int this, int a2, int a3)
{
  int v3; // edi
  HWND v4; // ST14_4
  int v5; // esi
  int v6; // ebx
  LONG v7; // ecx
  HWND v8; // ST00_4
  HWND v9; // ST00_4
  struct tagSCROLLINFO v10; // [esp+4h] [ebp-40h]
  struct tagRECT Rect; // [esp+20h] [ebp-24h]
  RECT prcScroll; // [esp+30h] [ebp-14h]

  v3 = this;
  if ( a3 && !*(this + 157) )
  {
    v10.cbSize = 28;
    v4 = *(this + 28);
    v10.nTrackPos = 0;
    _mm_storeu_si128(&v10.nMin, 0i64);
    v10.fMask = 4;
    GetScrollInfo(v4, 2, &v10);
    v5 = CTreeList::GetHeaderHeight(v3);
    GetClientRect(*(v3 + 8), &Rect);
    v6 = a3 * v5;
    GetWindowRect(*(v3 + 12), &prcScroll);
    prcScroll.left = Rect.left;
    prcScroll.right = Rect.right;
    v7 = prcScroll.bottom + v5 * (a2 - v10.nPos) - prcScroll.top;
    if ( a3 < 0 )
    {
      prcScroll.bottom = Rect.bottom;
      if ( v7 - v6 < Rect.bottom )
      {
        v9 = *(v3 + 8);
        prcScroll.top = v7 - v6;
        ScrollWindowEx(v9, 0, v6, &prcScroll, 0, 0, 0, 2u);
        prcScroll.top = v6 + Rect.bottom;
      }
      else
      {
        prcScroll.top = v7;
      }
      InvalidateRect(*(v3 + 8), &prcScroll, 0);
    }
    else
    {
      prcScroll.bottom = Rect.bottom;
      v8 = *(v3 + 8);
      prcScroll.top = v7;
      ScrollWindowEx(v8, 0, v6, &prcScroll, 0, 0, 0, 2u);
    }
    if ( *(v3 + 156) )
    {
      *(v3 + 152) = sub_121C080(v3, 0);
      sub_121EFD0(v3);
    }
    sub_121EF00(v3);
  }
}

//----- (0121D980) --------------------------------------------------------
bool __thiscall sub_121D980(_DWORD *this, int a2)
{
  _DWORD *v2; // ebx
  HWND v3; // ST00_4
  HDC v4; // esi
  LONG v5; // edi
  int v6; // eax
  int v7; // esi
  struct tagTEXTMETRICW tm; // [esp+Ch] [ebp-7Ch]
  struct tagRECT v10; // [esp+48h] [ebp-40h]
  struct tagRECT Rect; // [esp+58h] [ebp-30h]
  struct tagSCROLLINFO v12; // [esp+68h] [ebp-20h]

  v12.cbSize = 28;
  v2 = this;
  v12.nTrackPos = 0;
  v12.fMask = 4;
  v3 = this[7];
  _mm_storeu_si128(&v12.nMin, 0i64);
  GetScrollInfo(v3, 2, &v12);
  v4 = GetDC(v2[2]);
  SelectObject(v4, v2[12]);
  GetTextMetricsW(v4, &tm);
  v5 = tm.tmHeight;
  ReleaseDC(v2[2], v4);
  if ( v2[14] )
  {
    v6 = GetSystemMetrics(50);
    if ( v5 < v6 )
      v5 = v6;
  }
  v7 = v5 + v2[26];
  GetWindowRect(v2[3], &Rect);
  GetClientRect(v2[2], &v10);
  return a2 >= v12.nPos && a2 <= v12.nPos + (v10.bottom + Rect.top - Rect.bottom) / v7;
}

//----- (0121DA70) --------------------------------------------------------
_DWORD *__thiscall sub_121DA70(_DWORD *this, int a2)
{
  int v2; // esi
  int v3; // eax
  _DWORD *i; // edx
  int v6; // ecx

  if ( !this )
    return 0;
  v2 = a2;
  while ( v2 < 0 )
  {
    v3 = this[3];
    if ( v3 )
    {
      this = this[3];
      for ( i = *(v3 + 24); i; i = i[6] )
      {
        if ( !((this[8] >> 4) & 1) )
          break;
        this = i;
      }
    }
    else
    {
      this = this[2];
      if ( this && !this[1] )
        return 0;
    }
    ++v2;
    if ( !this )
      return 0;
  }
  for ( ; this; --v2 )
  {
    if ( v2 <= 0 )
      break;
    if ( this[5] && (this[8] >> 4) & 1 )
    {
      this = this[5];
    }
    else if ( this[4] )
    {
      this = this[4];
    }
    else
    {
      v6 = this[2];
      if ( v6 )
      {
        while ( !*(v6 + 16) )
        {
          v6 = *(v6 + 8);
          if ( !v6 )
            goto LABEL_24;
        }
        this = *(v6 + 16);
      }
      else
      {
LABEL_24:
        this = 0;
      }
    }
  }
  return this;
}

//----- (0121DB30) --------------------------------------------------------
int __thiscall CTreeList::GetHeaderHeight(CTreeList *this)
{
  CTreeList *v1; // ebx
  HDC v2; // esi
  LONG v3; // edi
  int v4; // eax
  struct tagTEXTMETRICW tm; // [esp+Ch] [ebp-40h]

  v1 = this;
  v2 = GetDC(this->m_hWnd);
  SelectObject(v2, v1->m_Font);
  GetTextMetricsW(v2, &tm);
  v3 = tm.tmHeight;
  ReleaseDC(v1->m_hWnd, v2);
  if ( v1->m_ImageList )
  {
    v4 = GetSystemMetrics(SM_CYSMICON);
    if ( v3 < v4 )
      v3 = v4;
  }
  return v3 + v1->m_Height;
}

//----- (0121DBA0) --------------------------------------------------------
int __cdecl sub_121DBA0(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return a3(*(a1 + 4), *(a2 + 4));
}

//----- (0121DBC0) --------------------------------------------------------
int __cdecl sub_121DBC0(int a1, int a2, int (__stdcall *a3)(_DWORD, _DWORD, int), int a4)
{
  return a3(*(a1 + 4), *(a2 + 4), a4);
}

//----- (0121DBE0) --------------------------------------------------------
HWND __thiscall CTreeList::HandleLVMessage(CTreeList *pTreeList, HWND hWnd, UINT Msg, WPARAM wParam, NMLISTVIEW *lParam)
{
  CTreeList *pTreeList1; // ebx
  HWND result; // eax
  int v7; // ST0C_4
  bool v8; // zf
  int v9; // eax
  LRESULT v10; // eax
  HWND v11; // ecx
  UINT v12; // ecx
  HWND v13; // edx
  int v14; // ecx
  UINT v15; // eax
  UINT v16; // eax
  UINT v17; // edx
  int v18; // edx
  int v19; // edx
  int v20; // eax
  int v21; // eax
  signed int v22; // eax
  __m128i v23; // xmm1
  const __m128i *v24; // ecx
  __m128i v25; // xmm0
  LRESULT v26; // esi
  int v27; // eax
  signed int v28; // esi
  int v29; // ecx
  int v30; // edx
  int v31; // edx
  __m128i v32; // xmm1
  const __m128i *v33; // eax
  __m128i v34; // xmm0
  CListViewData *pTreeListData; // eax
  int v36; // ecx
  CTreeList *v37; // eax
  _DWORD *pItem; // eax
  _DWORD *v39; // eax
  const wchar_t *v40; // eax
  wchar_t *v41; // ecx
  int v42; // ST14_4
  LVITEMUSERDATA2 *v43; // ecx
  _DWORD *v44; // eax
  _DWORD *v45; // esi
  char v46; // bl
  int v47; // ecx
  UINT v48; // ST10_4
  int v49; // ecx
  LVITEMUSERDATA2 *v50; // ecx
  WPARAM v51; // esi
  HWND v52; // ebx
  LVITEMUSERDATA2 *v53; // ecx
  unsigned int v54; // eax
  LVITEMUSERDATA2 *v55; // eax
  int v56; // edx
  int i; // ecx
  _DWORD *v58; // eax
  int v59; // ST14_4
  LVITEMUSERDATA2 *v60; // ecx
  _DWORD *v61; // eax
  char v62; // dl
  LVITEMW item; // [esp+Ch] [ebp-4Ch]
  __int64 v64; // [esp+38h] [ebp-20h]
  int uID; // [esp+40h] [ebp-18h]
  LPARAM v66; // [esp+44h] [ebp-14h]
  int v67; // [esp+48h] [ebp-10h]
  __int64 v68; // [esp+4Ch] [ebp-Ch]

  pTreeList1 = pTreeList;
  uID = wParam;
  switch ( Msg )
  {
    case LVM_GETITEMCOUNT:
      return CTreeList::GetItemCount(pTreeList);
    case LVM_DELETEITEM:
      if ( !pTreeList->m_bValid )
        return 0;
      pItem = sub_121DA70(&pTreeList->m_RowInfo->field_0, wParam);
      if ( !pItem )
        return 0;
      sub_121A7D0(pTreeList1, pItem);
      return 1;
    case LVM_DELETEALLITEMS:
      CTreeList::Close(pTreeList);
      return 1;
    case LVM_GETNEXTITEM:
      if ( !pTreeList->m_bValid )
        return HWND_MESSAGE|0x2;
      v51 = wParam + 1;
      v58 = sub_121DA70(&pTreeList->m_RowInfo->field_0, wParam + 1);
      if ( lParam != 2 || !v58 )
        return HWND_MESSAGE|0x2;
      while ( !(v58[8] & 1) )
      {
        v58 = sub_121E650(v58);
        ++v51;
        if ( !v58 )
          return HWND_MESSAGE|0x2;
      }
      return v51;
    case LVM_GETITEMRECT:
      if ( lParam->hdr.hwndFrom )
        return 0;
      CTreeList::GetItemRect(pTreeList, wParam, lParam);
      return 1;
    case LVM_HITTEST:
      if ( !(sub_121CDB0(pTreeList, lParam->hdr.hwndFrom, lParam->hdr.idFrom, &lParam->iItem, &lParam->iSubItem, 0) & 0xE0) )
        return HWND_MESSAGE|0x2;
      return lParam->iItem;
    case LVM_ENSUREVISIBLE:
      CTreeList::EnsureVisible(pTreeList, wParam);
      return 1;
    case LVM_REDRAWITEMS:
      CTreeList::RedrawItems(pTreeList, wParam, lParam);
      return 1;
    case LVM_DELETECOLUMN:
      return CTreeList::DeleteColumn(pTreeList, wParam);
    case LVM_GETCOLUMNWIDTH:
      if ( !CTreeList::GetItemWidth(pTreeList, wParam, &v66) )
        return 0;
      return (v68 - v66);
    case LVM_GETHEADER:
      return pTreeList->m_hWndHeaderLeft;
    case LVM_SETITEMSTATE:
      item.stateMask = lParam->iSubItem;
      item.state = lParam->iItem;
      item.mask = 8;
      item.iItem = wParam;
      item.iSubItem = 0;
      return CTreeList::HandleLVMessage(pTreeList, hWnd, LVM_SETITEMW, wParam, &item);
    case LVM_GETITEMPOSITION|WM_SETCURSOR:      // LVM_SORTITEMS
      v53 = pTreeList->m_RowInfo;
      if ( v53 && v53 != pTreeList1->field_58 )
      {
        v54 = sub_121F500(&pTreeList1->m_RowInfo, pTreeList1->m_bValid, sub_121DBC0, lParam, wParam, 0);
        pTreeList1->m_RowInfo = v54;
        *(v54 + 12) = 0;
        v55 = pTreeList1->m_RowInfo;
        v56 = v55->isHandlesList;
        for ( i = &v55->isHandlesList; v56; i = *i + 16 )
        {
          *(v56 + 12) = v55;
          v55 = *i;
          v56 = *(*i + 16);
        }
        pTreeList1->field_58 = v55;
      }
      InvalidateRect(pTreeList1->m_hWnd, 0, 0);
      return 1;
    case LVM_GETSUBITEMRECT:
      if ( lParam->hdr.hwndFrom && lParam->hdr.hwndFrom != 2 )
        return 0;
      return CTreeList::GetSubItemRect(pTreeList, wParam, lParam->hdr.idFrom, 1, 0, 0, lParam);
    case LVM_SETCOLUMNORDERARRAY:
      if ( wParam <= 1 )
        return ((wParam & 0x80000000) == 0);
      v22 = 1;
      if ( wParam - 1 >= 8 )
      {
        v23 = _mm_load_si128(&xmmword_12B4280);
        v24 = &lParam->hdr.idFrom;
        do
        {
          v25 = _mm_loadu_si128(v24);
          v22 += 8;
          v24 += 2;
          _mm_storeu_si128(&v24[-2], _mm_sub_epi32(v25, v23));
          _mm_storeu_si128(&v24[-1], _mm_sub_epi32(_mm_loadu_si128(v24 - 1), v23));
        }
        while ( v22 < (wParam - (wParam - 1) % 8) );
      }
      for ( ; v22 < wParam; ++v22 )
        --*(&lParam->hdr.hwndFrom + v22);
      return SendMessageW(pTreeList1->m_hWndHeaderRight, 0x1212u, wParam - 1, &lParam->hdr.idFrom);
    case LVM_GETCOLUMNORDERARRAY:
      v26 = SendMessageW(pTreeList->m_hWndHeaderLeft, 0x1200u, 0, 0);
      v27 = v26 + SendMessageW(pTreeList1->m_hWndHeaderRight, HDM_GETITEMCOUNT, 0, 0);
      v28 = uID;
      if ( uID != v27 )
        return 0;
      if ( uID <= 0 )
        return 1;
      lParam->hdr.hwndFrom = 0;
      result = SendMessageW(pTreeList1->m_hWndHeaderRight, HDM_GETORDERARRAY, v28 - 1, &lParam->hdr.idFrom);
      v29 = 1;
      uID = result;
      v30 = v28 - 1;
      if ( v28 > 1 )
      {
        if ( v30 >= 8 )
        {
          v31 = v30 % 8;
          v32 = _mm_load_si128(&xmmword_12B4280);
          v33 = &lParam->hdr.idFrom;
          do
          {
            v34 = _mm_loadu_si128(v33);
            v29 += 8;
            v33 += 2;
            _mm_storeu_si128(&v33[-2], _mm_add_epi32(v34, v32));
            _mm_storeu_si128(&v33[-1], _mm_add_epi32(_mm_loadu_si128(v33 - 1), v32));
          }
          while ( v29 < v28 - v31 );
          result = uID;
        }
        for ( ; v29 < v28; ++v29 )
          ++*(&lParam->hdr.hwndFrom + v29);
      }
      return result;
    case LVM_GETITEMW:
      if ( !pTreeList->m_bValid )
        return 0;
      v42 = lParam->hdr.idFrom;
      v43 = pTreeList->m_RowInfo;
      uID = lParam->hdr.hwndFrom;
      v44 = sub_121DA70(v43, v42);
      v45 = v44;
      if ( !v44 )
        return 0;
      v46 = uID;
      if ( uID & 1 )
      {
        v47 = v44[1];
        v46 = uID & 0xFE;
        v48 = lParam->uNewState;
        uID = lParam->uOldState;
        lParam->uNewState = (*(*v47 + 8))(v44, lParam->hdr.code, v48, &uID);
      }
      if ( v46 & 8 )
      {
        v46 &= 0xF7u;
        lParam->iItem = 0;
        if ( v45[8] & 1 )
          lParam->iItem = 2;
      }
      if ( v46 & 4 )
      {
        v46 &= 0xFBu;
        lParam->ptAction.x = *(v45[1] + 4);
      }
      if ( v46 & 2 )
      {
        v49 = v45[1];
        uID = 0;
        lParam->uChanged = (*(*v49 + 12))(v45, &uID);
      }
      return 1;
    case LVM_SETITEMW:
      if ( !pTreeList->m_bValid )
        return 0;
      v59 = lParam->hdr.idFrom;
      v60 = pTreeList->m_RowInfo;
      uID = lParam->hdr.hwndFrom;
      v61 = sub_121DA70(v60, v59);
      if ( !v61 )
        return 0;
      v62 = uID;
      if ( uID & 4 )
      {
        v62 = uID & 0xFB;
        *(v61[1] + 4) = lParam->ptAction.x;
      }
      if ( !(v62 & 8) )
        return 1;
      if ( v61[8] & 1 )
      {
        if ( !(lParam->iItem & 3) )
        {
          sub_121F090(pTreeList1, 0);
          return 1;
        }
        return 1;
      }
      if ( !(lParam->iItem & 3) )
        return 1;
      sub_121F090(pTreeList1, v61);
      return 1;
    case LVM_INSERTITEMW:
      uID = lParam->hdr.idFrom;
      pTreeListData = operator new(8u);
      if ( pTreeListData )
      {
        v36 = lParam->ptAction.x;
        pTreeListData->vtptr = &CListViewData::`vftable';
        pTreeListData->field_4 = v36;
      }
      else
      {
        pTreeListData = 0;
      }
      v37 = sub_121D7E0(pTreeList1, wParam, pTreeListData, 1, uID);
      return sub_121BFE0(pTreeList1, v37);
    case LVM_FINDITEMW:
      v50 = pTreeList->m_RowInfo;
      v51 = 0;
      if ( !v50 )
        return HWND_MESSAGE|0x2;
      v52 = lParam->hdr.hwndFrom;
      while ( v52 != 1 || *(v50->field_4 + 4) != lParam->hdr.code )
      {
        ++v51;
        v50 = sub_121E650(v50);
        if ( !v50 )
          return HWND_MESSAGE|0x2;
      }
      return v51;
    case LVM_GETCOLUMNW:
      v8 = (lParam->hdr.hwndFrom & 4) == 0;
      _mm_storeu_si128(&item.state, 0i64);
      item.iSubItem = 5;
      _mm_storeu_si128(&item.iImage, 0i64);
      v64 = 0i64;
      if ( !v8 )
      {
        item.stateMask = lParam->iItem;
        v9 = lParam->iSubItem;
        item.iSubItem = 7;
        item.cchTextMax = v9;
      }
      if ( wParam )
        v10 = SendMessageW(pTreeList->m_hWndHeaderRight, HDM_GETITEMW, wParam - 1, &item.iSubItem);
      else
        v10 = SendMessageW(pTreeList->m_hWndHeaderLeft, HDM_GETITEMW, 0, &item.iSubItem);
      if ( !v10 )
        return 0;
      v11 = lParam->hdr.hwndFrom;
      if ( lParam->hdr.hwndFrom & 2 )
        lParam->hdr.code = item.state;
      result = 1;
      if ( v11 & 1 )
      {
        v12 = 0;
        if ( item.iImage & 1 )
          v12 = 1;
        lParam->hdr.idFrom = v12;
      }
      return result;
    case LVM_SETCOLUMNW:
      v13 = lParam->hdr.hwndFrom;
      v14 = 0;
      v64 = 0i64;
      item.iSubItem = 0;
      _mm_storeu_si128(&item.state, 0i64);
      _mm_storeu_si128(&item.iImage, 0i64);
      if ( v13 & 2 )
      {
        v15 = lParam->hdr.code;
        v14 = 1;
        item.iSubItem = 1;
        item.state = v15;
      }
      if ( v13 & 1 )
      {
        v16 = lParam->hdr.idFrom;
        v14 |= 4u;
        v17 = lParam->hdr.idFrom & 1;
        item.iSubItem = v14;
        v18 = v17 | 0x4000;
        if ( v16 & 0x800 )
          v19 = v18 | 0x1800;
        else
          v19 = v18 & 0xFFFFE7FF;
        item.iImage = v19;
        v13 = lParam->hdr.hwndFrom;
      }
      if ( v13 & 4 )
      {
        v20 = lParam->iItem;
        v14 |= 2u;
        item.iSubItem = v14;
        item.stateMask = v20;
      }
      if ( v13 & 0x10 )
      {
        v21 = lParam->uOldState;
        item.iSubItem = v14 | 0x20;
        item.iIndent = v21;
      }
      if ( wParam )
        result = SendMessageW(pTreeList1->m_hWndHeaderRight, HDM_SETITEMW, wParam - 1, &item.iSubItem);
      else
        result = SendMessageW(pTreeList1->m_hWndHeaderLeft, HDM_SETITEMW, 0, &item.iSubItem);
      return result;
    case LVM_INSERTCOLUMNW:
      v7 = lParam->hdr.code;
      v68 = 0i64;
      LODWORD(v68) = MulDiv(v7, 96, gLogPixelsX);
      v67 = lParam->iItem;
      HIDWORD(v68) = lParam->hdr.idFrom & 1;
      return sub_121D750(pTreeList1, &v67, wParam);
    case LVM_GETITEMTEXTW:
      if ( !pTreeList->m_bValid )
        return 0;
      v39 = sub_121DA70(&pTreeList->m_RowInfo->field_0, wParam);
      if ( !v39 )
        return 0;
      uID = lParam->uOldState;
      v40 = (*(*v39[1] + 8))(v39, lParam->hdr.code, lParam->uNewState, &uID);
      v41 = lParam->uNewState;
      if ( v40 != v41 )
        wcsncpy_s(v41, lParam->uOldState, v40, 0xFFFFFFFF);
      return 1;
    case LVM_SETITEMTEXTW:
      return (lParam->uNewState == -1);
    case LVM_ISITEMVISIBLE:
      return sub_121D980(pTreeList, wParam);
    default:
      return DefWindowProcW(hWnd, Msg, wParam, lParam);
  }
}
// 12B4268: using guessed type void *CListViewData::`vftable';
// 12B4280: using guessed type __int128 xmmword_12B4280;

//----- (0121E5D0) --------------------------------------------------------
int __stdcall sub_121E5D0(void *pInfo)
{
  return *(*(pInfo + 1) + 4);
}

//----- (0121E5E0) --------------------------------------------------------
CTreeList *__thiscall sub_121E5E0(_DWORD *this, int a2, int a3, int a4)
{
  CTreeList *v4; // edi
  CTreeListData *v5; // eax
  int *v6; // esi
  CTreeList *v7; // eax
  CTreeList *v8; // ebx
  int v9; // eax

  v4 = this;
  v5 = operator new(8u);
  if ( v5 )
  {
    v5->vtptr = &CListViewData::`vftable';
    v5->field_4 = a3;
  }
  else
  {
    v5 = 0;
  }
  v6 = a2;
  if ( !a2 )
    v6 = &v4->field_40;
  v7 = sub_121D640(v6, v4, v5, sub_121DBA0, a4);
  v8 = v7;
  if ( v6[8] & 0x10 )
  {
    v9 = sub_121BFE0(v4, v7);
    sub_121D830(v4, v9, 1);
  }
  return v8;
}
// 12B4268: using guessed type void *CListViewData::`vftable';

//----- (0121E650) --------------------------------------------------------
int __thiscall sub_121E650(_DWORD *this)
{
  int result; // eax
  int v2; // eax

  result = this[5];
  if ( !result || !((this[8] >> 4) & 1) )
  {
    result = this[4];
    if ( !result )
    {
      v2 = this[2];
      if ( v2 )
      {
        while ( !*(v2 + 16) )
        {
          v2 = *(v2 + 8);
          if ( !v2 )
            goto LABEL_7;
        }
        result = *(v2 + 16);
      }
      else
      {
LABEL_7:
        result = 0;
      }
    }
  }
  return result;
}

//----- (0121E690) --------------------------------------------------------
int __thiscall sub_121E690(_DWORD *this, HWND hWnd, LPARAM a3)
{
  CTreeList *v3; // edi
  int v4; // ebx
  unsigned int v5; // eax
  int v6; // eax
  CTreeList *v7; // edi
  int v8; // eax
  HWND v9; // edi
  int result; // eax
  int v11; // eax
  WPARAM v12; // ST08_4
  int v13; // eax
  char lParam[12]; // [esp+Ch] [ebp-34h]
  int v15; // [esp+18h] [ebp-28h]
  int v16; // [esp+1Ch] [ebp-24h]
  int v17; // [esp+20h] [ebp-20h]
  __int128 v18; // [esp+24h] [ebp-1Ch]
  __int64 v19; // [esp+34h] [ebp-Ch]
  CTreeList **v20; // [esp+3Ch] [ebp-4h]

  v20 = this;
  v3 = *(a3 + 16);
  if ( v3 )
    v4 = v3->m_ThemeData;
  else
    v4 = 0;
  v5 = *(a3 + 8);
  if ( v5 > 0x7D5 )
  {
    if ( v5 > 0xFFFFFFFB )
    {
      if ( v5 + 3 > 1 )
        return SendMessageW(hWnd, 0x4Eu, *(a3 + 4), a3);
    }
    else if ( v5 != -5 )
    {
      if ( v5 == 2006 )
      {
        _mm_storeu_si128(&lParam[8], 0i64);
        v15 = 2006;
        _mm_storeu_si128(&v18, 0i64);
        v19 = 0i64;
        *&lParam[4] = *a3;
        v15 = -103;
        v16 = sub_121BFE0(this, v3);
        HIDWORD(v19) = *(v4 + 4);
        SendMessageW(hWnd, 0x4Eu, *&lParam[8], &lParam[4]);
        return 0;
      }
      return SendMessageW(hWnd, 0x4Eu, *(a3 + 4), a3);
    }
    memset(&lParam[4], 0, 0x2Cu);
    v13 = *(a3 + 8);
    *lParam = *a3;
    *&lParam[8] = v13;
    if ( v3 )
      v15 = sub_121BFE0(v20, v3);
    else
      v15 = -1;
    v16 = *(a3 + 20);
    if ( v4 )
      LODWORD(v19) = *(v4 + 4);
    else
      LODWORD(v19) = 0;
    return SendMessageW(hWnd, 0x4Eu, *&lParam[4], lParam);
  }
  if ( v5 >= 0x7D4 )
    return SendMessageW(hWnd, 0x4Eu, *(a3 + 4), a3);
  switch ( v5 )
  {
    case 0x7D0u:
      v6 = *(a3 + 8);
      v7 = *(a3 + 12);
      v19 = 0i64;
      _mm_storeu_si128(&lParam[8], 0i64);
      v15 = -101;
      _mm_storeu_si128(&v18, 0i64);
      *&lParam[4] = *a3;
      if ( v7 )
      {
        v16 = sub_121BFE0(this, v7);
        v8 = v7->m_ThemeData;
        v9 = hWnd;
        HIDWORD(v19) = *(v8 + 4);
        *&v18 = 12884901888i64;
        DWORD2(v18) = 3;
        SendMessageW(hWnd, 0x4Eu, *&lParam[8], &lParam[4]);
        this = v20;
      }
      else
      {
        v9 = hWnd;
      }
      if ( *(a3 + 16) )
      {
        v16 = sub_121BFE0(this, *(a3 + 16));
        HIDWORD(v19) = *(v4 + 4);
        *&v18 = 12884901888i64;
        DWORD2(v18) = 3;
        SendMessageW(v9, 0x4Eu, *&lParam[8], &lParam[4]);
      }
      result = 0;
      break;
    case 0x7D3u:
      v11 = *(a3 + 8);
      _mm_storeu_si128(&lParam[8], 0i64);
      v15 = v11;
      v17 = *(a3 + 20);
      v12 = *(a3 + 4);
      _mm_storeu_si128(&v18, 0i64);
      v19 = 0i64;
      *&lParam[4] = *a3;
      v15 = -108;
      v16 = -1;
      SendMessageW(hWnd, 0x4Eu, v12, &lParam[4]);
      result = 0;
      break;
    default:
      return SendMessageW(hWnd, 0x4Eu, *(a3 + 4), a3);
  }
  return result;
}

//----- (0121E900) --------------------------------------------------------
BOOL __thiscall sub_121E900(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, const __m128i *a6)
{
  _DWORD *v6; // ST20_4
  int v7; // ST1C_4
  signed int v8; // edi
  LONG v9; // eax
  __m128i v10; // xmm0
  WPARAM v11; // ST08_4
  HWND v12; // eax
  LPARAM lParam; // [esp+18h] [ebp-34h]
  LONG v15; // [esp+1Ch] [ebp-30h]
  int v16; // [esp+20h] [ebp-2Ch]
  int v17; // [esp+24h] [ebp-28h]
  int v18; // [esp+28h] [ebp-24h]
  int v19; // [esp+2Ch] [ebp-20h]
  int v20; // [esp+30h] [ebp-1Ch]
  __int128 v21; // [esp+34h] [ebp-18h]
  int v22; // [esp+44h] [ebp-8h]

  v6 = this;
  v7 = *a2;
  v8 = sub_121BFE0(*a2, a2);
  lParam = 0;
  memset(&v15, 0, 0x2Cu);
  v20 = a3;
  v9 = GetWindowLongW(*(v7 + 8), -12);
  v10 = _mm_loadu_si128(a6);
  lParam = 102;
  v15 = v9;
  v19 = *(v7 + 8);
  v18 = a2[8];
  _mm_storeu_si128(&v21, v10);
  v16 = v8;
  v17 = a4;
  v22 = v6[1];
  v11 = v9;
  v12 = GetParent(*(v7 + 8));
  return SendMessageW(v12, 0x2Bu, v11, &lParam) != 0;
}

//----- (0121E9C0) --------------------------------------------------------
char __stdcall sub_121E9C0(int a1, int a2, int a3, int a4, int a5)
{
  return 0;
}

//----- (0121E9D0) --------------------------------------------------------
int __thiscall sub_121E9D0(_DWORD *this)
{
  int v1; // edx
  int i; // ecx
  int result; // eax

  v1 = this[3];
  if ( v1 )
  {
    for ( i = *(v1 + 24); i; i = *(i + 24) )
    {
      if ( !((*(v1 + 32) >> 4) & 1) )
        break;
      v1 = i;
    }
    result = v1;
  }
  else
  {
    result = this[2];
    if ( result && !*(result + 4) )
      result = 0;
  }
  return result;
}

//----- (0121EA10) --------------------------------------------------------
LRESULT __thiscall sub_121EA10(HWND *this)
{
  HWND *v1; // edi

  v1 = this;
  InvalidateRect(this[2], 0, 0);
  InvalidateRect(v1[3], 0, 0);
  InvalidateRect(v1[5], 0, 0);
  v1[38] = sub_121C080(v1, 0);
  sub_121EF00(v1);
  sub_121EFD0(v1);
  return sub_121EC50(v1);
}

//----- (0121EA60) --------------------------------------------------------
BOOL __thiscall sub_121EA60(HWND *this, int a2)
{
  HWND *v2; // esi
  BOOL result; // eax
  LPARAM lParam; // [esp+4h] [ebp-14h]

  v2 = this;
  if ( a2 )
  {
    SendMessageW(this[5], 0x1207u, a2 - 1, &lParam);
    result = InvalidateRect(v2[5], &lParam, 0);
  }
  else
  {
    SendMessageW(this[3], 0x1207u, 0, &lParam);
    result = InvalidateRect(v2[3], &lParam, 0);
  }
  return result;
}

//----- (0121EAD0) --------------------------------------------------------
void __thiscall sub_121EAD0(_DWORD *this, _DWORD *a2)
{
  CTreeList *v2; // esi
  int v3; // eax

  v2 = this;
  v3 = sub_121BFE0(this, a2);
  if ( v3 >= 0 )
    CTreeList::RedrawItems(v2, v3, v3);
}

//----- (0121EAF0) --------------------------------------------------------
void __thiscall CTreeList::RedrawItems(CTreeList *this, int a2, int a3)
{
  CTreeList *v3; // ebx
  HWND v4; // ST00_4
  HDC v5; // esi
  LONG v6; // ebx
  int v7; // eax
  int v8; // esi
  CTreeList *v9; // [esp+8h] [ebp-80h]
  struct tagTEXTMETRICW tm; // [esp+Ch] [ebp-7Ch]
  struct tagRECT Rect; // [esp+48h] [ebp-40h]
  struct tagSCROLLINFO v12; // [esp+58h] [ebp-30h]
  RECT v13; // [esp+74h] [ebp-14h]

  v3 = this;
  v9 = this;
  if ( a3 >= a2 )
  {
    v12.cbSize = 28;
    v4 = this->m_hWndScrollBarRightRight;
    v12.nTrackPos = 0;
    _mm_storeu_si128(&v12.nMin, 0i64);
    v12.fMask = 4;
    GetScrollInfo(v4, 2, &v12);
    v5 = GetDC(v3->m_hWnd);
    SelectObject(v5, v3->m_Font);
    GetTextMetricsW(v5, &tm);
    v6 = tm.tmHeight;
    ReleaseDC(v9->m_hWnd, v5);
    if ( v9->m_ImageList )
    {
      v7 = GetSystemMetrics(50);
      if ( v6 < v7 )
        v6 = v7;
    }
    v8 = v6 + v9->m_Height;
    GetWindowRect(v9->m_hWndHeaderLeft, &Rect);
    GetClientRect(v9->m_hWnd, &v13);
    v13.top = Rect.bottom + v8 * (a2 - v12.nPos) - Rect.top;
    v13.bottom = Rect.bottom + v8 * (a2 - v12.nPos) - Rect.top + v8 * (a3 - a2 + 1);
    InvalidateRect(v9->m_hWnd, &v13, 0);
  }
}

//----- (0121EBF0) --------------------------------------------------------
ATOM RegisterTreeListCtrl()
{
  WNDCLASSEXW wc; // [esp+0h] [ebp-30h]

  memset(&wc.style, 0, 44u);
  wc.cbSize = 48;
  wc.lpfnWndProc = TreeListWndProc;
  wc.hCursor = LoadCursorW(0, IDC_ARROW);
  wc.hbrBackground = NULL;
  wc.lpszMenuName = 0;
  wc.style = LVS_SHOWSELALWAYS;
  wc.lpszClassName = L"TreeListWindowClass";
  return RegisterClassExW(&wc);
}
// 12B41A4: using guessed type wchar_t aTreelistwindow[20];

//----- (0121EC50) --------------------------------------------------------
LRESULT __thiscall sub_121EC50(CTreeList *this)
{
  CTreeList *pTreeList; // esi
  HWND WndScrollBarRightBottom; // ST10_4
  HWND hWndScrollBarRightRight; // ST14_4
  int cxVscroll; // eax
  LONG right; // edx
  HWND hWndHeader; // eax
  RECT rcTooltip; // [esp+4h] [ebp-70h]
  RECT rcHeader2; // [esp+14h] [ebp-60h]
  __int64 v10; // [esp+2Ch] [ebp-48h]
  RECT rcWindow; // [esp+34h] [ebp-40h]
  SCROLLINFO ScrollInfo; // [esp+44h] [ebp-30h]
  RECT rcHeader; // [esp+60h] [ebp-14h]

  pTreeList = this;
  GetClientRect(this->m_hWnd, &rcWindow);
  GetWindowRect(pTreeList->m_hWndHeaderRight, &rcHeader);
  ScrollInfo.cbSize = 28;
  WndScrollBarRightBottom = pTreeList->m_hWndScrollBarRightBottom;
  ScrollInfo.nTrackPos = 0;
  _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
  ScrollInfo.fMask = SIF_POS;
  GetScrollInfo(WndScrollBarRightBottom, SB_CTL, &ScrollInfo);
  rcHeader.left = pTreeList->m_rcHeader.left - ScrollInfo.nPos;
  hWndScrollBarRightRight = pTreeList->m_hWndScrollBarRightRight;
  rcHeader.right = rcWindow.right - rcWindow.left;
  rcHeader.bottom -= rcHeader.top;
  rcHeader.top = 0;
  if ( (GetWindowLongW(hWndScrollBarRightRight, GWL_STYLE) >> 28) & 1 )
  {
    cxVscroll = GetSystemMetrics(SM_CXVSCROLL);
    right = rcHeader.right - cxVscroll;
    rcHeader.right -= cxVscroll;
  }
  else
  {
    right = rcHeader.right;
  }
  SetWindowPos(
    pTreeList->m_hWndHeaderRight,
    HWND_DESKTOP,
    rcHeader.left,
    rcHeader.top,
    right - rcHeader.left,
    rcHeader.bottom - rcHeader.top,
    SWP_NOZORDER);
  hWndHeader = pTreeList->m_hWndHeaderRight;
  rcTooltip.left = 48;
  _mm_storeu_si128(&rcTooltip.right, 0i64);
  rcTooltip.top = 0;
  _mm_storeu_si128(&rcHeader2.right, 0i64);
  rcTooltip.right = hWndHeader;
  v10 = 0i64;
  GetClientRect(hWndHeader, &rcHeader2);
  return SendMessageW(pTreeList->m_hWndTooltipOfRightHeader, TTM_NEWTOOLRECTW, 0, &rcTooltip);
}

//----- (0121ED70) --------------------------------------------------------
LRESULT __thiscall CTreeList::SetHeaderWidth(CTreeList *this, int width)
{
  CTreeList *pListCtrl; // ebx
  HWND v3; // ST10_4
  LONG v4; // edx
  HWND hWndHeaderLeft; // ST00_4
  HWND hWndHeaderRight; // eax
  RECT rcTooltip; // [esp+8h] [ebp-8Ch]
  RECT rcCient; // [esp+18h] [ebp-7Ch]
  __int64 v10; // [esp+30h] [ebp-64h]
  struct tagSCROLLINFO ScrollInfo1; // [esp+38h] [ebp-5Ch]
  struct tagSCROLLINFO ScrollInfo2; // [esp+54h] [ebp-40h]
  struct tagRECT rcHeaderLeft; // [esp+70h] [ebp-24h]
  struct tagRECT rcHeaderRight; // [esp+80h] [ebp-14h]

  pListCtrl = this;
  this->m_rcHeader.left = width;
  GetWindowRect(this->m_hWndHeaderLeft, &rcHeaderLeft);
  GetWindowRect(pListCtrl->m_hWndHeaderRight, &rcHeaderRight);
  MapWindowPoints(0, pListCtrl->m_hWnd, &rcHeaderLeft, 2u);
  MapWindowPoints(0, pListCtrl->m_hWnd, &rcHeaderRight, 2u);
  v3 = pListCtrl->m_hWndScrollBarLeftHorz;
  ScrollInfo1.cbSize = 28;
  _mm_storeu_si128(&ScrollInfo1.nMin, 0i64);
  ScrollInfo1.nTrackPos = 0;
  ScrollInfo2.cbSize = 28;
  _mm_storeu_si128(&ScrollInfo2.nMin, 0i64);
  ScrollInfo2.nTrackPos = 0;
  ScrollInfo1.fMask = SIF_POS;
  ScrollInfo2.fMask = SIF_POS;
  GetScrollInfo(v3, SB_CTL, &ScrollInfo1);
  GetScrollInfo(pListCtrl->m_hWndScrollBarRightBottom, SB_CTL, &ScrollInfo2);
  v4 = pListCtrl->m_rcHeader.left;
  rcHeaderRight.left = pListCtrl->m_rcHeader.left - ScrollInfo2.nPos;
  rcHeaderLeft.left = 0;
  hWndHeaderLeft = pListCtrl->m_hWndHeaderLeft;
  rcHeaderLeft.right = v4;
  SetWindowPos(hWndHeaderLeft, 0, 0, rcHeaderLeft.top, v4, rcHeaderLeft.bottom - rcHeaderLeft.top, SWP_NOZORDER);
  SetWindowPos(
    pListCtrl->m_hWndHeaderRight,
    0,
    rcHeaderRight.left,
    rcHeaderRight.top,
    rcHeaderRight.right - rcHeaderRight.left,
    rcHeaderRight.bottom - rcHeaderRight.top,
    SWP_NOZORDER);
  rcTooltip.left = 48;
  rcTooltip.top = 0;
  hWndHeaderRight = pListCtrl->m_hWndHeaderRight;
  _mm_storeu_si128(&rcTooltip.right, 0i64);
  _mm_storeu_si128(&rcCient.right, 0i64);
  rcTooltip.right = hWndHeaderRight;
  v10 = 0i64;
  GetClientRect(hWndHeaderRight, &rcCient);
  SendMessageW(pListCtrl->m_hWndTooltipOfRightHeader, TTM_NEWTOOLRECTW, 0, &rcTooltip);
  rcTooltip.right = pListCtrl->m_hWndHeaderLeft;
  GetClientRect(rcTooltip.right, &rcCient);
  return SendMessageW(pListCtrl->m_hWndTooltipOfLeftHeader, TTM_NEWTOOLRECTW, 0, &rcTooltip);
}

//----- (0121EF00) --------------------------------------------------------
void __thiscall sub_121EF00(CTreeList *this)
{
  CTreeList *pTreeList; // ebx
  bool v2; // al
  bool bFlags2; // [esp+Bh] [ebp-45h]
  bool bFlags1; // [esp+Fh] [ebp-41h]
  bool v5; // [esp+13h] [ebp-3Dh]
  SCROLLINFO ScrollInfo1; // [esp+14h] [ebp-3Ch]
  SCROLLINFO ScrollInfo2; // [esp+30h] [ebp-20h]

  pTreeList = this;
  CTreeList::GetScrollInfo(this, &ScrollInfo1, &ScrollInfo2);
  bFlags2 = ScrollInfo1.nPage <= ScrollInfo1.nMax;
  bFlags1 = ScrollInfo2.nPage <= ScrollInfo2.nMax;
  v5 = sub_121F400(pTreeList, ScrollInfo1.nPage <= ScrollInfo1.nMax, ScrollInfo2.nPage <= ScrollInfo2.nMax);
  CTreeList::AutoSize(pTreeList, pTreeList->m_hWndScrollBarRightBottom, bFlags1, bFlags2);
  v2 = bFlags2 && bFlags1;
  sub_121F240(pTreeList, v2);
  if ( bFlags2 )
  {
    SetScrollInfo(pTreeList->m_hWndScrollBarRightRight, 2, &ScrollInfo1, 1);
    CTreeList::VScroll(pTreeList, 0);
  }
  if ( bFlags1 )
  {
    SetScrollInfo(pTreeList->m_hWndScrollBarRightBottom, 2, &ScrollInfo2, 1);
    CTreeList::Scroll(pTreeList, pTreeList->m_hWndScrollBarRightBottom, 0);
  }
  if ( v5 )
    sub_121EC50(pTreeList);
}

//----- (0121EFD0) --------------------------------------------------------
void __thiscall sub_121EFD0(int this)
{
  int v1; // esi
  int v2; // edi
  bool v3; // bl
  HWND v4; // ST00_4
  UINT v5; // [esp+8h] [ebp-34h]
  struct tagRECT Rect; // [esp+Ch] [ebp-30h]
  SCROLLINFO v7; // [esp+1Ch] [ebp-20h]

  v1 = this;
  if ( *(this + 156) )
  {
    GetClientRect(*(this + 8), &Rect);
    v2 = *(v1 + 152);
    v3 = v2 > *(v1 + 144);
    v5 = *(v1 + 144);
    CTreeList::AutoSize(v1, *(v1 + 32), v3, 0);
    if ( v3 )
    {
      v7.cbSize = 28;
      _mm_storeu_si128(&v7.nMin, 0i64);
      v7.nTrackPos = 0;
      v7.nMax = v2 - 1;
      v7.nPage = v5;
      v4 = *(v1 + 32);
      v7.fMask = 3;
      v7.nMin = 0;
      SetScrollInfo(v4, 2, &v7, 1);
      CTreeList::Scroll(v1, *(v1 + 32), 0);
    }
  }
}

//----- (0121F090) --------------------------------------------------------
void __thiscall sub_121F090(_DWORD *this, _DWORD *a2)
{
  CTreeList *v2; // esi
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // eax

  v2 = this;
  v3 = this[31];
  if ( a2 != v3 )
  {
    if ( v3 )
    {
      v3[8] &= 0xFFFFFFFE;
      v4 = sub_121BFE0(this, this[31]);
      if ( v4 >= 0 )
        CTreeList::RedrawItems(v2, v4, v4);
      v2->field_7C = 0;
    }
    if ( a2 )
    {
      a2[8] |= 1u;
      v5 = sub_121BFE0(v2, a2);
      if ( v5 >= 0 )
        CTreeList::RedrawItems(v2, v5, v5);
      v2->field_7C = a2;
    }
    sub_121AE40(v2, v2->m_hWnd, 2000, 0, a2, v3, 0);
  }
}

//----- (0121F110) --------------------------------------------------------
LRESULT __thiscall sub_121F110(HWND *this, int a2, int a3)
{
  LRESULT result; // eax
  LPARAM lParam; // [esp+0h] [ebp-2Ch]
  int v5; // [esp+4h] [ebp-28h]

  v5 = a3;
  lParam = 1;
  if ( a2 )
    result = SendMessageW(this[5], 0x120Cu, a2 - 1, &lParam);
  else
    result = SendMessageW(this[3], 0x120Cu, 0, &lParam);
  return result;
}

//----- (0121F160) --------------------------------------------------------
int __stdcall sub_121F160(int a1, char a2)
{
  int result; // eax

  result = a1;
  if ( a2 )
  {
    *(a1 + 32) |= 0x40u;
    if ( !*(a1 + 28) )
      *(a1 + 32) &= 0xFFFFFFEF;
  }
  else
  {
    *(a1 + 32) &= 0xFFFFFFBF;
  }
  return result;
}

//----- (0121F190) --------------------------------------------------------
LRESULT __thiscall CTreeList::SetSortImgList(CTreeList *this, LPARAM hImg, int a3, int a4)
{
  CTreeList *v4; // ebx
  HWND hWndHeaderLeft; // ST00_4

  v4 = this;
  hWndHeaderLeft = this->m_hWndHeaderLeft;
  this->m_AscendImage = a3;
  this->m_DescendImage = a4;
  SendMessageW(hWndHeaderLeft, HDM_SETIMAGELIST, 0, hImg);
  return SendMessageW(v4->m_hWndHeaderRight, HDM_SETIMAGELIST, 0, hImg);
}

//----- (0121F1E0) --------------------------------------------------------
char __thiscall CTreeList::SetImageList(CTreeList *this, int hImageList, char a3)
{
  CTreeList *v3; // esi
  char result; // al

  v3 = this;
  if ( this->m_ImageList && !LOBYTE(this->m_ImageFlag) )
    ImageList_Destroy(this->m_ImageList);
  v3->m_ImageList = hImageList;
  result = a3;
  LOBYTE(v3->m_ImageFlag) = a3;
  return result;
}

//----- (0121F210) --------------------------------------------------------
int __thiscall sub_121F210(CTreeList *this, int Height)
{
  int result; // eax

  result = Height;
  this->m_Height = Height;
  return result;
}

//----- (0121F230) --------------------------------------------------------
int __thiscall sub_121F230(CTreeList *this, int a2)
{
  int result; // eax

  result = a2;
  this->field_74 = a2;
  return result;
}

//----- (0121F240) --------------------------------------------------------
BOOL __thiscall sub_121F240(HWND *this, char a2)
{
  HWND *v2; // edi
  int v3; // eax
  struct tagRECT Rect; // [esp+4h] [ebp-14h]

  v2 = this;
  if ( !a2 )
    return ShowWindow(this[10], 0);
  GetClientRect(this[2], &Rect);
  Rect.left = Rect.right - GetSystemMetrics(2);
  v3 = GetSystemMetrics(3);
  Rect.top = Rect.bottom - v3;
  return SetWindowPos(v2[10], 0, Rect.left, Rect.bottom - v3, Rect.right - Rect.left, v3, 0x44u);
}

//----- (0121F2D0) --------------------------------------------------------
bool __thiscall CTreeList::AutoSize(CTreeList *this, HWND hWndScrollbar, char bFlags1, char bFlags2)
{
  CTreeList *pTreeList; // esi
  char bMaximized; // al
  bool v6; // bl
  int width; // eax
  HWND hWndScrollBarLeftHorz; // ecx
  int X2; // esi
  int Height; // ebx
  int ClientHeight; // eax
  bool result; // al
  int width2; // [esp+Ch] [ebp-40h]
  int height; // [esp+10h] [ebp-3Ch]
  int X1; // [esp+14h] [ebp-38h]
  bool v16; // [esp+1Bh] [ebp-31h]
  SCROLLINFO ScrollInfo; // [esp+1Ch] [ebp-30h]
  RECT rcClient; // [esp+38h] [ebp-14h]

  pTreeList = this;
  GetClientRect(this->m_hWnd, &rcClient);
  bMaximized = (GetWindowLongW(hWndScrollbar, GWL_STYLE) >> 28) & 1;
  v6 = bMaximized != bFlags1;
  v16 = bMaximized != bFlags1;
  if ( bFlags1 )
  {
    height = GetSystemMetrics(SM_CYHSCROLL);
    width = GetSystemMetrics(SM_CXVSCROLL);
    hWndScrollBarLeftHorz = pTreeList->m_hWndScrollBarLeftHorz;
    width2 = width;
    if ( hWndScrollbar == hWndScrollBarLeftHorz )
      X1 = 0;
    else
      X1 = pTreeList->m_rcHeader.left;
    if ( hWndScrollbar == hWndScrollBarLeftHorz )
      X2 = pTreeList->m_rcHeader.left;
    else
      X2 = rcClient.right - rcClient.left;
    Height = rcClient.bottom - rcClient.top - height;
    ClientHeight = Height + GetSystemMetrics(SM_CYHSCROLL);
    if ( bFlags2 )
      X2 -= width2;
    SetWindowPos(hWndScrollbar, HWND_TOP, X1, Height, X2 - X1, ClientHeight - Height, 0x44u);
    result = v16;
  }
  else
  {
    if ( bMaximized )
    {
      ScrollInfo.cbSize = 0x1C;
      ScrollInfo.nTrackPos = 0;
      _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
      ScrollInfo.fMask = 4;
      ScrollInfo.nPos = 0;
      SetScrollInfo(hWndScrollbar, SB_CTL, &ScrollInfo, 1);
      CTreeList::Scroll(pTreeList, hWndScrollbar, 0);
      ShowWindow(hWndScrollbar, 0);
    }
    result = v6;
  }
  return result;
}

//----- (0121F400) --------------------------------------------------------
bool __thiscall sub_121F400(HWND *this, char a2, char a3)
{
  HWND *v3; // edi
  char v4; // al
  bool v5; // bl
  int v6; // edx
  int v7; // eax
  bool result; // al
  HWND v9; // ST0C_4
  int v10; // [esp+8h] [ebp-34h]
  SCROLLINFO v11; // [esp+Ch] [ebp-30h]
  struct tagRECT Rect; // [esp+28h] [ebp-14h]

  v3 = this;
  GetClientRect(this[2], &Rect);
  v4 = (GetWindowLongW(v3[7], -16) >> 28) & 1;
  v5 = v4 != a2;
  if ( a2 )
  {
    v10 = GetSystemMetrics(3);
    v6 = Rect.right - Rect.left - GetSystemMetrics(2);
    v7 = Rect.bottom - Rect.top;
    if ( a3 )
      v7 -= v10;
    SetWindowPos(v3[7], 0, v6, 0, Rect.right - Rect.left - v6, v7, 0x44u);
    result = v5;
  }
  else
  {
    if ( v4 )
    {
      v11.cbSize = 28;
      v9 = v3[7];
      v11.nTrackPos = 0;
      _mm_storeu_si128(&v11.nMin, 0i64);
      v11.fMask = 4;
      v11.nPos = 0;
      SetScrollInfo(v9, 2, &v11, 1);
      CTreeList::VScroll(v3, 0);
      ShowWindow(v3[7], 0);
    }
    result = v5;
  }
  return result;
}

//----- (0121F500) --------------------------------------------------------
unsigned int __cdecl sub_121F500(unsigned int *a1, unsigned int a2, int (__cdecl *a3)(_DWORD, _DWORD, int, int), int a4, int a5, int a6)
{
  unsigned int result; // eax
  unsigned int v7; // edi
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned int *v10; // esi
  unsigned int v11; // edi
  int v12; // eax

  if ( a2 > 1 )
  {
    v7 = a2 >> 1;
    v8 = sub_121F500(a1, a2 >> 1, a3, a4, a5, a6);
    v9 = sub_121F500(a1, a2 - v7, a3, a4, a5, a6);
    a2 = 0;
    v10 = &a2;
    v11 = v9;
    if ( !v8 )
      goto LABEL_12;
    while ( v11 )
    {
      v12 = a3(*(v8 + 4), *(v11 + 4), a4, a5);
      if ( a6 )
        v12 = -v12;
      if ( v12 > 0 )
      {
        *v10 = v11;
        v11 = *(v11 + 16);
      }
      else
      {
        *v10 = v8;
        v8 = *(v8 + 16);
      }
      v10 = (*v10 + 16);
      if ( !v8 )
        goto LABEL_12;
    }
    if ( v8 )
    {
      *v10 = v8;
      result = a2;
    }
    else
    {
LABEL_12:
      *v10 = v11;
      result = a2;
    }
  }
  else
  {
    result = *a1;
    if ( *a1 )
    {
      *a1 = *(result + 16);
      *(result + 16) = 0;
    }
  }
  return result;
}

//----- (0121F5C0) --------------------------------------------------------
LRESULT __stdcall TreeListHeaderWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  CTreeList *pTreeList; // eax
  LRESULT result; // eax

  pTreeList = GetPropW(hWnd, gAtomTreeListProperty);
  if ( pTreeList )
    result = CTreeList::HeaderCtrlWndProc(pTreeList, hWnd, Msg, wParam, lParam);
  else
    result = CallWindowProcW(MEMORY[0xC8], hWnd, Msg, wParam, lParam);
  return result;
}

//----- (0121F610) --------------------------------------------------------
LRESULT __stdcall TreeListTooltipWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  CTreeList *pTreeList; // eax
  LRESULT v5; // ecx

  pTreeList = GetPropW(hWnd, gAtomTreeListProperty);
  v5 = 0;
  if ( Msg != WM_TIMER )
    return CallWindowProcW(pTreeList->m_OldTooltipWndProc, hWnd, Msg, wParam, lParam);
  if ( !BYTE1(pTreeList->m_rcHeader.bottom) )
    v5 = CallWindowProcW(pTreeList->m_OldTooltipWndProc, hWnd, WM_TIMER, wParam, lParam);
  return v5;
}

//----- (0121F680) --------------------------------------------------------
int *__stdcall TreeListWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  CTreeList *pTreeListWnd; // eax
  int *result; // eax

  pTreeListWnd = GetPropW(hWnd, gAtomTreeListProperty);
  if ( pTreeListWnd )
    result = CTreeList::HandleMessage(pTreeListWnd, hWnd, msg, wParam, lParam);
  else
    result = DefWindowProcW(hWnd, msg, wParam, lParam);
  return result;
}

//----- (0121F6C0) --------------------------------------------------------
LVITEMUSERDATA2 *__thiscall sub_121F6C0(CTreeList *pTreeList)
{
  CTreeList *this; // esi
  HWND hWndScrollbar; // ST00_4
  LVITEMUSERDATA2 *v3; // ecx
  int pos; // esi
  int v5; // eax
  SCROLLINFO ScrollInfo; // [esp+4h] [ebp-20h]

  ScrollInfo.cbSize = 28;
  this = pTreeList;
  ScrollInfo.nTrackPos = 0;
  ScrollInfo.fMask = SIF_POS;
  hWndScrollbar = pTreeList->m_hWndScrollBarRightRight;
  _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
  GetScrollInfo(hWndScrollbar, SB_CTL, &ScrollInfo);
  v3 = this->m_RowInfo;
  pos = 0;
  if ( !v3 )
    return 0;
  do
  {
    if ( pos >= ScrollInfo.nPos )
      break;
    if ( v3->dwTotalHighlightDuration && (v3->field_20 >> 4) & 1 )
    {
      v3 = v3->dwTotalHighlightDuration;
    }
    else if ( v3->isHandlesList )
    {
      v3 = v3->isHandlesList;
    }
    else
    {
      v5 = v3->m_Counter;
      if ( v5 )
      {
        while ( !*(v5 + 0x10) )
        {
          v5 = *(v5 + 8);
          if ( !v5 )
            goto LABEL_11;
        }
        v3 = *(v5 + 16);
      }
      else
      {
LABEL_11:
        v3 = 0;
      }
    }
    ++pos;
  }
  while ( v3 );
  return v3;
}

//----- (0121F780) --------------------------------------------------------
int __thiscall CTreeList::GetVertScrollPosition(CTreeList *this)
{
  HWND v1; // ST00_4
  SCROLLINFO v3; // [esp+0h] [ebp-20h]

  v3.cbSize = 28;
  v1 = this->m_hWndScrollBarRightRight;
  v3.nTrackPos = 0;
  _mm_storeu_si128(&v3.nMin, 0i64);
  v3.fMask = SIF_POS;
  GetScrollInfo(v1, SB_CTL, &v3);
  return v3.nPos;
}

//----- (0121F7D0) --------------------------------------------------------
bool __thiscall CTreeList::SetSortableColumn(CTreeList *this, HWND ProcessSortColumn, char bProcessSortDirection)
{
  CTreeList *TreeList; // ebx
  HWND nItem; // eax
  HWND dwProcessSortColumn; // edi
  WPARAM iItem; // esi
  bool bDescend; // zf
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ecx
  HWND hWndHeader; // eax
  HWND hWndHeader1; // esi
  MACRO_HDF fmt; // ecx
  HDITEMW lParam; // [esp+Ch] [ebp-30h]
  char bAscending; // [esp+3Bh] [ebp-1h]
  HWND hWnda; // [esp+44h] [ebp+8h]
  bool bDescending; // [esp+4Bh] [ebp+Fh]

  TreeList = this;
  nItem = CTreeList::FindFirstSortableColumn(this, &bAscending);
  dwProcessSortColumn = ProcessSortColumn;
  iItem = nItem;
  if ( ProcessSortColumn == nItem )
    bDescend = bAscending == 0;
  else
    bDescend = bProcessSortDirection == 0;
  SendMessageW = ::SendMessageW;
  bDescending = bDescend;
  if ( nItem >= 0 )
  {
    if ( nItem )
    {
      hWndHeader = TreeList->m_hWndHeaderRight;
      --iItem;
    }
    else
    {
      hWndHeader = TreeList->m_hWndHeaderLeft;
    }
    hWnda = hWndHeader;
    lParam.mask = HDI_FORMAT;
    ::SendMessageW(hWndHeader, HDM_GETITEMW, iItem, &lParam);
    if ( gbTreeListSortable )
      // HDF_SORTDOWN|HDF_SORTUP|HDF_LEFT|HDF_RIGHT
      lParam.fmt &= -0x601u;
    else
      // HDF_BITMAP_ON_RIGHT|HDF_IMAGE|HDF_RIGHT|HDF_LEFT
      lParam.fmt &= -0x1801u;
    ::SendMessageW(hWnda, HDM_SETITEMW, iItem, &lParam);
    SendMessageW = ::SendMessageW;
  }
  if ( dwProcessSortColumn >= 0 )
  {
    if ( dwProcessSortColumn )
    {
      hWndHeader1 = TreeList->m_hWndHeaderRight;
      dwProcessSortColumn = (dwProcessSortColumn - 1);
    }
    else
    {
      hWndHeader1 = TreeList->m_hWndHeaderLeft;
    }
    // HDI_IMAGE|HDI_FORMAT
    lParam.mask = 0x24;
    SendMessageW(hWndHeader1, HDM_GETITEMW, dwProcessSortColumn, &lParam);
    if ( gbTreeListSortable )
    {
      fmt = HDF_SORTUP;
      lParam.mask = HDI_FORMAT;
      if ( bDescending )
        fmt = HDF_SORTDOWN;
      // HDF_SORTDOWN|HDF_SORTUP|HDF_LEFT|HDF_RIGHT
      lParam.fmt = lParam.fmt & -0x601u | fmt;
    }
    else
    {
      // HDF_BITMAP_ON_RIGHT|HDF_IMAGE|HDF_LEFT
      lParam.fmt |= 0x1800u;
      if ( bDescending )
        lParam.iImage = TreeList->m_DescendImage;
      else
        lParam.iImage = TreeList->m_AscendImage;
    }
    ::SendMessageW(hWndHeader1, HDM_SETITEMW, dwProcessSortColumn, &lParam);
  }
  return bDescending;
}
// 12EA8F8: using guessed type char gbTreeListSortable;

//----- (0121F8F0) --------------------------------------------------------
LRESULT __thiscall sub_121F8F0(CTreeList *pTreeList, HWND hWnd, POINT *pt)
{
  CTreeList *this; // esi
  int v4; // ecx
  LRESULT result; // eax
  int a4; // [esp+4h] [ebp-Ch]
  WPARAM a5; // [esp+8h] [ebp-8h]
  int a6; // [esp+Ch] [ebp-4h]

  a4 = 0;
  a5 = 0;
  a6 = 0;
  this = pTreeList;
  sub_121CDB0(pTreeList, pt->x, pt->y, &a4, &a5, &a6);
  v4 = a6;
  result = a5;
  if ( this->field_AC != a6 || a5 != this->m_nHeaderItem )
  {
    this->m_nHeaderItem = a5;
    this->field_A8 = a4;
    this->field_AC = v4;
    result = SendMessageW(hWnd, TTM_POP, 0, 0);
  }
  return result;
}

//----- (0121F970) --------------------------------------------------------
unsigned int __thiscall CTreeList::VScroll(CTreeList *this, int Delta)
{
  CTreeList *pTreeList; // ebx
  unsigned int result; // eax
  int v4; // esi
  int delta; // edi
  int v6; // [esp+4h] [ebp-54h]
  struct tagRECT rcHeader; // [esp+8h] [ebp-50h]
  struct tagRECT Rect; // [esp+18h] [ebp-40h]
  RECT prcScroll; // [esp+28h] [ebp-30h]
  SCROLLINFO ScrollInfo; // [esp+38h] [ebp-20h]

  pTreeList = this;
  result = GetWindowLongW(this->m_hWndScrollBarRightRight, GWL_STYLE) >> 28;
  if ( result & 1 )
  {
    ScrollInfo.cbSize = 28;
    ScrollInfo.nTrackPos = 0;
    ScrollInfo.fMask = SIF_POS;
    _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
    if ( Delta )
    {
      GetScrollInfo(pTreeList->m_hWndScrollBarRightRight, SB_CTL, &ScrollInfo);
      ScrollInfo.nPos += Delta;
      SetScrollInfo(pTreeList->m_hWndScrollBarRightRight, SB_CTL, &ScrollInfo, 1);
    }
    GetScrollInfo(pTreeList->m_hWndScrollBarRightRight, SB_CTL, &ScrollInfo);
    result = ScrollInfo.nPos;
    v6 = ScrollInfo.nPos;
    if ( ScrollInfo.nPos != pTreeList->m_posVertScrollLast )
    {
      v4 = CTreeList::GetHeaderHeight(pTreeList);
      GetClientRect(pTreeList->m_hWnd, &Rect);
      delta = pTreeList->m_posVertScrollLast - v6;
      pTreeList->m_posVertScrollLast = v6;
      prcScroll.left = Rect.left;
      GetWindowRect(pTreeList->m_hWndHeaderLeft, &rcHeader);
      prcScroll.top = rcHeader.bottom - rcHeader.top;
      prcScroll.right = Rect.right;
      prcScroll.bottom = Rect.bottom;
      result = ScrollWindowEx(pTreeList->m_hWnd, 0, v4 * delta, &prcScroll, 0, 0, 0, 2u);
    }
  }
  return result;
}

//----- (0121FA80) --------------------------------------------------------
unsigned int __thiscall CTreeList::VScrollToPos(CTreeList *this, int pos)
{
  CTreeList *v2; // esi
  HWND v3; // ST00_4
  SCROLLINFO ScrollInfo; // [esp+0h] [ebp-20h]

  _mm_storeu_si128(&ScrollInfo.nMin, 0i64);
  ScrollInfo.nPos = pos;
  v2 = this;
  ScrollInfo.cbSize = 28;
  v3 = this->m_hWndScrollBarRightRight;
  ScrollInfo.nTrackPos = 0;
  ScrollInfo.fMask = SIF_POS;
  SetScrollInfo(v3, SB_CTL, &ScrollInfo, 1);
  return CTreeList::VScroll(v2, 0);
}

//----- (0121FAF0) --------------------------------------------------------
int *__thiscall CTreeList::HandleMessage(CTreeList *pTreeList, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  CTreeList *this; // esi
  HWND *lParam1; // edi
  int *result; // eax
  HWND hWndTooltipOfTreeList; // ST18_4
  unsigned int msg; // ecx
  LONG v10; // eax
  int v11; // ecx
  LONG v12; // edx
  int v13; // edi
  int v14; // edi
  HWND v15; // ST10_4
  HCURSOR v16; // eax
  bool v17; // zf
  HCURSOR v18; // ecx
  int v19; // eax
  HWND v20; // edx
  HWND v21; // eax
  HCURSOR v22; // ST1C_4
  LRESULT v23; // eax
  int *v24; // edi
  WPARAM v25; // ecx
  BOOL v26; // edi
  HWND v27; // ST10_4
  HWND v28; // ST10_4
  HRGN rgn; // eax
  HWND hWinde; // edi
  HWND v31; // eax
  int v32; // eax
  int v33; // ST14_4
  int v34; // eax
  HWND v35; // ST14_4
  HWND v36; // ST1C_4
  HDC v37; // eax
  void *v38; // ST1C_4
  HGDIOBJ v39; // edi
  void *v40; // ST1C_4
  HDC v41; // edi
  void *v42; // ecx
  HWND v43; // ecx
  HWND v44; // edx
  unsigned int v45; // eax
  int v46; // eax
  const WCHAR *v47; // eax
  BOOL v48; // eax
  char *v49; // eax
  int v50; // edi
  HWND v51; // eax
  HWND v52; // edx
  LONG v53; // edi
  int v54; // eax
  int v55; // eax
  WPARAM v56; // ST18_4
  HWND v57; // eax
  int v58; // edi
  int v59; // eax
  _DWORD *v60; // ecx
  CTreeList *v61; // eax
  signed int v62; // edi
  HWND v63; // ST14_4
  _DWORD *v64; // edi
  int v65; // eax
  int v66; // eax
  signed int v67; // edi
  CTreeList *v68; // ecx
  unsigned int v69; // edx
  unsigned int v70; // eax
  LONG v71; // edx
  signed int v72; // edi
  __int32 v73; // ecx
  int v74; // ecx
  BSTR **v75; // eax
  int v76; // eax
  UINT v77; // edx
  LONG v78; // eax
  _DWORD *v79; // eax
  UINT v80; // eax
  signed int v81; // eax
  HWND v82; // ST14_4
  HGDIOBJ v83; // edi
  LONG v84; // ecx
  int v85; // [esp-14h] [ebp-2E0h]
  LPCWSTR v86; // [esp-10h] [ebp-2DCh]
  int v87; // [esp-Ch] [ebp-2D8h]
  BSTR *v88; // [esp+Ch] [ebp-2C0h]
  LPARAM v89; // [esp+10h] [ebp-2BCh]
  POINT pt1; // [esp+14h] [ebp-2B8h]
  LPCWSTR lpchText; // [esp+1Ch] [ebp-2B0h]
  bool v92; // [esp+23h] [ebp-2A9h]
  int a6; // [esp+24h] [ebp-2A8h]
  UINT format; // [esp+28h] [ebp-2A4h]
  HWND hWnd1; // [esp+2Ch] [ebp-2A0h]
  WPARAM wParam1; // [esp+30h] [ebp-29Ch]
  HGDIOBJ hRgn; // [esp+34h] [ebp-298h]
  RECT prcScroll; // [esp+38h] [ebp-294h]
  int v99; // [esp+48h] [ebp-284h]
  HWND hWndInsertAfter[4]; // [esp+4Ch] [ebp-280h]
  int cy[2]; // [esp+5Ch] [ebp-270h]
  int Paint; // [esp+64h] [ebp-268h]
  LPARAM v103; // [esp+74h] [ebp-258h]
  HDITEMW hditem; // [esp+78h] [ebp-254h]
  __int64 cyy; // [esp+9Ch] [ebp-230h]
  RECT Rect; // [esp+A4h] [ebp-228h]
  int v107[130]; // [esp+B4h] [ebp-218h]
  int v108; // [esp+2C8h] [ebp-4h]

  this = pTreeList;
  lParam1 = lParam;
  hWnd1 = hWnd;
  wParam1 = wParam;
  pt1.y = lParam;
  if ( uMsg - 0x1000 <= 0xFF )
    return CTreeList::HandleLVMessage(pTreeList, hWnd1, uMsg, wParam, lParam);
  // uMsg<=525
  if ( uMsg - 512 <= 13 )
  {
    Rect.right = lParam;
    Rect.bottom = SHIWORD(lParam);
    hditem.cchTextMax = hWnd1;
    hWndTooltipOfTreeList = pTreeList->m_hWndTooltipOfTreeList;
    hditem.lParam = wParam;
    hditem.fmt = uMsg;
    hditem.iImage = lParam;
    *&hditem.iOrder = 0i64;
    HIDWORD(cyy) = 0;
    sub_121F8F0(pTreeList, hWndTooltipOfTreeList, &Rect.right);
    SendMessageW(this->m_hWndTooltipOfTreeList, TTM_RELAYEVENT, 0, &hditem.cchTextMax);
  }
  msg = uMsg;
  if ( uMsg == WM_LBUTTONDOWN )
  {
    if ( LOBYTE(this->field_BC) )
    {
      hRgn = lParam;
      if ( abs(lParam - this->m_rcHeader.left) <= 8 )
      {
        SetCapture(hWnd1);
        SetCursor(this->m_hSplitterCursor);
        this->m_posLast.x = hRgn;
LABEL_9:
        SetFocus(hWnd1);
        Rect.bottom = 0;
        format = 0;
        v10 = sub_121CDB0(this, lParam, SHIWORD(lParam), &Rect.bottom, 0, &format);
        Rect.bottom = v10;
        if ( v10 & 0xE0 )
        {
          sub_121AE40(this, this->m_hWnd, -2, 0, format, 0, 0);
          LOWORD(v10) = Rect.bottom;
        }
        if ( v10 & 0x40 )
        {
          sub_121BF00(this, format, ~(*(format + 32) >> 4) & 1);
        }
        else if ( v10 & 0x1E0 )
        {
          sub_121F090(this, format);
        }
        return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
      }
      goto LABEL_40;
    }
LABEL_32:
    v20 = hWnd1;
    goto LABEL_33;
  }
  if ( uMsg == WM_MOUSEMOVE )
  {
    if ( LOBYTE(this->field_BC) )
    {
      format = lParam;
      if ( GetCapture() == hWnd1 && wParam1 & 1 )
      {
        v11 = format - this->m_posLast.x;
        if ( format != this->m_posLast.x )
        {
          v12 = this->m_rcHeader.left;
          v13 = this->m_rcHeader.top;
          if ( v12 + v11 < v13 )
            v11 = v13 - v12;
          this->m_posLast.x += v11;
          v14 = v12 + v11;
          CTreeList::SetHeaderWidth(this, v12 + v11);
          hditem.mask = 1;
          v15 = this->m_hWndHeaderLeft;
          hditem.cxy = v14;
          SendMessageW(v15, HDM_SETITEMW, 0, &hditem);
          sub_121EF00(this);
          lParam1 = pt1.y;
        }
        SetCursor(this->m_hSplitterCursor);
        msg = WM_MOUSEMOVE;
        goto LABEL_209;
      }
      if ( abs(format - this->m_rcHeader.left) <= 8 )
      {
        SetCursor(this->m_hSplitterCursor);
        msg = WM_MOUSEMOVE;
        goto LABEL_209;
      }
      v16 = GetClassLongW(this->m_hWnd, GCL_HCURSOR);
      v17 = this->m_HandCursor == 0;
      v18 = v16;
      hRgn = v16;
      if ( !v17 )
      {
        pt1.x = 0;
        lpchText = 0;
        a6 = 0;
        sub_121CDB0(this, format, SHIWORD(lParam), &pt1, &lpchText, &a6);
        if ( a6 )
        {
          v19 = (this->m_HandCursor)(a6, lpchText);
          v18 = hRgn;
          if ( v19 )
            v18 = v19;
        }
        else
        {
          v18 = hRgn;
        }
      }
      SetCursor(v18);
      goto LABEL_31;
    }
    goto LABEL_32;
  }
  if ( uMsg != WM_LBUTTONUP || !LOBYTE(this->field_BC) )
    goto LABEL_32;
  v21 = GetCapture();
  v20 = hWnd1;
  if ( v21 == hWnd1 )
  {
    ReleaseCapture();
LABEL_40:
    v22 = GetClassLongW(this->m_hWnd, GCL_HCURSOR);
    SetCursor(v22);
LABEL_31:
    msg = uMsg;
    goto LABEL_32;
  }
  msg = WM_LBUTTONUP;
LABEL_33:
  if ( msg > WM_KEYDOWN )
  {
    if ( msg > WM_MOUSEWHEEL )
    {
      switch ( msg )
      {
        case 0x2000u:
          sub_121F160(wParam1, lParam != 0);
          return 0;
        case 0x2001u:
          return sub_121BF00(this, wParam1, lParam != 0);
        case 0x2002u:
          return *(wParam1 + 28);
        case 0x2003u:
          sub_121EAD0(this, wParam1);
          return 0;
        case 0x2004u:
          return sub_121E5E0(this, *lParam, *(lParam + 4), *(lParam + 8));
        case 0x2005u:
          return sub_121BFE0(this, wParam1);
        default:
          goto LABEL_82;
      }
      goto LABEL_82;
    }
    if ( msg == WM_MOUSEWHEEL )
    {
      Rect.bottom = this->field_8C + SHIWORD(wParam1);
      v84 = Rect.bottom;
      this->field_8C = Rect.bottom;
      if ( abs(v84) >= 40 )
      {
        this->field_8C = Rect.bottom - 40 * (v84 / 40);
        CTreeList::VScroll(this, Rect.bottom / -40);
      }
      return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
    }
    if ( msg <= WM_VSCROLL )
    {
      if ( msg == WM_VSCROLL )
      {
        hditem.cchTextMax = 28;
        v82 = this->m_hWndScrollBarRightRight;
        HIDWORD(cyy) = 0;
        _mm_storeu_si128(&hditem.lParam, 0i64);
        hditem.fmt = 7;
        GetScrollInfo(v82, 2, &hditem.cchTextMax);
        switch ( wParam1 )
        {
          case 0u:
            LODWORD(cyy) = cyy - 1;
            CTreeList::VScrollToPos(this, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 1u:
            LODWORD(cyy) = cyy + 1;
            CTreeList::VScrollToPos(this, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 2u:
            LODWORD(cyy) = cyy - hditem.iOrder;
            CTreeList::VScrollToPos(this, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 3u:
            LODWORD(cyy) = hditem.iOrder + cyy;
            CTreeList::VScrollToPos(this, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 4u:
          case 5u:
            LODWORD(cyy) = wParam1 >> 16;
            CTreeList::VScrollToPos(this, wParam1 >> 16);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 6u:
            LODWORD(cyy) = 0;
            CTreeList::VScrollToPos(this, 0);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 7u:
            LODWORD(cyy) = hditem.iImage;
            CTreeList::VScrollToPos(this, hditem.iImage);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 8u:
            return 1;
          default:
            return 0;
        }
        return 0;
      }
      v73 = msg - WM_CHAR;
      if ( !v73 )
      {
        if ( this->m_bValid )
        {
          pt1.x = GetTickCount();
          if ( (pt1.x - this->field_CC) > 750 )
            sub_121A320(&this->field_D0, gszStatusBarText);
          if ( !this->field_7C
            || ((v75 = CComBSTR::AssignA(&v88, gszStatusBarText),
                 v92 = sub_121A3E0(&this->field_D0, v75),
                 bstr_t::Data_t::Free(&v88),
                 !v92) ? (v76 = this->field_7C) : (v76 = sub_121E650(this->field_7C)),
                (a6 = v76) == 0) )
          {
            a6 = this->m_RowInfo;
          }
          this->field_CC = pt1.x;
          hRgn = wParam1;
          bstr_t::EqualAssign(&lpchText, &hRgn);
          v108 = 0;
          bstr_t::Append(&this->field_D0, &lpchText);
          v108 = -1;
          bstr_t::Data_t::Free(&lpchText);
          v77 = a6;
          format = a6;
          while ( 1 )
          {
            Rect.bottom = 260;
            v78 = (*(**(v77 + 4) + 8))(v77, 0, v107, &Rect.bottom);
            lParam1 = pt1.y;
            pt1.x = v78;
            v79 = this->field_D0;
            lpchText = (v79 ? *v79 : 0);
            v80 = sub_1200440(&this->field_D0);
            if ( !_wcsnicmp(pt1.x, lpchText, v80) )
              break;
            v77 = sub_121E650(format);
            format = v77;
            if ( !v77 )
            {
              v77 = this->m_RowInfo;
              format = this->m_RowInfo;
            }
            if ( v77 == a6 )
              return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          }
          sub_121F090(this, format);
          v81 = sub_121BFE0(this, format);
          CTreeList::EnsureVisible(this, v81);
        }
        return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
      }
      v74 = v73 - 17;
      if ( !v74 )
      {
        if ( wParam1 == 100 )
        {
          GetCursorPos(&Rect.right);
          MapWindowPoints(0, hWnd1, &Rect.right, 1u);
          sub_121F8F0(this, this->m_hWndTooltipOfTreeList, &Rect.right);
        }
        return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
      }
      if ( v74 == 1 )
      {
        if ( !lParam )
          return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
        hditem.cchTextMax = 28;
        HIDWORD(cyy) = 0;
        _mm_storeu_si128(&hditem.lParam, 0i64);
        hditem.fmt = 7;
        GetScrollInfo(lParam, 2, &hditem.cchTextMax);
        switch ( wParam1 )
        {
          case 0u:
            LODWORD(cyy) = cyy - 1;
            sub_121D2A0(this, lParam, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 1u:
            LODWORD(cyy) = cyy + 1;
            sub_121D2A0(this, lParam, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 2u:
            LODWORD(cyy) = cyy - hditem.iOrder;
            sub_121D2A0(this, lParam, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 3u:
            LODWORD(cyy) = hditem.iOrder + cyy;
            sub_121D2A0(this, lParam, cyy);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 4u:
          case 5u:
            LODWORD(cyy) = wParam1 >> 16;
            sub_121D2A0(this, lParam, wParam1 >> 16);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 6u:
            LODWORD(cyy) = 0;
            sub_121D2A0(this, lParam, 0);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 7u:
            LODWORD(cyy) = hditem.iImage;
            sub_121D2A0(this, lParam, hditem.iImage);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          case 8u:
            return 1;
          default:
            return 0;
        }
        return 0;
      }
LABEL_82:
      if ( uMsg == WM_THEMECHANGED )
      {
        if ( this->m_ThemeData )
          CloseThemeData(this->m_ThemeData);
        this->m_ThemeData = 0;
        if ( *IsThemeActive && IsThemeActive() )
        {
          v47 = (this->vtptr->GetThemeName)(this);
          this->m_ThemeData = OpenThemeData(hWnd1, v47);
        }
      }
LABEL_88:
      lParam1 = pt1.y;
      return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
    }
    if ( msg == WM_LBUTTONDOWN )
      goto LABEL_9;
LABEL_209:
    if ( msg - WM_LBUTTONDBLCLK <= 1 )
    {
      Rect.bottom = 0;
      lpchText = 0;
      hRgn = 0;
      if ( sub_121CDB0(this, lParam1, SHIWORD(lParam1), &Rect.bottom, &lpchText, &hRgn) & 0xE0 )
      {
        v83 = hRgn;
        sub_121F090(this, hRgn);
        v87 = v83;
        v86 = lpchText;
        v85 = 2 * (uMsg == WM_LBUTTONDBLCLK) - 5;
LABEL_81:
        sub_121AE40(this, this->m_hWnd, v85, v86, v87, 0, 0);
      }
    }
    goto LABEL_82;
  }
  if ( msg == WM_KEYDOWN )
  {
    v17 = LOBYTE(this->m_posLast.y) == 0;
    v54 = 2007;
    hditem.lParam = v20;
    if ( !v17 )
      v54 = -155;
    hditem.iOrder = v54;
    v55 = GetWindowLongW(v20, -12);
    LOWORD(cyy) = wParam1;
    v56 = v55;
    hditem.iImage = v55;
    *(&cyy + 2) = 0;
    v57 = GetParent(hWnd1);
    SendMessageW(v57, 0x4Eu, v56, &hditem.lParam);
    switch ( wParam1 )
    {
      case VK_PRIOR:
      case VK_NEXT:
        a6 = this->field_7C;
        if ( !a6 )
          return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
        hditem.cchTextMax = 28;
        v63 = this->m_hWndScrollBarRightRight;
        HIDWORD(cyy) = 0;
        _mm_storeu_si128(&hditem.lParam, 0i64);
        hditem.fmt = 2;
        GetScrollInfo(v63, 2, &hditem.cchTextMax);
        hRgn = 0;
        if ( !hditem.iOrder )
          goto LABEL_149;
        v64 = a6;
        break;
      case VK_LEFT:
      case VK_RIGHT:
        v68 = this->field_7C;
        if ( !v68 )
          return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
        v69 = v68->m_hWndScrollBarLeftHorz;
        v70 = v68->m_hWndScrollBarLeftHorz;
        if ( wParam1 == 39 )
        {
          if ( !((v70 >> 6) & 1) )
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          if ( !((v69 >> 4) & 1) )
          {
            sub_121BF00(this, v68, 1);
            return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
          }
          return CTreeList::HandleMessage(this, hWnd1, 0x100u, 0x28u, 0);
        }
        if ( (v70 >> 4) & 1 && (v69 >> 6) & 1 )
        {
          sub_121BF00(this, v68, 0);
          return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
        }
        v71 = v68->m_hWnd;
        pt1.x = v71;
        if ( v71 && v71 != &this->field_40 )
        {
          v72 = sub_121BFE0(this, v68);
          sub_121F090(this, pt1.x);
          CTreeList::EnsureVisible(this, v72);
          goto LABEL_88;
        }
        return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
      case VK_UP:
      case VK_DOWN:
        v60 = this->field_7C;
        if ( !v60 )
          return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
        v61 = (wParam1 == 40 ? sub_121E650(v60) : sub_121E9D0(v60));
        hRgn = v61;
        if ( !v61 )
          return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
        v62 = sub_121BFE0(this, v61);
        sub_121F090(this, hRgn);
        CTreeList::EnsureVisible(this, v62);
        goto LABEL_88;
      case VK_ADD:
        if ( GetKeyState(162) )
        {
          if ( SendMessageW(this->m_hWndHeaderRight, 0x1200u, 0, 0) + 1 > 0 )
          {
            v58 = 0;
            do
            {
              if ( v58 || !LOBYTE(this->m_rcHeader.bottom) )
                v59 = sub_121C080(this, v58);
              else
                v59 = this->m_rcHeader.right;
              sub_121F110(this, v58++, v59);
            }
            while ( v58 < SendMessageW(this->m_hWndHeaderRight, 0x1200u, 0, 0) + 1 );
            lParam1 = pt1.y;
          }
          sub_121EF00(this);
        }
        return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
      default:
        return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
    }
    do
    {
      if ( wParam1 == VK_NEXT )
      {
        v65 = sub_121E650(v64);
        if ( !v65 )
          break;
        v64 = v65;
        a6 = v65;
      }
      else
      {
        v66 = sub_121E9D0(v64);
        if ( !v66 )
          break;
        v64 = v66;
        a6 = v66;
      }
      hRgn = hRgn + 1;
    }
    while ( hRgn < hditem.iOrder );
    lParam1 = pt1.y;
LABEL_149:
    if ( !a6 )
      return (this->vtptr->WindowProc)(this, hWnd1, uMsg, wParam1, lParam1);
    v67 = sub_121BFE0(this, a6);
    sub_121F090(this, a6);
    CTreeList::EnsureVisible(this, v67);
    goto LABEL_88;
  }
  switch ( msg )
  {
    case WM_DESTROY:
      CTreeList::Close(this);
      goto LABEL_82;
    case WM_SIZE:
      sub_121EF00(this);
      sub_121EFD0(this);
      sub_121EC50(this);
      v31 = this->m_hWnd;
      v103 = 48;
      _mm_storeu_si128(&hditem.cxy, 0i64);
      hditem.mask = 0;
      _mm_storeu_si128(&hditem.fmt, 0i64);
      hditem.cxy = v31;
      cyy = 0i64;
      GetClientRect(v31, &hditem.hbm);
      SendMessageW(this->m_hWndTooltipOfTreeList, TTM_NEWTOOLRECTW, 0, &v103);
      goto LABEL_82;
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
      if ( this->field_7C )
        sub_121EAD0(this, this->field_7C);
      goto LABEL_82;
    case WM_SETREDRAW:
      if ( wParam1 )
      {
        v23 = DefWindowProcW(v20, msg, wParam1, lParam);
        BYTE1(this->m_rcHeader.bottom) = 0;
        v24 = v23;
        sub_121EA10(this);
        result = v24;
      }
      else
      {
        BYTE1(this->m_rcHeader.bottom) = 1;
        result = DefWindowProcW(v20, msg, 0, lParam);
      }
      return result;
    case WM_PAINT:
      rgn = CreateRectRgn(0, 0, 0, 0);
      hWinde = hWnd1;
      hRgn = rgn;
      if ( GetUpdateRgn(hWnd1, rgn, 0) != 1 )
      {
        BeginPaint(hWinde, &Paint);
        sub_121AEC0(this, &Paint, hRgn);
        EndPaint(hWinde, &Paint);
      }
      DeleteObject(hRgn);
      return 0;
    case WM_ERASEBKGND:
      return 1;
    case WM_SETCURSOR:
      if ( wParam1 != v20 )
        goto LABEL_82;
      return 1;
    case WM_SETFONT:
      v25 = wParam1;
      this->m_Font = wParam1;
      v26 = lParam != 0;
      v27 = this->m_hWndHeaderLeft;
      v92 = lParam != 0;
      SendMessageW(v27, 0x30u, v25, v26);
      SendMessageW(this->m_hWndHeaderRight, 0x30u, this->m_Font, v26);
      SendMessageW(this->m_hWndTooltipOfTreeList, 0x30u, this->m_Font, v26);
      SendMessageW(this->m_hWndTooltipOfLeftHeader, 0x30u, this->m_Font, v26);
      SendMessageW(this->m_hWndTooltipOfRightHeader, 0x30u, this->m_Font, v26);
      GetClientRect(this->m_hWnd, &hditem.iImage);
      v99 = 0;
      v89 = &hditem.iImage;
      *cy = 0i64;
      pt1.x = &v99;
      v28 = this->m_hWndHeaderLeft;
      _mm_storeu_si128(hWndInsertAfter, 0i64);
      SendMessageW(v28, 0x1205u, 0, &v89);
      SetWindowPos(this->m_hWndHeaderLeft, hWndInsertAfter[0], 0, 0, this->m_rcHeader.left, cy[0], cy[1] | 0x40);
      SetWindowPos(
        this->m_hWndHeaderRight,
        this->m_hWndHeaderLeft,
        this->m_rcHeader.left,
        0,
        hWndInsertAfter[3] - this->m_rcHeader.left,
        cy[0],
        cy[1] | 0x40);
      if ( !v92 )
        return 0;
      sub_121EA10(this);
      return 0;
    case WM_NOTIFY:
      if ( *lParam != this->m_hWndTooltipOfTreeList )
        goto LABEL_69;
      v32 = *(lParam + 8);
      if ( v32 == -530 )
      {
        if ( this->field_AC )
        {
          a6 = lParam + 12;
          *(lParam + 12) = lParam + 16;
          v33 = this->field_AC;
          hRgn = (lParam + 16);
          if ( sub_121AE40(this, this->m_hWnd, 2004, this->m_nHeaderItem, v33, 0, lParam + 12) )
            return 0;
          v34 = this->field_AC;
          pt1.x = 80;
          lpchText = (*(**(v34 + 4) + 8))(v34, this->m_nHeaderItem, hRgn, &pt1);
          hWndInsertAfter[2] = 0;
          hWndInsertAfter[3] = 0;
          cy[0] = GetSystemMetrics(78);
          cy[1] = CTreeList::GetHeaderHeight(this);
          CTreeList::GetSubItemRect(this, this->field_A8, this->m_nHeaderItem, 1, 1, this->field_AC, &prcScroll);
          hditem.cchTextMax = 28;
          v35 = this->m_hWndScrollBarRightBottom;
          HIDWORD(cyy) = 0;
          _mm_storeu_si128(&hditem.lParam, 0i64);
          hditem.fmt = 4;
          GetScrollInfo(v35, 2, &hditem.cchTextMax);
          if ( prcScroll.left == this->m_rcHeader.left )
          {
            if ( cyy )
              return 0;
          }
          v36 = this->m_hWnd;
          format = this->m_HeaderFormat & 0xFFFB3FFF | 0x400;
          v37 = GetDC(v36);
          v38 = this->m_Font;
          hRgn = v37;
          v39 = SelectObject(v37, v38);
          DrawTextW(hRgn, lpchText, -1, &hWndInsertAfter[2], format);
          v40 = v39;
          v41 = hRgn;
          SelectObject(hRgn, v40);
          ReleaseDC(this->m_hWnd, v41);
          v42 = gpszTargetName;
          lParam1 = pt1.y;
          if ( (cy[0] - hWndInsertAfter[2]) > prcScroll.right - prcScroll.left )
            v42 = lpchText;
          *a6 = v42;
        }
        else
        {
          *(lParam + 12) = gpszTargetName;
        }
      }
      else if ( v32 == -521 )
      {
        CTreeList::GetSubItemRect(this, this->field_A8, this->m_nHeaderItem, 0, 1, this->field_AC, &hWndInsertAfter[2]);
        SendMessageW(this->m_hWndTooltipOfTreeList, 0x41Fu, 1u, &hWndInsertAfter[2]);
        MapWindowPoints(this->m_hWnd, 0, &hWndInsertAfter[2], 2u);
        SetWindowPos(this->m_hWndTooltipOfTreeList, 0, hWndInsertAfter[2], hWndInsertAfter[3], 0, 0, 0x15u);
        SendMessageW(this->m_hWndTooltipOfTreeList, 0x30u, this->m_Font, 0);
        sub_121AE40(this, this->m_hWndTooltipOfTreeList, 2005, this->m_nHeaderItem, this->field_AC, 0, 0);
        return 1;
      }
LABEL_69:
      v43 = *lParam1;
      v44 = this->m_hWndHeaderLeft;
      if ( *lParam1 != v44 && v43 != this->m_hWndHeaderRight )
        goto LABEL_82;
      v45 = lParam1[2];
      if ( v45 > 0xFFFFFEC0 )
      {
        if ( v45 == -311 )
        {
          InvalidateRect(this->m_hWnd, 0, 0);
          return 0;
        }
        if ( v45 == -5 )
          sub_121AE40(this, v43, -5, 0, 0, 0, 0);
        goto LABEL_82;
      }
      if ( v45 != -320 )
      {
        switch ( v45 )
        {
          case 0xFFFFFEBB:
            v48 = v43 == this->m_hWndHeaderRight;
            v17 = (lParam1[3] + v48) == 0;
            v49 = lParam1[3] + v48;
            hRgn = v49;
            if ( v17 && LOBYTE(this->m_rcHeader.bottom) )
            {
              v50 = this->m_rcHeader.right;
            }
            else
            {
              v50 = sub_121C080(this, v49);
              v49 = hRgn;
            }
            sub_121F110(this, v49, v50);
            if ( !hRgn )
              CTreeList::SetHeaderWidth(this, v50);
            sub_121EF00(this);
            break;
          case 0xFFFFFEBE:
            if ( v43 == v44 )
              v46 = 0;
            else
              v46 = lParam1[3] + 1;
            v87 = 0;
            v86 = v46;
            v85 = 2003;
            goto LABEL_81;
          case 0xFFFFFEBF:
            sub_121EF00(this);
            break;
        }
        goto LABEL_82;
      }
      v51 = lParam1[5];
      if ( !(*v51 & 1) )
        goto LABEL_82;
      v52 = lParam1[3];
      if ( !v52 && *(v51 + 1) < this->m_rcHeader.top )
        return 1;
      pt1.x = v52 + (v43 == this->m_hWndHeaderRight);
      CTreeList::GetItemWidth(this, pt1.x, &hWndInsertAfter[2]);
      GetClientRect(this->m_hWnd, &hditem.iImage);
      hRgn = hWndInsertAfter[2] + *(lParam1[5] + 1) - cy[0];
      if ( !hRgn )
        return 0;
      v53 = pt1.x;
      prcScroll.top = cy[1];
      *&prcScroll.right = cyy;
      prcScroll.left = cy[0];
      if ( !pt1.x )
        prcScroll.left = cy[0] - 1;
      if ( (GetWindowLongW(this->m_hWndScrollBarRightRight, -16) >> 28) & 1 )
        prcScroll.right -= GetSystemMetrics(2);
      ScrollWindowEx(this->m_hWnd, hRgn, 0, &prcScroll, 0, 0, 0, 2u);
      if ( (v53 || !LOBYTE(this->m_rcHeader.bottom))
        && (Rect.left = hWndInsertAfter[2],
            Rect.top = cy[1],
            Rect.right = cy[0],
            Rect.bottom = HIDWORD(cyy),
            InvalidateRect(this->m_hWnd, &Rect, 0),
            v53) )
      {
        sub_121EF00(this);
        UpdateWindow(this->m_hWndScrollBarRightBottom);
        result = 0;
      }
      else
      {
        CTreeList::SetHeaderWidth(this, hRgn + cy[0]);
        sub_121EF00(this);
        sub_121EFD0(this);
        UpdateWindow(this->m_hWndHeaderRight);
        UpdateWindow(this->m_hWndScrollBarLeftHorz);
        UpdateWindow(this->m_hWndScrollBarRightBottom);
        result = 0;
      }
      break;
    case WM_NCDESTROY:
      if ( this->m_ImageList && !LOBYTE(this->m_ImageFlag) )
        ImageList_Destroy(this->m_ImageList);
      SetPropW(hWnd1, gAtomTreeListProperty, 0);
      sub_121A1F0(this);
      j__free(this);
      return DefWindowProcW(hWnd1, uMsg, wParam1, lParam);
    case WM_GETDLGCODE:
      return (DefWindowProcW(v20, msg, wParam1, lParam) | 1);
    default:
      goto LABEL_82;
  }
  return result;
}

//----- (012211F0) --------------------------------------------------------
CSysProcItem *__thiscall sub_12211F0(_DWORD *this, int *a2)
{
  CSysProcItem *result; // eax
  CSysProcItem *v3; // esi
  int *v4; // edi
  int v5; // eax
  int v6; // eax

  result = CMapNode::NewNode_0(this);
  v3 = result;
  v4 = &result->dwPid;
  *&result->_Color = 0;
  if ( result != -16 )
  {
    v5 = *a2;
    *v4 = *a2;
    if ( v5 )
      InterlockedIncrement((v5 + 8));
    v6 = a2[1];
    v4[1] = v6;
    if ( v6 )
      InterlockedIncrement((v6 + 8));
    result = v3;
  }
  return result;
}

//----- (01221240) --------------------------------------------------------
int __thiscall sub_1221240(int *this, int a2, int a3, int a4, void *a5)
{
  int *v5; // edx
  int v6; // ecx
  bool v7; // al
  int v8; // ebx
  int v9; // esi
  volatile LONG *v10; // ecx
  volatile LONG *v11; // ecx
  int v12; // esi
  int *v13; // eax
  int v14; // ecx
  int result; // eax
  volatile LONG *v16; // ecx
  void *v17; // edi
  volatile LONG *v18; // [esp-8h] [ebp-34h]
  volatile LONG *v19; // [esp-8h] [ebp-34h]
  volatile LONG *v20; // [esp-8h] [ebp-34h]
  void *v21; // [esp-4h] [ebp-30h]
  volatile LONG *v22; // [esp-4h] [ebp-30h]
  volatile LONG *v23; // [esp-4h] [ebp-30h]
  int v24; // [esp+0h] [ebp-2Ch]
  int *v25; // [esp+10h] [ebp-1Ch]
  int v26; // [esp+14h] [ebp-18h]
  int v27; // [esp+18h] [ebp-14h]
  int *v28; // [esp+1Ch] [ebp-10h]
  int v29; // [esp+28h] [ebp-4h]

  v28 = &v24;
  v5 = this;
  v25 = this;
  v6 = *this;
  v7 = 1;
  v8 = a4;
  v29 = 0;
  v9 = *(v6 + 4);
  v27 = v6;
  LOBYTE(v26) = 1;
  if ( !*(v9 + 13) )
  {
    do
    {
      v27 = v9;
      if ( a3 )
      {
        v21 = *v8;
        if ( *v8 )
          InterlockedIncrement((*v8 + 8));
        v10 = *(v9 + 16);
        v18 = v10;
        if ( v10 )
          InterlockedIncrement(v10 + 2);
        v7 = sub_12114B0(v18, v21) == 0;
      }
      else
      {
        v11 = *(v9 + 16);
        v22 = v11;
        if ( v11 )
          InterlockedIncrement(v11 + 2);
        v19 = *v8;
        if ( *v8 )
          InterlockedIncrement(v19 + 2);
        v7 = sub_12114B0(v19, v22);
      }
      LOBYTE(v26) = v7;
      if ( v7 )
        v9 = *v9;
      else
        v9 = *(v9 + 8);
    }
    while ( !*(v9 + 13) );
    v6 = v27;
    v5 = v25;
  }
  v12 = v6;
  a3 = v6;
  if ( v7 )
  {
    if ( v6 == **v5 )
    {
      v13 = sub_122AEE0(v5, &a3, 1, v6, v8, a5);
LABEL_21:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v12 = a3;
  }
  v23 = *v8;
  if ( *v8 )
    InterlockedIncrement(v23 + 2);
  v16 = *(v12 + 16);
  v20 = v16;
  if ( v16 )
    InterlockedIncrement(v16 + 2);
  if ( sub_12114B0(v20, v23) )
  {
    v13 = sub_122AEE0(v25, &a3, v26, v27, v8, a5);
    goto LABEL_21;
  }
  v17 = a5;
  sub_1221430(a5 + 4);
  j__free(v17);
  result = a2;
  *a2 = v12;
  *(a2 + 4) = 0;
  return result;
}

//----- (012213E0) --------------------------------------------------------
int wsprintf(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 16u, Format, ArgList);
}

//----- (01221400) --------------------------------------------------------
void __thiscall sub_1221400(int **this)
{
  void **v1; // esi
  char v2; // [esp+4h] [ebp-4h]

  v1 = this;
  sub_1226540(this, &v2, **this, *this);
  j__free(*v1);
}

//----- (01221430) --------------------------------------------------------
void __thiscall sub_1221430(int *this)
{
  int *v1; // edi
  LONG (__stdcall *v2)(volatile LONG *); // ecx
  int v3; // esi
  int v4; // esi

  v1 = this;
  v2 = InterlockedDecrement;
  v3 = v1[1];
  if ( v3 )
  {
    if ( !InterlockedDecrement((v3 + 8)) && v3 )
    {
      if ( *v3 )
      {
        SysFreeString(*v3);
        *v3 = 0;
      }
      if ( *(v3 + 4) )
      {
        j_j__free(*(v3 + 4));
        *(v3 + 4) = 0;
      }
      j__free(v3);
    }
    v2 = InterlockedDecrement;
    v1[1] = 0;
  }
  v4 = *v1;
  if ( *v1 )
  {
    if ( !v2((v4 + 8)) && v4 )
    {
      if ( *v4 )
      {
        SysFreeString(*v4);
        *v4 = 0;
      }
      if ( *(v4 + 4) )
      {
        j_j__free(*(v4 + 4));
        *(v4 + 4) = 0;
      }
      j__free(v4);
    }
    *v1 = 0;
  }
}

//----- (012214F0) --------------------------------------------------------
int __cdecl sub_12214F0(int ppComBSTR1, LPCSTR lpString, int ppComBSTR2)
{
  CComBSTR::AssignA(ppComBSTR1, lpString);
  bstr_t::Append(ppComBSTR1, ppComBSTR2);
  return ppComBSTR1;
}

//----- (01221560) --------------------------------------------------------
int __stdcall CHttp::CHttp(HWND hWnd, OLECHAR *lpszCaption, char a3, char a4, LPCTSTR lpszDescription)
{
  CComBSTR **bstrCaption; // esi
  CComBSTR **bstrKey; // eax
  _bstr_t *v7; // eax
  CComBSTR *pBSTR; // esi
  CComBSTR *v9; // esi
  CComBSTR *v10; // esi
  CComBSTR *v11; // esi
  const wchar_t *v12; // eax
  char v13; // al
  HWND v14; // ebx
  FILE *v15; // eax
  int v16; // eax
  bool v17; // bl
  int result; // eax
  CComBSTR *v19; // esi
  CComBSTR bstr; // [esp+14h] [ebp-58h]
  CComBSTR *bstrCaption0; // [esp+20h] [ebp-4Ch]
  CComBSTR *bstrKey0; // [esp+24h] [ebp-48h]
  CComBSTR *pComBSTR1; // [esp+28h] [ebp-44h]
  CComBSTR *bstrVirusTotal; // [esp+2Ch] [ebp-40h]
  CComBSTR *pComBSTR; // [esp+30h] [ebp-3Ch]
  __int16 Str[20]; // [esp+34h] [ebp-38h]
  int ret; // [esp+68h] [ebp-4h]

  bstr.Length = hWnd;
  bstr_t::EqualAssign(&bstrVirusTotal, L"\\VirusTotal");
  ret = 0;
  bstrCaption = bstr_t::EqualAssign(&bstrCaption0, lpszCaption);
  LOBYTE(ret) = 1;
  bstrKey = bstr_t::EqualAssign(&bstrKey0, L"Software\\Sysinternals\\");
  LOBYTE(ret) = 2;
  v7 = CComBSTR::AppendTail(bstrKey, &pComBSTR1, bstrCaption);
  LOBYTE(ret) = 3;
  CComBSTR::AppendTail(v7, &pComBSTR, &bstrVirusTotal);
  pBSTR = pComBSTR1;
  if ( pComBSTR1 )
  {
    if ( !InterlockedDecrement(&pComBSTR1->Length) && pBSTR )
    {
      if ( pBSTR->bstr )
      {
        SysFreeString(pBSTR->bstr);
        pBSTR->bstr = 0;
      }
      if ( pBSTR->hKey )
      {
        j_j__free(pBSTR->hKey);
        pBSTR->hKey = 0;
      }
      j__free(pBSTR);
    }
    pComBSTR1 = 0;
  }
  v9 = bstrKey0;
  if ( bstrKey0 )
  {
    if ( !InterlockedDecrement(&bstrKey0->Length) && v9 )
    {
      if ( v9->bstr )
      {
        SysFreeString(v9->bstr);
        v9->bstr = 0;
      }
      if ( v9->hKey )
      {
        j_j__free(v9->hKey);
        v9->hKey = 0;
      }
      j__free(v9);
    }
    bstrKey0 = 0;
  }
  v10 = bstrCaption0;
  if ( bstrCaption0 )
  {
    if ( !InterlockedDecrement(&bstrCaption0->Length) && v10 )
    {
      if ( v10->bstr )
      {
        SysFreeString(v10->bstr);
        v10->bstr = 0;
      }
      if ( v10->hKey )
      {
        j_j__free(v10->hKey);
        v10->hKey = 0;
      }
      j__free(v10);
    }
    bstrCaption0 = 0;
  }
  v11 = bstrVirusTotal;
  if ( bstrVirusTotal && !InterlockedDecrement(&bstrVirusTotal->Length) )
  {
    if ( v11->bstr )
    {
      SysFreeString(v11->bstr);
      v11->bstr = 0;
    }
    if ( v11->hKey )
    {
      j_j__free(v11->hKey);
      v11->hKey = 0;
    }
    j__free(v11);
  }
  if ( pComBSTR )
    v12 = pComBSTR->bstr;
  else
    v12 = 0;
  bstr.bstr = _wcsdup(v12);
  LOBYTE(ret) = 9;
  LoadGlobalVariablesFromRegistry(&bstr, gTextInfo);
  v13 = byte_12E4DB0;
  if ( byte_12E4DB0 )
    goto LABEL_52;
  if ( a4 != byte_12E4DB0 )
    goto LABEL_63;
  v14 = bstr.Length;
  sub_1245750(bstr.Length, 0, L"https://www.virustotal.com/about/terms-of-service");
  if ( a3 )
  {
    wprintf(L"%s\n\n", aYouMustAgreeTo);
    wprintf(L"Enter 'y' to agree: ");
    v15 = sub_1287B15();
    fflush(v15 + 1);
    _getws_s(Str, 0x14u);
    if ( wcschr(Str, 'y') )
    {
      byte_12E4DB0 = 1;
      wprintf(L"\n");
    }
    else
    {
      wprintf(L"\nYou must agree to VirusTotal's terms of service to use VirusTotal features.\n\n");
    }
    goto LABEL_48;
  }
  v16 = lpszDescription ? MessageBoxW(v14, lpszDescription, L"VirusTotal Terms of Service", 0x24u) : MessageBoxW(v14, L"You must agree to VirusTotal's terms of service to use VirusTotal features.\n\n", L"VirusTotal Terms of Service", 0x24u);
  if ( v16 == 6 )
  {
LABEL_63:
    byte_12E4DB0 = 1;
LABEL_51:
    SaveGlobalVariable(&bstr, gTextInfo);
    v13 = byte_12E4DB0;
    goto LABEL_52;
  }
LABEL_48:
  v13 = byte_12E4DB0;
  if ( byte_12E4DB0 )
    goto LABEL_51;
LABEL_52:
  v17 = v13 == 1;
  free(bstr.bstr);
  v19 = pComBSTR;
  if ( pComBSTR )
  {
    result = InterlockedDecrement(&pComBSTR->Length);
    if ( !result )
    {
      if ( v19 )
      {
        if ( v19->bstr )
        {
          SysFreeString(v19->bstr);
          v19->bstr = 0;
        }
        if ( v19->hKey )
        {
          j_j__free(v19->hKey);
          v19->hKey = 0;
        }
        j__free(v19);
      }
    }
  }
  LOBYTE(result) = v17;
  return result;
}
// 12B4500: using guessed type wchar_t aYouMustAgreeTo_1[78];
// 12DC338: using guessed type wchar_t aYouMustAgreeTo[175];
// 12E4DB0: using guessed type char byte_12E4DB0;

//----- (012218A0) --------------------------------------------------------
int __stdcall sub_12218A0(int ppComBSTR, FILETIME *lpFileTime)
{
  CComBSTR **v2; // esi
  CComBSTR **v3; // eax
  _bstr_t *v4; // eax
  CComBSTR ***v5; // esi
  CComBSTR **v6; // eax
  CComBSTR *v7; // esi
  LONG (__stdcall *v8)(volatile LONG *); // ecx
  CComBSTR *v9; // esi
  CComBSTR *v10; // esi
  CComBSTR *v11; // esi
  CComBSTR *v12; // esi
  struct _FILETIME LocalFileTime; // [esp+14h] [ebp-140h]
  int v15; // [esp+1Ch] [ebp-138h]
  CComBSTR *ppComBSTR1; // [esp+20h] [ebp-134h]
  CComBSTR *ppv; // [esp+24h] [ebp-130h]
  CComBSTR *v18; // [esp+28h] [ebp-12Ch]
  CComBSTR *v19; // [esp+2Ch] [ebp-128h]
  CComBSTR *v20; // [esp+30h] [ebp-124h]
  struct _SYSTEMTIME SystemTime; // [esp+34h] [ebp-120h]
  WCHAR TimeStr; // [esp+44h] [ebp-110h]
  WCHAR DateStr; // [esp+C4h] [ebp-90h]
  int v24; // [esp+150h] [ebp-4h]

  *ppComBSTR = 0;
  v24 = 0;
  v15 = 1;
  FileTimeToLocalFileTime(lpFileTime, &LocalFileTime);
  FileTimeToSystemTime(&LocalFileTime, &SystemTime);
  GetDateFormatW(0x400u, 0, &SystemTime, L"yyyy-MM-dd", &DateStr, 64);
  GetTimeFormatW(0x400u, 8u, &SystemTime, L"hh:mm:ss", &TimeStr, 64);
  bstr_t::EqualAssign(&ppv, L" ");
  v24 = 1;
  v2 = bstr_t::EqualAssign(&v20, &TimeStr);
  LOBYTE(v24) = 2;
  v3 = bstr_t::EqualAssign(&v18, &DateStr);
  LOBYTE(v24) = 3;
  v4 = CComBSTR::AppendTail(v3, &ppComBSTR1, &ppv);
  LOBYTE(v24) = 4;
  v5 = CComBSTR::AppendTail(v4, &v19, v2);
  if ( ppComBSTR != v5 )
  {
    bstr_t::Data_t::Free(ppComBSTR);
    v6 = *v5;
    *ppComBSTR = *v5;
    if ( v6 )
      InterlockedIncrement(v6 + 2);
  }
  v7 = v19;
  v8 = InterlockedDecrement;
  if ( v19 )
  {
    if ( !InterlockedDecrement(&v19->Length) && v7 )
    {
      if ( v7->bstr )
      {
        SysFreeString(v7->bstr);
        v7->bstr = 0;
      }
      if ( v7->hKey )
      {
        j_j__free(v7->hKey);
        v7->hKey = 0;
      }
      j__free(v7);
    }
    v8 = InterlockedDecrement;
    v19 = 0;
  }
  v9 = ppComBSTR1;
  if ( ppComBSTR1 )
  {
    if ( !v8(&ppComBSTR1->Length) && v9 )
    {
      if ( v9->bstr )
      {
        SysFreeString(v9->bstr);
        v9->bstr = 0;
      }
      if ( v9->hKey )
      {
        j_j__free(v9->hKey);
        v9->hKey = 0;
      }
      j__free(v9);
    }
    ppComBSTR1 = 0;
  }
  v10 = v18;
  if ( v18 )
  {
    if ( !InterlockedDecrement(&v18->Length) && v10 )
    {
      if ( v10->bstr )
      {
        SysFreeString(v10->bstr);
        v10->bstr = 0;
      }
      if ( v10->hKey )
      {
        j_j__free(v10->hKey);
        v10->hKey = 0;
      }
      j__free(v10);
    }
    v18 = 0;
  }
  v11 = v20;
  if ( v20 )
  {
    if ( !InterlockedDecrement(&v20->Length) && v11 )
    {
      if ( v11->bstr )
      {
        SysFreeString(v11->bstr);
        v11->bstr = 0;
      }
      if ( v11->hKey )
      {
        j_j__free(v11->hKey);
        v11->hKey = 0;
      }
      j__free(v11);
    }
    v20 = 0;
  }
  v12 = ppv;
  if ( ppv && !InterlockedDecrement(&ppv->Length) )
  {
    if ( v12->bstr )
    {
      SysFreeString(v12->bstr);
      v12->bstr = 0;
    }
    if ( v12->hKey )
    {
      j_j__free(v12->hKey);
      v12->hKey = 0;
    }
    j__free(v12);
  }
  return ppComBSTR;
}

//----- (01221BC0) --------------------------------------------------------
int __stdcall sub_1221BC0(int ppComBSTR1, OLECHAR *psz)
{
  OLECHAR *v2; // edi
  CComBSTR *v3; // eax
  CComBSTR *v4; // eax
  CComBSTR *v5; // esi
  BSTR v6; // eax
  Data_t *v7; // eax
  BSTR *v8; // eax
  int v9; // edi
  CComBSTR *v10; // eax
  CComBSTR *v11; // esi
  BSTR v12; // eax
  Data_t *v13; // eax
  BSTR *v14; // eax
  int v15; // edi
  CComBSTR *v16; // edi
  CComBSTR *v17; // eax
  CComBSTR *v18; // esi
  BSTR v19; // eax
  Data_t *v20; // eax
  BSTR *v21; // eax
  int v22; // edi
  CComBSTR *v24; // [esp+10h] [ebp-18h]
  CComBSTR *ppComBSTR2; // [esp+14h] [ebp-14h]
  int v26; // [esp+18h] [ebp-10h]
  int v27; // [esp+24h] [ebp-4h]
  OLECHAR *psza; // [esp+34h] [ebp+Ch]
  OLECHAR *pszb; // [esp+34h] [ebp+Ch]
  OLECHAR *pszc; // [esp+34h] [ebp+Ch]

  *ppComBSTR1 = 0;
  v2 = psz;
  v27 = 0;
  v26 = 1;
  if ( psz )
  {
    while ( 1 )
    {
      v3 = wcschr(v2, 0x5Cu);
      v24 = v3;
      if ( !v3 )
        break;
      LOWORD(v3->bstr) = 0;
      v4 = operator new(0xCu);
      v5 = v4;
      v27 = 1;
      if ( v4 )
      {
        v4->hKey = 0;
        v4->Length = 1;
        v6 = SysAllocString(v2);
        v5->bstr = v6;
        if ( !v6 && v2 )
          goto LABEL_56;
      }
      else
      {
        v5 = 0;
      }
      LOBYTE(v27) = 0;
      ppComBSTR2 = v5;
      if ( !v5 )
        goto LABEL_56;
      v27 = 2;
      v7 = operator new(0xCu);
      LOBYTE(v27) = 3;
      v8 = v7 ? ConcatenateBSTR(v7, ppComBSTR1, &ppComBSTR2) : 0;
      psza = v8;
      LOBYTE(v27) = 2;
      if ( !v8 )
        goto LABEL_56;
      v9 = *ppComBSTR1;
      if ( *ppComBSTR1 )
      {
        if ( !InterlockedDecrement((v9 + 8)) && v9 )
        {
          if ( *v9 )
          {
            SysFreeString(*v9);
            *v9 = 0;
          }
          if ( *(v9 + 4) )
          {
            j_j__free(*(v9 + 4));
            *(v9 + 4) = 0;
          }
          j__free(v9);
        }
        v8 = psza;
        *ppComBSTR1 = 0;
      }
      *ppComBSTR1 = v8;
      LOBYTE(v27) = 0;
      if ( !InterlockedDecrement(&v5->Length) )
      {
        if ( v5->bstr )
        {
          SysFreeString(v5->bstr);
          v5->bstr = 0;
        }
        if ( v5->hKey )
        {
          j_j__free(v5->hKey);
          v5->hKey = 0;
        }
        j__free(v5);
      }
      v10 = operator new(0xCu);
      v11 = v10;
      v27 = 4;
      if ( v10 )
      {
        v10->hKey = 0;
        v10->Length = 1;
        v12 = SysAllocString(L"\\\\");
        v11->bstr = v12;
        if ( !v12 )
          goto LABEL_56;
      }
      else
      {
        v11 = 0;
      }
      LOBYTE(v27) = 0;
      ppComBSTR2 = v11;
      if ( !v11 )
        goto LABEL_56;
      v27 = 5;
      v13 = operator new(0xCu);
      LOBYTE(v27) = 6;
      v14 = v13 ? ConcatenateBSTR(v13, ppComBSTR1, &ppComBSTR2) : 0;
      pszb = v14;
      LOBYTE(v27) = 5;
      if ( !v14 )
        goto LABEL_56;
      v15 = *ppComBSTR1;
      if ( *ppComBSTR1 )
      {
        if ( !InterlockedDecrement((v15 + 8)) && v15 )
        {
          if ( *v15 )
          {
            SysFreeString(*v15);
            *v15 = 0;
          }
          if ( *(v15 + 4) )
          {
            j_j__free(*(v15 + 4));
            *(v15 + 4) = 0;
          }
          j__free(v15);
        }
        v14 = pszb;
        *ppComBSTR1 = 0;
      }
      *ppComBSTR1 = v14;
      LOBYTE(v27) = 0;
      if ( !InterlockedDecrement(&v11->Length) )
      {
        if ( v11->bstr )
        {
          SysFreeString(v11->bstr);
          v11->bstr = 0;
        }
        if ( v11->hKey )
        {
          j_j__free(v11->hKey);
          v11->hKey = 0;
        }
        j__free(v11);
      }
      v16 = v24;
      LOWORD(v24->bstr) = 92;
      v2 = (&v16->bstr + 2);
    }
    v17 = operator new(0xCu);
    v18 = v17;
    v27 = 7;
    if ( v17 )
    {
      v17->hKey = 0;
      v17->Length = 1;
      v19 = SysAllocString(v2);
      v18->bstr = v19;
      if ( !v19 && v2 )
        goto LABEL_56;
    }
    else
    {
      v18 = 0;
    }
    LOBYTE(v27) = 0;
    v24 = v18;
    if ( !v18
      || ((v27 = 8, v20 = operator new(0xCu), LOBYTE(v27) = 9, !v20) ? (v21 = 0) : (v21 = ConcatenateBSTR(
                                                                                            v20,
                                                                                            ppComBSTR1,
                                                                                            &v24)),
          pszc = v21,
          LOBYTE(v27) = 8,
          !v21) )
    {
LABEL_56:
      com_error::throw(-2147024882);
    }
    v22 = *ppComBSTR1;
    if ( *ppComBSTR1 )
    {
      if ( !InterlockedDecrement((v22 + 8)) && v22 )
      {
        if ( *v22 )
        {
          SysFreeString(*v22);
          *v22 = 0;
        }
        if ( *(v22 + 4) )
        {
          j_j__free(*(v22 + 4));
          *(v22 + 4) = 0;
        }
        j__free(v22);
      }
      v21 = pszc;
      *ppComBSTR1 = 0;
    }
    *ppComBSTR1 = v21;
    if ( !InterlockedDecrement(&v18->Length) )
    {
      if ( v18->bstr )
      {
        SysFreeString(v18->bstr);
        v18->bstr = 0;
      }
      if ( v18->hKey )
      {
        j_j__free(v18->hKey);
        v18->hKey = 0;
      }
      j__free(v18);
    }
  }
  return ppComBSTR1;
}

//----- (01221FC0) --------------------------------------------------------
DWORD __thiscall sub_1221FC0(CHttp *this)
{
  CHttp *v1; // ebx
  void **v2; // eax
  bool v3; // zf
  DWORD v4; // edi
  _DWORD *v5; // eax
  void (__stdcall *v6)(BSTR); // ebx
  BSTR *v7; // esi
  _DWORD *v8; // edi
  BSTR *v9; // eax
  BSTR *v10; // ebx
  Data_t *v11; // eax
  BSTR *v12; // eax
  DWORD v13; // ebx
  Data_t *v14; // eax
  BSTR *v15; // eax
  CComBSTR *v16; // eax
  CComBSTR *v17; // esi
  OLECHAR *v18; // eax
  int v19; // eax
  _bstr_t *v20; // eax
  _bstr_t *v21; // ebx
  Data_t *v22; // eax
  BSTR *v23; // eax
  BSTR *v24; // ebx
  CComBSTR *v25; // ebx
  void *v26; // ebx
  void *v27; // ebx
  CComBSTR *v28; // eax
  CComBSTR *v29; // esi
  HKEY v30; // eax
  OLECHAR *v31; // eax
  int v32; // eax
  _bstr_t *v33; // eax
  _bstr_t *v34; // ebx
  Data_t *v35; // eax
  BSTR *v36; // eax
  DWORD v37; // ebx
  CComBSTR *v38; // ebx
  void *v39; // ebx
  void *v40; // ebx
  BSTR *v41; // eax
  BSTR *v42; // ebx
  CComBSTR *v43; // esi
  _bstr_t *v44; // eax
  Data_t *v45; // eax
  BSTR *v46; // eax
  void **v47; // eax
  void **v48; // eax
  void **v49; // eax
  BSTR *v50; // eax
  BSTR *v51; // esi
  BSTR v52; // eax
  OLECHAR *v53; // eax
  int v54; // eax
  _bstr_t *v55; // eax
  _bstr_t *v56; // ebx
  Data_t *v57; // eax
  BSTR *v58; // ebx
  void **v59; // eax
  CComBSTR *v60; // ebx
  CComBSTR *v61; // ebx
  CComBSTR *v62; // ebx
  BSTR *v63; // eax
  BSTR *v64; // esi
  int v65; // eax
  _bstr_t *v66; // eax
  _bstr_t *v67; // ebx
  Data_t *v68; // eax
  CComBSTR *v69; // ebx
  void **v70; // eax
  CComBSTR *v71; // ebx
  void *v72; // ebx
  CComBSTR *v73; // ebx
  BSTR *v74; // eax
  BSTR *v75; // ebx
  Data_t *v76; // eax
  CComBSTR *v77; // eax
  BSTR *v78; // eax
  volatile LONG *v79; // edi
  Data_t *v80; // eax
  CComBSTR *v81; // eax
  CComBSTR *v82; // esi
  void *v83; // ecx
  BSTR *v84; // eax
  volatile LONG *v85; // esi
  CComBSTR **v86; // eax
  CHAR *v87; // ecx
  DWORD v88; // eax
  CComBSTR *v89; // edi
  DWORD v90; // edi
  int v91; // ebx
  HKEY v92; // edi
  CHAR *v93; // ecx
  const wchar_t *v94; // eax
  CHAR *v95; // ecx
  const wchar_t *v96; // eax
  const wchar_t *v97; // eax
  _DWORD *v98; // eax
  _DWORD *v99; // esi
  HKEY v100; // ebx
  CComBSTR **v101; // edi
  CComBSTR *v102; // eax
  CComBSTR *v103; // edi
  OLECHAR *v104; // eax
  void *v105; // ecx
  CComBSTR *v106; // eax
  const wchar_t *v107; // eax
  CHAR *v108; // ecx
  CComBSTR **v109; // eax
  BSTR *v110; // edi
  BSTR v111; // eax
  CHAR *v112; // ecx
  CComBSTR **v113; // eax
  BSTR *v114; // edi
  BSTR v115; // eax
  _bstr_t *v116; // edi
  _DWORD *v117; // eax
  _DWORD *v118; // esi
  int v119; // edi
  OLECHAR **v120; // eax
  OLECHAR *v121; // eax
  void *v122; // esi
  Data_t *v123; // ecx
  _DWORD *v124; // eax
  _DWORD *v125; // edi
  HKEY v126; // ebx
  BSTR **v127; // eax
  int v128; // esi
  void *v129; // esi
  BSTR v130; // esi
  CComBSTR *v131; // edi
  _DWORD *v132; // eax
  _DWORD *v133; // edi
  HKEY v134; // ebx
  Data_t *v135; // eax
  HKEY v136; // edx
  _DWORD **v137; // eax
  _DWORD *v138; // ecx
  HKEY v139; // ebx
  _DWORD *v140; // esi
  CHAR *v142; // [esp-10h] [ebp-9Ch]
  void *v143; // [esp-Ch] [ebp-98h]
  void *v144; // [esp-8h] [ebp-94h]
  CHAR *v145; // [esp-4h] [ebp-90h]
  void *v146; // [esp+10h] [ebp-7Ch]
  int v147; // [esp+14h] [ebp-78h]
  void *v148; // [esp+18h] [ebp-74h]
  OLECHAR psz[2]; // [esp+1Ch] [ebp-70h]
  CComBSTR *ppComBSTR2; // [esp+20h] [ebp-6Ch]
  CComBSTR *ppv; // [esp+24h] [ebp-68h]
  void *v152; // [esp+28h] [ebp-64h]
  CComBSTR *v153; // [esp+2Ch] [ebp-60h]
  CComBSTR *v154; // [esp+30h] [ebp-5Ch]
  CComBSTR *v155; // [esp+34h] [ebp-58h]
  CComBSTR *v156; // [esp+38h] [ebp-54h]
  int v157; // [esp+3Ch] [ebp-50h]
  CComBSTR *v158; // [esp+40h] [ebp-4Ch]
  void *v159; // [esp+44h] [ebp-48h]
  void *v160; // [esp+48h] [ebp-44h]
  CComBSTR *v161; // [esp+4Ch] [ebp-40h]
  void *v162; // [esp+50h] [ebp-3Ch]
  void *v163; // [esp+54h] [ebp-38h]
  CComBSTR *ppComBSTR1; // [esp+58h] [ebp-34h]
  int v165; // [esp+5Ch] [ebp-30h]
  CComBSTR *v166; // [esp+60h] [ebp-2Ch]
  CComBSTR *ppComBSTR; // [esp+64h] [ebp-28h]
  OLECHAR v168[2]; // [esp+68h] [ebp-24h]
  DWORD dwMessageId; // [esp+6Ch] [ebp-20h]
  CComBSTR v170; // [esp+70h] [ebp-1Ch]
  bool v171; // [esp+7Fh] [ebp-Dh]
  int v172; // [esp+88h] [ebp-4h]

  v1 = this;
  v170.hKey = this;
  v147 = 0;
  v2 = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  v146 = v2;
  v3 = v1->field_C == 0;
  v172 = 0;
  v165 = 0;
  if ( v3 )
  {
    v4 = 0;
    goto LABEL_475;
  }
  CComBSTR::AssignA(&v170.Length, L"[");
  v5 = v1->field_8;
  v6 = SysFreeString;
  v7 = v170.Length;
  LOBYTE(v172) = 1;
  v8 = *v5;
  if ( *v5 != v5 )
  {
    do
    {
      v166 = v8[2];
      bstr_t::Assign(&v166[2], gpszTargetName);
      if ( v165 )
      {
        v9 = operator new(0xCu);
        v10 = v9;
        *psz = v9;
        LOBYTE(v172) = 2;
        if ( v9 )
        {
          v145 = ",";
          v9[1] = 0;
          v9[2] = 1;
          *v9 = AsciiToUTF(v145);
        }
        else
        {
          v10 = 0;
        }
        LOBYTE(v172) = 1;
        *v168 = v10;
        if ( !v10 )
          goto LABEL_311;
        LOBYTE(v172) = 3;
        v11 = operator new(0xCu);
        *psz = v11;
        LOBYTE(v172) = 4;
        v7 = v11 ? ConcatenateBSTR(v11, &v170.Length, v168) : 0;
        LOBYTE(v172) = 3;
        if ( !v7 )
          goto LABEL_311;
        bstr_t::Data_t::Free(&v170.Length);
        v170.Length = v7;
        LOBYTE(v172) = 1;
        if ( !InterlockedDecrement(v10 + 2) )
        {
          if ( *v10 )
          {
            SysFreeString(*v10);
            *v10 = 0;
          }
          if ( v10[1] )
          {
            j_j__free(v10[1]);
            v10[1] = 0;
          }
          j__free(v10);
        }
      }
      v12 = operator new(0xCu);
      v13 = v12;
      *psz = v12;
      LOBYTE(v172) = 5;
      if ( v12 )
      {
        v145 = L"{";
        v12[1] = 0;
        v12[2] = 1;
        *v12 = AsciiToUTF(v145);
      }
      else
      {
        v13 = 0;
      }
      LOBYTE(v172) = 1;
      dwMessageId = v13;
      if ( !v13 )
        goto LABEL_311;
      LOBYTE(v172) = 6;
      v14 = operator new(0xCu);
      *psz = v14;
      LOBYTE(v172) = 7;
      v15 = v14 ? ConcatenateBSTR(v14, &v170.Length, &dwMessageId) : 0;
      *v168 = v15;
      LOBYTE(v172) = 6;
      if ( !v15 )
        goto LABEL_311;
      if ( v7 )
      {
        if ( !InterlockedDecrement(v7 + 2) )
        {
          if ( *v7 )
          {
            SysFreeString(*v7);
            *v7 = 0;
          }
          if ( v7[1] )
          {
            j_j__free(v7[1]);
            v7[1] = 0;
          }
          j__free(v7);
        }
        v15 = *v168;
      }
      v170.Length = v15;
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement((v13 + 8)) )
      {
        if ( *v13 )
        {
          SysFreeString(*v13);
          *v13 = 0;
        }
        if ( *(v13 + 4) )
        {
          j_j__free(*(v13 + 4));
          *(v13 + 4) = 0;
        }
        j__free(v13);
      }
      v16 = operator new(0xCu);
      v17 = v16;
      *psz = v16;
      LOBYTE(v172) = 8;
      if ( v16 )
      {
        v145 = "\", ";
        v16->hKey = 0;
        v16->Length = 1;
        v16->bstr = AsciiToUTF(v145);
      }
      else
      {
        v17 = 0;
      }
      LOBYTE(v172) = 1;
      ppComBSTR2 = v17;
      if ( !v17 )
        goto LABEL_311;
      LOBYTE(v172) = 9;
      v18 = (v166->bstr ? *v166->bstr : 0);
      v19 = sub_1221BC0(&v162, v18);
      LOBYTE(v172) = 10;
      v20 = sub_12214F0(&v163, "\"autostart_location\": \"", v19);
      LOBYTE(v172) = 11;
      v21 = CComBSTR::AppendTail(v20, &ppComBSTR1, &ppComBSTR2);
      LOBYTE(v172) = 12;
      v22 = operator new(0xCu);
      *psz = v22;
      LOBYTE(v172) = 13;
      v23 = v22 ? ConcatenateBSTR(v22, &v170.Length, v21) : 0;
      dwMessageId = v23;
      LOBYTE(v172) = 12;
      if ( !v23 )
        goto LABEL_311;
      v24 = *v168;
      if ( !InterlockedDecrement((*v168 + 8)) )
      {
        if ( *v24 )
        {
          SysFreeString(*v24);
          *v24 = 0;
        }
        if ( v24[1] )
        {
          j_j__free(v24[1]);
          v24[1] = 0;
        }
        j__free(v24);
      }
      v25 = ppComBSTR1;
      v170.Length = dwMessageId;
      if ( ppComBSTR1 )
      {
        if ( !InterlockedDecrement(&ppComBSTR1->Length) && v25 )
        {
          if ( v25->bstr )
          {
            SysFreeString(v25->bstr);
            v25->bstr = 0;
          }
          if ( v25->hKey )
          {
            j_j__free(v25->hKey);
            v25->hKey = 0;
          }
          j__free(v25);
        }
        ppComBSTR1 = 0;
      }
      v26 = v163;
      if ( v163 )
      {
        if ( !InterlockedDecrement(v163 + 2) && v26 )
        {
          if ( *v26 )
          {
            SysFreeString(*v26);
            *v26 = 0;
          }
          if ( *(v26 + 1) )
          {
            j_j__free(*(v26 + 1));
            *(v26 + 1) = 0;
          }
          j__free(v26);
        }
        v163 = 0;
      }
      v27 = v162;
      if ( v162 )
      {
        if ( !InterlockedDecrement(v162 + 2) && v27 )
        {
          if ( *v27 )
          {
            SysFreeString(*v27);
            *v27 = 0;
          }
          if ( *(v27 + 1) )
          {
            j_j__free(*(v27 + 1));
            *(v27 + 1) = 0;
          }
          j__free(v27);
        }
        v162 = 0;
      }
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement(&v17->Length) )
      {
        if ( v17->bstr )
        {
          SysFreeString(v17->bstr);
          v17->bstr = 0;
        }
        if ( v17->hKey )
        {
          j_j__free(v17->hKey);
          v17->hKey = 0;
        }
        j__free(v17);
      }
      v28 = operator new(0xCu);
      v29 = v28;
      *psz = v28;
      LOBYTE(v172) = 14;
      if ( v28 )
      {
        v145 = "\", ";
        v28->hKey = 0;
        v28->Length = 1;
        v28->bstr = AsciiToUTF(v145);
      }
      else
      {
        v29 = 0;
      }
      LOBYTE(v172) = 1;
      ppComBSTR2 = v29;
      if ( !v29 )
        goto LABEL_311;
      LOBYTE(v172) = 15;
      v30 = v166->hKey;
      v31 = (v30 ? *v30 : 0);
      v32 = sub_1221BC0(&v159, v31);
      LOBYTE(v172) = 16;
      v33 = sub_12214F0(&v160, "\"autostart_entry\": \"", v32);
      LOBYTE(v172) = 17;
      v34 = CComBSTR::AppendTail(v33, &v161, &ppComBSTR2);
      LOBYTE(v172) = 18;
      v35 = operator new(0xCu);
      *psz = v35;
      LOBYTE(v172) = 19;
      v36 = v35 ? ConcatenateBSTR(v35, &v170.Length, v34) : 0;
      *v168 = v36;
      LOBYTE(v172) = 18;
      if ( !v36 )
        goto LABEL_311;
      v37 = dwMessageId;
      if ( !InterlockedDecrement((dwMessageId + 8)) )
      {
        if ( *v37 )
        {
          SysFreeString(*v37);
          *v37 = 0;
        }
        if ( *(v37 + 4) )
        {
          j_j__free(*(v37 + 4));
          *(v37 + 4) = 0;
        }
        j__free(v37);
      }
      v38 = v161;
      v170.Length = *v168;
      if ( v161 )
      {
        if ( !InterlockedDecrement(&v161->Length) && v38 )
        {
          if ( v38->bstr )
          {
            SysFreeString(v38->bstr);
            v38->bstr = 0;
          }
          if ( v38->hKey )
          {
            j_j__free(v38->hKey);
            v38->hKey = 0;
          }
          j__free(v38);
        }
        v161 = 0;
      }
      v39 = v160;
      if ( v160 )
      {
        if ( !InterlockedDecrement(v160 + 2) && v39 )
        {
          if ( *v39 )
          {
            SysFreeString(*v39);
            *v39 = 0;
          }
          if ( *(v39 + 1) )
          {
            j_j__free(*(v39 + 1));
            *(v39 + 1) = 0;
          }
          j__free(v39);
        }
        v160 = 0;
      }
      v40 = v159;
      if ( v159 )
      {
        if ( !InterlockedDecrement(v159 + 2) && v40 )
        {
          if ( *v40 )
          {
            SysFreeString(*v40);
            *v40 = 0;
          }
          if ( *(v40 + 1) )
          {
            j_j__free(*(v40 + 1));
            *(v40 + 1) = 0;
          }
          j__free(v40);
        }
        v159 = 0;
      }
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement(&v29->Length) )
      {
        if ( v29->bstr )
        {
          SysFreeString(v29->bstr);
          v29->bstr = 0;
        }
        if ( v29->hKey )
        {
          j_j__free(v29->hKey);
          v29->hKey = 0;
        }
        j__free(v29);
      }
      v41 = operator new(0xCu);
      v42 = v41;
      *psz = v41;
      LOBYTE(v172) = 20;
      if ( v41 )
      {
        v145 = "\", ";
        v41[1] = 0;
        v41[2] = 1;
        *v41 = AsciiToUTF(v145);
      }
      else
      {
        v42 = 0;
      }
      LOBYTE(v172) = 1;
      *psz = v42;
      if ( !v42 )
        goto LABEL_311;
      v43 = v166->Length;
      ppComBSTR2 = v43;
      if ( v43 )
        InterlockedIncrement(&v43->Length);
      LOBYTE(v172) = 22;
      v44 = sub_12214F0(&v157, "\"hash\": \"", &ppComBSTR2);
      LOBYTE(v172) = 23;
      dwMessageId = CComBSTR::AppendTail(v44, &v158, psz);
      LOBYTE(v172) = 24;
      v45 = operator new(0xCu);
      v148 = v45;
      LOBYTE(v172) = 25;
      v46 = v45 ? ConcatenateBSTR(v45, &v170.Length, dwMessageId) : 0;
      dwMessageId = v46;
      LOBYTE(v172) = 24;
      if ( !v46 )
        goto LABEL_311;
      if ( !InterlockedDecrement((*v168 + 8)) )
      {
        v47 = *v168;
        if ( **v168 )
        {
          SysFreeString(**v168);
          v47 = *v168;
          **v168 = 0;
        }
        if ( v47[1] )
        {
          j_j__free(v47[1]);
          v47 = *v168;
          *(*v168 + 4) = 0;
        }
        j__free(v47);
      }
      v170.Length = dwMessageId;
      *v168 = v158;
      if ( v158 )
      {
        if ( !InterlockedDecrement(&v158->Length) )
        {
          v48 = *v168;
          if ( *v168 )
          {
            if ( **v168 )
            {
              SysFreeString(**v168);
              v48 = *v168;
              **v168 = 0;
            }
            if ( v48[1] )
            {
              j_j__free(v48[1]);
              v48 = *v168;
              *(*v168 + 4) = 0;
            }
            j__free(v48);
          }
        }
        v158 = 0;
      }
      *v168 = v157;
      if ( v157 )
      {
        if ( !InterlockedDecrement((v157 + 8)) )
        {
          v49 = *v168;
          if ( *v168 )
          {
            if ( **v168 )
            {
              SysFreeString(**v168);
              v49 = *v168;
              **v168 = 0;
            }
            if ( v49[1] )
            {
              j_j__free(v49[1]);
              v49 = *v168;
              *(*v168 + 4) = 0;
            }
            j__free(v49);
          }
        }
        v157 = 0;
      }
      if ( v43 && !InterlockedDecrement(&v43->Length) )
      {
        if ( v43->bstr )
        {
          SysFreeString(v43->bstr);
          v43->bstr = 0;
        }
        if ( v43->hKey )
        {
          j_j__free(v43->hKey);
          v43->hKey = 0;
        }
        j__free(v43);
      }
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement(v42 + 2) )
      {
        if ( *v42 )
        {
          SysFreeString(*v42);
          *v42 = 0;
        }
        if ( v42[1] )
        {
          j_j__free(v42[1]);
          v42[1] = 0;
        }
        j__free(v42);
      }
      v50 = operator new(0xCu);
      v51 = v50;
      v148 = v50;
      LOBYTE(v172) = 26;
      if ( v50 )
      {
        v145 = "\", ";
        v50[1] = 0;
        v50[2] = 1;
        *v50 = AsciiToUTF(v145);
      }
      else
      {
        v51 = 0;
      }
      LOBYTE(v172) = 1;
      *psz = v51;
      if ( !v51 )
        goto LABEL_311;
      LOBYTE(v172) = 27;
      v52 = v166[1].bstr;
      v53 = (v52 ? *v52 : 0);
      v54 = sub_1221BC0(&v154, v53);
      LOBYTE(v172) = 28;
      v55 = sub_12214F0(&v155, "\"image_path\": \"", v54);
      LOBYTE(v172) = 29;
      v56 = CComBSTR::AppendTail(v55, &v156, psz);
      LOBYTE(v172) = 30;
      v57 = operator new(0xCu);
      v148 = v57;
      LOBYTE(v172) = 31;
      if ( v57 )
      {
        v58 = ConcatenateBSTR(v57, &v170.Length, v56);
        *v168 = v58;
      }
      else
      {
        v58 = 0;
        *v168 = 0;
      }
      LOBYTE(v172) = 30;
      if ( !v58 )
        goto LABEL_311;
      if ( !InterlockedDecrement((dwMessageId + 8)) )
      {
        v59 = dwMessageId;
        if ( *dwMessageId )
        {
          SysFreeString(*dwMessageId);
          v59 = dwMessageId;
          *dwMessageId = 0;
        }
        if ( v59[1] )
        {
          j_j__free(v59[1]);
          v59 = dwMessageId;
          *(dwMessageId + 4) = 0;
        }
        j__free(v59);
      }
      v170.Length = v58;
      v60 = v156;
      if ( v156 )
      {
        if ( !InterlockedDecrement(&v156->Length) && v60 )
        {
          if ( v60->bstr )
          {
            SysFreeString(v60->bstr);
            v60->bstr = 0;
          }
          if ( v60->hKey )
          {
            j_j__free(v60->hKey);
            v60->hKey = 0;
          }
          j__free(v60);
        }
        v156 = 0;
      }
      v61 = v155;
      if ( v155 )
      {
        if ( !InterlockedDecrement(&v155->Length) && v61 )
        {
          if ( v61->bstr )
          {
            SysFreeString(v61->bstr);
            v61->bstr = 0;
          }
          if ( v61->hKey )
          {
            j_j__free(v61->hKey);
            v61->hKey = 0;
          }
          j__free(v61);
        }
        v155 = 0;
      }
      v62 = v154;
      if ( v154 )
      {
        if ( !InterlockedDecrement(&v154->Length) && v62 )
        {
          if ( v62->bstr )
          {
            SysFreeString(v62->bstr);
            v62->bstr = 0;
          }
          if ( v62->hKey )
          {
            j_j__free(v62->hKey);
            v62->hKey = 0;
          }
          j__free(v62);
        }
        v154 = 0;
      }
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement(v51 + 2) )
      {
        if ( *v51 )
        {
          SysFreeString(*v51);
          *v51 = 0;
        }
        if ( v51[1] )
        {
          j_j__free(v51[1]);
          v51[1] = 0;
        }
        j__free(v51);
      }
      v63 = operator new(0xCu);
      v64 = v63;
      v148 = v63;
      LOBYTE(v172) = 32;
      if ( v63 )
      {
        v145 = "\"";
        v63[1] = 0;
        v63[2] = 1;
        *v63 = AsciiToUTF(v145);
      }
      else
      {
        v64 = 0;
      }
      LOBYTE(v172) = 1;
      *psz = v64;
      if ( !v64 )
        goto LABEL_311;
      LOBYTE(v172) = 33;
      v65 = sub_12218A0(&ppv, &v166[1].hKey);
      LOBYTE(v172) = 34;
      v66 = sub_12214F0(&v152, "\"creation_datetime\": \"", v65);
      LOBYTE(v172) = 35;
      v67 = CComBSTR::AppendTail(v66, &v153, psz);
      LOBYTE(v172) = 36;
      v68 = operator new(0xCu);
      v148 = v68;
      LOBYTE(v172) = 37;
      if ( v68 )
      {
        v69 = ConcatenateBSTR(v68, &v170.Length, v67);
        v166 = v69;
      }
      else
      {
        v69 = 0;
        v166 = 0;
      }
      LOBYTE(v172) = 36;
      if ( !v69 )
        goto LABEL_311;
      if ( !InterlockedDecrement((*v168 + 8)) )
      {
        v70 = *v168;
        if ( **v168 )
        {
          SysFreeString(**v168);
          v70 = *v168;
          **v168 = 0;
        }
        if ( v70[1] )
        {
          j_j__free(v70[1]);
          v70 = *v168;
          *(*v168 + 4) = 0;
        }
        j__free(v70);
      }
      v170.Length = v69;
      v71 = v153;
      if ( v153 )
      {
        if ( !InterlockedDecrement(&v153->Length) && v71 )
        {
          if ( v71->bstr )
          {
            SysFreeString(v71->bstr);
            v71->bstr = 0;
          }
          if ( v71->hKey )
          {
            j_j__free(v71->hKey);
            v71->hKey = 0;
          }
          j__free(v71);
        }
        v153 = 0;
      }
      v72 = v152;
      if ( v152 )
      {
        if ( !InterlockedDecrement(v152 + 2) && v72 )
        {
          if ( *v72 )
          {
            SysFreeString(*v72);
            *v72 = 0;
          }
          if ( *(v72 + 1) )
          {
            j_j__free(*(v72 + 1));
            *(v72 + 1) = 0;
          }
          j__free(v72);
        }
        v152 = 0;
      }
      v73 = ppv;
      if ( ppv )
      {
        if ( !InterlockedDecrement(&ppv->Length) && v73 )
        {
          if ( v73->bstr )
          {
            SysFreeString(v73->bstr);
            v73->bstr = 0;
          }
          if ( v73->hKey )
          {
            j_j__free(v73->hKey);
            v73->hKey = 0;
          }
          j__free(v73);
        }
        ppv = 0;
      }
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement(v64 + 2) )
      {
        if ( *v64 )
        {
          SysFreeString(*v64);
          *v64 = 0;
        }
        if ( v64[1] )
        {
          j_j__free(v64[1]);
          v64[1] = 0;
        }
        j__free(v64);
      }
      v74 = operator new(0xCu);
      v75 = v74;
      v148 = v74;
      LOBYTE(v172) = 38;
      if ( v74 )
      {
        v145 = "}";
        v74[1] = 0;
        v74[2] = 1;
        *v74 = AsciiToUTF(v145);
      }
      else
      {
        v75 = 0;
      }
      LOBYTE(v172) = 1;
      *psz = v75;
      if ( !v75 )
        goto LABEL_311;
      LOBYTE(v172) = 39;
      v76 = operator new(0xCu);
      v148 = v76;
      LOBYTE(v172) = 40;
      v7 = v76 ? ConcatenateBSTR(v76, &v170.Length, psz) : 0;
      LOBYTE(v172) = 39;
      if ( !v7 )
        goto LABEL_311;
      if ( !InterlockedDecrement(&v166->Length) )
      {
        v77 = v166;
        if ( v166->bstr )
        {
          SysFreeString(v166->bstr);
          v77 = v166;
          v166->bstr = 0;
        }
        if ( v77->hKey )
        {
          j_j__free(v77->hKey);
          v77 = v166;
          v166->hKey = 0;
        }
        j__free(v77);
      }
      v170.Length = v7;
      LOBYTE(v172) = 1;
      if ( !InterlockedDecrement(v75 + 2) )
      {
        if ( *v75 )
        {
          SysFreeString(*v75);
          *v75 = 0;
        }
        if ( v75[1] )
        {
          j_j__free(v75[1]);
          v75[1] = 0;
        }
        j__free(v75);
      }
      ++v165;
      v8 = *v8;
    }
    while ( v8 != *(v170.hKey + 2) );
    v6 = SysFreeString;
  }
  v78 = operator new(0xCu);
  v79 = v78;
  v148 = v78;
  LOBYTE(v172) = 41;
  if ( v78 )
  {
    v145 = "]";
    v78[1] = 0;
    v78[2] = 1;
    *v78 = AsciiToUTF(v145);
  }
  else
  {
    v79 = 0;
  }
  LOBYTE(v172) = 1;
  *psz = v79;
  if ( !v79 )
LABEL_311:
    com_error::throw(-2147024882);
  LOBYTE(v172) = 42;
  v80 = operator new(0xCu);
  v148 = v80;
  LOBYTE(v172) = 43;
  if ( v80 )
    v81 = ConcatenateBSTR(v80, &v170.Length, psz);
  else
    v81 = 0;
  ppv = v81;
  LOBYTE(v172) = 42;
  if ( !v81 )
    com_error::throw(-2147024882);
  if ( v7 && !InterlockedDecrement(v7 + 2) )
  {
    if ( *v7 )
    {
      v6(*v7);
      *v7 = 0;
    }
    if ( v7[1] )
    {
      j_j__free(v7[1]);
      v7[1] = 0;
    }
    j__free(v7);
  }
  v82 = ppv;
  v170.Length = ppv;
  if ( !InterlockedDecrement(v79 + 2) )
  {
    if ( *v79 )
    {
      v6(*v79);
      *v79 = 0;
    }
    if ( *(v79 + 1) )
    {
      j_j__free(*(v79 + 1));
      *(v79 + 1) = 0;
    }
    j__free(v79);
  }
  *v168 = 0;
  v145 = v168;
  v148 = &v144;
  v144 = v82;
  InterlockedIncrement(&v82->Length);
  v143 = v83;
  ppComBSTR2 = &v143;
  LOBYTE(v172) = 45;
  bstr_t::EqualAssign(&v143, L"Content-Type: application/json\r\n");
  LOBYTE(v172) = 46;
  v84 = operator new(0xCu);
  v85 = v84;
  *psz = v84;
  LOBYTE(v172) = 47;
  if ( v84 )
  {
    v142 = "4e3202fdbe953d628f650229af5b3eb49cd46b2d3bfe5546ae3c5fa48b554e0c";
    v84[1] = 0;
    v84[2] = 1;
    *v84 = AsciiToUTF(v142);
  }
  else
  {
    v85 = 0;
  }
  LOBYTE(v172) = 46;
  *psz = v85;
  if ( !v85 )
    com_error::throw(-2147024882);
  LOBYTE(v172) = 48;
  v86 = bstr_t::EqualAssign(&ppv, L"/partners/sysinternals/file-reports?apikey=");
  v142 = v87;
  LOBYTE(v172) = 49;
  CComBSTR::AppendTail(v86, &v142, psz);
  LOBYTE(v172) = 51;
  v88 = sub_1224F00(v170.hKey, v142, v143, v144, v145);
  v89 = ppv;
  dwMessageId = v88;
  if ( ppv )
  {
    if ( !InterlockedDecrement(&ppv->Length) && v89 )
    {
      if ( v89->bstr )
      {
        v6(v89->bstr);
        v89->bstr = 0;
      }
      if ( v89->hKey )
      {
        j_j__free(v89->hKey);
        v89->hKey = 0;
      }
      j__free(v89);
    }
    ppv = 0;
  }
  LOBYTE(v172) = 44;
  if ( !InterlockedDecrement(v85 + 2) )
  {
    if ( *v85 )
    {
      v6(*v85);
      *v85 = 0;
    }
    if ( *(v85 + 1) )
    {
      j_j__free(*(v85 + 1));
      *(v85 + 1) = 0;
    }
    j__free(v85);
  }
  v90 = dwMessageId;
  v91 = *v168;
  if ( dwMessageId || !*v168 || !**v168 || (v145 = **v168, !SysStringLen(v145)) )
  {
    v130 = 0;
    v170.bstr = 0;
    LOBYTE(v172) = 56;
    if ( v90 )
    {
      if ( v90 != 232 )
      {
        v131 = sub_1224320(psz, v90);
        if ( &v170 != v131 )
        {
          bstr_t::Data_t::Free(&v170);
          v130 = v131->bstr;
          v170.bstr = v130;
          if ( v130 )
            InterlockedIncrement(v130 + 2);
        }
        bstr_t::Data_t::Free(psz);
        goto LABEL_455;
      }
      v145 = L"Throttled request. Try again later.";
    }
    else
    {
      v145 = L"Unable to connect to VT";
    }
    bstr_t::Assign(&v170, v145);
    v130 = v170.bstr;
LABEL_455:
    v132 = *(v170.hKey + 2);
    v133 = *v132;
    if ( *v132 != v132 )
    {
      v134 = v170.hKey;
      do
      {
        v135 = (v133[2] + 24);
        *psz = v135;
        if ( v135 != &v170 )
        {
          bstr_t::Data_t::Free(v135);
          **psz = v130;
          if ( v130 )
            InterlockedIncrement(v130 + 2);
        }
        v133 = *v133;
      }
      while ( v133 != *(v134 + 2) );
      v91 = *v168;
    }
    v4 = 13;
    v123 = &v170;
    goto LABEL_463;
  }
  v92 = v170.hKey;
  *psz = *v91;
  sub_1224530(v170.hKey, &ppComBSTR, psz, &v146);
  v145 = v93;
  LOBYTE(v172) = 52;
  CComBSTR::AssignA(&v145, "result");
  sub_1224950(&v166, &v146, v145);
  LOBYTE(v172) = 53;
  if ( v166 )
    v94 = v166->bstr;
  else
    v94 = 0;
  if ( _wcsicmp(v94, L"-1") )
  {
    v96 = v166 ? v166->bstr : 0;
    if ( _wcsicmp(v96, L"0") )
    {
      v145 = v95;
      CComBSTR::AssignA(&v145, "data");
      sub_1224950(&v152, &v146, v145);
      LOBYTE(v172) = 54;
      if ( v152 )
        v97 = *v152;
      else
        v97 = 0;
      *psz = wcschr(v97, 0x5Bu) + 1;
      v98 = *(v92 + 2);
      v99 = *v98;
      if ( *v98 == v98 )
      {
LABEL_397:
        v117 = *(v92 + 2);
        v118 = *v117;
        if ( *v117 != v117 )
        {
          do
          {
            v119 = v118[2];
            v120 = *(v119 + 28);
            if ( !v120 || (v121 = *v120) == 0 || !SysStringLen(v121) )
            {
              if ( *(v170.hKey + 24) )
                dwMessageId = CHttp::Requery(v170.hKey, v119, v168);
              else
                bstr_t::Assign((v119 + 32), L"Unknown");
            }
            v118 = *v118;
          }
          while ( v118 != *(v170.hKey + 2) );
          v91 = *v168;
        }
        v122 = v152;
        if ( v152 && !InterlockedDecrement(v152 + 2) && v122 )
        {
          if ( *v122 )
          {
            SysFreeString(*v122);
            *v122 = 0;
          }
          if ( *(v122 + 1) )
          {
            j_j__free(*(v122 + 1));
            *(v122 + 1) = 0;
          }
          j__free(v122);
        }
        v4 = dwMessageId;
        bstr_t::Data_t::Free(&v166);
        v123 = &ppComBSTR;
        goto LABEL_463;
      }
      v100 = v170.hKey;
      while ( 1 )
      {
        v165 = v99[2];
        v101 = sub_1224530(v100, &ppv, psz, &v146);
        if ( &ppComBSTR == v101 )
          goto LABEL_370;
        bstr_t::Data_t::Free(&ppComBSTR);
        v102 = *v101;
        ppComBSTR = v102;
        if ( v102 )
          break;
LABEL_371:
        v103 = ppv;
        if ( ppv )
        {
          if ( !InterlockedDecrement(&ppv->Length) && v103 )
          {
            if ( v103->bstr )
            {
              SysFreeString(v103->bstr);
              v103->bstr = 0;
            }
            if ( v103->hKey )
            {
              j_j__free(v103->hKey);
              v103->hKey = 0;
            }
            j__free(v103);
          }
          v102 = ppComBSTR;
          ppv = 0;
        }
        if ( v102 )
        {
          v104 = v102->bstr;
          if ( v104 )
          {
            if ( SysStringLen(v104) )
            {
              v145 = L"true";
              v144 = v105;
              bstr_t::EqualAssign(&v144, L"found");
              v106 = *sub_1224950(&ppComBSTR2, &v146, v144);
              v107 = v106 ? v106->bstr : 0;
              v171 = _wcsicmp(v107, v145) == 0;
              bstr_t::Data_t::Free(&ppComBSTR2);
              if ( v171 )
              {
                v145 = v108;
                bstr_t::EqualAssign(&v145, L"detection_ratio");
                v109 = sub_1224950(&v154, &v146, v145);
                v110 = (v165 + 32);
                v153 = v109;
                if ( (v165 + 32) != v109 )
                {
                  bstr_t::Data_t::Free((v165 + 32));
                  v111 = v153->bstr;
                  *v110 = v153->bstr;
                  if ( v111 )
                    InterlockedIncrement(v111 + 2);
                }
                bstr_t::Data_t::Free(&v154);
                v145 = v112;
                bstr_t::EqualAssign(&v145, L"Permalink");
                v113 = sub_1224950(&v155, &v146, v145);
                v114 = (v165 + 28);
                v153 = v113;
                if ( (v165 + 28) != v113 )
                {
                  bstr_t::Data_t::Free((v165 + 28));
                  v115 = v153->bstr;
                  *v114 = v153->bstr;
                  if ( v115 )
                    InterlockedIncrement(v115 + 2);
                }
                bstr_t::Data_t::Free(&v155);
              }
              else
              {
                v116 = v165;
                bstr_t::Assign((v165 + 32), gpszTargetName);
                bstr_t::Assign(v116 + 7, gpszTargetName);
              }
              v99 = *v99;
              if ( v99 != *(v100 + 2) )
                continue;
            }
          }
        }
        v91 = *v168;
        v92 = v170.hKey;
        goto LABEL_397;
      }
      InterlockedIncrement(&v102->Length);
LABEL_370:
      v102 = ppComBSTR;
      goto LABEL_371;
    }
  }
  v145 = v95;
  bstr_t::EqualAssign(&v145, L"message");
  sub_1224950(&v153, &v146, v145);
  LOBYTE(v172) = 55;
  if ( !v153 || !v153->bstr || (v145 = v153->bstr, !SysStringLen(v145)) )
  {
    v4 = 0;
    goto LABEL_444;
  }
  v124 = *(v92 + 2);
  v125 = *v124;
  if ( *v124 == v124 )
    goto LABEL_443;
  v126 = v170.hKey;
  do
  {
    ppv = v125[2];
    v127 = CComBSTR::AssignA(&v152, "message");
    v128 = (*sub_1282F90(&v146, &v148, v127))[5];
    if ( v128 )
      InterlockedIncrement((v128 + 8));
    if ( &ppv[2] != psz )
    {
      bstr_t::Data_t::Free(&ppv[2]);
      ppv[2].bstr = v128;
      if ( !v128 )
        goto LABEL_432;
      InterlockedIncrement((v128 + 8));
    }
    if ( v128 && !InterlockedDecrement((v128 + 8)) )
    {
      if ( *v128 )
      {
        SysFreeString(*v128);
        *v128 = 0;
      }
      if ( *(v128 + 4) )
      {
        j_j__free(*(v128 + 4));
        *(v128 + 4) = 0;
      }
      j__free(v128);
    }
LABEL_432:
    v129 = v152;
    if ( v152 )
    {
      if ( !InterlockedDecrement(v152 + 2) && v129 )
      {
        if ( *v129 )
        {
          SysFreeString(*v129);
          *v129 = 0;
        }
        if ( *(v129 + 1) )
        {
          j_j__free(*(v129 + 1));
          *(v129 + 1) = 0;
        }
        j__free(v129);
      }
      v152 = 0;
    }
    v125 = *v125;
  }
  while ( v125 != *(v126 + 2) );
  v91 = *v168;
LABEL_443:
  v4 = dwMessageId;
LABEL_444:
  bstr_t::Data_t::Free(&v153);
  bstr_t::Data_t::Free(&v166);
  v123 = &ppComBSTR;
LABEL_463:
  bstr_t::Data_t::Free(v123);
  v136 = v170.hKey;
  v137 = *(v170.hKey + 2);
  v138 = *v137;
  *v137 = v137;
  *(*(v136 + 2) + 4) = *(v136 + 8);
  *(v136 + 3) = 0;
  if ( v138 != *(v136 + 2) )
  {
    v139 = v136;
    do
    {
      v140 = *v138;
      j__free(v138);
      v138 = v140;
    }
    while ( v140 != *(v139 + 2) );
    v91 = *v168;
  }
  if ( v91 && !InterlockedDecrement((v91 + 8)) )
  {
    if ( *v91 )
    {
      SysFreeString(*v91);
      *v91 = 0;
    }
    if ( *(v91 + 4) )
    {
      j_j__free(*(v91 + 4));
      *(v91 + 4) = 0;
    }
    j__free(v91);
  }
  bstr_t::Data_t::Free(&v170.Length);
  v2 = v146;
LABEL_475:
  v145 = v2;
  v144 = *v2;
  v172 = -1;
  sub_1226540(&v146, &v148, v144, v2);
  j__free(v146);
  return v4;
}
// 12B4790: using guessed type wchar_t aThrottledReque[36];

//----- (012237E0) --------------------------------------------------------
CComBSTR *__thiscall sub_12237E0(_DWORD *this)
{
  _DWORD *v1; // ebx
  HKEY *v2; // eax
  char *v3; // esi
  CComBSTR *v4; // esi
  BSTR **v5; // eax
  _bstr_t *v6; // eax
  _DWORD *v7; // eax
  LONG (__stdcall *v8)(volatile LONG *); // ebx
  _DWORD *v9; // edi
  CComBSTR *v10; // eax
  CComBSTR *v11; // esi
  CComBSTR *v12; // eax
  CComBSTR *v13; // eax
  CComBSTR *v14; // esi
  CComBSTR *v15; // eax
  CComBSTR *v16; // ebx
  HKEY v17; // ebx
  HKEY *v18; // ecx
  void *v19; // ecx
  int v20; // edi
  CComBSTR *v21; // ebx
  const wchar_t **v22; // esi
  const wchar_t *v23; // esi
  CComBSTR *v24; // edi
  void *v25; // ecx
  wchar_t **v26; // eax
  wchar_t *v27; // ebx
  CComBSTR **v28; // esi
  void *v29; // esi
  HKEY v30; // ecx
  OLECHAR *v31; // eax
  OLECHAR *v32; // esi
  BSTR v33; // eax
  CComBSTR *v34; // eax
  const wchar_t *v35; // eax
  int v36; // eax
  wchar_t *v37; // ecx
  void *v38; // esi
  char v39; // al
  wchar_t *v40; // ecx
  _bstr_t *v41; // eax
  CComBSTR *v42; // eax
  int v43; // edx
  CComBSTR *v44; // ecx
  int *v45; // eax
  int v46; // esi
  BSTR v47; // eax
  CComBSTR *v48; // esi
  CComBSTR *v49; // esi
  CComBSTR *v50; // esi
  CComBSTR *v51; // ecx
  int *v52; // eax
  int v53; // esi
  BSTR v54; // eax
  CComBSTR *v55; // esi
  wchar_t *v56; // eax
  CComBSTR *v57; // esi
  CComBSTR *v58; // esi
  LONG (__stdcall *v59)(volatile LONG *); // edi
  void *v60; // ebx
  HKEY v61; // esi
  BSTR v63; // esi
  CComBSTR *v64; // edi
  _DWORD *v65; // eax
  _DWORD *v66; // edi
  CComBSTR *v67; // eax
  BSTR v68; // ebx
  void *v69; // [esp-10h] [ebp-80h]
  OLECHAR *v70; // [esp-Ch] [ebp-7Ch]
  HKEY v71; // [esp-8h] [ebp-78h]
  wchar_t *v72; // [esp-4h] [ebp-74h]
  void *v73; // [esp+10h] [ebp-60h]
  int v74; // [esp+14h] [ebp-5Ch]
  void *v75; // [esp+18h] [ebp-58h]
  CComBSTR *v76; // [esp+1Ch] [ebp-54h]
  CComBSTR *ppComBSTR; // [esp+20h] [ebp-50h]
  CComBSTR *ppComBSTR1; // [esp+24h] [ebp-4Ch]
  CComBSTR *v79; // [esp+28h] [ebp-48h]
  void *v80; // [esp+2Ch] [ebp-44h]
  void *v81; // [esp+30h] [ebp-40h]
  OLECHAR psz[2]; // [esp+34h] [ebp-3Ch]
  CComBSTR *ppComBSTR2; // [esp+38h] [ebp-38h]
  void *v84; // [esp+3Ch] [ebp-34h]
  CComBSTR *v85; // [esp+40h] [ebp-30h]
  CComBSTR *v86; // [esp+44h] [ebp-2Ch]
  CComBSTR *v87; // [esp+48h] [ebp-28h]
  CComBSTR *ppv; // [esp+4Ch] [ebp-24h]
  int v89; // [esp+50h] [ebp-20h]
  CComBSTR v90; // [esp+54h] [ebp-1Ch]
  char v91; // [esp+63h] [ebp-Dh]
  int v92; // [esp+6Ch] [ebp-4h]

  v1 = this;
  v90.Length = this;
  v74 = 0;
  v2 = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  v73 = v2;
  v3 = 0;
  v92 = 0;
  v84 = 0;
  if ( !v1[5] )
  {
    v4 = 232;
    goto LABEL_188;
  }
  CComBSTR::AssignA(&ppComBSTR2, "&resource=");
  LOBYTE(v92) = 1;
  v5 = CComBSTR::AssignA(&ppComBSTR1, "4e3202fdbe953d628f650229af5b3eb49cd46b2d3bfe5546ae3c5fa48b554e0c");
  LOBYTE(v92) = 2;
  v6 = sub_12214F0(&ppComBSTR, "apikey=", v5);
  LOBYTE(v92) = 3;
  CComBSTR::AppendTail(v6, &v90.hKey, &ppComBSTR2);
  bstr_t::Data_t::Free(&ppComBSTR);
  bstr_t::Data_t::Free(&ppComBSTR1);
  LOBYTE(v92) = 7;
  bstr_t::Data_t::Free(&ppComBSTR2);
  v7 = v1[4];
  v8 = InterlockedDecrement;
  v9 = *v7;
  if ( *v7 != v7 )
  {
    do
    {
      v80 = v9[2];
      bstr_t::Assign(v80 + 6, gpszTargetName);
      if ( v3 )
      {
        v10 = operator new(0xCu);
        v11 = v10;
        v76 = v10;
        LOBYTE(v92) = 8;
        if ( v10 )
        {
          v72 = ",";
          v10->hKey = 0;
          v10->Length = 1;
          v10->bstr = AsciiToUTF(v72);
        }
        else
        {
          v11 = 0;
        }
        LOBYTE(v92) = 7;
        v79 = v11;
        if ( !v11 )
          goto LABEL_74;
        LOBYTE(v92) = 9;
        v12 = operator new(0xCu);
        v76 = v12;
        LOBYTE(v92) = 10;
        v13 = (v12 ? ConcatenateBSTR(v12, &v90.hKey, &v79) : 0);
        ppComBSTR2 = v13;
        LOBYTE(v92) = 9;
        if ( !v13 )
          goto LABEL_74;
        bstr_t::Data_t::Free(&v90.hKey);
        v90.hKey = ppComBSTR2;
        if ( !v8(&v11->Length) )
        {
          if ( v11->bstr )
          {
            SysFreeString(v11->bstr);
            v11->bstr = 0;
          }
          if ( v11->hKey )
          {
            j_j__free(v11->hKey);
            v11->hKey = 0;
          }
          j__free(v11);
        }
      }
      v14 = *(v80 + 2);
      v79 = v14;
      if ( v14 )
        InterlockedIncrement(&v14->Length);
      LOBYTE(v92) = 11;
      v15 = operator new(0xCu);
      v76 = v15;
      LOBYTE(v92) = 12;
      if ( v15 )
      {
        v16 = ConcatenateBSTR(v15, &v90.hKey, &v79);
        ppComBSTR2 = v16;
      }
      else
      {
        v16 = 0;
        ppComBSTR2 = 0;
      }
      LOBYTE(v92) = 11;
      if ( !v16 )
LABEL_74:
        com_error::throw(-2147024882);
      v17 = v90.hKey;
      if ( v90.hKey && !InterlockedDecrement(v90.hKey + 2) && v17 )
      {
        if ( *v17 )
        {
          SysFreeString(*v17);
          *v17 = 0;
        }
        if ( *(v17 + 1) )
        {
          j_j__free(*(v17 + 1));
          *(v17 + 1) = 0;
        }
        j__free(v17);
      }
      v8 = InterlockedDecrement;
      v90.hKey = ppComBSTR2;
      LOBYTE(v92) = 7;
      if ( v14 && !InterlockedDecrement(&v14->Length) )
      {
        if ( v14->bstr )
        {
          SysFreeString(v14->bstr);
          v14->bstr = 0;
        }
        if ( v14->hKey )
        {
          j_j__free(v14->hKey);
          v14->hKey = 0;
        }
        j__free(v14);
      }
      v9 = *v9;
      v3 = v84 + 1;
      v84 = v84 + 1;
    }
    while ( v9 != *(v90.Length + 16) );
  }
  v84 = 0;
  v72 = &v84;
  v76 = &v71;
  v18 = &v71;
  v71 = v90.hKey;
  if ( v90.hKey )
    InterlockedIncrement(v90.hKey + 2);
  v70 = v18;
  ppComBSTR = &v70;
  LOBYTE(v92) = 14;
  bstr_t::EqualAssign(&v70, L"Content-Type: application/x-www-form-urlencoded\r\n");
  v69 = v19;
  LOBYTE(v92) = 15;
  bstr_t::EqualAssign(&v69, L"vtapi/v2/file/report");
  v20 = v90.Length;
  LOBYTE(v92) = 13;
  v21 = sub_1224F00(v90.Length, v69, v70, v71, v72);
  ppComBSTR2 = v21;
  if ( !v21 )
  {
    v22 = v84;
    if ( v84 )
    {
      if ( *v84 )
      {
        v72 = *v84;
        if ( SysStringLen(v72) )
        {
          v23 = *v22;
          *psz = v23;
          if ( wcschr(v23, 0x5Bu) )
            *psz = wcschr(v23, 0x5Bu) + 1;
          v24 = 0;
          v85 = 0;
          v25 = v90.Length;
          LOBYTE(v92) = 16;
          v26 = *(v90.Length + 16);
          v27 = *v26;
          if ( *v26 != v26 )
          {
            do
            {
              v89 = *(v27 + 2);
              v28 = sub_1224530(v25, &v81, psz, &v73);
              if ( &v85 != v28 )
              {
                if ( v24 && !InterlockedDecrement(&v24->Length) )
                {
                  if ( v24->bstr )
                  {
                    SysFreeString(v24->bstr);
                    v24->bstr = 0;
                  }
                  if ( v24->hKey )
                  {
                    j_j__free(v24->hKey);
                    v24->hKey = 0;
                  }
                  j__free(v24);
                }
                v24 = *v28;
                v85 = v24;
                if ( v24 )
                  InterlockedIncrement(&v24->Length);
              }
              v29 = v81;
              if ( v81 )
              {
                if ( !InterlockedDecrement(v81 + 2) && v29 )
                {
                  if ( *v29 )
                  {
                    SysFreeString(*v29);
                    *v29 = 0;
                  }
                  if ( *(v29 + 1) )
                  {
                    j_j__free(*(v29 + 1));
                    *(v29 + 1) = 0;
                  }
                  j__free(v29);
                }
                v81 = 0;
              }
              if ( !v24 )
                break;
              if ( !v24->bstr )
                break;
              v72 = v24->bstr;
              if ( !SysStringLen(v72) )
                break;
              v72 = L"1";
              v71 = v30;
              v76 = &v71;
              v31 = operator new(0xCu);
              v32 = v31;
              v75 = v31;
              LOBYTE(v92) = 17;
              if ( v31 )
              {
                v70 = L"response_code";
                *(v31 + 1) = 0;
                *(v31 + 2) = 1;
                v33 = SysAllocString(v70);
                *v32 = v33;
                if ( !v33 )
                  goto LABEL_74;
              }
              else
              {
                v32 = 0;
              }
              LOBYTE(v92) = 16;
              v76->bstr = v32;
              if ( !v32 )
                goto LABEL_74;
              v34 = *sub_1224950(&v80, &v73, v71);
              if ( v34 )
                v35 = v34->bstr;
              else
                v35 = 0;
              v36 = _wcsicmp(v35, v72);
              v38 = v80;
              v39 = v36 == 0;
              v91 = v39;
              if ( v80 )
              {
                if ( !InterlockedDecrement(v80 + 2) && v38 )
                {
                  if ( *v38 )
                  {
                    SysFreeString(*v38);
                    *v38 = 0;
                  }
                  if ( *(v38 + 1) )
                  {
                    j_j__free(*(v38 + 1));
                    *(v38 + 1) = 0;
                  }
                  j__free(v38);
                }
                v39 = v91;
                v80 = 0;
              }
              if ( v39 )
              {
                v72 = v37;
                bstr_t::EqualAssign(&v72, L"positives");
                sub_1224950(&v86, &v73, v72);
                v72 = v40;
                LOBYTE(v92) = 18;
                bstr_t::EqualAssign(&v72, L"total");
                sub_1224950(&v87, &v73, v72);
                LOBYTE(v92) = 19;
                bstr_t::EqualAssign(&ppv, L"/");
                LOBYTE(v92) = 20;
                v41 = CComBSTR::AppendTail(&v86, &ppComBSTR1, &ppv);
                LOBYTE(v92) = 21;
                v42 = CComBSTR::AppendTail(v41, &v79, &v87);
                v43 = v89;
                v44 = v42;
                v76 = v42;
                v45 = (v89 + 32);
                if ( (v89 + 32) != v76 )
                {
                  v46 = *v45;
                  if ( *v45 )
                  {
                    if ( !InterlockedDecrement((v46 + 8)) && v46 )
                    {
                      if ( *v46 )
                      {
                        SysFreeString(*v46);
                        *v46 = 0;
                      }
                      if ( *(v46 + 4) )
                      {
                        j_j__free(*(v46 + 4));
                        *(v46 + 4) = 0;
                      }
                      j__free(v46);
                    }
                    v43 = v89;
                    v44 = v76;
                    *(v89 + 32) = 0;
                  }
                  v47 = v44->bstr;
                  *(v43 + 32) = v44->bstr;
                  if ( v47 )
                    InterlockedIncrement(v47 + 2);
                }
                v48 = v79;
                if ( v79 )
                {
                  if ( !InterlockedDecrement(&v79->Length) && v48 )
                  {
                    if ( v48->bstr )
                    {
                      SysFreeString(v48->bstr);
                      v48->bstr = 0;
                    }
                    if ( v48->hKey )
                    {
                      j_j__free(v48->hKey);
                      v48->hKey = 0;
                    }
                    j__free(v48);
                  }
                  v79 = 0;
                }
                v49 = ppComBSTR1;
                if ( ppComBSTR1 )
                {
                  if ( !InterlockedDecrement(&ppComBSTR1->Length) && v49 )
                  {
                    if ( v49->bstr )
                    {
                      SysFreeString(v49->bstr);
                      v49->bstr = 0;
                    }
                    if ( v49->hKey )
                    {
                      j_j__free(v49->hKey);
                      v49->hKey = 0;
                    }
                    j__free(v49);
                  }
                  ppComBSTR1 = 0;
                }
                v50 = ppv;
                LOBYTE(v92) = 19;
                if ( ppv )
                {
                  if ( !InterlockedDecrement(&ppv->Length) )
                  {
                    if ( v50->bstr )
                    {
                      SysFreeString(v50->bstr);
                      v50->bstr = 0;
                    }
                    if ( v50->hKey )
                    {
                      j_j__free(v50->hKey);
                      v50->hKey = 0;
                    }
                    j__free(v50);
                  }
                  ppv = 0;
                }
                v72 = v44;
                bstr_t::EqualAssign(&v72, L"Permalink");
                v51 = sub_1224950(&ppComBSTR, &v73, v72);
                v52 = (v89 + 28);
                v76 = v51;
                if ( (v89 + 28) != v51 )
                {
                  v53 = *v52;
                  if ( *v52 )
                  {
                    if ( !InterlockedDecrement((v53 + 8)) && v53 )
                    {
                      if ( *v53 )
                      {
                        SysFreeString(*v53);
                        *v53 = 0;
                      }
                      if ( *(v53 + 4) )
                      {
                        j_j__free(*(v53 + 4));
                        *(v53 + 4) = 0;
                      }
                      j__free(v53);
                    }
                    v51 = v76;
                    *(v89 + 28) = 0;
                  }
                  v54 = v51->bstr;
                  *(v89 + 28) = v51->bstr;
                  if ( v54 )
                    InterlockedIncrement(v54 + 2);
                }
                v55 = ppComBSTR;
                if ( ppComBSTR )
                {
                  if ( !InterlockedDecrement(&ppComBSTR->Length) && v55 )
                  {
                    if ( v55->bstr )
                    {
                      SysFreeString(v55->bstr);
                      v55->bstr = 0;
                    }
                    if ( v55->hKey )
                    {
                      j_j__free(v55->hKey);
                      v55->hKey = 0;
                    }
                    j__free(v55);
                  }
                  ppComBSTR = 0;
                }
                v56 = v27;
                v27 = *v27;
                v72 = v56;
                **(v56 + 1) = *v56;
                *(*v56 + 4) = *(v56 + 1);
                --*(v90.Length + 20);
                j__free(v72);
                v57 = v87;
                if ( v87 )
                {
                  if ( !InterlockedDecrement(&v87->Length) && v57 )
                  {
                    if ( v57->bstr )
                    {
                      SysFreeString(v57->bstr);
                      v57->bstr = 0;
                    }
                    if ( v57->hKey )
                    {
                      j_j__free(v57->hKey);
                      v57->hKey = 0;
                    }
                    j__free(v57);
                  }
                  v87 = 0;
                }
                v58 = v86;
                LOBYTE(v92) = 16;
                if ( v86 )
                {
                  if ( !InterlockedDecrement(&v86->Length) && v58 )
                  {
                    if ( v58->bstr )
                    {
                      SysFreeString(v58->bstr);
                      v58->bstr = 0;
                    }
                    if ( v58->hKey )
                    {
                      j_j__free(v58->hKey);
                      v58->hKey = 0;
                    }
                    j__free(v58);
                  }
                  v86 = 0;
                }
              }
              else
              {
                v27 = *v27;
              }
              v25 = v90.Length;
            }
            while ( v27 != *(v90.Length + 16) );
          }
          bstr_t::Data_t::Free(&v85);
          goto LABEL_170;
        }
      }
    }
  }
  v63 = 0;
  v90.bstr = 0;
  LOBYTE(v92) = 22;
  if ( !v21 )
  {
    v72 = L"Unable to connect to VT";
    goto LABEL_197;
  }
  if ( v21 == 232 )
  {
    v72 = L"Throttled request. Try again later.";
LABEL_197:
    bstr_t::Assign(&v90, v72);
    v63 = v90.bstr;
    goto LABEL_198;
  }
  v64 = sub_1224320(&v76, v21);
  if ( &v90 != v64 )
  {
    bstr_t::Data_t::Free(&v90);
    v63 = v64->bstr;
    if ( v64->bstr )
      InterlockedIncrement(v63 + 2);
  }
  bstr_t::Data_t::Free(&v76);
  v20 = v90.Length;
LABEL_198:
  v65 = *(v20 + 16);
  v66 = *v65;
  if ( *v65 != v65 )
  {
    do
    {
      v67 = (v66[2] + 24);
      v76 = v67;
      if ( v67 != &v90 )
      {
        v68 = v67->bstr;
        if ( v67->bstr )
        {
          if ( !InterlockedDecrement(v68 + 2) && v68 )
          {
            if ( *v68 )
            {
              SysFreeString(*v68);
              *v68 = 0;
            }
            if ( *(v68 + 1) )
            {
              j_j__free(*(v68 + 1));
              *(v68 + 1) = 0;
            }
            j__free(v68);
          }
          v67 = v76;
          v76->bstr = 0;
        }
        v67->bstr = v63;
        if ( v63 )
          InterlockedIncrement(v63 + 2);
      }
      v66 = *v66;
    }
    while ( v66 != *(v90.Length + 16) );
  }
  ppComBSTR2 = 13;
  if ( v63 )
  {
    v59 = InterlockedDecrement;
    if ( !InterlockedDecrement(v63 + 2) )
    {
      if ( *v63 )
      {
        SysFreeString(*v63);
        *v63 = 0;
      }
      if ( *(v63 + 1) )
      {
        j_j__free(*(v63 + 1));
        *(v63 + 1) = 0;
      }
      j__free(v63);
    }
    goto LABEL_171;
  }
LABEL_170:
  v59 = InterlockedDecrement;
LABEL_171:
  v60 = v84;
  if ( v84 && !v59(v84 + 2) )
  {
    if ( *v60 )
    {
      SysFreeString(*v60);
      *v60 = 0;
    }
    if ( *(v60 + 1) )
    {
      j_j__free(*(v60 + 1));
      *(v60 + 1) = 0;
    }
    j__free(v60);
  }
  v61 = v90.hKey;
  if ( v90.hKey )
  {
    if ( !v59(v90.hKey + 2) && v61 )
    {
      if ( *v61 )
      {
        SysFreeString(*v61);
        *v61 = 0;
      }
      if ( *(v61 + 1) )
      {
        j_j__free(*(v61 + 1));
        *(v61 + 1) = 0;
      }
      j__free(v61);
    }
    v90.hKey = 0;
  }
  v4 = ppComBSTR2;
  v2 = v73;
LABEL_188:
  v72 = v2;
  v71 = *v2;
  v92 = -1;
  sub_1226540(&v73, &v75, v71, v2);
  j__free(v73);
  return v4;
}
// 12B4790: using guessed type wchar_t aThrottledReque[36];

//----- (01224320) --------------------------------------------------------
int __stdcall sub_1224320(int ppv, DWORD dwMessageId)
{
  HMODULE v2; // eax
  wchar_t *i; // esi
  int v4; // eax
  WCHAR Buffer; // [esp+Ch] [ebp-804h]

  Buffer = 0;
  if ( !FormatMessageW(0x1200u, 0, dwMessageId, 0, &Buffer, 0x400u, 0) )
  {
    v2 = GetModuleHandle(L"winhttp.dll");
    FormatMessageW(0xA00u, v2, dwMessageId, 0, &Buffer, 0x400u, 0);
  }
  if ( Buffer )
  {
    for ( i = wcschr(&Buffer, 0); i > &Buffer; *i = 0 )
    {
      v4 = *(i - 1);
      --i;
      if ( !isspace(v4) )
        break;
    }
  }
  else
  {
    _swprintf(&Buffer, L"Error %d (0x%0x)", dwMessageId, dwMessageId);
  }
  bstr_t::EqualAssign(ppv, &Buffer);
  return ppv;
}

//----- (01224420) --------------------------------------------------------
DWORD __stdcall sub_1224420(void *a1, int a2, int a3)
{
  const WCHAR *v3; // eax
  HANDLE v4; // esi
  DWORD v5; // edi
  DWORD v6; // edi
  void *v7; // ebx
  LARGE_INTEGER FileSize; // [esp+0h] [ebp-Ch]
  DWORD NumberOfBytesRead; // [esp+8h] [ebp-4h]

  if ( a1 )
    v3 = *a1;
  else
    v3 = 0;
  v4 = CreateFile(v3, 0x80000000, 7u, 0, 3u, 0, 0);
  if ( v4 == -1 )
  {
    v5 = GetLastError();
  }
  else
  {
    GetFileSizeEx(v4, &FileSize);
    v6 = FileSize.LowPart;
    if ( FileSize.QuadPart <= 0x2000000 )
    {
      v7 = malloc(FileSize.LowPart);
      if ( ReadFile(v4, v7, v6, &NumberOfBytesRead, 0) )
      {
        CloseHandle(v4);
        v5 = 0;
        *a2 = v7;
        *a3 = FileSize.LowPart;
      }
      else
      {
        free(v7);
        CloseHandle(v4);
        v5 = GetLastError();
      }
    }
    else
    {
      v5 = 223;
    }
  }
  if ( a1 && !InterlockedDecrement(a1 + 2) && a1 )
  {
    if ( *a1 )
    {
      SysFreeString(*a1);
      *a1 = 0;
    }
    if ( *(a1 + 1) )
    {
      j_j__free(*(a1 + 1));
      *(a1 + 1) = 0;
    }
    j__free(a1);
  }
  return v5;
}

//----- (01224530) --------------------------------------------------------
BSTR **__thiscall sub_1224530(void *this, int a2, OLECHAR psz, int a4)
{
  int *v4; // esi
  signed int v5; // edi
  bool v6; // bl
  const wchar_t **v7; // eax
  wchar_t *v8; // eax
  OLECHAR *v9; // edx
  OLECHAR *i; // esi
  int v11; // ecx
  BSTR **v12; // ebx
  BSTR v13; // eax
  bool v14; // zf
  CSysProcItem *v15; // eax
  void *v16; // esi
  void *v17; // esi
  int v19; // [esp+10h] [ebp-2Ch]
  void *v20; // [esp+18h] [ebp-24h]
  void *v21; // [esp+1Ch] [ebp-20h]
  int v22; // [esp+20h] [ebp-1Ch]
  void *v23; // [esp+24h] [ebp-18h]
  void *v24; // [esp+28h] [ebp-14h]
  void *v25; // [esp+2Ch] [ebp-10h]
  int v26; // [esp+38h] [ebp-4h]

  v23 = this;
  *a2 = 0;
  v4 = a4;
  v5 = 1;
  v26 = 0;
  v22 = 1;
  v6 = 0;
  sub_1226500(*(*a4 + 4));
  *(*v4 + 4) = *v4;
  **v4 = *v4;
  *(*v4 + 8) = *v4;
  v7 = psz;
  v4[1] = 0;
  v8 = wcschr(*v7, 0x7Bu);
  if ( v8 )
  {
    v9 = v8 + 1;
    for ( i = v8 + 1; *i; ++i )
    {
      v11 = *i;
      if ( v11 == 125 && v6 != 1 && !v5 )
        break;
      if ( (i != v9 || v11 != 34) && (v11 == 93 || v11 != 34) )
      {
        if ( !v6 )
        {
          if ( v11 == 91 || v11 == 123 )
          {
            ++v5;
          }
          else if ( (v11 == 93 || v11 == 125) && !--v5 )
          {
            break;
          }
        }
      }
      else
      {
        v6 = v6 == 0;
      }
    }
    if ( !*i || v6 )
    {
      v12 = a2;
      bstr_t::Assign(a2, v9);
      *psz = i;
      v4 = a4;
    }
    else
    {
      v12 = a2;
      *i = 0;
      bstr_t::Assign(a2, v9);
      *i = 125;
      *psz = i;
      v4 = a4;
    }
  }
  else
  {
    v12 = a2;
  }
  if ( !*v12 || !**v12 || !SysStringLen(**v12) )
    return v12;
  v13 = *v12 ? **v12 : 0;
  v14 = *v13 == 0;
  *&psz = v13;
  if ( v14 )
    return v12;
  do
  {
    sub_1224810(&v24, &psz, 58);
    v26 = 1;
    sub_1224810(&v25, &psz, 44);
    v20 = v24;
    if ( v24 )
      InterlockedIncrement(v24 + 2);
    v21 = v25;
    if ( v25 )
      InterlockedIncrement(v25 + 2);
    LOBYTE(v26) = 3;
    v15 = sub_12211F0(v4, &v20);
    sub_1221240(v4, &v19, 0, &v15->dwPid, v15);
    sub_1221430(&v20);
    v16 = v25;
    if ( v25 )
    {
      if ( !InterlockedDecrement(v25 + 2) && v16 )
      {
        if ( *v16 )
        {
          SysFreeString(*v16);
          *v16 = 0;
        }
        if ( *(v16 + 1) )
        {
          j_j__free(*(v16 + 1));
          *(v16 + 1) = 0;
        }
        j__free(v16);
      }
      v25 = 0;
    }
    v17 = v24;
    LOBYTE(v26) = 0;
    if ( v24 )
    {
      if ( !InterlockedDecrement(v24 + 2) && v17 )
      {
        if ( *v17 )
        {
          SysFreeString(*v17);
          *v17 = 0;
        }
        if ( *(v17 + 1) )
        {
          j_j__free(*(v17 + 1));
          *(v17 + 1) = 0;
        }
        j__free(v17);
      }
      v24 = 0;
    }
    v4 = a4;
  }
  while ( *psz );
  return a2;
}

//----- (01224810) --------------------------------------------------------
int __stdcall sub_1224810(int a1, OLECHAR *psz, __int16 a3)
{
  char v3; // dl
  int v4; // ecx
  OLECHAR *v5; // edi
  _WORD *v6; // eax
  int v7; // esi
  int v8; // eax
  __int16 v9; // si
  _WORD *v10; // eax
  int result; // eax
  char v12; // [esp+17h] [ebp-Dh]
  OLECHAR *psza; // [esp+30h] [ebp+Ch]

  v3 = 0;
  v4 = 0;
  v12 = 0;
  *a1 = 0;
  v5 = psz;
  if ( **psz )
  {
    do
    {
      if ( **psz != 32 )
        break;
      v6 = (*psz + 2);
      *psz = v6;
    }
    while ( *v6 );
  }
  if ( **psz == 34 )
  {
    v3 = 1;
    v12 = 1;
    *psz += 2;
  }
  v7 = *psz;
  psza = *psz;
  if ( **v5 )
  {
    while ( v4 || v3 || **v5 != a3 )
    {
      v8 = **v5;
      if ( v8 == 34 )
      {
        v3 = v12;
        if ( v12 && !v4 )
          break;
      }
      else
      {
        if ( v8 == 91 )
        {
          ++v4;
        }
        else if ( v8 == 93 )
        {
          --v4;
        }
        else if ( v8 == 92 && **(v5 + 1) == 34 )
        {
          *v5 += 2;
        }
        v3 = v12;
      }
      *v5 += 2;
      if ( !**v5 )
        break;
    }
  }
  if ( v7 )
  {
    v9 = **v5;
    **v5 = 0;
    bstr_t::Assign(a1, psza);
    **v5 = v9;
  }
  if ( **v5 )
  {
    do
    {
      if ( **v5 == a3 )
        break;
      v10 = (*v5 + 2);
      *v5 = v10;
    }
    while ( *v10 );
  }
  result = a1;
  if ( **v5 == a3 )
    *v5 += 2;
  return result;
}

//----- (01224950) --------------------------------------------------------
CComBSTR **__stdcall sub_1224950(int a1, int a2, void *a3)
{
  Data_t *v3; // ebx
  void *v4; // edi
  int *v5; // esi
  char v6; // al
  int v7; // esi
  void *v8; // esi
  char v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]

  v3 = a1;
  v4 = a3;
  v11 = 0;
  *a1 = 0;
  a1 = v4;
  if ( v4 )
    InterlockedIncrement(v4 + 2);
  v5 = *a2;
  v6 = *sub_1282F90(a2, &v10, &a1) != v5;
  HIBYTE(a1) = v6;
  if ( v4 )
  {
    if ( !InterlockedDecrement(v4 + 2) )
    {
      if ( *v4 )
      {
        SysFreeString(*v4);
        *v4 = 0;
      }
      if ( *(v4 + 1) )
      {
        j_j__free(*(v4 + 1));
        *(v4 + 1) = 0;
      }
      j__free(v4);
    }
    v6 = HIBYTE(a1);
  }
  if ( v6 )
  {
    a1 = a3;
    if ( a3 )
      InterlockedIncrement(a3 + 2);
    v7 = (*sub_1282F90(a2, &v10, &a1))[5];
    a2 = v7;
    if ( v7 )
      InterlockedIncrement((v7 + 8));
    if ( v3 != &a2 )
    {
      bstr_t::Data_t::Free(v3);
      v3->m_wstr = v7;
      if ( v7 )
        InterlockedIncrement((v7 + 8));
    }
    bstr_t::Data_t::Free(&a2);
    bstr_t::Data_t::Free(&a1);
  }
  v8 = a3;
  if ( a3 && !InterlockedDecrement(a3 + 2) && v8 )
  {
    if ( *v8 )
    {
      SysFreeString(*v8);
      *v8 = 0;
    }
    if ( *(v8 + 1) )
    {
      j_j__free(*(v8 + 1));
      *(v8 + 1) = 0;
    }
    j__free(v8);
  }
  return v3;
}

//----- (01224AA0) --------------------------------------------------------
DWORD __stdcall CHttp::ReadData(HINTERNET hRequest, CComBSTR *ppComBSTR)
{
  DWORD v2; // ebx
  int v3; // eax
  HKEY v4; // esi
  const unsigned __int16 *v5; // eax
  int v6; // eax
  CHAR *pBuffer; // eax
  CHAR *str; // edi
  DWORD v9; // eax
  const unsigned __int16 *v10; // eax
  int v11; // eax
  HKEY v13; // [esp-4h] [ebp-30h]
  DWORD dwNumberOfBytesRead; // [esp+10h] [ebp-1Ch]
  CComBSTR bstr; // [esp+14h] [ebp-18h]
  int v16; // [esp+28h] [ebp-4h]

  v2 = 0;
  dwNumberOfBytesRead = 0;
  bstr.hKey = 0;
  v16 = 0;
  v3 = CHttp::RequestHeader(hRequest, L"StatusCode", 0x13u, &bstr.hKey);
  v4 = bstr.hKey;
  if ( v3 >= 0 )
  {
    if ( bstr.hKey )
      v5 = *bstr.hKey;
    else
      v5 = 0;
    v6 = wcscmp(v5, L"200");
    if ( v6 )
      v6 = -(v6 < 0) | 1;
    if ( !v6 )
    {
      while ( 1 )
      {
        bstr.Length = 0;
        if ( !WinHttpQueryDataAvailable(hRequest, &bstr.Length) )
          break;
        pBuffer = operator new[](bstr.Length + 1);
        str = pBuffer;
        if ( !pBuffer )
        {
          bstr.Length = 0;
          goto LABEL_28;
        }
        memset(pBuffer, 0, bstr.Length + 1);
        if ( WinHttpReadData(hRequest, str, bstr.Length, &dwNumberOfBytesRead) )
        {
          CComBSTR::AssignA(&bstr, str);
          LOBYTE(v16) = 1;
          bstr_t::Append(ppComBSTR, &bstr);
          LOBYTE(v16) = 0;
          bstr_t::Data_t::Free(&bstr);
        }
        else
        {
          v2 = GetLastError();
        }
        j_j__free(str);
        if ( !bstr.Length )
          goto LABEL_28;
      }
      v9 = GetLastError();
      goto LABEL_27;
    }
  }
  if ( bstr.hKey )
    v10 = *bstr.hKey;
  else
    v10 = 0;
  v11 = wcscmp(v10, L"204");
  if ( v11 )
    v11 = -(v11 < 0) | 1;
  if ( v11 )
  {
    v13 = bstr.hKey;
    if ( bstr.hKey )
      InterlockedIncrement(bstr.hKey + 2);
    v9 = sub_1224D50(v13);
LABEL_27:
    v2 = v9;
    goto LABEL_28;
  }
  v2 = 232;
LABEL_28:
  if ( v4 && !InterlockedDecrement(v4 + 2) )
  {
    if ( *v4 )
    {
      SysFreeString(*v4);
      *v4 = 0;
    }
    if ( *(v4 + 1) )
    {
      j_j__free(*(v4 + 1));
      *(v4 + 1) = 0;
    }
    j__free(v4);
  }
  return v2;
}
// 12B45DC: using guessed type wchar_t a200[4];
// 12B45EC: using guessed type wchar_t a204[4];
// 12B45F4: using guessed type wchar_t aStatuscode[11];

//----- (01224CA0) --------------------------------------------------------
int __stdcall CHttp::RequestHeader(HINTERNET hRequest, int a2, DWORD dwInfoLevel, int a4)
{
  int v4; // esi
  int result; // eax
  OLECHAR *pBuffer; // ebx
  signed int v7; // eax
  unsigned int v8; // esi
  DWORD dwBufferLength; // [esp+8h] [ebp-4h]

  v4 = 0;
  dwBufferLength = 0;
  if ( WinHttpQueryHeaders(hRequest, dwInfoLevel, 0, 0, &dwBufferLength, 0)
    || GetLastError() == ERROR_INSUFFICIENT_BUFFER )
  {
    pBuffer = malloc(dwBufferLength);
    if ( WinHttpQueryHeaders(hRequest, dwInfoLevel, 0, pBuffer, &dwBufferLength, 0) )
    {
      bstr_t::Assign(a4, pBuffer);
    }
    else
    {
      v7 = GetLastError();
      v4 = v7;
      if ( v7 > 0 )
      {
        v8 = v7 | 0x80070000;
        free(pBuffer);
        return v8;
      }
    }
    free(pBuffer);
    result = v4;
  }
  else
  {
    result = GetLastError();
    if ( result > 0 )
      result = result | 0x80070000;
  }
  return result;
}

//----- (01224D50) --------------------------------------------------------
int __stdcall sub_1224D50(void *a1)
{
  const unsigned __int16 *v1; // eax
  int v2; // eax
  signed int v3; // edi
  const unsigned __int16 *v4; // eax
  int v5; // eax
  const unsigned __int16 *v6; // eax
  int v7; // eax

  if ( a1 )
    v1 = *a1;
  else
    v1 = 0;
  v2 = wcscmp(v1, L"200");
  if ( v2 )
    v2 = -(v2 < 0) | 1;
  if ( v2 )
  {
    if ( a1 )
      v4 = *a1;
    else
      v4 = 0;
    v5 = wcscmp(v4, L"403");
    if ( v5 )
      v5 = -(v5 < 0) | 1;
    if ( v5 )
    {
      if ( a1 )
        v6 = *a1;
      else
        v6 = 0;
      v7 = wcscmp(v6, L"204");
      if ( v7 )
        v7 = -(v7 < 0) | 1;
      v3 = 1460;
      if ( v7 )
        v3 = 31;
    }
    else
    {
      v3 = 5;
    }
  }
  else
  {
    v3 = 0;
  }
  if ( a1 && !InterlockedDecrement(a1 + 2) && a1 )
  {
    if ( *a1 )
    {
      SysFreeString(*a1);
      *a1 = 0;
    }
    if ( *(a1 + 1) )
    {
      j_j__free(*(a1 + 1));
      *(a1 + 1) = 0;
    }
    j__free(a1);
  }
  return v3;
}
// 12B45DC: using guessed type wchar_t a200[4];
// 12B45E4: using guessed type wchar_t a403[4];
// 12B45EC: using guessed type wchar_t a204[4];

//----- (01224E80) --------------------------------------------------------
DWORD __thiscall CHttp::Open(CHttp *this, int a2, OLECHAR *psz, char a4, char a5, char a6)
{
  CHttp *v6; // esi
  void *v8; // eax
  CHttp *v9; // eax

  v6 = this;
  LOBYTE(this->field_18) = a6;
  if ( !CHttp::CHttp(a2, psz, a4, a5, 0) )
    return -1;
  v8 = WinHttpOpen(L"VirusTotal", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
  v6->hSession = v8;
  if ( !v8 )
    return GetLastError();
  v9 = WinHttpConnect(v8, L"www.virustotal.com", 0x1BBu, 0);
  v6->hConnection = v9;
  if ( !v9 )
  {
    WinHttpCloseHandle(v6->hSession);
    v6->hSession = 0;
    return GetLastError();
  }
  return 0;
}

//----- (01224F00) --------------------------------------------------------
DWORD __thiscall sub_1224F00(HINTERNET *this, void *a2, void *a3, void *a4, int a5)
{
  HINTERNET *v5; // esi
  const WCHAR *v6; // eax
  void *v7; // ebx
  BSTR *v8; // esi
  UINT v9; // eax
  DWORD v10; // edi
  BSTR v11; // edx
  DWORD v12; // ecx
  const WCHAR *v13; // eax
  DWORD v14; // eax
  DWORD v15; // edi
  LONG (__stdcall *v16)(volatile LONG *); // ecx
  WINHTTP_AUTOPROXY_OPTIONS pAutoProxyOptions; // [esp+10h] [ebp-38h]
  WINHTTP_PROXY_INFO pProxyInfo; // [esp+28h] [ebp-20h]
  HINTERNET *v20; // [esp+34h] [ebp-14h]
  DWORD dwTotalLength; // [esp+38h] [ebp-10h]
  int v22; // [esp+44h] [ebp-4h]

  v5 = this;
  v20 = this;
  v22 = 2;
  if ( a2 )
    v6 = *a2;
  else
    v6 = 0;
  v7 = WinHttpOpenRequest(this[1], L"POST", v6, 0, 0, 0, 0x800000u);
  pAutoProxyOptions.dwFlags = 1;
  pAutoProxyOptions.dwAutoDetectFlags = 3;
  pAutoProxyOptions.fAutoLogonIfChallenged = 1;
  if ( WinHttpGetProxyForUrl(*v5, L"https://www.virustotal.com", &pAutoProxyOptions, &pProxyInfo) )
    WinHttpSetOption(v7, 0x26u, &pProxyInfo, 0xCu);
  v8 = a4;
  if ( !a4 )
  {
    v12 = 0;
    v10 = 0;
LABEL_21:
    v11 = 0;
    goto LABEL_22;
  }
  if ( *a4 )
  {
    v8 = a4;
    dwTotalLength = SysStringLen(*a4);
  }
  else
  {
    dwTotalLength = 0;
  }
  if ( !v8 )
  {
    v12 = dwTotalLength;
    v10 = 0;
    goto LABEL_21;
  }
  if ( *v8 )
  {
    v9 = SysStringLen(*v8);
    v8 = a4;
    v10 = v9;
  }
  else
  {
    v10 = 0;
  }
  if ( !v8 )
  {
    v12 = dwTotalLength;
    goto LABEL_21;
  }
  if ( !v8[1] )
    v8[1] = UTFToAscii(*v8);
  v11 = v8[1];
  v12 = dwTotalLength;
LABEL_22:
  if ( a3 )
    v13 = *a3;
  else
    v13 = 0;
  if ( WinHttpSendRequest(v7, v13, 0, v11, v10, v12, 0) && WinHttpReceiveResponse(v7, 0) )
    v14 = CHttp::ReadData(v7, a5);
  else
    v14 = GetLastError();
  v15 = v14;
  WinHttpCloseHandle(v7);
  v16 = InterlockedDecrement;
  if ( a2 )
  {
    if ( !InterlockedDecrement(a2 + 2) && a2 )
    {
      if ( *a2 )
      {
        SysFreeString(*a2);
        *a2 = 0;
      }
      if ( *(a2 + 1) )
      {
        j_j__free(*(a2 + 1));
        *(a2 + 1) = 0;
      }
      j__free(a2);
    }
    v16 = InterlockedDecrement;
  }
  if ( a3 && !v16(a3 + 2) && a3 )
  {
    if ( *a3 )
    {
      SysFreeString(*a3);
      *a3 = 0;
    }
    if ( *(a3 + 1) )
    {
      j_j__free(*(a3 + 1));
      *(a3 + 1) = 0;
    }
    j__free(a3);
  }
  if ( a4 && !InterlockedDecrement(a4 + 2) && a4 )
  {
    if ( *a4 )
    {
      SysFreeString(*a4);
      *a4 = 0;
    }
    if ( *(a4 + 1) )
    {
      j_j__free(*(a4 + 1));
      *(a4 + 1) = 0;
    }
    j__free(a4);
  }
  return v15;
}

//----- (01225160) --------------------------------------------------------
_DWORD *__thiscall sub_1225160(_DWORD *this, char a2)
{
  int v2; // edi
  _DWORD *v3; // esi
  _DWORD *v4; // edx
  int v5; // eax
  _DWORD *result; // eax

  v2 = this[2];
  v3 = this + 2;
  v4 = sub_1281420(this[2], *(v2 + 4), &a2);
  v5 = v3[1];
  if ( (357913940 - v5) < 1 )
    std::_Xlength_error("list<T> too long");
  v3[1] = v5 + 1;
  *(v2 + 4) = v4;
  result = v4[1];
  *result = v4;
  return result;
}

//----- (012251B0) --------------------------------------------------------
char __thiscall LoadGlobalVariablesFromRegistry(CRegStr *bstrKey, GLOBALVAR *pGlobalVar)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  hMainKey = bstrKey;
  pThis = bstrKey;
  v3 = &bstrKey->hKey;
  hKey = &bstrKey->hKey;
  if ( RegOpenKeyExW(HKEY_CURRENT_USER, bstrKey->strKeyName.m_Data, 0, KEY_READ, &bstrKey->hKey) )
    return 0;
  if ( pGlobalVar->Name )
  {
    RegQueryValueExW = ::RegQueryValueExW;
    pVarInfo = (pGlobalVar + 0x10);
    do
    {
      // pVarInfo->Type
      switch ( pVarInfo[-1u].Value )
      {
        case 0:
          cbData = *&pVarInfo->Name;
          szKeyName = pVarInfo[-1u].Size;
          Address[1] = pVarInfo[-1].dDefaultValue.HighPart;
          v7 = *v3;
          pGlobalVar = 4;
          if ( ::RegQueryValueExW(v7, szKeyName, 0, REG_NONE, Address[1], &pGlobalVar) )
            *Address[1] = cbData;
          goto __next;
        case 1:
          v8 = pVarInfo[-1].dDefaultValue.HighPart;
          v9 = *&pVarInfo->Name;
          cbData = 4;
          pGlobalVar = *v8;
          v10 = RegQueryValueExW(pThis->hKey, pVarInfo[-1].Size, 0, 0, &pGlobalVar, &cbData);
          v11 = pGlobalVar;
          v12 = v9;
          v3 = hKey;
          if ( v10 )
            v11 = v12;
          *v8 = v11;
          hMainKey = pThis;
          goto __next;
        case 2:
          v13 = pVarInfo[-1].dDefaultValue.HighPart;
          v14 = pVarInfo[-1].Size;
          *Address = *&pVarInfo->Name;
          v15 = *v3;
          cbData = v13;
          pGlobalVar = 8;
          v16 = RegQueryValueExW(v15, v14, 0, 0, v13, &pGlobalVar);
          RegQueryValueExW = ::RegQueryValueExW;
          if ( v16 )
            *cbData = *Address;
          break;
        case 3:
          CReg::ReadWidth(hMainKey, pVarInfo[-1].Size, pVarInfo[-1].dDefaultValue.HighPart, *&pVarInfo->Name);
          goto __next;
        case 4:
          v17 = *&pVarInfo->Name;
          pGlobalVar = pVarInfo[-1].dDefaultValue.LowPart;
          cbData = v17;
          v18 = pVarInfo[-1].Size;
          Address[1] = pVarInfo[-1].dDefaultValue.HighPart;
          if ( ::RegQueryValueExW(*v3, v18, 0, 0, Address[1], &pGlobalVar) && cbData )
            tcscpy_s(Address[1], pGlobalVar, cbData);
          goto __next;
        case 5:
          CReyKey::ReadInts(
            pVarInfo[-1].Size,
            pVarInfo[-1].dDefaultValue.LowPart >> 2,
            pVarInfo[-1].dDefaultValue.HighPart);
          goto __next;
        case 6:
          CReg::ReadWidthArray(
            pVarInfo[-1].Size,
            pVarInfo[-1].dDefaultValue.LowPart >> 1,
            pVarInfo[-1].dDefaultValue.HighPart);
          goto __next;
        case 7:
          pGlobalVar = pVarInfo[-1].dDefaultValue.LowPart;
          RegQueryValueExW(*v3, pVarInfo[-1].Size, 0, 0, pVarInfo[-1].dDefaultValue.HighPart, &pGlobalVar);
__next:
          RegQueryValueExW = ::RegQueryValueExW;
          break;
        default:
          break;
      }
      ++pVarInfo;
    }
    while ( pVarInfo[-1].Size );                // pVarInfo->Name
  }
  RegCloseKey(*v3);
  return 1;
}

//----- (012253E0) --------------------------------------------------------
// 从注册表中读取一组整形数据
LSTATUS __userpurge CReyKey::ReadInts@<eax>(LPCTSTR szKeyName, int Size, LPBYTE lpData)
{
  CRegStr *v3; // ecx
  BYTE *pBuffer; // edi
  LSTATUS result; // eax
  unsigned int nIndex; // esi
  DWORD cbData; // [esp+4h] [ebp-2Ch]
  HKEY hSubKey; // [esp+8h] [ebp-28h]
  __int16 szName[16]; // [esp+Ch] [ebp-24h]

  pBuffer = lpData;
  result = RegOpenKeyExW(v3->hKey, szKeyName, 0, KEY_READ, &hSubKey);
  if ( !result )
  {
    nIndex = 0;
    if ( Size )
    {
      do
      {
        cbData = 4;
        wsprintf(szName, L"%d", nIndex);
        RegQueryValueExW(hSubKey, szName, 0, 0, pBuffer, &cbData);
        ++nIndex;
        pBuffer += 4;
      }
      while ( nIndex < Size );
    }
    result = RegCloseKey(hSubKey);
  }
  return result;
}

//----- (01225480) --------------------------------------------------------
int __thiscall CReg::ReadWidth(CRegStr *this, LPCTSTR lpszName, BYTE *pnValue, int nDefValue)
{
  BYTE *pBuffer; // esi
  LSTATUS v5; // eax
  __int16 nValue; // dx
  int result; // eax
  DWORD cbData; // [esp+4h] [ebp-4h]

  pBuffer = pnValue;
  cbData = 4;
  pnValue = *pnValue;
  v5 = RegQueryValueExW(this->hKey, lpszName, 0, REG_NONE, &pnValue, &cbData);
  nValue = pnValue;
  if ( v5 )
    nValue = nDefValue;
  *pBuffer = nValue;
  result = MulDiv(nValue, gLogPixelsX, 96);
  *pBuffer = result;
  return result;
}

//----- (012254E0) --------------------------------------------------------
int __stdcall CReg::ReadWidthArray(LPCWSTR lpSubKey, int Size, void *pBuffer)
{
  CComBSTR *pThisKey; // ecx
  int result; // eax
  unsigned int idx; // esi
  __int16 nRealWidth; // ax
  int cbData; // [esp+0h] [ebp-34h]
  int *pnWidth; // [esp+4h] [ebp-30h]
  int nValue; // [esp+8h] [ebp-2Ch]
  HKEY hSubKey; // [esp+Ch] [ebp-28h]
  __int16 Name[16]; // [esp+10h] [ebp-24h]

  pnWidth = pBuffer;
  result = RegOpenKeyExW(pThisKey->hKey, lpSubKey, 0, KEY_READ, &hSubKey);
  if ( !result )
  {
    idx = 0;
    if ( Size )
    {
      do
      {
        cbData = 4;
        wsprintf(Name, L"%d", idx);
        if ( !RegQueryValueExW(hSubKey, Name, 0, 0, &nValue, &cbData) )
        {
          nRealWidth = MulDiv(nValue, gLogPixelsX, 96);
          *(pnWidth + idx) = nRealWidth;
        }
        ++idx;
      }
      while ( idx < Size );
    }
    result = RegCloseKey(hSubKey);
  }
  return result;
}

//----- (012255A0) --------------------------------------------------------
DWORD __thiscall CHttp::Requery(CHttp *pMainHttp, CComBSTR **ppComBSTR2, CComBSTR *psz)
{
  CHttp *pHttp; // ebx
  CComBSTR **v4; // esi
  CComBSTR *v5; // ecx
  DWORD v6; // eax
  DWORD v7; // edi
  Data_t *v8; // esi
  int v9; // eax
  Data_t *v10; // ecx
  CComBSTR **v11; // esi
  CComBSTR **v12; // eax
  _bstr_t *v13; // eax
  _bstr_t *v14; // eax
  CComBSTR **v15; // edi
  CComBSTR **v16; // esi
  CComBSTR **v17; // eax
  _bstr_t *v18; // eax
  _bstr_t *v19; // eax
  CComBSTR **v20; // esi
  CComBSTR **v21; // eax
  _bstr_t *v22; // eax
  _bstr_t *v23; // eax
  CComBSTR **v24; // edi
  CComBSTR **v25; // esi
  CComBSTR **v26; // eax
  _bstr_t *v27; // eax
  _bstr_t *v28; // eax
  CComBSTR **v29; // edi
  UINT (__stdcall *v30)(BSTR); // eax
  CComBSTR **v31; // esi
  CComBSTR **v32; // eax
  _bstr_t *v33; // eax
  _bstr_t *v34; // eax
  CComBSTR **v35; // esi
  CComBSTR **v36; // eax
  _bstr_t *v37; // eax
  _bstr_t *v38; // eax
  CComBSTR *v39; // ecx
  CComBSTR **v40; // edi
  OLECHAR *v41; // ecx
  CComBSTR **v42; // esi
  CComBSTR **v43; // eax
  _bstr_t *v44; // eax
  _bstr_t *v45; // eax
  CComBSTR **v46; // esi
  CComBSTR **v47; // eax
  _bstr_t *v48; // eax
  _bstr_t *v49; // eax
  CComBSTR **v50; // esi
  CComBSTR **v51; // eax
  _bstr_t *v52; // eax
  _bstr_t *v53; // eax
  CComBSTR **v54; // esi
  _bstr_t *v55; // eax
  _bstr_t *v56; // eax
  _bstr_t *v57; // eax
  CComBSTR **v58; // eax
  _bstr_t *v59; // eax
  CComBSTR **v60; // edi
  CComBSTR **v61; // esi
  CComBSTR **v62; // eax
  _bstr_t *v63; // eax
  _bstr_t *v64; // eax
  _bstr_t *v65; // eax
  _bstr_t *v66; // eax
  void *hRequestData; // esi
  void *hSession; // ST0C_4
  CComBSTR **v69; // edi
  CComBSTR **v70; // esi
  CComBSTR **v71; // eax
  _bstr_t *v72; // eax
  CComBSTR *v73; // edi
  CComBSTR *v74; // esi
  UINT v75; // ecx
  const WCHAR *szHeaders; // edx
  void *v77; // edi
  CComBSTR **v78; // esi
  int v79; // eax
  Data_t *v80; // ecx
  HKEY pBuffer; // ecx
  DWORD dwSizeToWrite; // eax
  void *hRequest1; // edi
  HKEY v84; // ecx
  DWORD v85; // eax
  DWORD v86; // eax
  CComBSTR **v87; // esi
  int v88; // eax
  CComBSTR ***v89; // esi
  void *v90; // ecx
  int *v91; // eax
  CComBSTR **v92; // edi
  void *v93; // ecx
  CComBSTR **v94; // eax
  int *v95; // eax
  void *v96; // ecx
  int *v97; // eax
  CComBSTR **v98; // esi
  CComBSTR *v99; // eax
  CComBSTR *v101; // [esp-Ch] [ebp-A0h]
  void *v102; // [esp-4h] [ebp-98h]
  WINHTTP_AUTOPROXY_OPTIONS pAutoProxyOptions; // [esp+10h] [ebp-84h]
  WINHTTP_PROXY_INFO pProxyInfo; // [esp+28h] [ebp-6Ch]
  void *v105; // [esp+34h] [ebp-60h]
  int v106; // [esp+38h] [ebp-5Ch]
  CComBSTR *v107; // [esp+3Ch] [ebp-58h]
  BSTR *v108; // [esp+40h] [ebp-54h]
  BSTR *v109; // [esp+44h] [ebp-50h]
  BSTR *v110; // [esp+48h] [ebp-4Ch]
  CComBSTR *ppComBSTR; // [esp+4Ch] [ebp-48h]
  BSTR *v112; // [esp+50h] [ebp-44h]
  CComBSTR *ppv; // [esp+54h] [ebp-40h]
  CComBSTR *v114; // [esp+58h] [ebp-3Ch]
  DWORD dwNumberOfBytesWritten; // [esp+5Ch] [ebp-38h]
  DWORD dwLength; // [esp+60h] [ebp-34h]
  CComBSTR *ppComBSTR1; // [esp+64h] [ebp-30h]
  CComBSTR *v118; // [esp+68h] [ebp-2Ch]
  int v119; // [esp+6Ch] [ebp-28h]
  LPCVOID lpBuffer; // [esp+70h] [ebp-24h]
  HINTERNET hRequest; // [esp+74h] [ebp-20h]
  int v122; // [esp+78h] [ebp-1Ch]
  DWORD dwNumberOfBytesToWrite; // [esp+7Ch] [ebp-18h]
  int v124; // [esp+80h] [ebp-14h]
  CComBSTR *v125; // [esp+84h] [ebp-10h]
  int ret; // [esp+90h] [ebp-4h]

  pHttp = pMainHttp;
  v106 = 0;
  v105 = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
  ret = 0;
  bstr_t::Assign(psz, gpszTargetName);
  v4 = ppComBSTR2;
  v102 = &dwLength;
  ppComBSTR = (ppComBSTR2 + 3);
  v5 = ppComBSTR2[3];
  v101 = v5;
  if ( v5 )
    InterlockedIncrement(&v5->Length);
  v6 = sub_1224420(v101, &lpBuffer, v102);
  v7 = v6;
  if ( v6 )
  {
    sub_1224320(&v124, v6);
    v8 = (v4 + 6);
    if ( v8 != &v124 )
    {
      bstr_t::Data_t::Free(v8);
      v9 = v124;
      v8->m_wstr = v124;
      if ( v9 )
        InterlockedIncrement((v9 + 8));
    }
    v10 = &v124;
  }
  else
  {
    v125 = 0;
    LOBYTE(ret) = 1;
    v11 = bstr_t::EqualAssign(&ppv, L"\r\n");
    LOBYTE(ret) = 2;
    v12 = bstr_t::EqualAssign(&dwNumberOfBytesToWrite, L"---------------------------41184676334");
    LOBYTE(ret) = 3;
    v13 = sub_11F3B50(&hRequest, L"--", v12);
    LOBYTE(ret) = 4;
    v14 = CComBSTR::AppendTail(v13, &ppComBSTR1, v11);
    LOBYTE(ret) = 5;
    bstr_t::Append(&v125, v14);
    bstr_t::Data_t::Free(&ppComBSTR1);
    bstr_t::Data_t::Free(&hRequest);
    bstr_t::Data_t::Free(&dwNumberOfBytesToWrite);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&ppv);
    bstr_t::EqualAssign(&ppComBSTR1, L"Content-Disposition: form-data; name=\"apikey\"\r\n");
    LOBYTE(ret) = 6;
    bstr_t::Append(&v125, &ppComBSTR1);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&ppComBSTR1);
    v15 = bstr_t::EqualAssign(&v112, L"\r\n");
    LOBYTE(ret) = 7;
    v16 = CComBSTR::AssignA(&dwNumberOfBytesToWrite, "4e3202fdbe953d628f650229af5b3eb49cd46b2d3bfe5546ae3c5fa48b554e0c");
    LOBYTE(ret) = 8;
    v17 = bstr_t::EqualAssign(&hRequest, L"\r\n");
    LOBYTE(ret) = 9;
    v18 = CComBSTR::AppendTail(v17, &ppComBSTR1, v16);
    LOBYTE(ret) = 10;
    v19 = CComBSTR::AppendTail(v18, &ppv, v15);
    LOBYTE(ret) = 11;
    bstr_t::Append(&v125, v19);
    bstr_t::Data_t::Free(&ppv);
    bstr_t::Data_t::Free(&ppComBSTR1);
    bstr_t::Data_t::Free(&hRequest);
    bstr_t::Data_t::Free(&dwNumberOfBytesToWrite);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&v112);
    v20 = bstr_t::EqualAssign(&hRequest, L"\r\n");
    LOBYTE(ret) = 12;
    v21 = bstr_t::EqualAssign(&ppComBSTR1, L"---------------------------41184676334");
    LOBYTE(ret) = 13;
    v22 = sub_11F3B50(&ppv, L"--", v21);
    LOBYTE(ret) = 14;
    v23 = CComBSTR::AppendTail(v22, &v112, v20);
    LOBYTE(ret) = 15;
    bstr_t::Append(&v125, v23);
    bstr_t::Data_t::Free(&v112);
    bstr_t::Data_t::Free(&ppv);
    bstr_t::Data_t::Free(&ppComBSTR1);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&hRequest);
    bstr_t::EqualAssign(&ppComBSTR1, L"Content-Disposition: form-data; name=\"creation_datetime\"\r\n");
    LOBYTE(ret) = 16;
    bstr_t::Append(&v125, &ppComBSTR1);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&ppComBSTR1);
    v24 = bstr_t::EqualAssign(&dwNumberOfBytesToWrite, L"\r\n");
    LOBYTE(ret) = 17;
    v25 = sub_12218A0(&hRequest, ppComBSTR2 + 2);
    LOBYTE(ret) = 18;
    v26 = bstr_t::EqualAssign(&ppComBSTR1, L"\r\n");
    LOBYTE(ret) = 19;
    v27 = CComBSTR::AppendTail(v26, &ppv, v25);
    LOBYTE(ret) = 20;
    v28 = CComBSTR::AppendTail(v27, &v112, v24);
    LOBYTE(ret) = 21;
    bstr_t::Append(&v125, v28);
    bstr_t::Data_t::Free(&v112);
    bstr_t::Data_t::Free(&ppv);
    bstr_t::Data_t::Free(&ppComBSTR1);
    bstr_t::Data_t::Free(&hRequest);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&dwNumberOfBytesToWrite);
    v29 = ppComBSTR2;
    v30 = SysStringLen;
    if ( *ppComBSTR2 && (*ppComBSTR2)->bstr )
    {
      if ( SysStringLen((*ppComBSTR2)->bstr) )
      {
        v31 = bstr_t::EqualAssign(&hRequest, L"\r\n");
        LOBYTE(ret) = 22;
        v32 = bstr_t::EqualAssign(&ppComBSTR1, L"---------------------------41184676334");
        LOBYTE(ret) = 23;
        v33 = sub_11F3B50(&ppv, L"--", v32);
        LOBYTE(ret) = 24;
        v34 = CComBSTR::AppendTail(v33, &v112, v31);
        LOBYTE(ret) = 25;
        bstr_t::Append(&v125, v34);
        bstr_t::Data_t::Free(&v112);
        bstr_t::Data_t::Free(&ppv);
        bstr_t::Data_t::Free(&ppComBSTR1);
        LOBYTE(ret) = 1;
        bstr_t::Data_t::Free(&hRequest);
        bstr_t::EqualAssign(&ppComBSTR1, L"Content-Disposition: form-data; name=\"autostart_location\"\r\n");
        LOBYTE(ret) = 26;
        bstr_t::Append(&v125, &ppComBSTR1);
        LOBYTE(ret) = 1;
        bstr_t::Data_t::Free(&ppComBSTR1);
        v35 = bstr_t::EqualAssign(&hRequest, L"\r\n");
        LOBYTE(ret) = 27;
        v36 = bstr_t::EqualAssign(&ppComBSTR1, L"\r\n");
        LOBYTE(ret) = 28;
        v37 = CComBSTR::AppendTail(v36, &ppv, v29);
        LOBYTE(ret) = 29;
        v38 = CComBSTR::AppendTail(v37, &v112, v35);
        LOBYTE(ret) = 30;
        bstr_t::Append(&v125, v38);
        bstr_t::Data_t::Free(&v112);
        bstr_t::Data_t::Free(&ppv);
        bstr_t::Data_t::Free(&ppComBSTR1);
        LOBYTE(ret) = 1;
        bstr_t::Data_t::Free(&hRequest);
      }
      v30 = SysStringLen;
    }
    v39 = v29[1];
    v40 = v29 + 1;
    if ( v39 )
    {
      v41 = v39->bstr;
      if ( v41 )
      {
        if ( v30(v41) )
        {
          v42 = bstr_t::EqualAssign(&hRequest, L"\r\n");
          LOBYTE(ret) = 31;
          v43 = bstr_t::EqualAssign(&ppComBSTR1, L"---------------------------41184676334");
          LOBYTE(ret) = 32;
          v44 = sub_11F3B50(&ppv, L"--", v43);
          LOBYTE(ret) = 33;
          v45 = CComBSTR::AppendTail(v44, &v112, v42);
          LOBYTE(ret) = 34;
          bstr_t::Append(&v125, v45);
          bstr_t::Data_t::Free(&v112);
          bstr_t::Data_t::Free(&ppv);
          bstr_t::Data_t::Free(&ppComBSTR1);
          LOBYTE(ret) = 1;
          bstr_t::Data_t::Free(&hRequest);
          bstr_t::EqualAssign(&ppComBSTR1, L"Content-Disposition: form-data; name=\"autostart_entry\"\r\n");
          LOBYTE(ret) = 35;
          bstr_t::Append(&v125, &ppComBSTR1);
          LOBYTE(ret) = 1;
          bstr_t::Data_t::Free(&ppComBSTR1);
          v46 = bstr_t::EqualAssign(&hRequest, L"\r\n");
          LOBYTE(ret) = 36;
          v47 = bstr_t::EqualAssign(&ppComBSTR1, L"\r\n");
          LOBYTE(ret) = 37;
          v48 = CComBSTR::AppendTail(v47, &ppv, v40);
          LOBYTE(ret) = 38;
          v49 = CComBSTR::AppendTail(v48, &v112, v46);
          LOBYTE(ret) = 39;
          bstr_t::Append(&v125, v49);
          bstr_t::Data_t::Free(&v112);
          bstr_t::Data_t::Free(&ppv);
          bstr_t::Data_t::Free(&ppComBSTR1);
          LOBYTE(ret) = 1;
          bstr_t::Data_t::Free(&hRequest);
        }
      }
    }
    v50 = bstr_t::EqualAssign(&hRequest, L"\r\n");
    LOBYTE(ret) = 40;
    v51 = bstr_t::EqualAssign(&ppComBSTR1, L"---------------------------41184676334");
    LOBYTE(ret) = 41;
    v52 = sub_11F3B50(&ppv, L"--", v51);
    LOBYTE(ret) = 42;
    v53 = CComBSTR::AppendTail(v52, &v112, v50);
    LOBYTE(ret) = 43;
    bstr_t::Append(&v125, v53);
    bstr_t::Data_t::Free(&v112);
    bstr_t::Data_t::Free(&ppv);
    bstr_t::Data_t::Free(&ppComBSTR1);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&hRequest);
    bstr_t::EqualAssign(&ppComBSTR1, L"\"");
    LOBYTE(ret) = 44;
    v54 = bstr_t::EqualAssign(&dwNumberOfBytesToWrite, L"\r\n");
    LOBYTE(ret) = 45;
    v55 = sub_11F3B50(&hRequest, L"Content-Disposition: form-data; name=\"file\"; filename=\"", ppComBSTR);
    LOBYTE(ret) = 46;
    v56 = CComBSTR::AppendTail(v55, &ppv, &ppComBSTR1);
    LOBYTE(ret) = 47;
    v57 = CComBSTR::AppendTail(v56, &v112, v54);
    LOBYTE(ret) = 48;
    bstr_t::Append(&v125, v57);
    bstr_t::Data_t::Free(&v112);
    bstr_t::Data_t::Free(&ppv);
    bstr_t::Data_t::Free(&hRequest);
    bstr_t::Data_t::Free(&dwNumberOfBytesToWrite);
    LOBYTE(ret) = 1;
    bstr_t::Data_t::Free(&ppComBSTR1);
    v58 = bstr_t::EqualAssign(&v112, L"\r\n");
    LOBYTE(ret) = 49;
    v59 = sub_11F3B50(&ppComBSTR, L"Content-Type: application/octet-stream\r\n", v58);
    LOBYTE(ret) = 50;
    bstr_t::Append(&v125, v59);
    bstr_t::Data_t::Free(&ppComBSTR);
    bstr_t::Data_t::Free(&v112);
    ppComBSTR1 = 0;
    LOBYTE(ret) = 51;
    bstr_t::EqualAssign(&dwNumberOfBytesToWrite, L"--");
    LOBYTE(ret) = 52;
    bstr_t::EqualAssign(&hRequest, L"--");
    LOBYTE(ret) = 53;
    v60 = bstr_t::EqualAssign(&v107, L"\r\n");
    LOBYTE(ret) = 54;
    v61 = bstr_t::EqualAssign(&v108, L"---------------------------41184676334");
    LOBYTE(ret) = 55;
    v62 = bstr_t::EqualAssign(&v109, L"\r\n");
    LOBYTE(ret) = 56;
    v63 = CComBSTR::AppendTail(v62, &v110, &hRequest);
    LOBYTE(ret) = 57;
    v64 = CComBSTR::AppendTail(v63, &ppv, v61);
    LOBYTE(ret) = 58;
    v65 = CComBSTR::AppendTail(v64, &v112, &dwNumberOfBytesToWrite);
    LOBYTE(ret) = 59;
    v66 = CComBSTR::AppendTail(v65, &ppComBSTR, v60);
    LOBYTE(ret) = 60;
    bstr_t::Append(&ppComBSTR1, v66);
    bstr_t::Data_t::Free(&ppComBSTR);
    bstr_t::Data_t::Free(&v112);
    bstr_t::Data_t::Free(&ppv);
    bstr_t::Data_t::Free(&v110);
    bstr_t::Data_t::Free(&v109);
    bstr_t::Data_t::Free(&v108);
    bstr_t::Data_t::Free(&v107);
    bstr_t::Data_t::Free(&hRequest);
    LOBYTE(ret) = 51;
    bstr_t::Data_t::Free(&dwNumberOfBytesToWrite);
    v102 = 0x800000;
    hRequestData = WinHttpOpenRequest(pHttp->hConnection, L"POST", L"vtapi/v2/file/scan", 0, 0, 0, 0x800000u);
    pAutoProxyOptions.dwFlags = 1;
    hRequest = hRequestData;
    v102 = &pProxyInfo;
    pAutoProxyOptions.dwAutoDetectFlags = 3;
    hSession = pHttp->hSession;
    pAutoProxyOptions.fAutoLogonIfChallenged = 1;
    if ( WinHttpGetProxyForUrl(hSession, L"https://www.virustotal.com", &pAutoProxyOptions, &pProxyInfo) )
      WinHttpSetOption(hRequestData, 0x26u, &pProxyInfo, 0xCu);
    v69 = bstr_t::EqualAssign(&v110, L"\r\n");
    LOBYTE(ret) = 61;
    v70 = bstr_t::EqualAssign(&v109, L"---------------------------41184676334");
    LOBYTE(ret) = 62;
    v71 = bstr_t::EqualAssign(&v108, L"Content-Type: multipart/form-data; boundary=");
    LOBYTE(ret) = 63;
    v72 = CComBSTR::AppendTail(v71, &v107, v70);
    LOBYTE(ret) = 64;
    CComBSTR::AppendTail(v72, &v114, v69);
    bstr_t::Data_t::Free(&v107);
    bstr_t::Data_t::Free(&v108);
    bstr_t::Data_t::Free(&v109);
    LOBYTE(ret) = 69;
    bstr_t::Data_t::Free(&v110);
    v73 = v125;
    if ( v125 && v125->bstr )
      dwNumberOfBytesToWrite = SysStringLen(v125->bstr);
    else
      dwNumberOfBytesToWrite = 0;
    v74 = ppComBSTR1;
    if ( ppComBSTR1 && ppComBSTR1->bstr )
      v75 = SysStringLen(ppComBSTR1->bstr);
    else
      v75 = 0;
    if ( v114 )
      szHeaders = v114->bstr;
    else
      szHeaders = 0;
    if ( WinHttpSendRequest(hRequest, szHeaders, 0, 0, 0, dwLength + v75 + dwNumberOfBytesToWrite, 0) )
    {
      if ( v73 )
      {
        if ( v73->bstr )
          dwNumberOfBytesToWrite = SysStringLen(v73->bstr);
        else
          dwNumberOfBytesToWrite = 0;
        if ( !v73->hKey )
          v73->hKey = UTFToAscii(v73->bstr);
        pBuffer = v73->hKey;
        dwSizeToWrite = dwNumberOfBytesToWrite;
      }
      else
      {
        dwSizeToWrite = 0;
        pBuffer = 0;
      }
      hRequest1 = hRequest;
      WinHttpWriteData(hRequest, pBuffer, dwSizeToWrite, &dwNumberOfBytesWritten);
      WinHttpWriteData(hRequest1, lpBuffer, dwLength, &dwNumberOfBytesWritten);
      if ( v74 )
      {
        if ( v74->bstr )
          dwLength = SysStringLen(v74->bstr);
        else
          dwLength = 0;
        if ( !v74->hKey )
          v74->hKey = UTFToAscii(v74->bstr);
        v84 = v74->hKey;
        v85 = dwLength;
      }
      else
      {
        v85 = 0;
        v84 = 0;
      }
      WinHttpWriteData(hRequest1, v84, v85, &dwNumberOfBytesWritten);
      free(lpBuffer);
      if ( WinHttpReceiveResponse(hRequest1, 0) )
      {
        v89 = psz;
        dwLength = CHttp::ReadData(hRequest1, psz);
        WinHttpCloseHandle(hRequest1);
        v7 = dwLength;
        if ( dwLength )
        {
          sub_1224320(&v118, dwLength);
          v98 = ppComBSTR2 + 6;
          if ( ppComBSTR2 + 6 != &v118 )
          {
            bstr_t::Data_t::Free(ppComBSTR2 + 2);
            v99 = v118;
            *v98 = v118;
            if ( v99 )
              InterlockedIncrement(&v99->Length);
          }
          v80 = &v118;
        }
        else
        {
          if ( *v89 )
            psz = **v89;
          else
            psz = 0;
          sub_1224530(pHttp, &lpBuffer, &psz, &v105);
          LOBYTE(ret) = 70;
          if ( lpBuffer && *lpBuffer && SysStringLen(*lpBuffer) )
          {
            v102 = v90;
            bstr_t::EqualAssign(&v102, L"permalink");
            v91 = sub_1224950(&psz, &v105, v102);
            v92 = ppComBSTR2;
            sub_11F3A50(ppComBSTR2 + 7, v91);
            bstr_t::Data_t::Free(&psz);
            if ( sub_1200440(v92 + 7) )
            {
              bstr_t::Assign(v92 + 8, L"Submitted");
            }
            else
            {
              v102 = v93;
              bstr_t::EqualAssign(&v102, L"verbose_msg");
              v94 = sub_1224950(&v107, &v105, v102);
              LOBYTE(ret) = 71;
              v95 = sub_11F3B50(&psz, L"Submission error: ", v94);
              sub_11F3A50(v92 + 6, v95);
              bstr_t::Data_t::Free(&psz);
              LOBYTE(ret) = 70;
              bstr_t::Data_t::Free(&v107);
            }
            v102 = v96;
            bstr_t::EqualAssign(&v102, L"scan_id");
            v97 = sub_1224950(&psz, &v105, v102);
            sub_11F3A50(v92 + 2, v97);
            bstr_t::Data_t::Free(&psz);
            sub_1219380(&pHttp->field_10, &ppComBSTR2);
            v7 = dwLength;
          }
          v80 = &lpBuffer;
        }
      }
      else
      {
        v86 = GetLastError();
        sub_1224320(&v119, v86);
        v87 = ppComBSTR2 + 6;
        if ( ppComBSTR2 + 6 != &v119 )
        {
          bstr_t::Data_t::Free(ppComBSTR2 + 2);
          v88 = v119;
          *v87 = v119;
          if ( v88 )
            InterlockedIncrement((v88 + 8));
        }
        WinHttpCloseHandle(hRequest1);
        v7 = GetLastError();
        v80 = &v119;
      }
    }
    else
    {
      v77 = lpBuffer;
      free(lpBuffer);
      sub_1224320(&v122, 0);
      v78 = ppComBSTR2 + 6;
      if ( ppComBSTR2 + 6 != &v122 )
      {
        bstr_t::Data_t::Free(ppComBSTR2 + 2);
        v79 = v122;
        *v78 = v122;
        if ( v79 )
          InterlockedIncrement((v79 + 8));
      }
      WinHttpCloseHandle(hRequest);
      free(v77);
      v7 = GetLastError();
      v80 = &v122;
    }
    bstr_t::Data_t::Free(v80);
    bstr_t::Data_t::Free(&v114);
    bstr_t::Data_t::Free(&ppComBSTR1);
    v10 = &v125;
  }
  bstr_t::Data_t::Free(v10);
  v102 = v105;
  ret = -1;
  sub_1226540(&v105, &ppComBSTR2, *v105, v105);
  j__free(v105);
  return v7;
}
// 128C50C: using guessed type int (__stdcall *)(_DWORD);

//----- (01226210) --------------------------------------------------------
LSTATUS __thiscall SaveGlobalVariable(CComBSTR *this, GLOBALVAR *pVariable)
{
  CComBSTR *bstrKey; // esi
  HKEY *phKey; // ebx
  LSTATUS result; // eax
  void (__stdcall *RegSetValueExW)(HKEY, LPCWSTR, DWORD, DWORD, const BYTE *, DWORD); // edx
  PUCHAR pValue; // edi
  const WCHAR *v7; // esi
  GLOBALVAR **end; // ecx
  __int16 v9; // ax
  GLOBALVAR **pData; // [esp-Ch] [ebp-28h]
  DWORD cbSize; // [esp-8h] [ebp-24h]
  __int64 v12; // [esp+8h] [ebp-14h]
  CComBSTR *v13; // [esp+10h] [ebp-Ch]
  BYTE Data[4]; // [esp+14h] [ebp-8h]
  int start; // [esp+18h] [ebp-4h]

  bstrKey = this;
  v13 = this;
  phKey = &this->hKey;
  result = RegCreateKeyExW(HKEY_CURRENT_USER, this->bstr, 0, 0, 0, 0x20006u, 0, &this->hKey, 0);
  if ( !result )
  {
    if ( pVariable->Name )
    {
      RegSetValueExW = RegSetValueEx;
      pValue = &pVariable->Value;
      do
      {
        // pVariable->Type
        switch ( *(pValue - 2) )
        {
          case 0:
            pVariable = **pValue;
            RegSetValueExW(*phKey, *(pValue - 3), 0, REG_DWORD, &pVariable, 4u);
            goto LABEL_16;
          case 1:
            start = **pValue;
            RegSetValueExW(*phKey, *(pValue - 3), 0, REG_DWORD, &start, 4u);
            goto LABEL_16;
          case 2:
            cbSize = 8;
            v12 = **pValue;
            pData = &v12;
            goto LABEL_15;
          case 3:
            v7 = *(pValue - 3);
            *Data = MulDiv(**pValue, 96, gLogPixelsX);
            RegSetValueEx(*phKey, v7, 0, REG_DWORD, Data, 4u);
            bstrKey = v13;
            goto LABEL_16;
          case 4:                               // string
            end = *pValue;
            start = *pValue + 2;
            do
            {
              v9 = *end;
              end = (end + 2);
            }
            while ( v9 );
            RegSetValueExW(*phKey, *(pValue - 3), 0, REG_SZ, *pValue, 2 * ((end - start) >> 1) + 2);
            goto LABEL_16;
          case 5:
            // Size/4
            SaveIntValueVectorToRegistry(bstrKey, *(pValue - 3), *(pValue - 1) >> 2, *pValue);
            goto LABEL_16;
          case 6:
            // Size/2
            sub_1226430(bstrKey, *(pValue - 3), *(pValue - 1) >> 1, *pValue);
            goto LABEL_16;
          case 7:
            cbSize = *(pValue - 1);
            pData = *pValue;
LABEL_15:
            RegSetValueExW(*phKey, *(pValue - 3), 0, REG_BINARY, pData, cbSize);
LABEL_16:
            RegSetValueExW = RegSetValueEx;
            break;
          default:
            break;
        }
        pValue += 24;
      }
      while ( *(pValue - 3) );
    }
    result = RegCloseKey(*phKey);
  }
  return result;
}

//----- (01226390) --------------------------------------------------------
LSTATUS __thiscall SaveIntValueVectorToRegistry(HKEY *this, LPCWSTR lpSubKey, int a3, BYTE *lpData)
{
  BYTE *v4; // edi
  LSTATUS result; // eax
  unsigned int v6; // esi
  HKEY phkResult; // [esp+4h] [ebp-28h]
  WCHAR ValueName; // [esp+8h] [ebp-24h]

  v4 = lpData;
  result = RegCreateKeyExW(this[1], lpSubKey, 0, 0, 0, KEY_WRITE, 0, &phkResult, 0);
  if ( !result )
  {
    v6 = 0;
    if ( a3 )
    {
      do
      {
        wsprintf(&ValueName, L"%d", v6);
        if ( *v4 )
          RegSetValueEx(phkResult, &ValueName, 0, REG_DWORD, v4, 4u);
        else
          RegDeleteValueW(phkResult, &ValueName);
        ++v6;
        v4 += 4;
      }
      while ( v6 < a3 );
    }
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (01226430) --------------------------------------------------------
LSTATUS __thiscall sub_1226430(HKEY *this, LPCWSTR lpSubKey, int a3, int a4)
{
  LSTATUS result; // eax
  unsigned int v5; // esi
  BYTE Data[4]; // [esp+0h] [ebp-30h]
  int v7; // [esp+4h] [ebp-2Ch]
  HKEY phkResult; // [esp+8h] [ebp-28h]
  WCHAR ValueName; // [esp+Ch] [ebp-24h]

  v7 = a4;
  result = RegCreateKeyExW(this[1], lpSubKey, 0, 0, 0, 0x20006u, 0, &phkResult, 0);
  if ( !result )
  {
    v5 = 0;
    if ( a3 )
    {
      do
      {
        wsprintf(&ValueName, L"%d", v5);
        *Data = MulDiv(*(v7 + 2 * v5), 96, gLogPixelsX);
        if ( *(v7 + 2 * v5) )
          RegSetValueEx(phkResult, &ValueName, 0, 4u, Data, 4u);
        else
          RegDeleteValueW(phkResult, &ValueName);
        ++v5;
      }
      while ( v5 < a3 );
    }
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (01226500) --------------------------------------------------------
void __stdcall sub_1226500(void *a1)
{
  int *v1; // edi
  void *i; // esi

  v1 = a1;
  for ( i = a1; !*(i + 13); v1 = i )
  {
    sub_1226500(*(i + 2));
    i = *i;
    sub_1221430(v1 + 4);
    j__free(v1);
  }
}

//----- (01226540) --------------------------------------------------------
int *__thiscall sub_1226540(int **this, int *a2, int **a3, int **a4)
{
  int **v4; // eax
  int **v5; // esi
  int *v6; // ecx
  int *v7; // eax
  int v8; // ecx
  int *result; // eax
  int **v10; // ecx
  int *i; // edx
  int *v12; // eax
  char v13; // [esp+4h] [ebp-4h]

  v4 = a3;
  v5 = this;
  v6 = *this;
  if ( a3 != *v6 || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v10 = v4;
      if ( !*(v4 + 13) )
      {
        i = v4[2];
        if ( *(i + 13) )
        {
          for ( i = v4[1]; !*(i + 13); i = i[1] )
          {
            if ( v4 != i[2] )
              break;
            v4 = i;
          }
        }
        else
        {
          v12 = *i;
          if ( !*(*i + 13) )
          {
            do
            {
              i = v12;
              v12 = *v12;
            }
            while ( !*(v12 + 13) );
          }
        }
        a3 = i;
      }
      sub_1226600(v5, &v13, v10);
    }
    *a2 = v4;
    result = a2;
  }
  else
  {
    sub_1226500(v6[1]);
    (*v5)[1] = *v5;
    **v5 = *v5;
    (*v5)[2] = *v5;
    v7 = *v5;
    v5[1] = 0;
    v8 = *v7;
    result = a2;
    *a2 = v8;
  }
  return result;
}

//----- (01226600) --------------------------------------------------------
_DWORD *__thiscall sub_1226600(int **this, _DWORD *a2, _DWORD *a3)
{
  CMapNode *v3; // ebx
  CMapNode *v4; // ecx
  CMapNode *v5; // edi
  CMapNode *v6; // edx
  CMapNode *v7; // esi
  CMapNode *v8; // eax
  CMapNode *v9; // edx
  CMapNode *v10; // eax
  CMapNode *v11; // eax
  CMapNode *i; // edx
  CMapNode *v13; // eax
  char v14; // cl
  CMapNode *v15; // ecx
  CMapNode *v16; // eax
  _DWORD *v17; // ecx
  _DWORD *result; // eax
  CMapNode *v19; // [esp+10h] [ebp-4h]

  v3 = this;
  v19 = a3;
  sub_1214CE0(&a3);
  v4 = v19;
  if ( v19->_Left->_isnil )
  {
    v5 = v19->_Right;
  }
  else if ( v19->_Right->_isnil )
  {
    v5 = v19->_Left;
  }
  else
  {
    v6 = a3;
    v5 = a3[2];
    if ( a3 != v19 )
    {
      v19->_Left->_Parent = a3;
      v6->_Left = v19->_Left;
      if ( v6 == v19->_Right )
      {
        v7 = v6;
      }
      else
      {
        v7 = v6->_Parent;
        if ( !v5->_isnil )
          v5->_Parent = v7;
        v7->_Left = v5;
        v6->_Right = v19->_Right;
        v19->_Right->_Parent = v6;
      }
      if ( v3->_Left->_Parent == v19 )
      {
        v3->_Left->_Parent = v6;
      }
      else
      {
        v13 = v19->_Parent;
        if ( v13->_Left == v19 )
          v13->_Left = v6;
        else
          v13->_Right = v6;
      }
      v6->_Parent = v19->_Parent;
      v14 = v6->_Color;
      v6->_Color = v19->_Color;
      v19->_Color = v14;
      v4 = v19;
      goto LABEL_37;
    }
  }
  v7 = v19->_Parent;
  if ( !v5->_isnil )
    v5->_Parent = v7;
  if ( v3->_Left->_Parent == v19 )
  {
    v3->_Left->_Parent = v5;
  }
  else if ( v7->_Left == v19 )
  {
    v7->_Left = v5;
  }
  else
  {
    v7->_Right = v5;
  }
  v8 = v3->_Left;
  if ( v3->_Left->_Left == v19 )
  {
    if ( v5->_isnil )
    {
      v9 = v7;
    }
    else
    {
      v10 = v5->_Left;
      v9 = v5;
      if ( !v5->_Left->_isnil )
      {
        do
        {
          v9 = v10;
          v10 = v10->_Left;
        }
        while ( !v10->_isnil );
      }
      v8 = v3->_Left;
    }
    v8->_Left = v9;
  }
  if ( v3->_Left->_Right == v19 )
  {
    if ( v5->_isnil )
    {
      v3->_Left->_Right = v7;
    }
    else
    {
      v11 = v5->_Right;
      for ( i = v5; !v11->_isnil; v11 = v11->_Right )
        i = v11;
      v3->_Left->_Right = i;
    }
  }
LABEL_37:
  if ( v4->_Color != 1 )
    goto LABEL_62;
  if ( v5 == v3->_Left->_Parent )
    goto LABEL_61;
  while ( v5->_Color == 1 )
  {
    v15 = v7->_Left;
    if ( v5 == v7->_Left )
    {
      v15 = v7->_Right;
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_12754B0(v3, v7);
        v15 = v7->_Right;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
      {
        if ( v15->_Right->_Color == 1 )
        {
          v15->_Left->_Color = 1;
          v15->_Color = 0;
          sub_1282BB0(v3, v15);
          v15 = v7->_Right;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Right->_Color = 1;
        sub_12754B0(v3, v7);
        break;
      }
    }
    else
    {
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_1282BB0(v3, v7);
        v15 = v7->_Left;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
      {
        if ( v15->_Left->_Color == 1 )
        {
          v15->_Right->_Color = 1;
          v15->_Color = 0;
          sub_12754B0(v3, v15);
          v15 = v7->_Left;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Left->_Color = 1;
        sub_1282BB0(v3, v7);
        break;
      }
    }
    v15->_Color = 0;
LABEL_55:
    v5 = v7;
    v7 = v7->_Parent;
    if ( v5 == v3->_Left->_Parent )
      break;
  }
  v4 = v19;
LABEL_61:
  v5->_Color = 1;
LABEL_62:
  sub_1221430(&v4->_KeyValue);
  j__free(v19);
  v16 = v3->_Parent;
  v17 = a3;
  if ( v16 )
    v3->_Parent = (v16 - 1);
  result = a2;
  *a2 = v17;
  return result;
}

//----- (01226870) --------------------------------------------------------
unsigned int __cdecl StrCpy(WCHAR *pBuffer, WCHAR *pszText)
{
  WCHAR *psz; // ecx
  unsigned int nLength; // eax
  WCHAR chr; // dx

  psz = pszText;
  nLength = wcslen(pszText) + 1;
  do
  {
    chr = *psz;
    ++psz;
    // pBuffer[psz-pszText-1]=chr
    *(psz + pBuffer - pszText - 2) = chr;
  }
  while ( chr );
  return nLength;
}

//----- (012268C0) --------------------------------------------------------
HBRUSH __stdcall UserProtocolDialogFunc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam_1)
{
  HWND v5; // eax
  _BYTE *v6; // ebx
  HWND v7; // eax
  HWND v8; // eax
  LPARAM lParam; // [esp+8h] [ebp-220h]
  int v10; // [esp+Ch] [ebp-21Ch]
  int (__stdcall *v11)(int, void *, int, int); // [esp+10h] [ebp-218h]
  _BYTE *v12; // [esp+14h] [ebp-214h]
  HWND v13; // [esp+18h] [ebp-210h]
  __int16 String[260]; // [esp+1Ch] [ebp-20Ch]

  v13 = hDlg;
  if ( uMsg == WM_INITDIALOG )
  {
    v6 = sub_1226A40();
    v10 = 0;
    v12 = v6;
    lParam = &v12;
    v11 = sub_1227910;
    _swprintf(String, L"%s License Agreement", lParam_1);
    SetWindowTextW(hDlg, String);
    v7 = GetDlgItem(hDlg, 500);
    SendMessageW(v7, 0x435u, 0, 0x100000);
    v8 = GetDlgItem(v13, 500);
    SendMessageW(v8, 0x449u, 2u, &lParam);
    free(v6);
  }
  else
  {
    if ( uMsg != WM_COMMAND )
    {
      if ( uMsg == WM_CTLCOLORSTATIC && lParam_1 == GetDlgItem(hDlg, 500) )
        return GetSysColorBrush(COLOR_WINDOW);
      return 0;
    }
    switch ( wParam )
    {
      case IDOK:
        EndDialog(hDlg, 1);
        break;
      case IDCANCEL:
        EndDialog(hDlg, 0);
        break;
      case 0x1F5u:
        v5 = GetDlgItem(hDlg, 500);
        sub_1226D40(v5);
        break;
      default:
        return 0;
    }
  }
  return 1;
}

//----- (01226A40) --------------------------------------------------------
_BYTE *sub_1226A40()
{
  const char *v0; // esi
  int v1; // edx
  size_t v2; // edi
  const char *v3; // ecx
  _BYTE *v4; // eax
  int v5; // edi
  _BYTE *i; // ebx
  const char *v7; // eax
  char v8; // cl
  int v10; // [esp+Ch] [ebp-4h]

  v0 = off_12DC4C8[0];
  v1 = 0;
  v2 = 1;
  if ( off_12DC4C8[0] )
  {
    v3 = off_12DC4C8[0];
    do
    {
      ++v1;
      v2 += strlen(v3);
      v3 = off_12DC4C8[v1];
    }
    while ( v3 );
  }
  v4 = malloc(v2);
  v5 = 0;
  v10 = 0;
  for ( i = v4; v0; v0 = off_12DC4C8[v10] )
  {
    v7 = v0;
    do
    {
      v8 = *v7++;
      v7[v5 - 1 + i - v0] = v8;
    }
    while ( v8 );
    v5 += strlen(v0);
    ++v10;
  }
  i[v5] = 0;
  return i;
}
// 12DC4C8: using guessed type char *off_12DC4C8[6];

//----- (01226AE0) --------------------------------------------------------
BOOL __cdecl sub_1226AE0(HKEY hKey, LPCWSTR lpSubKey)
{
  LSTATUS v2; // esi
  BOOL result; // eax
  DWORD cbData; // [esp+0h] [ebp-Ch]
  BYTE Data[4]; // [esp+4h] [ebp-8h]
  HKEY phkResult; // [esp+8h] [ebp-4h]

  phkResult = 0;
  *Data = 0;
  result = 0;
  if ( !RegOpenKeyExW(hKey, lpSubKey, 0, 0x101u, &phkResult) )
  {
    cbData = 4;
    v2 = RegQueryValueExW(phkResult, L"EulaAccepted", 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
    if ( !v2 )
    {
      if ( *Data )
        result = 1;
    }
  }
  return result;
}

//----- (01226B60) --------------------------------------------------------
BOOL __cdecl sub_1226B60(int a1)
{
  BOOL result; // eax
  wchar_t Dest; // [esp+0h] [ebp-20Ch]

  _swprintf(&Dest, L"%s\\%s", L"Software\\Sysinternals", a1);
  if ( sub_1226AE0(HKEY_LOCAL_MACHINE, L"Software\\Sysinternals")
    || sub_1226AE0(HKEY_CURRENT_USER, L"Software\\Sysinternals") )
  {
    result = 1;
  }
  else
  {
    result = sub_1226AE0(HKEY_CURRENT_USER, &Dest) != 0;
  }
  return result;
}

//----- (01226C00) --------------------------------------------------------
signed int sub_1226C00()
{
  signed int v0; // esi
  DWORD Type; // [esp+4h] [ebp-218h]
  DWORD cbData; // [esp+8h] [ebp-214h]
  HKEY phkResult; // [esp+Ch] [ebp-210h]
  wchar_t Data[260]; // [esp+10h] [ebp-20Ch]

  phkResult = 0;
  v0 = 0;
  cbData = 520;
  Type = 0;
  if ( !RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\windows nt\\currentversion", &phkResult) )
  {
    if ( !RegQueryValueExW(phkResult, L"ProductName", 0, &Type, Data, &cbData) && !_wcsicmp(L"iotuap", Data) )
      v0 = 1;
    RegCloseKey(phkResult);
  }
  return v0;
}

//----- (01226CC0) --------------------------------------------------------
signed int OSIsNanoServer()
{
  signed int v0; // esi
  DWORD cbData; // [esp+4h] [ebp-10h]
  BYTE Data[4]; // [esp+8h] [ebp-Ch]
  DWORD Type; // [esp+Ch] [ebp-8h]
  HKEY phkResult; // [esp+10h] [ebp-4h]

  phkResult = 0;
  v0 = 0;
  *Data = 0;
  cbData = 4;
  Type = 0;
  if ( !RegOpenKeyW(
          HKEY_LOCAL_MACHINE,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Server\\ServerLevels",
          &phkResult) )
  {
    if ( !RegQueryValueExW(phkResult, L"NanoServer", 0, &Type, Data, &cbData) && Type == 4 && *Data == 1 )
      v0 = 1;
    RegCloseKey(phkResult);
  }
  return v0;
}

//----- (01226D40) --------------------------------------------------------
BOOL __cdecl sub_1226D40(HWND a1)
{
  BOOL result; // eax
  HCURSOR v2; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi
  HWND v6; // ebx
  LRESULT v7; // esi
  DOCINFOW v8; // [esp+4h] [ebp-98h]
  struct tagPDW pPD; // [esp+18h] [ebp-84h]
  HWND hWnd; // [esp+5Ch] [ebp-40h]
  HCURSOR hCursor; // [esp+60h] [ebp-3Ch]
  int v12; // [esp+64h] [ebp-38h]
  LPARAM lParam; // [esp+68h] [ebp-34h]
  HDC v14; // [esp+6Ch] [ebp-30h]
  struct tagRECT rc; // [esp+70h] [ebp-2Ch]
  __int128 v16; // [esp+80h] [ebp-1Ch]
  LRESULT v17; // [esp+90h] [ebp-Ch]
  int v18; // [esp+94h] [ebp-8h]

  hWnd = a1;
  memset(&pPD.hwndOwner, 0, 0x3Eu);
  pPD.lStructSize = 66;
  pPD.hwndOwner = a1;
  pPD.hInstance = GetModuleHandle(0);
  pPD.Flags = 332;
  result = PrintDlgW(&pPD);
  if ( result )
  {
    v2 = LoadCursorW(0, 0x7F02);
    hCursor = SetCursor(v2);
    v12 = GetDeviceCaps(pPD.hDC, 8);
    v3 = GetDeviceCaps(pPD.hDC, 10);
    v4 = GetDeviceCaps(pPD.hDC, 88);
    v5 = GetDeviceCaps(pPD.hDC, 90);
    lParam = 0;
    memset(&v14, 0, 0x2Cu);
    _mm_storeu_si128(&v8.lpszDocName, 0i64);
    SetMapMode(pPD.hDC, 1);
    lParam = pPD.hDC;
    v14 = pPD.hDC;
    *&v16 = 0i64;
    HIDWORD(v16) = 1440 * (v3 / v5);
    DWORD2(v16) = 1440 * (v12 / v4);
    _mm_storeu_si128(&rc, _mm_loadu_si128(&v16));
    InflateRect(&rc, -1440, -1440);
    v17 = 0;
    v18 = -1;
    v8.cbSize = 20;
    v8.lpszDocName = L"Sysinternals License";
    StartDocW(pPD.hDC, &v8);
    v6 = hWnd;
    v12 = SendMessageW(hWnd, WM_GETTEXTLENGTH, 0, 0);
    StartPage(pPD.hDC);
    v7 = SendMessageW(v6, 0x439u, 1u, &lParam);
    EndPage(pPD.hDC);
    while ( v7 < v12 )
    {
      v17 = v7;
      v18 = -1;
      StartPage(pPD.hDC);
      v7 = SendMessageW(v6, 0x439u, 1u, &lParam);
      EndPage(pPD.hDC);
    }
    SendMessageW(v6, 0x439u, 0, 0);
    EndDoc(pPD.hDC);
    SetCursor(hCursor);
    result = 1;
  }
  return result;
}
// 12BACE4: using guessed type wchar_t aSysinternalsLi[21];

//----- (01226F60) --------------------------------------------------------
BOOL __cdecl sub_1226F60(TCHAR *strTitle, int *argc, TCHAR **argv)
{
  int idx; // esi
  signed int v4; // ebx
  signed int offset; // [esp+8h] [ebp-4h]

  offset = 0;
  if ( !argc || !argv )
    return sub_1227390(strTitle, 0, 0);
  idx = 0;
  if ( *argc > 0 )
  {
    offset = 0;
    while ( _wcsicmp(argv[idx], L"/accepteula") && _wcsicmp(argv[idx], L"-accepteula") )
    {
      if ( ++idx >= *argc )
        goto __exit;
    }
    for ( offset = 1; idx < *argc - 1; ++idx )
      argv[idx] = argv[idx + 1];
    --*argc;
  }
__exit:
  v4 = offset;
  if ( sub_12270B0(strTitle, offset) )
    v4 = 1;
  return v4 != 0;
}

//----- (01227020) --------------------------------------------------------
signed int sub_1227020()
{
  signed int v0; // esi
  char v1; // bh
  char v2; // bl

  v0 = 0;
  v1 = 0;
  wprintf(UserProtocal);
  do
  {
    printf("Accept Eula (Y/N)?");
    v2 = _getch();
    printf("%c\n", v2);
    if ( v2 == 'y' || v2 == 'Y' )
    {
      v0 = 1;
      v1 = 1;
    }
  }
  while ( v2 != 'n' && v2 != 'N' && v1 != '\x01' );
  return v0;
}

//----- (01227080) --------------------------------------------------------
void __noreturn sub_1227080()
{
  wprintf_s(L"%ls", UserProtocal);
  wprintf_s(L"This is the first run of this program. You must accept EULA to continue.\n");
  wprintf_s(L"Use -accepteula to accept EULA.\n\n");
  exit(1);
}

//----- (012270B0) --------------------------------------------------------
BOOL __cdecl sub_12270B0(LPARAM dwInitParam, BYTE Data)
{
  HANDLE v2; // eax
  PEP_DLGTEMPLATE *pDlgTemplate; // edi
  WCHAR *pszText; // esi
  unsigned int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // esi
  WCHAR *v14; // esi
  HKEY phkResult; // [esp+4h] [ebp-210h]
  WCHAR SubKey; // [esp+8h] [ebp-20Ch]

  phkResult = 0;
  _swprintf(&SubKey, L"Software\\Sysinternals\\%s", dwInitParam);
  if ( Data )
    goto LABEL_15;
  *&Data = sub_1226B60(dwInitParam);
  if ( Data )
    goto LABEL_15;
  if ( sub_1226C00() )
  {
    *&Data = sub_1227020();
  }
  else
  {
    if ( OSIsNanoServer() || (v2 = GetStdHandle(STD_OUTPUT_HANDLE), GetFileType(v2) == 3) )
      sub_1227080();
    pDlgTemplate = LocalAlloc(0x40u, 1000u);
    LoadLibraryW(L"Riched32.dll");
    pDlgTemplate->style = 0x80C808D0;
    *&pDlgTemplate->x = 0;
    *&pDlgTemplate->_cx = 11796792;
    pDlgTemplate->cdit = 0;
    pDlgTemplate->field_12 = 0;
    pszText = &pDlgTemplate->m_szAgreement[StrCpy(pDlgTemplate->m_szAgreement, L"License Agreement")];
    *pszText = '\b';
    v5 = (&pszText[StrCpy(pszText + 1, L"MS Shell Dlg") + 2] + 1) & 0xFFFFFFFC;
    *(v5 + 8) = 0x30007;
    *(v5 + 0xC) = 0xE012A;
    *(v5 + 0x10) = 0xFFFF01F6;
    *v5 = 0x50000000;
    *(v5 + 20) = 0x82;
    v5 += 0x16;
    v6 = StrCpy(v5, L"You can also use the /accepteula command-line switch to accept the EULA.");
    *(v5 + 2 * v6) = 0;
    ++pDlgTemplate->cdit;
    v7 = (v5 + 2 * v6 + 5) & 0xFFFFFFFC;
    *(v7 + 8) = 0x9F00C9;
    *(v7 + 12) = 0xE0032;
    *(v7 + 16) = 0xFFFF0001;
    *v7 = 0x50010000;
    *(v7 + 20) = 0x80;
    v7 += 22;
    v8 = StrCpy(v7, L"&Agree");
    *(v7 + 2 * v8) = 0;
    ++pDlgTemplate->cdit;
    v9 = (v7 + 2 * v8 + 5) & 0xFFFFFFFC;
    *(v9 + 8) = 0x9F00FF;
    *(v9 + 12) = 0xE0032;
    *(v9 + 16) = 0xFFFF0002;
    *v9 = 0x50010000;
    *(v9 + 20) = 0x80;
    v9 += 22;
    v10 = StrCpy(v9, L"&Decline");
    *(v9 + 2 * v10) = 0;
    ++pDlgTemplate->cdit;
    v11 = (v9 + 2 * v10 + 5) & 0xFFFFFFFC;
    *(v11 + 8) = 0x9F0007;
    *(v11 + 12) = 0xE0032;
    *(v11 + 16) = 0xFFFF01F5;
    *v11 = 0x50010000;
    *(v11 + 20) = 0x80;
    v11 += 22;
    v12 = StrCpy(v11, L"&Print");
    *(v11 + 2 * v12) = 0;
    ++pDlgTemplate->cdit;
    v13 = (v11 + 2 * v12 + 5) & 0xFFFFFFFC;
    *(v13 + 8) = 0xE0007;
    *(v13 + 12) = 0x8C012A;
    *(v13 + 16) = 0x1F4;
    *v13 = 0x50A11844;
    v14 = (v13 + 18 + 2 * StrCpy((v13 + 18), L"RICHEDIT"));
    v14[StrCpy(v14, L"&Decline")] = NULL;
    ++pDlgTemplate->cdit;
    *&Data = DialogBoxIndirectParamW(NULL, pDlgTemplate, NULL, UserProtocolDialogFunc, dwInitParam);
    LocalFree(pDlgTemplate);
  }
  if ( Data )
  {
LABEL_15:
    if ( !RegCreateKey(HKEY_CURRENT_USER, &SubKey, &phkResult) )
    {
      RegSetValueEx(phkResult, L"EulaAccepted", 0, REG_DWORD, &Data, 4u);
      RegCloseKey(phkResult);
    }
  }
  return Data != 0;
}

//----- (01227390) --------------------------------------------------------
BOOL __cdecl sub_1227390(TCHAR *a1, _DWORD *a2, int a3)
{
  TCHAR **argv; // ebx
  int *pnArgc; // edi
  HMODULE v5; // eax
  int (__stdcall *CommandLineToArgvW)(); // esi
  int idx; // esi
  int v8; // eax
  signed int v9; // ebx
  LSTATUS (__stdcall *v10)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // esi
  LSTATUS v11; // esi
  LSTATUS v12; // esi
  signed int v13; // eax
  signed int res; // eax
  HANDLE hOutputHandle; // eax
  USERPROTOCOLDLGITEMTEMPLATE *pDlgTemplate; // edi
  const WCHAR *strLicense; // ecx
  WCHAR psz; // ax
  const WCHAR *strDlgName; // ecx
  WCHAR pszName; // ax
  unsigned int v22; // eax
  int v23; // esi
  const WCHAR *v24; // ecx
  int v25; // edx
  WCHAR v26; // ax
  unsigned int v27; // eax
  int v28; // esi
  const WCHAR *v29; // ecx
  int v30; // edx
  WCHAR v31; // ax
  unsigned int v32; // eax
  int v33; // esi
  const WCHAR *v34; // ecx
  int v35; // edx
  WCHAR v36; // ax
  unsigned int v37; // eax
  int v38; // esi
  const WCHAR *v39; // ecx
  int v40; // edx
  WCHAR v41; // ax
  unsigned int v42; // eax
  int v43; // esi
  const WCHAR *v44; // ecx
  int v45; // edx
  WCHAR v46; // ax
  const WCHAR *v47; // ecx
  WCHAR v48; // ax
  TCHAR *v49; // ST14_4
  DWORD cbData; // [esp+Ch] [ebp-438h]
  DWORD v51; // [esp+10h] [ebp-434h]
  BYTE Data[4]; // [esp+14h] [ebp-430h]
  TCHAR *dwInitParam; // [esp+18h] [ebp-42Ch]
  BYTE v54[4]; // [esp+1Ch] [ebp-428h]
  HKEY v55; // [esp+20h] [ebp-424h]
  HKEY phkResult; // [esp+24h] [ebp-420h]
  HKEY hKey; // [esp+28h] [ebp-41Ch]
  BYTE nRet[4]; // [esp+2Ch] [ebp-418h]
  __int16 Dest[260]; // [esp+30h] [ebp-414h]
  __int16 SubKey[260]; // [esp+238h] [ebp-20Ch]

  argv = a3;
  pnArgc = a2;
  dwInitParam = a1;
  *nRet = 0;
  if ( !a2 || !a3 )
  {
    v5 = LoadLibraryW(L"Shell32.dll");
    CommandLineToArgvW = GetProcAddress(v5, "CommandLineToArgvW");
    if ( !CommandLineToArgvW )
      goto LABEL_14;
    pnArgc = &gnArgc;
    GetCommandLineW();
    argv = CommandLineToArgvW();
  }
  idx = 0;
  if ( *pnArgc > 0 )
  {
    *nRet = 0;
    while ( _wcsicmp(argv[idx], L"/accepteula") && _wcsicmp(argv[idx], L"-accepteula") )
    {
      if ( ++idx >= *pnArgc )
        goto LABEL_14;
    }
    v8 = *pnArgc - 1;
    *nRet = 1;
    if ( idx < v8 )
    {
      do
      {
        argv[idx] = argv[idx + 1];
        ++idx;
      }
      while ( idx < *pnArgc - 1 );
    }
    --*pnArgc;
  }
LABEL_14:
  v9 = *nRet;
  v55 = 0;
  _swprintf(SubKey, L"Software\\Sysinternals\\%s", dwInitParam);
  if ( *nRet )
    goto LABEL_25;
  _swprintf(Dest, L"%s\\%s", L"Software\\Sysinternals", dwInitParam);
  phkResult = 0;
  *Data = 0;
  v10 = RegQueryValueExW;
  if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Sysinternals", 0, 0x101u, &phkResult) )
  {
    cbData = 4;
    v11 = RegQueryValueExW(phkResult, L"EulaAccepted", 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
    if ( !v11 && *Data )
      goto LABEL_22;
    v10 = RegQueryValueExW;
  }
  hKey = 0;
  *v54 = 0;
  if ( RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Sysinternals", 0, 0x101u, &hKey)
    || (v51 = 4, v12 = v10(hKey, L"EulaAccepted", 0, 0, v54, &v51), RegCloseKey(hKey), v12)
    || !*v54 )
  {
    if ( !sub_1226AE0(HKEY_CURRENT_USER, Dest) )
    {
      v13 = 0;
      goto LABEL_31;
    }
    *nRet = 1;
LABEL_25:
    if ( !RegCreateKey(HKEY_CURRENT_USER, SubKey, &v55) )
    {
      RegSetValueEx(v55, L"EulaAccepted", 0, 4u, nRet, 4u);
      RegCloseKey(v55);
    }
    if ( *nRet )
      v9 = 1;
    return v9 != 0;
  }
LABEL_22:
  v13 = 1;
LABEL_31:
  *nRet = v13;
  if ( v13 )
    goto LABEL_25;
  if ( sub_1226C00() )
  {
    res = sub_1227020();
    *nRet = res;
  }
  else
  {
    if ( OSIsNanoServer() || (hOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE), GetFileType(hOutputHandle) == 3) )
      sub_1227080();
    pDlgTemplate = LocalAlloc(0x40u, 0x3E8u);
    LoadLibraryW(L"Riched32.dll");
    pDlgTemplate->style = 0x80C808D0;
    strLicense = L"License Agreement";
    *&pDlgTemplate->y = 0;
    *&pDlgTemplate->cy = 0xB40138;
    pDlgTemplate->x = 0;
    pDlgTemplate->field_12 = 0;
    do
    {
      psz = *strLicense;
      ++strLicense;
      *(strLicense + pDlgTemplate->field_16 - L"License Agreement" - 2) = psz;
    }
    while ( psz );
    strDlgName = L"MS Shell Dlg";
    pDlgTemplate->field_16[18] = '\b';
    do
    {
      pszName = *strDlgName;
      ++strDlgName;
      *(strDlgName + &pDlgTemplate->field_16[19] - L"MS Shell Dlg" - 2) = pszName;
    }
    while ( pszName );
    v22 = (&pDlgTemplate->field_16[33] + 1) & 0xFFFFFFFC;
    v23 = v22 + 18;
    *(v22 + 16) = 0x1F6;
    v24 = L"You can also use the /accepteula command-line switch to accept the EULA.";
    *(v22 + 8) = 0x30007;
    v25 = v22 + 22 - L"You can also use the /accepteula command-line switch to accept the EULA.";
    *(v22 + 0xC) = 0xE012A;
    *v22 = 0x50000000;
    *(v22 + 18) = 0x82FFFF;
    do
    {
      v26 = *v24;
      ++v24;
      *(v24 + v25 - 2) = v26;
    }
    while ( v26 );
    *(v23 + 150) = 0;
    ++pDlgTemplate->x;
    v27 = (v23 + 155) & 0xFFFFFFFC;
    v28 = v27 + 18;
    *(v27 + 16) = 1;
    v29 = L"&Agree";
    *(v27 + 8) = 0x9F00C9;
    v30 = v27 + 22 - L"&Agree";
    *(v27 + 12) = 0xE0032;
    *v27 = 0x50010000;
    *(v27 + 18) = 0x80FFFF;
    do
    {
      v31 = *v29;
      ++v29;
      *(v29 + v30 - 2) = v31;
    }
    while ( v31 );
    *(v28 + 18) = 0;
    ++pDlgTemplate->x;
    v32 = (v28 + 23) & 0xFFFFFFFC;
    v33 = v32 + 18;
    *(v32 + 16) = 2;
    v34 = L"&Decline";
    *(v32 + 8) = 10420479;
    v35 = v32 + 22 - L"&Decline";
    *(v32 + 12) = 0xE0032;
    *v32 = 0x50010000;
    *(v32 + 18) = 0x80FFFF;
    do
    {
      v36 = *v34;
      ++v34;
      *(v34 + v35 - 2) = v36;
    }
    while ( v36 );
    *(v33 + 22) = 0;
    ++pDlgTemplate->x;
    v37 = (v33 + 27) & 0xFFFFFFFC;
    v38 = v37 + 18;
    *(v37 + 16) = 501;
    v39 = L"&Print";
    *(v37 + 8) = 0x9F0007;
    v40 = v37 + 22 - L"&Print";
    *(v37 + 12) = 0xE0032;
    *v37 = 0x50010000;
    *(v37 + 18) = 0x80FFFF;
    do
    {
      v41 = *v39;
      ++v39;
      *(v39 + v40 - 2) = v41;
    }
    while ( v41 );
    *(v38 + 18) = 0;
    ++pDlgTemplate->x;
    v42 = (v38 + 23) & 0xFFFFFFFC;
    v43 = v42 + 18;
    *(v42 + 16) = 500;
    v44 = L"RICHEDIT";
    *(v42 + 8) = 0xE0007;
    *(v42 + 12) = 0x8C012A;
    *v42 = 0x50A11844;
    v45 = v42 + 18 - L"RICHEDIT";
    do
    {
      v46 = *v44;
      ++v44;
      *(v44 + v45 - 2) = v46;
    }
    while ( v46 );
    v47 = L"&Decline";
    do
    {
      v48 = *v47;
      ++v47;
      *(v47 + v43 + 18 - L"&Decline" - 2) = v48;
    }
    while ( v48 );
    v49 = dwInitParam;
    *(v43 + 36) = 0;
    ++pDlgTemplate->x;
    *nRet = DialogBoxIndirectParamW(0, pDlgTemplate, 0, UserProtocolDialogFunc, v49);
    LocalFree(pDlgTemplate);
    res = *nRet;
  }
  if ( res )
    goto LABEL_25;
  return v9 != 0;
}
// 12E4DB4: using guessed type int gnArgc;

//----- (01227910) --------------------------------------------------------
int __stdcall sub_1227910(int a1, void *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // esi

  *a1;
  v4 = strlen(*a1);
  v5 = a3;
  if ( a3 > v4 )
    v5 = v4;
  memmove_0(a2, *a1, v5);
  *a4 = v5;
  *a1 += v5;
  return 0;
}

//----- (01227950) --------------------------------------------------------
int __cdecl OnTreeListNotify7D2()
{
  return 1;
}

//----- (01227960) --------------------------------------------------------
LRESULT __cdecl sub_1227960(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam)
{
  return MSGHANDLER::HandleCommand(&stru_12DC5BC, hWnd, wParam, lParam);
}

//----- (01227980) --------------------------------------------------------
int __cdecl EndDialogOK(HWND hDlg)
{
  EndDialog(hDlg, 1);
  return 1;
}

//----- (012279A0) --------------------------------------------------------
HBRUSH __stdcall AboutOrSymbolConfigWarningProc(HWND hDlg, UINT Msg, WPARAM hdc, LPARAM lParam)
{
  HWND hWndOwner; // edi
  DWORD dwSize; // esi
  void *pVersion; // edi
  const WCHAR *v7; // eax
  const WCHAR *v8; // eax
  COLORREF v10; // ST14_4
  HGDIOBJ v11; // eax
  POINT v12; // ST10_8
  HWND hWndChild; // eax
  int v14; // edx
  POINT v15; // ST10_8
  DWORD dwHandle; // [esp+Ch] [ebp-28Ch]
  LOGFONT lf; // [esp+10h] [ebp-288h]
  struct tagRECT rcOwnerWnd; // [esp+6Ch] [ebp-22Ch]
  struct tagRECT rcDlgWindow; // [esp+7Ch] [ebp-21Ch]
  __int16 szFileName[260]; // [esp+8Ch] [ebp-20Ch]

  switch ( Msg )
  {
    case WM_INITDIALOG:
      hWndOwner = ghWndNewOwner;
      ghDefaultGUIFont = GetStockObject(DEFAULT_GUI_FONT);
      GetObjectW(ghDefaultGUIFont, 92, &lf);
      lf.lfUnderline = 1;
      ghDefaultGUIFontUnderline = CreateFontIndirectW(&lf);
      dword_12E4DBC = 1;
      ghButtonExplore = GetDlgItem(hDlg, IDC_ABOUTDLG_STATIC_HOMEPAGE);
      if ( ghButtonExplore )
      {
        GetWindowRect(hWndOwner, &rcOwnerWnd);
        GetWindowRect(hDlg, &rcDlgWindow);
        rcOwnerWnd.left += 70;
        rcOwnerWnd.top += 60;
        MoveWindow(
          hDlg,
          rcOwnerWnd.left,
          rcOwnerWnd.top,
          rcDlgWindow.right - rcDlgWindow.left,
          rcDlgWindow.bottom - rcDlgWindow.top,
          1);
        GetModuleFileNameW(0, szFileName, _MAX_PATH);
        dwSize = GetFileVersionInfoSizeW(szFileName, &dwHandle);
        pVersion = malloc(dwSize);
        GetFileVersionInfoW(szFileName, 0, dwSize, pVersion);
        v7 = GetDescInfo(pVersion, L"FileVersion");
        SetDlgItemTextW(hDlg, IDC_ABOUTDLG_STATIC_VERSION_1132, v7);
        v8 = GetDescInfo(pVersion, L"LegalCopyright");
        SetDlgItemTextW(hDlg, IDC_ABOUTDLG_STATIC_COPYRIGHT, v8);
        free(pVersion);
      }
      else
      {
        ghButtonExplore = GetDlgItem(hDlg, IDD_PROCINFO_BUTTON_EXPLORE2);
      }
      ghCursorHand = LoadCursorW(ghInstance, L"HAND");
      ghCursorArrow = LoadCursorW(0, IDC_ARROW);
      return 1;
    case WM_CTLCOLORSTATIC:
      if ( lParam != ghButtonExplore )
        return MSGHANDLER::HandleMessage(&gpMsgHandlerEx, hDlg, Msg, hdc, lParam);
      SetBkMode(hdc, 1);
      if ( GetSysColorBrush(COLOR_HOTLIGHT) )
      {
        v10 = GetSysColor(COLOR_HOTLIGHT);
        SetTextColor(hdc, v10);
      }
      else
      {
        SetTextColor(hdc, 0xFF0000u);
      }
      v11 = ghDefaultGUIFont;
      if ( dword_12E4DBC )
        v11 = ghDefaultGUIFontUnderline;
      SelectObject(hdc, v11);
      return GetSysColorBrush(15);
    case WM_MOUSEFIRST:
      v12.y = lParam >> 16;
      v12.x = lParam;
      hWndChild = ChildWindowFromPoint(hDlg, v12);
      v14 = dword_12E4DBC;
      if ( dword_12E4DBC == (hWndChild == ghButtonExplore) )
      {
        dword_12E4DBC = dword_12E4DBC == 0;
        InvalidateRect(ghButtonExplore, 0, 0);
        v14 = dword_12E4DBC;
      }
      if ( v14 )
        SetCursor(ghCursorArrow);
      else
        SetCursor(ghCursorHand);
      return MSGHANDLER::HandleMessage(&gpMsgHandlerEx, hDlg, Msg, hdc, lParam);
    case WM_LBUTTONUP:
      v15.y = lParam >> 16;
      v15.x = lParam;
      if ( ChildWindowFromPoint(hDlg, v15) == ghButtonExplore )
      {
        if ( GetDlgItem(hDlg, IDC_ABOUTDLG_STATIC_HOMEPAGE) )
          ShellExecuteW(hDlg, L"open", L"http://www.sysinternals.com", 0, 0, 1);
        else
          ShellExecuteW(hDlg, L"open", L"http://www.microsoft.com/whdc/devtools/debugging/default.mspx", 0, 0, 1);
      }
      break;
    default:
      return MSGHANDLER::HandleMessage(&gpMsgHandlerEx, hDlg, Msg, hdc, lParam);
  }
  return MSGHANDLER::HandleMessage(&gpMsgHandlerEx, hDlg, Msg, hdc, lParam);
}
// 12BB0D4: using guessed type wchar_t aFileversion[12];
// 12BB0EC: using guessed type wchar_t aLegalcopyright[15];
// 12BB118: using guessed type wchar_t aHttpWwwSysinte[28];
// 12E4DBC: using guessed type int dword_12E4DBC;
// 12E4DC0: using guessed type int ghDefaultGUIFont;

//----- (01227DC0) --------------------------------------------------------
int __cdecl OnAbout(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"AboutBox", hWndParent, AboutOrSymbolConfigWarningProc, 0);
  return 0;
}

//----- (01227DF0) --------------------------------------------------------
char *__cdecl sub_1227DF0(char *a1, const unsigned __int16 *a2)
{
  signed int v2; // esi
  unsigned int v3; // ecx
  char *v4; // edx
  int v5; // eax
  signed int v6; // ebx
  unsigned int v7; // edi
  signed int v8; // ebx
  int v9; // edi
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  char *v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  _DWORD *v17; // ecx
  _DWORD *v18; // edx
  _WORD **v19; // ecx
  _WORD *v20; // edx
  __int16 v21; // ax
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  int v27; // eax
  _WORD **v28; // ecx
  _WORD *v29; // edx
  __int16 v30; // ax
  int v31; // eax
  char *v32; // ecx
  int v33; // eax
  int v34; // eax
  int v35; // ecx
  bool v36; // al
  int v37; // esi
  int v38; // ecx
  int v40; // [esp+0h] [ebp-70h]
  void **v41; // [esp+10h] [ebp-60h]
  void **v42; // [esp+24h] [ebp-4Ch]
  void **v43; // [esp+38h] [ebp-38h]
  __int64 v44; // [esp+4Ch] [ebp-24h]
  int v45; // [esp+54h] [ebp-1Ch]
  int v46; // [esp+58h] [ebp-18h]
  unsigned int v47; // [esp+5Ch] [ebp-14h]
  int *v48; // [esp+60h] [ebp-10h]
  int v49; // [esp+6Ch] [ebp-4h]

  v48 = &v40;
  v2 = 0;
  v45 = 0;
  if ( *a2 )
    v3 = wcslen(a2);
  else
    v3 = 0;
  v4 = a1;
  v47 = v3;
  v5 = *(*a1 + 4);
  v6 = *&a1[v5 + 36];
  v7 = *&a1[v5 + 32];
  if ( v6 >= 0 && (v6 > 0 || v7 && v6 >= 0 && (v6 > 0 || v7 > v3)) )
  {
    v8 = (__PAIR__(v6, v7) - v3) >> 32;
    v9 = v7 - v3;
  }
  else
  {
    v44 = 0i64;
    v8 = 0;
    v9 = 0;
  }
  v10 = *&a1[v5 + 56];
  LODWORD(v44) = a1;
  if ( v10 )
  {
    (*(*v10 + 4))();
    v4 = a1;
  }
  v11 = *v4;
  v49 = 0;
  v12 = *(v11 + 4);
  if ( !*&v4[v12 + 12] )
  {
    v13 = *&v4[v12 + 60];
    if ( v13 )
    {
      if ( v13 != v4 )
      {
        sub_1229D10(v13);
        v4 = a1;
      }
    }
  }
  v14 = *(*v4 + 4);
  BYTE4(v44) = *&v4[v14 + 12] == 0;
  v49 = 1;
  if ( BYTE4(v44) )
  {
    v15 = *&v4[v14 + 20] & 0x1C0;
    LOBYTE(v49) = 2;
    if ( v15 == 64 )
      goto LABEL_66;
    while ( v8 >= 0 && (v8 > 0 || v9) )
    {
      v16 = *(*v4 + 4);
      v46 = *&v4[v16 + 64];
      v17 = *&v4[v16 + 56];
      if ( *v17[8] && (v18 = v17[12], *v18 > 0) )
      {
        --*v18;
        v19 = v17[8];
        v20 = *v19;
        ++*v19;
        v21 = v46;
        *v20 = v46;
      }
      else
      {
        v21 = (*(*v17 + 12))(v46);
      }
      v4 = a1;
      if ( v21 == -1 )
      {
        v2 = 4;
        v45 = 4;
        break;
      }
      v8 = (__PAIR__(v8, v9--) - 1) >> 32;
    }
    if ( !v2 )
    {
LABEL_66:
      v22 = (*(**&v4[*(*v4 + 4) + 56] + 36))(a2, v47, 0);
      if ( v22 != v47 || v23 )
      {
        v2 = 4;
      }
      else
      {
        while ( v8 >= 0 && (v8 > 0 || v9) )
        {
          v24 = *(*a1 + 4);
          v25 = *&a1[v24 + 64];
          v26 = *&a1[v24 + 56];
          v46 = *&a1[v24 + 64];
          if ( **(v26 + 32) && (v27 = **(v26 + 48), v27 > 0) )
          {
            **(v26 + 48) = v27 - 1;
            v28 = *(v26 + 32);
            v29 = *v28;
            ++*v28;
            v30 = v46;
            *v29 = v46;
          }
          else
          {
            v30 = (*(*v26 + 12))(v25);
          }
          if ( v30 == -1 )
          {
            v2 |= 4u;
            break;
          }
          v8 = (__PAIR__(v8, v9--) - 1) >> 32;
        }
      }
      v4 = a1;
    }
    v31 = *(*v4 + 4);
    *&v4[v31 + 32] = 0;
    *&v4[v31 + 36] = 0;
    v49 = 1;
  }
  else
  {
    v2 = 4;
  }
  v32 = &v4[*(*v4 + 4)];
  if ( v2 )
  {
    v33 = v2 | *(v32 + 3);
    if ( !*(v32 + 14) )
      LOBYTE(v33) = v33 | 4;
    v34 = v33 & 0x17;
    *(v32 + 3) = v34;
    v35 = v34 & *(v32 + 4);
    if ( v35 )
    {
      if ( v35 & 4 )
      {
        sub_1228630(&v43, 1, off_12DAA40, "ios_base::badbit set");
        v43 = &std::ios_base::failure::`vftable';
        _CxxThrowException(&v43, &_TI5_AVfailure_ios_base_std__);
      }
      if ( v35 & 2 )
      {
        sub_1228630(&v42, 1, off_12DAA40, "ios_base::failbit set");
        v42 = &std::ios_base::failure::`vftable';
        _CxxThrowException(&v42, &_TI5_AVfailure_ios_base_std__);
      }
      sub_1228630(&v41, 1, off_12DAA40, "ios_base::eofbit set");
      v41 = &std::ios_base::failure::`vftable';
      _CxxThrowException(&v41, &_TI5_AVfailure_ios_base_std__);
    }
  }
  v49 = -1;
  v36 = __uncaught_exception();
  v37 = v44;
  if ( !v36 )
    sub_12292D0(v44);
  v38 = *(*(*v37 + 4) + v37 + 56);
  if ( v38 )
    (*(*v38 + 8))();
  return a1;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BBEB8: using guessed type void *std::ios_base::failure::`vftable';
// 12D4548: using guessed type int _TI5_AVfailure_ios_base_std__;
// 12DAA40: using guessed type int (__thiscall **off_12DAA40[2])(void *, char);

//----- (01228150) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_1228150(int *a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // ecx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  char v7; // [esp+10h] [ebp-24h]
  char v8; // [esp+1Ch] [ebp-18h]
  char v9; // [esp+20h] [ebp-14h]
  struct std::_Facet_base *v10; // [esp+24h] [ebp-10h]
  int v11; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit(&v8, 0);
  v1 = dword_1305868;
  v2 = dword_12E4DD0;
  v11 = 0;
  v10 = dword_12E4DD0;
  if ( !dword_1305868 )
  {
    std::_Lockit::_Lockit(&v9, dword_1305868);
    if ( dword_1305868 == v1 )
      dword_1305868 = ++dword_1305840;
    std::_Lockit::~_Lockit(&v9);
    v1 = dword_1305868;
  }
  v3 = *a1;
  if ( v1 >= *(*a1 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(*(v3 + 8) + 4 * v1);
    if ( v4 )
      goto LABEL_19;
  }
  if ( !*(v3 + 20) )
    goto LABEL_12;
  v5 = sub_1284C4A();
  if ( v1 < *(v5 + 12) )
  {
    v4 = *(*(v5 + 8) + 4 * v1);
LABEL_12:
    if ( v4 )
      goto LABEL_19;
  }
  if ( v2 )
  {
    v4 = v2;
  }
  else
  {
    if ( sub_1229090(&v10, a1) == -1 )
    {
      sub_1289D12(&v7, "bad cast");
      _CxxThrowException(&v7, &_TI2_AVbad_cast_std__);
    }
    v4 = v10;
    dword_12E4DD0 = v10;
    (*(*v10 + 4))(v10);
    std::_Facet_Register(v4);
  }
LABEL_19:
  std::_Lockit::~_Lockit(&v8);
  return v4;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12D45C4: using guessed type int _TI2_AVbad_cast_std__;
// 12E4DD0: using guessed type int dword_12E4DD0;
// 1305840: using guessed type int dword_1305840;

//----- (01228270) --------------------------------------------------------
_DWORD *__thiscall sub_1228270(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi

  v1 = this;
  *this = &std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';
  v2 = operator new(4u);
  if ( v2 )
    *v2 = std::locale::_Init(1);
  else
    v2 = 0;
  v1[13] = v2;
  v1[3] = v1 + 1;
  v1[4] = v1 + 2;
  v1[7] = v1 + 5;
  v1[8] = v1 + 6;
  v1[11] = v1 + 9;
  v1[12] = v1 + 10;
  v1[2] = 0;
  *v1[8] = 0;
  *v1[12] = 0;
  *v1[3] = 0;
  *v1[7] = 0;
  *v1[11] = 0;
  return v1;
}
// 12BBF1C: using guessed type void *std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';

//----- (01228300) --------------------------------------------------------
char *__thiscall sub_1228300(char *this, int a2, int a3)
{
  char *v3; // esi
  _Cvtvec v4; // rax
  char v6; // [esp+30h] [ebp-10h]

  v3 = this;
  *(this + 1) = a3;
  *this = &std::ctype<unsigned short>::`vftable';
  _mm_storeu_si128((this + 8), _mm_loadu_si128(_Getctype(&v6)));
  v4 = _Getcvt();
  _mm_storeu_si128((v3 + 24), _mm_loadu_si128(v4._Hand));
  _mm_storeu_si128((v3 + 40), _mm_loadu_si128((v4._Hand + 16)));
  _mm_storel_epi64((v3 + 56), _mm_loadl_epi64((v4._Hand + 32)));
  *(v3 + 16) = *(v4._Hand + 40);
  return v3;
}
// 12BBE5C: using guessed type void *std::ctype<unsigned short>::`vftable';

//----- (01228360) --------------------------------------------------------
struct std::_Locinfo *__thiscall sub_1228360(struct std::_Locinfo *this, char *a2)
{
  struct std::_Locinfo *v2; // esi
  void **v4; // [esp+8h] [ebp-1Ch]
  struct std::_Locinfo *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  v2 = this;
  v5 = this;
  std::_Lockit::_Lockit(this, 0);
  v6 = 0;
  *(v2 + 1) = 0;
  *(v2 + 8) = 0;
  *(v2 + 3) = 0;
  *(v2 + 16) = 0;
  *(v2 + 5) = 0;
  *(v2 + 12) = 0;
  *(v2 + 7) = 0;
  *(v2 + 16) = 0;
  *(v2 + 9) = 0;
  *(v2 + 40) = 0;
  *(v2 + 11) = 0;
  *(v2 + 48) = 0;
  LOBYTE(v6) = 6;
  if ( !a2 )
  {
    a2 = "bad locale name";
    std::exception::exception(&v4, &a2);
    v4 = &std::runtime_error::`vftable';
    _CxxThrowException(&v4, &_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor(v2, a2);
  return v2;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BBE30: using guessed type void *std::runtime_error::`vftable';
// 12D44F4: using guessed type int _TI2_AVruntime_error_std__;

//----- (01228420) --------------------------------------------------------
std::exception *__thiscall sub_1228420(std::exception *this, int a2, int a3, int a4)
{
  std::exception *v4; // esi
  char *v5; // eax
  bool v6; // cf
  std::exception *result; // eax
  int v8; // [esp+0h] [ebp-4Ch]
  int v9; // [esp+4h] [ebp-48h]
  int v10; // [esp+8h] [ebp-44h]
  int v11; // [esp+Ch] [ebp-40h]
  int v12; // [esp+10h] [ebp-3Ch]
  int v13; // [esp+14h] [ebp-38h]
  char *v14; // [esp+20h] [ebp-2Ch]
  void *v15; // [esp+24h] [ebp-28h]
  unsigned int v16; // [esp+38h] [ebp-14h]
  int v17; // [esp+48h] [ebp-4h]

  v4 = this;
  v13 = 15;
  v12 = 0;
  LOBYTE(v8) = 0;
  sub_1216F00(&v8, a4, 0, 0xFFFFFFFF);
  v5 = sub_12291F0(&v15, a2, a3, v8, v9, v10, v11, v12, v13);
  v6 = *(v5 + 5) < 0x10u;
  v17 = 0;
  if ( !v6 )
    v5 = *v5;
  v14 = v5;
  std::exception::exception(v4, &v14);
  v6 = v16 < 0x10;
  *v4 = &std::runtime_error::`vftable';
  if ( !v6 )
    j__free(v15);
  result = v4;
  *(v4 + 3) = a2;
  *v4 = &std::_System_error::`vftable';
  *(v4 + 4) = a3;
  return result;
}
// 12BBE30: using guessed type void *std::runtime_error::`vftable';
// 12BBE9C: using guessed type void *std::_System_error::`vftable';

//----- (012284F0) --------------------------------------------------------
std::exception *__thiscall sub_12284F0(std::exception *this, struct exception *a2)
{
  std::exception *v2; // edi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::_System_error::`vftable';
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  return v2;
}
// 12BBE9C: using guessed type void *std::_System_error::`vftable';

//----- (01228520) --------------------------------------------------------
std::exception *__thiscall sub_1228520(std::exception *this, struct exception *a2)
{
  std::exception *v2; // edi
  std::exception *result; // eax

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::_System_error::`vftable';
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  result = v2;
  *v2 = &std::ios_base::failure::`vftable';
  return result;
}
// 12BBE9C: using guessed type void *std::_System_error::`vftable';
// 12BBEB8: using guessed type void *std::ios_base::failure::`vftable';

//----- (01228550) --------------------------------------------------------
std::exception *__thiscall sub_1228550(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::runtime_error::`vftable';
  return v2;
}
// 12BBE30: using guessed type void *std::runtime_error::`vftable';

//----- (01228570) --------------------------------------------------------
_DWORD *__thiscall sub_1228570(_DWORD *this, int a2)
{
  _DWORD *v2; // edi
  int v3; // ecx
  int v4; // eax
  char *v5; // ecx

  v2 = this;
  *this = a2;
  v3 = *(*(*a2 + 4) + a2 + 56);
  if ( v3 )
    (*(*v3 + 4))();
  v4 = *(*a2 + 4);
  if ( !*(v4 + a2 + 12) )
  {
    v5 = *(v4 + a2 + 60);
    if ( v5 )
    {
      if ( v5 != a2 )
        sub_1229D10(v5);
    }
  }
  *(v2 + 4) = *(*(*a2 + 4) + a2 + 12) == 0;
  return v2;
}

//----- (01228600) --------------------------------------------------------
std::exception *__thiscall sub_1228600(std::exception *this, struct exception *a2)
{
  std::exception *v2; // edi
  std::exception *result; // eax

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::_System_error::`vftable';
  *(v2 + 3) = *(a2 + 3);
  *(v2 + 4) = *(a2 + 4);
  result = v2;
  *v2 = &std::system_error::`vftable';
  return result;
}
// 12BBE9C: using guessed type void *std::_System_error::`vftable';
// 12BBEAC: using guessed type void *std::system_error::`vftable';

//----- (01228630) --------------------------------------------------------
std::exception *__thiscall sub_1228630(std::exception *this, int a2, int a3, void *a4)
{
  std::exception *v4; // esi
  size_t v5; // ecx
  std::exception *result; // eax
  void *v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+1Ch] [ebp-18h]
  unsigned int v9; // [esp+20h] [ebp-14h]
  int v10; // [esp+30h] [ebp-4h]

  v4 = this;
  v9 = 15;
  v8 = 0;
  LOBYTE(v7) = 0;
  if ( *a4 )
    v5 = strlen(a4);
  else
    v5 = 0;
  sub_1217030(&v7, a4, v5);
  v10 = 0;
  sub_1228420(v4, a2, a3, &v7);
  if ( v9 >= 0x10 )
    j__free(v7);
  result = v4;
  *v4 = &std::system_error::`vftable';
  return result;
}
// 12BBEAC: using guessed type void *std::system_error::`vftable';

//----- (012287D0) --------------------------------------------------------
int __thiscall sub_12287D0(_DWORD *this)
{
  _DWORD *v1; // edi
  void *v2; // esi
  void (__thiscall ***v3)(_DWORD, signed int); // eax
  int v4; // ecx
  int result; // eax

  v1 = this;
  *(this + *(*(this - 26) + 4) - 104) = &std::basic_stringstream<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
  *(v1 + *(*(v1 - 26) + 4) - 108) = *(*(v1 - 26) + 4) - 104;
  *(this - 20) = &std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
  sub_1229420((this - 20));
  v2 = *(v1 - 7);
  *(v1 - 20) = &std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';
  if ( v2 )
  {
    if ( *v2 )
    {
      v3 = (*(**v2 + 8))();
      if ( v3 )
        (**v3)(v3, 1);
    }
    j__free(v2);
  }
  *(v1 + *(*(v1 - 26) + 4) - 104) = &std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  *(v1 + *(*(v1 - 26) + 4) - 108) = *(*(v1 - 26) + 4) - 32;
  *(v1 + *(*(v1 - 22) + 4) - 88) = &std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  *(v1 + *(*(v1 - 22) + 4) - 92) = *(*(v1 - 22) + 4) - 8;
  *(v1 + *(*(v1 - 26) + 4) - 104) = &std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  v4 = *(*(v1 - 26) + 4);
  result = v4 - 24;
  *(v1 + v4 - 108) = v4 - 24;
  return result;
}
// 12BBF14: using guessed type void *std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF1C: using guessed type void *std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF5C: using guessed type void *std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF64: using guessed type void *std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF6C: using guessed type void *std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
// 12BBFAC: using guessed type void *std::basic_stringstream<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';

//----- (01228880) --------------------------------------------------------
int __thiscall sub_1228880(std::_Lockit *this)
{
  void **v1; // esi

  v1 = this;
  std::_Locinfo::_Locinfo_dtor(this);
  if ( v1[11] )
    free(v1[11]);
  v1[11] = 0;
  if ( v1[9] )
    free(v1[9]);
  v1[9] = 0;
  if ( v1[7] )
    free(v1[7]);
  v1[7] = 0;
  if ( v1[5] )
    free(v1[5]);
  v1[5] = 0;
  if ( v1[3] )
    free(v1[3]);
  v1[3] = 0;
  if ( v1[1] )
    free(v1[1]);
  v1[1] = 0;
  return std::_Lockit::~_Lockit(v1);
}

//----- (01228990) --------------------------------------------------------
void __thiscall sub_1228990(_DWORD *this)
{
  _DWORD *v1; // edx

  v1 = this + 8;
  *(v1 + *(*this + 4) - 32) = &std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  *(v1 + *(*this + 4) - 36) = *(*this + 4) - 32;
  *(v1 + *(this[4] + 4) - 16) = &std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  *(v1 + *(this[4] + 4) - 20) = *(this[4] + 4) - 8;
  *(v1 + *(*this + 4) - 32) = &std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  *(v1 + *(*this + 4) - 36) = *(*this + 4) - 24;
  *v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((this + 8));
}
// 12BBEC4: using guessed type void *std::ios_base::`vftable';
// 12BBF14: using guessed type void *std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF5C: using guessed type void *std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF64: using guessed type void *std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable';

//----- (01228A1C) --------------------------------------------------------
void __fastcall sub_1228A1C(unsigned int a1, int a2, int a3)
{
  bool v3; // cf

  v3 = a1 < *(a1 - 4);
  JUMPOUT(&loc_1228A40);
}

//----- (01228A24) --------------------------------------------------------
void __fastcall sub_1228A24(unsigned int a1, int a2, int a3)
{
  bool v3; // cf

  v3 = a1 < *(a1 - 4);
  JUMPOUT(&loc_1228A70);
}

//----- (01228A2C) --------------------------------------------------------
char *__thiscall sub_1228A2C(_DWORD *this, char a2)
{
  struct std::ios_base *v2; // ecx
  char *v3; // esi

  v2 = (this - *(this - 1));
  v3 = v2 - 8;
  *(v2 + *(*(v2 - 2) + 4) - 8) = &std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
  *(v2 + *(*(v2 - 2) + 4) - 12) = *(*(v2 - 2) + 4) - 8;
  *v2 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v2);
  if ( a2 & 1 )
    j__free(v3);
  return v3;
}
// 12BBEC4: using guessed type void *std::ios_base::`vftable';
// 12BBF14: using guessed type void *std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';

//----- (01228B10) --------------------------------------------------------
void *__thiscall sub_1228B10(void *this, char a2)
{
  void *v2; // esi
  void *v3; // edi
  void (__thiscall ***v4)(_DWORD, signed int); // eax

  v2 = this;
  v3 = *(this + 13);
  *this = &std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';
  if ( v3 )
  {
    if ( *v3 )
    {
      v4 = (*(**v3 + 8))();
      if ( v4 )
        (**v4)(v4, 1);
    }
    j__free(v3);
  }
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BBF1C: using guessed type void *std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';

//----- (01228B60) --------------------------------------------------------
_DWORD *__thiscall sub_1228B60(void *this, char a2)
{
  _DWORD *v2; // esi
  void *v3; // edi
  void (__thiscall ***v4)(_DWORD, signed int); // eax

  v2 = this;
  *this = &std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
  sub_1229420(this);
  v3 = v2[13];
  *v2 = &std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';
  if ( v3 )
  {
    if ( *v3 )
    {
      v4 = (*(**v3 + 8))();
      if ( v4 )
        (**v4)(v4, 1);
    }
    j__free(v3);
  }
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BBF1C: using guessed type void *std::basic_streambuf<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF6C: using guessed type void *std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';

//----- (01228BC0) --------------------------------------------------------
_DWORD *__thiscall sub_1228BC0(struct std::ios_base *this, char a2)
{
  char *v2; // edi
  struct std::ios_base *v3; // esi

  v2 = this - 104;
  v3 = this;
  sub_12287D0(this);
  *v3 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v3);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BBEC4: using guessed type void *std::ios_base::`vftable';

//----- (01228C00) --------------------------------------------------------
void **__thiscall sub_1228C00(void *this, char a2)
{
  void **v2; // esi
  bool v3; // zf

  v2 = this;
  v3 = *(this + 4) == 0;
  *this = &std::ctype<unsigned short>::`vftable';
  if ( !v3 )
    free(*(this + 3));
  free(v2[5]);
  *v2 = &std::_Facet_base::`vftable';
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BBE4C: using guessed type void *std::_Facet_base::`vftable';
// 12BBE5C: using guessed type void *std::ctype<unsigned short>::`vftable';

//----- (01228C50) --------------------------------------------------------
void *__thiscall sub_1228C50(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::_Facet_base::`vftable';
  if ( a2 & 1 )
    j__free(this);
  return v2;
}
// 12BBE4C: using guessed type void *std::_Facet_base::`vftable';

//----- (01228C80) --------------------------------------------------------
struct std::ios_base *__thiscall sub_1228C80(struct std::ios_base *this, char a2)
{
  struct std::ios_base *v2; // esi

  v2 = this;
  *this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BBEC4: using guessed type void *std::ios_base::`vftable';

//----- (01228CB0) --------------------------------------------------------
void *__thiscall sub_1228CB0(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_1289D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (01228CE0) --------------------------------------------------------
void __cdecl sub_1228CE0(int a1, int a2, wchar_t *a3)
{
  wchar_t *v3; // esi
  const wchar_t *v4; // ecx
  wchar_t v5; // ax
  unsigned int v6; // edi
  int v7; // eax
  char v8; // dl
  wchar_t *v9; // eax
  wchar_t *v10; // ecx
  wchar_t v11; // ax
  _WORD *v12; // eax
  const wchar_t *v13; // ecx
  const wchar_t *v14; // ecx
  wchar_t v15; // ax
  int v16; // [esp+10h] [ebp-E4h]
  _DWORD *v17; // [esp+14h] [ebp-E0h]
  __int64 v18; // [esp+1Ch] [ebp-D8h]
  char v19[8]; // [esp+24h] [ebp-D0h]
  void **v20; // [esp+2Ch] [ebp-C8h]
  int v21; // [esp+64h] [ebp-90h]
  int v22; // [esp+68h] [ebp-8Ch]
  int v23; // [esp+78h] [ebp-7Ch]
  void **v24; // [esp+7Ch] [ebp-78h]
  int v25; // [esp+C4h] [ebp-30h]
  char v26; // [esp+CBh] [ebp-29h]
  wchar_t *v27; // [esp+CCh] [ebp-28h]
  int v28; // [esp+DCh] [ebp-18h]
  unsigned int v29; // [esp+E0h] [ebp-14h]
  int v30; // [esp+F0h] [ebp-4h]

  v3 = a3;
  v25 = 0;
  if ( a1 )
  {
    v17 = &unk_12BBFB0;
    *v19 = dword_12BBFB8;
    v30 = 0;
    v25 = 1;
    v24 = &std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable';
    v23 = 80;
    v18 = 0i64;
    sub_1229E70(&v24, &v20, 0);
    *&v19[dword_12BBFB8[1]] = &std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
    *(&v18 + *(*v19 + 4) + 4) = *(*v19 + 4) - 8;
    *(&v17 + v17[1]) = &std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
    *(&v16 + v17[1]) = v17[1] - 32;
    v30 = 5;
    *(&v17 + v17[1]) = &std::basic_stringstream<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
    *(&v16 + v17[1]) = v17[1] - 104;
    sub_1228270(&v20);
    v20 = &std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
    v21 = 0;
    v22 = 0;
    v30 = 7;
    sub_1229000(&v17, a1, &gAccessMaskText, 8);
    v26 = 1;
    v6 = 0;
    do
    {
      v7 = wcscmp(a2, (&off_12DCB90)[v6]);
      if ( v7 )
        v7 = -(v7 < 0) | 1;
      if ( v7 )
      {
        v8 = v26;
      }
      else
      {
        sub_1229000(&v17, a1, (&off_12DCB88)[v6], dword_12DCB8C[v6]);
        v8 = 0;
        v26 = 0;
      }
      v6 += 3;
    }
    while ( v6 < 39 );
    if ( v8 )
    {
      if ( a1 )
        sub_1227DF0(v19, L"<Unknown>");
      else
        sub_1227DF0(v19, L"<None>");
      v9 = sub_122A6E0(&v17, &v27);
      v10 = v9;
      if ( *(v9 + 5) >= 8u )
        v10 = *v9;
      do
      {
        v11 = *v10;
        ++v10;
        *v3 = v11;
        ++v3;
      }
      while ( v11 );
      if ( v29 >= 8 )
        j__free(v27);
      v29 = 7;
      v28 = 0;
      LOWORD(v27) = 0;
    }
    else
    {
      sub_122A6E0(&v17, &v27);
      if ( v28 )
      {
        v12 = &v27;
        if ( v29 >= 8 )
          v12 = v27;
        v12[v28 - 3] = 0;
        v13 = &v27;
        if ( v29 >= 8 )
          v13 = v27;
        wcsncpy(a3, v13, v28 - 2);
      }
      else
      {
        v14 = L"<Unknown>";
        do
        {
          v15 = *v14;
          ++v14;
          *(v14 + a3 - L"<Unknown>" - 2) = v15;
        }
        while ( v15 );
      }
      if ( v29 >= 8 )
        j__free(v27);
    }
    v30 = -1;
    sub_12287D0(&v24);
    v24 = &std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor(&v24);
  }
  else
  {
    v4 = L"<None>";
    do
    {
      v5 = *v4;
      ++v4;
      *(v4 + a3 - L"<None>" - 2) = v5;
    }
    while ( v5 );
  }
}
// 12BBEC4: using guessed type void *std::ios_base::`vftable';
// 12BBF14: using guessed type void *std::basic_ostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF5C: using guessed type void *std::basic_istream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF64: using guessed type void *std::basic_iostream<unsigned short,std::char_traits<unsigned short>>::`vftable';
// 12BBF6C: using guessed type void *std::basic_stringbuf<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
// 12BBFAC: using guessed type void *std::basic_stringstream<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::`vftable';
// 12BBFD8: using guessed type wchar_t aUnknown_0[10];
// 12DC5C8: using guessed type int gAccessMaskText;
// 12DCB88: using guessed type int *off_12DCB88;
// 12DCB8C: using guessed type int dword_12DCB8C[];
// 12DCB90: using guessed type wchar_t *off_12DCB90;

//----- (01229000) --------------------------------------------------------
int __cdecl sub_1229000(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // ebx
  char *v6; // eax
  char *v7; // eax
  int v8; // eax

  v4 = 0;
  if ( a4 > 0 )
  {
    while ( 1 )
    {
      v5 = a3 + 12 * v4;
      if ( (a2 & *v5) == *v5 )
      {
        if ( a1 )
          v6 = (a1 + 16);
        else
          v6 = 0;
        v7 = sub_1227DF0(v6, *(v5 + 4));
        sub_1227DF0(v7, L" | ");
        v8 = *(v5 + 8);
        if ( v8 < 0 )
          return a1;
        v4 += v8;
      }
      if ( ++v4 >= a4 )
        return a1;
    }
  }
  return a1;
}
// 12BBFC0: using guessed type wchar_t asc_12BBFC0[4];

//----- (01229070) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_1229070(volatile signed __int32 *this)
{
  volatile signed __int32 *result; // eax

  result = 0;
  if ( !_InterlockedExchangeAdd(this + 1, 0xFFFFFFFF) )
    result = this;
  return result;
}

//----- (01229090) --------------------------------------------------------
signed int __cdecl sub_1229090(char **a1, int *a2)
{
  char v2; // bl
  char *v3; // edi
  int v4; // ecx
  char *v5; // eax
  struct std::_Locinfo *v6; // eax
  char *v7; // eax
  char v9; // [esp+10h] [ebp-44h]
  int v10; // [esp+44h] [ebp-10h]
  int v11; // [esp+50h] [ebp-4h]

  v2 = 0;
  v10 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x44u);
    v11 = 0;
    if ( v3 )
    {
      v4 = *a2;
      if ( *a2 )
      {
        v5 = *(v4 + 24);
        if ( !v5 )
          v5 = (v4 + 28);
      }
      else
      {
        v5 = gszStatusBarText;
      }
      v6 = sub_1228360(&v9, v5);
      v2 = 1;
      v7 = sub_1228300(v3, v6, 0);
    }
    else
    {
      v7 = 0;
    }
    *a1 = v7;
    if ( v2 & 1 )
      sub_1228880(&v9);
  }
  return 2;
}

//----- (01229140) --------------------------------------------------------
__int64 __thiscall sub_1229140(_DWORD **this)
{
  __int64 result; // rax

  if ( *this[7] )
    result = *this[11];
  else
    result = 0i64;
  return result;
}

//----- (01229160) --------------------------------------------------------
signed __int32 __thiscall sub_1229160(volatile signed __int32 *this)
{
  return _InterlockedExchangeAdd(this + 1, 1u);
}

//----- (01229170) --------------------------------------------------------
struct std::locale::_Locimp *__thiscall sub_1229170(_DWORD *this)
{
  _DWORD *v1; // esi
  struct std::locale::_Locimp *result; // eax
  struct std::locale::_Locimp *v3; // edi

  v1 = this;
  this[12] = 0;
  this[2] = 0;
  this[4] = 0;
  this[5] = 513;
  this[6] = 6;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 0;
  sub_1229860(this, 0);
  result = operator new(4u);
  v3 = result;
  if ( result )
  {
    result = std::locale::_Init(1);
    *v3 = result;
    v1[12] = v3;
  }
  else
  {
    v1[12] = 0;
  }
  return result;
}

//----- (012291F0) --------------------------------------------------------
void *__cdecl sub_12291F0(void *a1, char a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // eax
  int v10; // edx
  void *result; // eax
  void *v12; // [esp+Ch] [ebp-28h]
  unsigned int v13; // [esp+20h] [ebp-14h]
  int v14; // [esp+30h] [ebp-4h]

  v14 = 0;
  if ( a8 )
    sub_1229550(&a4, &unk_12BBEA4, 2u);
  v9 = sub_1229F90(&a2, &v12);
  LOBYTE(v14) = 1;
  sub_1229490(&a4, v9, 0, -1);
  if ( v13 >= 0x10 )
    j__free(v12);
  *(a1 + 5) = 15;
  *(a1 + 4) = 0;
  *a1 = 0;
  v10 = a9;
  if ( a9 >= 0x10 )
  {
    *a1 = a4;
  }
  else if ( a8 != -1 )
  {
    memmove(a1, &a4, a8 + 1);
    v10 = a9;
  }
  result = a1;
  *(a1 + 4) = a8;
  *(a1 + 5) = v10;
  return result;
}

//----- (012292D0) --------------------------------------------------------
int __thiscall sub_12292D0(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax
  int result; // eax
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // ecx
  char v7; // al
  int v8; // ecx
  int v9; // [esp+0h] [ebp-5Ch]
  void **v10; // [esp+10h] [ebp-4Ch]
  void **v11; // [esp+24h] [ebp-38h]
  void **v12; // [esp+38h] [ebp-24h]
  int *v13; // [esp+4Ch] [ebp-10h]
  int v14; // [esp+58h] [ebp-4h]

  v13 = &v9;
  v1 = this;
  v2 = *this;
  v14 = 0;
  result = *(v2 + 4);
  if ( !*(this + result + 12) )
  {
    if ( *(this + result + 20) & 2 )
    {
      result = (*(**(this + result + 56) + 52))();
      if ( result == -1 )
      {
        v4 = *(*v1 + 4);
        v5 = *(v1 + v4 + 12);
        v6 = (v1 + v4);
        v7 = v5 | 4;
        if ( !v6[14] )
          v7 |= 4u;
        result = v7 & 0x17;
        v6[3] = result;
        v8 = result & v6[4];
        if ( v8 )
        {
          if ( v8 & 4 )
          {
            sub_1228630(&v12, 1, off_12DAA40, "ios_base::badbit set");
            v12 = &std::ios_base::failure::`vftable';
            _CxxThrowException(&v12, &_TI5_AVfailure_ios_base_std__);
          }
          if ( v8 & 2 )
          {
            sub_1228630(&v11, 1, off_12DAA40, "ios_base::failbit set");
            v11 = &std::ios_base::failure::`vftable';
            _CxxThrowException(&v11, &_TI5_AVfailure_ios_base_std__);
          }
          sub_1228630(&v10, 1, off_12DAA40, "ios_base::eofbit set");
          v10 = &std::ios_base::failure::`vftable';
          _CxxThrowException(&v10, &_TI5_AVfailure_ios_base_std__);
        }
      }
    }
  }
  return result;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BBEB8: using guessed type void *std::ios_base::failure::`vftable';
// 12D4548: using guessed type int _TI5_AVfailure_ios_base_std__;
// 12DAA40: using guessed type int (__thiscall **off_12DAA40[2])(void *, char);

//----- (01229400) --------------------------------------------------------
__int64 __thiscall sub_1229400(_DWORD **this)
{
  __int64 result; // rax

  if ( *this[8] )
    result = *this[12];
  else
    result = 0i64;
  return result;
}

//----- (01229420) --------------------------------------------------------
_DWORD *__thiscall sub_1229420(int this)
{
  int v1; // esi
  _DWORD *result; // eax

  v1 = this;
  if ( *(this + 60) & 1 )
    j__free(**(this + 12));
  **(v1 + 12) = 0;
  **(v1 + 28) = 0;
  **(v1 + 44) = 0;
  **(v1 + 16) = 0;
  **(v1 + 32) = 0;
  result = *(v1 + 48);
  *result = 0;
  *(v1 + 60) &= 0xFFFFFFFE;
  *(v1 + 56) = 0;
  return result;
}

//----- (01229490) --------------------------------------------------------
_DWORD *__thiscall sub_1229490(void *this, int a2, int a3, int a4)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  int v9; // ecx
  _DWORD *v10; // ecx
  int v11; // ecx
  bool v12; // cf
  int v14; // [esp+14h] [ebp+8h]

  v4 = a2;
  v5 = this;
  v6 = *(a2 + 16);
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = a4;
  v8 = v6 - a3;
  v9 = *(this + 4);
  v14 = v5[4];
  if ( v8 < a4 )
    v7 = v8;
  if ( -1 - v9 <= v7 )
    std::_Xlength_error("string too long");
  if ( v7 && sub_1216E00(v5, v9 + v7, 0) )
  {
    if ( v4[5] >= 0x10u )
      v4 = *v4;
    if ( v5[5] < 0x10u )
      v10 = v5;
    else
      v10 = *v5;
    if ( v7 )
      memmove_0(v10 + v5[4], v4 + a3, v7);
    v11 = v7 + v14;
    v12 = v5[5] < 0x10u;
    v5[4] = v7 + v14;
    if ( !v12 )
    {
      *(*v5 + v11) = 0;
      return v5;
    }
    *(v5 + v11) = 0;
  }
  return v5;
}

//----- (01229550) --------------------------------------------------------
_DWORD *__thiscall sub_1229550(void *this, void *a2, size_t a3)
{
  void *v3; // edi
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // eax
  _DWORD *v7; // edx
  _DWORD *result; // eax
  char *v9; // ecx
  _DWORD *v10; // ecx
  size_t v11; // ecx
  bool v12; // cf
  char *v13; // [esp+10h] [ebp+8h]

  v3 = a2;
  v4 = this;
  if ( a2
    && ((v5 = *(this + 5), v5 < 0x10) ? (v6 = v4) : (v6 = *v4),
        a2 >= v6 && (v5 < 0x10 ? (v7 = v4) : (v7 = *v4), v7 + v4[4] > a2)) )
  {
    if ( v5 < 0x10 )
      result = sub_1229490(v4, v4, a2 - v4, a3);
    else
      result = sub_1229490(v4, v4, a2 - *v4, a3);
  }
  else
  {
    v9 = v4[4];
    v13 = v9;
    if ( -1 - v9 <= a3 )
      std::_Xlength_error("string too long");
    if ( a3 && sub_1216E00(v4, &v9[a3], 0) )
    {
      if ( v4[5] < 0x10u )
        v10 = v4;
      else
        v10 = *v4;
      if ( a3 )
        memmove_0(v10 + v4[4], v3, a3);
      v11 = &v13[a3];
      v12 = v4[5] < 0x10u;
      v4[4] = &v13[a3];
      if ( !v12 )
      {
        *(*v4 + v11) = 0;
        return v4;
      }
      *(v4 + v11) = 0;
    }
    result = v4;
  }
  return result;
}

//----- (01229640) --------------------------------------------------------
int *__thiscall sub_1229640(int *this, int *a2, unsigned int a3, unsigned int a4)
{
  int *v4; // ebx
  int *v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // edi
  unsigned int v8; // edi
  unsigned int v9; // eax
  bool v10; // cf
  int v11; // edx
  int *result; // eax
  unsigned int v13; // eax
  int *v14; // edx

  v4 = a2;
  v5 = this;
  v6 = a3;
  v7 = a2[4];
  if ( v7 < a3 )
    std::_Xout_of_range("invalid string position");
  v8 = v7 - a3;
  if ( a4 < v8 )
    v8 = a4;
  if ( v5 != a2 )
  {
    if ( v8 > 0x7FFFFFFE )
      std::_Xlength_error("string too long");
    v13 = v5[5];
    if ( v13 >= v8 )
    {
      if ( !v8 )
      {
        v5[4] = 0;
        if ( v13 < 8 )
        {
          result = v5;
          *v5 = 0;
        }
        else
        {
          **v5 = 0;
          result = v5;
        }
        return result;
      }
    }
    else
    {
      sub_11FF9D0(v5, v8, v5[4]);
      v6 = a3;
      if ( !v8 )
        return v5;
    }
    if ( a2[5] >= 8 )
      v4 = *a2;
    if ( v5[5] < 8 )
      v14 = v5;
    else
      v14 = *v5;
    if ( v8 )
      memmove_0(v14, v4 + 2 * v6, 2 * v8);
    v10 = v5[5] < 8;
    v5[4] = v8;
    if ( !v10 )
    {
      *(*v5 + 2 * v8) = 0;
      return v5;
    }
    *(v5 + v8) = 0;
    return v5;
  }
  v9 = v8 + a3;
  if ( v5[4] < v8 + a3 )
    std::_Xout_of_range("invalid string position");
  v10 = v5[5] < 8;
  v5[4] = v9;
  if ( v10 )
    v11 = v5;
  else
    v11 = *v5;
  *(v11 + 2 * v9) = 0;
  sub_1229C60(v5, 0, a3);
  return v5;
}

//----- (01229760) --------------------------------------------------------
int *__thiscall sub_1229760(int *this, void *a2, int a3)
{
  int *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // eax
  int v6; // edx
  int v7; // eax
  int *result; // eax
  unsigned int v9; // eax
  int *v10; // ecx
  bool v11; // cf

  v3 = this;
  if ( !a2
    || ((v4 = this[5], v4 < 8) ? (v5 = v3) : (v5 = *v3),
        a2 < v5 || (v4 < 8 ? (v6 = v3) : (v6 = *v3), v6 + 2 * v3[4] <= a2)) )
  {
    if ( a3 > 0x7FFFFFFE )
      std::_Xlength_error("string too long");
    v9 = v3[5];
    if ( v9 >= a3 )
    {
      if ( !a3 )
      {
        v3[4] = 0;
        if ( v9 < 8 )
        {
          result = v3;
          *v3 = 0;
        }
        else
        {
          **v3 = 0;
          result = v3;
        }
        return result;
      }
    }
    else
    {
      sub_11FF9D0(v3, a3, v3[4]);
      if ( !a3 )
        return v3;
    }
    if ( v3[5] < 8 )
      v10 = v3;
    else
      v10 = *v3;
    if ( a3 )
      memmove_0(v10, a2, 2 * a3);
    v11 = v3[5] < 8;
    v3[4] = a3;
    if ( !v11 )
    {
      *(*v3 + 2 * a3) = 0;
      return v3;
    }
    *(v3 + a3) = 0;
    return v3;
  }
  if ( v4 < 8 )
    v7 = v3;
  else
    v7 = *v3;
  return sub_1229640(v3, v3, (a2 - v7) >> 1, a3);
}

//----- (01229860) --------------------------------------------------------
int __thiscall sub_1229860(_DWORD *this, char a2)
{
  int result; // eax
  int v3; // ecx
  void **v4; // [esp+0h] [ebp-14h]

  result = a2 & 0x17;
  this[3] = result;
  v3 = result & this[4];
  if ( v3 )
  {
    if ( !(v3 & 4) )
    {
      if ( v3 & 2 )
        sub_1228630(&v4, 1, off_12DAA40, "ios_base::failbit set");
      else
        sub_1228630(&v4, 1, off_12DAA40, "ios_base::eofbit set");
      v4 = &std::ios_base::failure::`vftable';
      _CxxThrowException(&v4, &_TI5_AVfailure_ios_base_std__);
    }
    sub_1228630(&v4, 1, off_12DAA40, "ios_base::badbit set");
    v4 = &std::ios_base::failure::`vftable';
    _CxxThrowException(&v4, &_TI5_AVfailure_ios_base_std__);
  }
  return result;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BBEB8: using guessed type void *std::ios_base::failure::`vftable';
// 12D4548: using guessed type int _TI5_AVfailure_ios_base_std__;
// 12DAA40: using guessed type int (__thiscall **off_12DAA40[2])(void *, char);

//----- (01229900) --------------------------------------------------------
BOOL __stdcall sub_1229900(__int16 a1, WCHAR SrcStr)
{
  return (_Getwctype(SrcStr) & a1) != 0;
}

//----- (01229930) --------------------------------------------------------
char __thiscall sub_1229930(const _Cvtvec *this, wchar_t a2, int a3)
{
  int v3; // eax
  char v4; // dl
  mbstate_t v6; // [esp+0h] [ebp-10h]
  char v7; // [esp+4h] [ebp-Ch]

  v6 = 0;
  v3 = _Wcrtomb(&v7, a2, &v6, this + 3);
  v4 = v7;
  if ( v3 != 1 )
    v4 = a3;
  return v4;
}

//----- (01229980) --------------------------------------------------------
wchar_t *__thiscall sub_1229980(const _Cvtvec *this, wchar_t *a2, unsigned int a3, char a4, int a5)
{
  int v5; // ebx
  wchar_t *v6; // esi
  unsigned int v7; // edi
  const _Cvtvec *v8; // ecx
  wchar_t v9; // ax
  int v10; // eax
  char v11; // dl
  int v12; // eax
  const _Cvtvec *v14; // [esp+Ch] [ebp-18h]
  mbstate_t v15; // [esp+10h] [ebp-14h]
  int v16; // [esp+14h] [ebp-10h]
  char v17; // [esp+18h] [ebp-Ch]

  v5 = a5;
  v6 = a2;
  v16 = 0;
  v7 = (a3 - a2 + 1) >> 1;
  if ( a2 > a3 )
    v7 = 0;
  if ( v7 )
  {
    v8 = this + 3;
    v14 = v8;
    do
    {
      v9 = *v6;
      v15 = 0;
      v10 = _Wcrtomb(&v17, v9, &v15, v8);
      ++v5;
      v11 = v17;
      if ( v10 != 1 )
        v11 = a4;
      v8 = v14;
      v12 = v16 + 1;
      *(v5 - 1) = v11;
      ++v6;
      v16 = v12;
    }
    while ( v12 != v7 );
  }
  return v6;
}

//----- (01229A20) --------------------------------------------------------
unsigned __int16 *__thiscall sub_1229A20(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *v4; // esi
  void *i; // ebx

  v4 = a3;
  for ( i = this; v4 != a4; ++v4 )
  {
    if ( (*(*i + 16))(i, a2, *v4) )
      break;
  }
  return v4;
}

//----- (01229A60) --------------------------------------------------------
unsigned __int16 *__thiscall sub_1229A60(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *v4; // esi
  void *i; // ebx

  v4 = a3;
  for ( i = this; v4 != a4; ++v4 )
  {
    if ( !(*(*i + 16))(i, a2, *v4) )
      break;
  }
  return v4;
}

//----- (01229AA0) --------------------------------------------------------
int __thiscall sub_1229AA0(void *this, wchar_t Src)
{
  return _Towlower(Src, this + 8);
}

//----- (01229AC0) --------------------------------------------------------
wchar_t *__thiscall sub_1229AC0(char *this, wchar_t *a2, unsigned int a3)
{
  wchar_t *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  char *v6; // eax
  char *v8; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v4 = (a3 - a2 + 1) >> 1;
  v5 = 0;
  if ( a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = this + 8;
    v8 = this + 8;
    do
    {
      *v3 = _Towlower(*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (01229B10) --------------------------------------------------------
int __thiscall sub_1229B10(void *this, wchar_t Src)
{
  return _Towupper(Src, this + 8);
}

//----- (01229B30) --------------------------------------------------------
wchar_t *__thiscall sub_1229B30(char *this, wchar_t *a2, unsigned int a3)
{
  wchar_t *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  char *v6; // eax
  char *v8; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v4 = (a3 - a2 + 1) >> 1;
  v5 = 0;
  if ( a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = this + 8;
    v8 = this + 8;
    do
    {
      *v3 = _Towupper(*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (01229B80) --------------------------------------------------------
wchar_t __thiscall sub_1229B80(const _Cvtvec *this, char a2)
{
  int v2; // eax
  wchar_t v3; // cx
  mbstate_t v5; // [esp+0h] [ebp-8h]
  wchar_t v6; // [esp+4h] [ebp-4h]

  v5 = 0;
  v2 = _Mbrtowc(&v6, &a2, 1u, &v5, this + 3);
  v3 = v6;
  if ( v2 < 0 )
    v3 = -1;
  return v3;
}

//----- (01229BD0) --------------------------------------------------------
char *__thiscall sub_1229BD0(const _Cvtvec *this, wchar_t a2, char a3, mbstate_t a4)
{
  char *v4; // esi
  int v5; // edi
  const _Cvtvec *v6; // ecx
  mbstate_t v7; // ebx
  int v8; // eax
  wchar_t v9; // cx
  const _Cvtvec *v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v4 = a2;
  v5 = a3 - a2;
  v12 = 0;
  if ( a2 > a3 )
    v5 = 0;
  if ( v5 )
  {
    v6 = this + 3;
    v7 = a4;
    v11 = v6;
    do
    {
      a3 = *v4;
      a4 = 0;
      v8 = _Mbrtowc(&a2, &a3, 1u, &a4, v6);
      v9 = a2;
      v7 += 2;
      if ( v8 < 0 )
        v9 = -1;
      *(v7 - 2) = v9;
      v6 = v11;
      ++v4;
      ++v12;
    }
    while ( v12 != v5 );
  }
  return v4;
}

//----- (01229C60) --------------------------------------------------------
_DWORD *__thiscall sub_1229C60(_DWORD *this, unsigned int a2, unsigned int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // edi
  bool v5; // cf
  _DWORD *result; // eax
  _DWORD *v7; // eax
  unsigned int v8; // edi

  v3 = this;
  v4 = this[4];
  if ( v4 < a2 )
    std::_Xout_of_range("invalid string position");
  if ( v4 - a2 > a3 )
  {
    if ( a3 )
    {
      if ( this[5] < 8u )
        v7 = this;
      else
        v7 = *this;
      v8 = v4 - a3;
      if ( v8 != a2 )
        memmove(v7 + 2 * a2, v7 + 2 * a2 + 2 * a3, 2 * (v8 - a2));
      v5 = v3[5] < 8u;
      v3[4] = v8;
      if ( !v5 )
      {
        *(*v3 + 2 * v8) = 0;
        return v3;
      }
      *(v3 + v8) = 0;
    }
    result = v3;
  }
  else
  {
    v5 = this[5] < 8u;
    this[4] = a2;
    if ( v5 )
    {
      result = this;
      *(this + a2) = 0;
    }
    else
    {
      *(*this + 2 * a2) = 0;
      result = this;
    }
  }
  return result;
}

//----- (01229D10) --------------------------------------------------------
char *__thiscall sub_1229D10(char *this)
{
  char *v1; // esi
  int v2; // ecx
  int v3; // eax
  char *v4; // ecx
  char v5; // al
  int v6; // eax
  int v7; // ecx
  int v8; // ecx
  void **v10; // [esp+8h] [ebp-28h]
  _DWORD *v11; // [esp+1Ch] [ebp-14h]
  char v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-4h]

  v1 = this;
  if ( *&this[*(*this + 4) + 56] )
  {
    sub_1228570(&v11, this);
    v13 = 0;
    if ( v12 && (*(**&v1[*(*v1 + 4) + 56] + 52))() == -1 )
    {
      v2 = *(*v1 + 4);
      v3 = *&v1[v2 + 12];
      v4 = &v1[v2];
      v5 = v3 | 4;
      if ( !*(v4 + 14) )
        v5 |= 4u;
      v6 = v5 & 0x17;
      *(v4 + 3) = v6;
      v7 = v6 & *(v4 + 4);
      if ( v7 )
      {
        if ( v7 & 4 )
        {
          sub_1228630(&v10, 1, off_12DAA40, "ios_base::badbit set");
          v10 = &std::ios_base::failure::`vftable';
          _CxxThrowException(&v10, &_TI5_AVfailure_ios_base_std__);
        }
        if ( v7 & 2 )
          sub_1228630(&v10, 1, off_12DAA40, "ios_base::failbit set");
        else
          sub_1228630(&v10, 1, off_12DAA40, "ios_base::eofbit set");
        v10 = &std::ios_base::failure::`vftable';
        _CxxThrowException(&v10, &_TI5_AVfailure_ios_base_std__);
      }
    }
    v13 = -1;
    if ( !__uncaught_exception() )
      sub_12292D0(v11);
    v8 = *(v11 + *(*v11 + 4) + 56);
    if ( v8 )
      (*(*v8 + 8))();
  }
  return v1;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BBEB8: using guessed type void *std::ios_base::failure::`vftable';
// 12D4548: using guessed type int _TI5_AVfailure_ios_base_std__;
// 12DAA40: using guessed type int (__thiscall **off_12DAA40[2])(void *, char);

//----- (01229E40) --------------------------------------------------------
int *__thiscall sub_1229E40(_DWORD *this, int *a2)
{
  int *v2; // eax
  int v3; // ecx

  v2 = this[12];
  v3 = *v2;
  *a2 = *v2;
  (*(*v3 + 4))();
  return a2;
}

//----- (01229E70) --------------------------------------------------------
void __thiscall sub_1229E70(struct std::ios_base *this, int a2, char a3)
{
  struct std::ios_base *v3; // esi
  int *v4; // eax
  struct std::_Facet_base *v5; // edi
  void (__thiscall ***v6)(_DWORD, signed int); // eax
  __int16 v7; // ax
  bool v8; // zf
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  void **v12; // [esp+Ch] [ebp-34h]
  void **v13; // [esp+20h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-4h]

  v3 = this;
  sub_1229170(this);
  *(v3 + 14) = a2;
  *(v3 + 15) = 0;
  v4 = sub_1229E40(v3, &a2);
  v14 = -1;
  v5 = sub_1228150(v4);
  if ( a2 )
  {
    v6 = (*(*a2 + 8))();
    if ( v6 )
      (**v6)(v6, 1);
  }
  v7 = (*(*v5 + 48))(v5, 32);
  v8 = *(v3 + 14) == 0;
  *(v3 + 32) = v7;
  if ( v8 )
  {
    v9 = *(v3 + 4);
    v10 = (*(v3 + 3) | 4) & 0x17;
    *(v3 + 3) = v10;
    v11 = v10 & v9;
    if ( v11 )
    {
      if ( v11 & 4 )
      {
        sub_1228630(&v13, 1, off_12DAA40, "ios_base::badbit set");
      }
      else
      {
        if ( !(v11 & 2) )
        {
          sub_1228630(&v12, 1, off_12DAA40, "ios_base::eofbit set");
          v12 = &std::ios_base::failure::`vftable';
          _CxxThrowException(&v12, &_TI5_AVfailure_ios_base_std__);
        }
        sub_1228630(&v13, 1, off_12DAA40, "ios_base::failbit set");
      }
      v13 = &std::ios_base::failure::`vftable';
      _CxxThrowException(&v13, &_TI5_AVfailure_ios_base_std__);
    }
  }
  if ( a3 )
    std::ios_base::_Addstd(v3);
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BBEB8: using guessed type void *std::ios_base::failure::`vftable';
// 12D4548: using guessed type int _TI5_AVfailure_ios_base_std__;
// 12DAA40: using guessed type int (__thiscall **off_12DAA40[2])(void *, char);

//----- (01229F90) --------------------------------------------------------
int __thiscall sub_1229F90(_DWORD **this, int a2)
{
  (*(*this[1] + 8))(a2, *this, 0);
  return a2;
}

//----- (01229FC0) --------------------------------------------------------
__int16 __thiscall sub_1229FC0(_DWORD *this, __int16 a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  __int16 result; // ax
  unsigned int *v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  int v8; // eax
  unsigned int v9; // ecx
  _DWORD *v10; // edx
  __int16 **v11; // edx
  __int16 *v12; // esi
  unsigned int v13; // edi
  unsigned int v14; // ecx
  void *v15; // eax
  const void **v16; // ecx
  signed int v17; // ebx
  signed int *v18; // eax
  void *v19; // edi
  bool v20; // zf
  signed int *v21; // eax
  _DWORD *v22; // ecx
  int v23; // edx
  int v24; // ecx
  int v25; // edx
  _DWORD *v26; // eax
  __int16 **v27; // ecx
  __int16 *v28; // edx
  int v29; // [esp+4h] [ebp-8h]
  void *v30; // [esp+8h] [ebp-4h]

  v2 = this;
  v3 = this[15];
  if ( v3 & 2 )
    return -1;
  if ( a2 == -1 )
    return 0;
  if ( v3 & 8 )
  {
    v5 = this[8];
    v6 = *v5;
    if ( *v5 )
    {
      v7 = v2[14];
      if ( v6 < v7 )
      {
        v8 = *v2[12];
        *v5 = v7;
        *v2[12] = (v6 + 2 * v8 - v7) >> 1;
      }
    }
  }
  v9 = *v2[8];
  if ( !v9 )
    goto LABEL_35;
  v10 = v2[12];
  if ( v9 < v9 + 2 * *v10 )
  {
    result = a2;
    --*v10;
    v11 = v2[8];
    v12 = *v11;
    ++*v11;
    *v12 = a2;
    return result;
  }
  if ( v9 )
    v13 = (v9 + 2 * *v2[12] - *v2[3]) >> 1;
  else
LABEL_35:
    v13 = 0;
  v14 = v13 >> 1;
  if ( v13 >> 1 >= 0x20 )
  {
    if ( !v14 )
      return -1;
  }
  else
  {
    v14 = 32;
  }
  do
  {
    if ( 0x7FFFFFFF - v14 >= v13 )
      break;
    v14 >>= 1;
  }
  while ( v14 );
  if ( !v14 )
    return -1;
  v29 = v14 + v13;
  v15 = sub_11FFFE0(v14 + v13);
  v16 = v2[3];
  v17 = v15;
  v30 = *v16;
  if ( v13 && (memmove_0(v15, *v16, 2 * v13), v13) )
  {
    v22 = v2[4];
    v19 = v30;
    v2[14] = v17 + 2 * ((v2[14] - v30) >> 1);
    v23 = v17 + 2 * ((*v2[8] - v30) >> 1);
    *v22 = v17 + 2 * ((*v22 - v30) >> 1);
    *v2[8] = v23;
    *v2[12] = (v17 + 2 * v29 - v23) >> 1;
    if ( v2[15] & 4 )
    {
      *v2[3] = v17;
      *v2[7] = 0;
      *v2[11] = v17 >> 1;
    }
    else
    {
      v24 = v17 + 2 * ((*v2[7] - v30) >> 1);
      v25 = (*v2[8] - v24 + 2) >> 1;
      *v2[3] = v17;
      *v2[7] = v24;
      *v2[11] = v25;
    }
  }
  else
  {
    v18 = v2[4];
    v19 = v30;
    v2[14] = v17;
    *v18 = v17;
    *v2[8] = v17;
    *v2[12] = 2 * v29 >> 1;
    v20 = (v2[15] & 4) == 0;
    *v2[3] = v17;
    v21 = v2[7];
    if ( v20 )
    {
      *v21 = v17;
      *v2[11] = 1;
    }
    else
    {
      *v21 = 0;
      *v2[11] = v17 >> 1;
    }
  }
  if ( v2[15] & 1 )
    j__free(v19);
  v26 = v2[12];
  v2[15] |= 1u;
  --*v26;
  v27 = v2[8];
  v28 = *v27;
  ++*v27;
  result = a2;
  *v28 = a2;
  return result;
}

//----- (0122A1E0) --------------------------------------------------------
signed int __stdcall sub_122A1E0(int a1)
{
  return 0xFFFF;
}

//----- (0122A1F0) --------------------------------------------------------
signed __int16 __thiscall sub_122A1F0(int this, __int16 a2)
{
  unsigned int v2; // esi

  v2 = **(this + 28);
  if ( !v2 || v2 <= **(this + 12) || -1 != a2 && a2 != *(v2 - 2) && *(this + 60) & 2 )
    return -1;
  ++**(this + 44);
  **(this + 28) -= 2;
  if ( -1 == a2 )
    return 0;
  ***(this + 28) = a2;
  return a2;
}

//----- (0122A260) --------------------------------------------------------
_DWORD *__stdcall sub_122A260(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  a1[1] = -1;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  return result;
}

//----- (0122A290) --------------------------------------------------------
signed int *__thiscall sub_122A290(int this, signed int *a2, __int64 a3, int a4, char a5)
{
  int v5; // ebx
  unsigned int *v6; // edx
  unsigned int v7; // eax
  int v8; // esi
  signed int v9; // edi
  signed int v10; // esi
  int v11; // ecx
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // ecx
  unsigned int v15; // edx
  int v16; // ecx
  signed int *result; // eax
  int v18; // [esp+Ch] [ebp-4h]
  int v19; // [esp+24h] [ebp+14h]
  int v20; // [esp+28h] [ebp+18h]

  v5 = this;
  v6 = *(this + 32);
  v7 = *v6;
  if ( *v6 && *(this + 56) < v7 )
    *(this + 56) = v7;
  if ( !(a5 & 1) || (v8 = **(this + 28), (v18 = v8) == 0) )
  {
    if ( a5 & 2 && (v15 = *v6) != 0 )
    {
      if ( a4 == 2 )
      {
        v9 = (((*(this + 56) - **(this + 12)) >> 1) + a3) >> 32;
        v10 = ((*(this + 56) - **(this + 12)) >> 1) + a3;
      }
      else if ( a4 == 1 )
      {
        v9 = (((v15 - **(this + 12)) >> 1) + a3) >> 32;
        v10 = ((v15 - **(this + 12)) >> 1) + a3;
      }
      else if ( a4 )
      {
        v10 = -1;
        v9 = -1;
      }
      else
      {
        v9 = HIDWORD(a3);
        v10 = a3;
      }
      if ( v9 >= 0 )
      {
        v16 = **(this + 12);
        if ( __PAIR__(v9, v10) <= (*(v5 + 56) - v16) >> 1 )
        {
          v20 = v10 + ((v16 - v15) >> 1);
          **(v5 + 48) -= v20;
          **(v5 + 32) += 2 * v20;
          goto LABEL_33;
        }
      }
    }
    else
    {
      v9 = HIDWORD(a3);
      v10 = a3;
      if ( !a3 )
        goto LABEL_33;
    }
LABEL_32:
    v10 = -1;
    v9 = -1;
    goto LABEL_33;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( !(a5 & 2) )
      {
        v9 = (((v8 - **(this + 12)) >> 1) + a3) >> 32;
        v10 = ((v8 - **(this + 12)) >> 1) + a3;
        goto LABEL_14;
      }
    }
    else if ( !a4 )
    {
      v9 = HIDWORD(a3);
      v10 = a3;
      goto LABEL_14;
    }
    v10 = -1;
    v9 = -1;
    goto LABEL_14;
  }
  v9 = (((*(this + 56) - **(this + 12)) >> 1) + a3) >> 32;
  v10 = ((*(this + 56) - **(this + 12)) >> 1) + a3;
LABEL_14:
  if ( v9 < 0 )
    goto LABEL_32;
  v11 = **(this + 12);
  if ( __PAIR__(v9, v10) > (*(v5 + 56) - v11) >> 1 )
    goto LABEL_32;
  v19 = v10 + ((v11 - v18) >> 1);
  **(v5 + 44) -= v19;
  **(v5 + 28) += 2 * v19;
  if ( a5 & 2 )
  {
    v12 = *(v5 + 32);
    if ( *v12 )
    {
      v13 = **(v5 + 28);
      v14 = (*v12 + 2 * **(v5 + 48) - v13) >> 1;
      **(v5 + 32) = v13;
      **(v5 + 48) = v14;
    }
  }
LABEL_33:
  result = a2;
  a2[1] = v9;
  *a2 = v10;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  return result;
}

//----- (0122A480) --------------------------------------------------------
_DWORD *__stdcall sub_122A480(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  a1[1] = -1;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  return result;
}

//----- (0122A4B0) --------------------------------------------------------
signed int *__thiscall sub_122A4B0(int this, signed int *a2, __int64 a3, __int64 a4, int a5, int a6, char a7)
{
  signed int v7; // ebx
  signed int v8; // esi
  int v9; // edi
  unsigned int *v10; // edx
  unsigned int v11; // eax
  int v12; // ecx
  int v13; // ST0C_4
  _DWORD *v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // ecx
  signed int *result; // eax
  int v19; // [esp+Ch] [ebp-4h]
  unsigned int v20; // [esp+34h] [ebp+24h]
  int v21; // [esp+34h] [ebp+24h]

  v7 = (a3 + a4) >> 32;
  v8 = a3 + a4;
  v9 = this;
  v10 = *(this + 32);
  v11 = *v10;
  if ( *v10 && *(this + 56) < v11 )
    *(this + 56) = v11;
  if ( v8 != -1 || v7 != -1 )
  {
    if ( a7 & 1 && (v19 = **(this + 28)) != 0 )
    {
      if ( v7 >= 0 )
      {
        v12 = **(this + 12);
        if ( __PAIR__(v7, v8) <= (*(v9 + 56) - v12) >> 1 )
        {
          v13 = v8 + ((v12 - v19) >> 1);
          **(v9 + 44) -= v13;
          **(v9 + 28) += 2 * v13;
          if ( a7 & 2 )
          {
            v14 = *(v9 + 32);
            if ( *v14 )
            {
              v15 = **(v9 + 28);
              v16 = (*v14 + 2 * **(v9 + 48) - v15) >> 1;
              **(v9 + 32) = v15;
              **(v9 + 48) = v16;
            }
          }
          goto LABEL_21;
        }
      }
    }
    else
    {
      if ( !(a7 & 2) || (v20 = *v10) == 0 )
      {
        v7 = -1;
        goto LABEL_20;
      }
      if ( v7 >= 0 )
      {
        v17 = **(this + 12);
        if ( __PAIR__(v7, v8) <= (*(v9 + 56) - v17) >> 1 )
        {
          v21 = v8 + ((v17 - v20) >> 1);
          **(v9 + 48) -= v21;
          **(v9 + 32) += 2 * v21;
          goto LABEL_21;
        }
      }
    }
    v7 = -1;
LABEL_20:
    v8 = -1;
  }
LABEL_21:
  result = a2;
  *a2 = v8;
  a2[1] = v7;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  return result;
}

//----- (0122A600) --------------------------------------------------------
void *__thiscall sub_122A600(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (0122A610) --------------------------------------------------------
__int64 sub_122A610()
{
  return 0i64;
}

//----- (0122A620) --------------------------------------------------------
void *__thiscall sub_122A620(_DWORD *this, void *a2)
{
  _DWORD *v2; // edx
  int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // ecx
  void **v6; // eax
  void *v7; // eax
  _DWORD *v8; // eax
  void *v10; // [esp+8h] [ebp-1Ch]
  int v11; // [esp+18h] [ebp-Ch]
  unsigned int v12; // [esp+1Ch] [ebp-8h]

  v2 = this;
  v3 = this[15];
  if ( !(v3 & 2) )
  {
    v4 = *v2[8];
    if ( v4 )
    {
      v5 = v2[14];
      if ( v5 < v4 )
        v5 = *v2[8];
      v6 = v2[4];
      goto LABEL_6;
    }
  }
  if ( !(v3 & 4) )
  {
    v8 = v2[7];
    if ( *v8 )
    {
      v5 = *v8 + 2 * *v2[11];
      v6 = v2[3];
LABEL_6:
      v7 = *v6;
      v12 = 7;
      v11 = 0;
      LOWORD(v10) = 0;
      sub_1229760(&v10, v7, (v5 - v7) >> 1);
      goto LABEL_11;
    }
  }
  v12 = 7;
  v11 = 0;
  LOWORD(v10) = 0;
LABEL_11:
  sub_11F3530(a2, &v10);
  if ( v12 >= 8 )
    j__free(v10);
  return a2;
}

//----- (0122A6E0) --------------------------------------------------------
void *__thiscall sub_122A6E0(_DWORD *this, void *a2)
{
  sub_122A620(this + 6, a2);
  return a2;
}

//----- (0122A700) --------------------------------------------------------
signed int __thiscall sub_122A700(_DWORD **this)
{
  _DWORD **v1; // esi
  unsigned __int16 **v3; // ecx
  unsigned __int16 *v4; // edx

  v1 = this;
  if ( ((*this)[6])() == -1 )
    return 0xFFFF;
  --*v1[11];
  v3 = v1[7];
  v4 = *v3;
  ++*v3;
  return *v4;
}

//----- (0122A730) --------------------------------------------------------
signed int sub_122A730()
{
  return 0xFFFF;
}

//----- (0122A740) --------------------------------------------------------
signed __int16 __thiscall sub_122A740(int this)
{
  unsigned int *v1; // edi
  unsigned int v2; // esi
  int *v4; // ebx
  unsigned int v5; // eax

  v1 = *(this + 28);
  v2 = *v1;
  if ( !*v1 )
    return -1;
  v4 = *(this + 44);
  if ( v2 < v2 + 2 * *v4 )
    return *v2;
  if ( *(this + 60) & 4 )
    return -1;
  v5 = **(this + 32);
  if ( !v5 || v5 <= v2 && *(this + 56) <= v2 )
    return -1;
  if ( *(this + 56) < v5 )
    *(this + 56) = v5;
  *v4 = (*(this + 56) - *v1) >> 1;
  return ***(this + 28);
}

//----- (0122A7B0) --------------------------------------------------------
unsigned int __thiscall sub_122A7B0(_DWORD **this, void *a2, int a3, int a4)
{
  int v4; // ebx
  _DWORD **v5; // edx
  int v6; // edi
  __int64 v7; // rax
  unsigned int v8; // esi
  bool v9; // cf
  __int16 v10; // ax
  int v12; // [esp+8h] [ebp-Ch]
  _DWORD **v13; // [esp+Ch] [ebp-8h]
  unsigned int v14; // [esp+10h] [ebp-4h]
  int v15; // [esp+24h] [ebp+10h]

  v4 = a4;
  v5 = this;
  v13 = this;
  if ( a4 < 0 )
    return 0;
  v6 = a3;
  if ( a4 <= 0 && !a3 )
    return 0;
  v15 = 0;
  v14 = 0;
  do
  {
    v7 = sub_1229140(v5);
    v12 = HIDWORD(v7);
    v8 = v7;
    if ( v7 >= 0 && (SHIDWORD(v7) > 0 || v7) )
    {
      if ( __PAIR__(v4, v6) < v7 )
      {
        v8 = v6;
        v12 = v4;
      }
      if ( v8 )
        memmove_0(a2, *v13[7], 2 * v8);
      a2 = a2 + 2 * v8;
      v9 = __CFADD__(v8, v14);
      v14 += v8;
      v5 = v13;
      v15 += v12 + v9;
      v4 = (__PAIR__(v4, v6) - __PAIR__(v12, v8)) >> 32;
      v6 -= v8;
      *v13[11] -= v8;
      *v13[7] += 2 * v8;
    }
    else
    {
      v10 = ((*v13)[7])();
      if ( v10 == -1 )
        return v14;
      *a2 = v10;
      a2 = a2 + 2;
      v15 = (__PAIR__(v15, v14++) + 1) >> 32;
      v9 = v6-- != 0;
      v5 = v13;
      v4 = v9 + v4 - 1;
    }
  }
  while ( v4 > 0 || v4 >= 0 && v6 );
  return v14;
}

//----- (0122A8C0) --------------------------------------------------------
unsigned int __thiscall sub_122A8C0(_DWORD **this, void *a2, int a3, int a4)
{
  signed int v4; // ebx
  _DWORD **v5; // edx
  int v6; // edi
  __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int8 v9; // cf
  unsigned int v11; // [esp+8h] [ebp-Ch]
  _DWORD **v12; // [esp+Ch] [ebp-8h]
  unsigned int v13; // [esp+10h] [ebp-4h]
  int v14; // [esp+24h] [ebp+10h]

  v4 = a4;
  v5 = this;
  v12 = this;
  if ( a4 < 0 )
    return 0;
  v6 = a3;
  if ( a4 <= 0 && !a3 )
    return 0;
  v14 = 0;
  v13 = 0;
  do
  {
    v7 = sub_1229400(v5);
    v11 = HIDWORD(v7);
    v8 = v7;
    if ( v7 >= 0 && (SHIDWORD(v7) > 0 || v7) )
    {
      if ( __PAIR__(v4, v6) < v7 )
      {
        v8 = v6;
        v11 = v4;
      }
      if ( v8 )
        memmove_0(*v12[8], a2, 2 * v8);
      a2 = a2 + 2 * v8;
      v9 = __CFADD__(v8, v13);
      v13 += v8;
      v5 = v12;
      v14 += v11 + v9;
      v4 = (__PAIR__(v4, v6) - __PAIR__(v11, v8)) >> 32;
      v6 -= v8;
      *v12[12] -= v8;
      *v12[8] += 2 * v8;
    }
    else
    {
      if ( ((*v12)[3])(*a2) == -1 )
        return v13;
      v5 = v12;
      a2 = a2 + 2;
      v14 = (__PAIR__(v14, v13++) + 1) >> 32;
      v4 = (__PAIR__(v4, v6--) - 1) >> 32;
    }
  }
  while ( v4 > 0 || v4 >= 0 && v6 );
  return v13;
}

//----- (0122A9D0) --------------------------------------------------------
void *__thiscall CObjSecurity::`scalar deleting destructor'(void *this, char a2)
{
  void *v2; // esi
  HLOCAL *v3; // edi

  v2 = this;
  v3 = (this + 12);
  *this = &CObjSecurity::`vftable';
  if ( this != -12 )
  {
    if ( *v3 )
      LocalFree(*v3);
    *v3 = 0;
  }
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BC4C4: using guessed type void *CObjSecurity::`vftable';

//----- (0122AA10) --------------------------------------------------------
int __cdecl sub_122AA10(int a1)
{
  return (*(*a1 + 8))(a1);
}

//----- (0122AA20) --------------------------------------------------------
int __cdecl sub_122AA20(int a1, int a2, int a3, int a4, int a5)
{
  CObjSecurity *pObjSecurity; // eax
  CObjSecurity *v6; // esi
  CObjSecurityVTbl *v7; // ecx
  int result; // eax
  int v9; // ebx

  *a3 = 0;
  pObjSecurity = operator new(0x1Cu);
  v6 = pObjSecurity;
  if ( !pObjSecurity )
    return E_OUTOFMEMORY;
  pObjSecurity->vtptr = &CObjSecurity::`vftable';
  v7 = pObjSecurity->vtptr;
  pObjSecurity->field_4 = 1;
  result = (v7->pfnCreate)(pObjSecurity, 0x213, a1, a2, gpszTargetName, a4, a5);
  v9 = result;
  if ( result < 0 )
  {
    (v6->vtptr->DestroyMe)(v6, 1);
    result = v9;
  }
  else
  {
    *a3 = v6;
  }
  return result;
}
// 12BC4C4: using guessed type void *CObjSecurity::`vftable';

//----- (0122AA90) --------------------------------------------------------
int __stdcall sub_122AA90(int a1)
{
  int result; // eax

  result = *(a1 + 4) + 1;
  *(a1 + 4) = result;
  return result;
}

//----- (0122AAB0) --------------------------------------------------------
int __stdcall sub_122AAB0(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int result; // eax

  switch ( *(a1 + 20) )
  {
    case 0:
      *a4 = &off_12DD008;
      *a5 = 9;
      *a6 = 0;
      result = 0;
      break;
    case 2:
      *a4 = &off_12DD098;
      *a5 = 5;
      *a6 = 0;
      result = 0;
      break;
    case 3:
      *a4 = &off_12DCCD8;
      *a5 = 19;
      *a6 = 0;
      result = 0;
      break;
    case 4:
      *a4 = &off_12DCF18;
      *a5 = 15;
      *a6 = 0;
      result = 0;
      break;
    case 5:
      *a4 = &off_12DCE08;
      *a5 = 17;
      *a6 = 0;
      result = 0;
      break;
    default:
      *a4 = &off_12DCC68;
      *a5 = 7;
      *a6 = 0;
      result = 0;
      break;
  }
  return result;
}
// 12DCC68: using guessed type GUID *off_12DCC68;
// 12DCCD8: using guessed type GUID *off_12DCCD8;
// 12DCE08: using guessed type GUID *off_12DCE08;
// 12DCF18: using guessed type GUID *off_12DCF18;
// 12DD008: using guessed type GUID *off_12DD008;
// 12DD098: using guessed type GUID *off_12DD098;

//----- (0122ABB0) --------------------------------------------------------
int __stdcall sub_122ABB0(int a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = &off_12DD0E8;
  *a3 = 1;
  return 0;
}
// 12DD0E8: using guessed type GUID *off_12DD0E8;

//----- (0122ABD0) --------------------------------------------------------
int __stdcall sub_122ABD0(int a1, int a2)
{
  *a2 = *(a1 + 8);
  *(a2 + 4) = ghInstance2;
  *(a2 + 8) = *(a1 + 12);
  *(a2 + 12) = *(a1 + 16);
  return 0;
}

//----- (0122AC00) --------------------------------------------------------
int __stdcall sub_122AC00(CObjSecurity *a1, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, int a4)
{
  bool v4; // zf
  _DWORD *pSercutiyInfo; // esi
  int result; // eax
  HLOCAL v7; // eax

  v4 = a4 == 0;
  pSercutiyInfo = lpSecurityDescriptor;
  *lpSecurityDescriptor = 0;
  if ( !v4 )
    return E_NOTIMPL;
  if ( a1->field_14 == 4 )
  {
    QueryServiceObjectSecurity(
      *(a1->m_pServiceMgr + 44),
      dwSecurityInformation,
      pSercutiyInfo,
      0,
      &lpSecurityDescriptor);
    if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
      v7 = LocalAlloc(0, lpSecurityDescriptor);
      *pSercutiyInfo = v7;
      if ( QueryServiceObjectSecurity(
             *(a1->m_pServiceMgr + 44),
             dwSecurityInformation,
             v7,
             lpSecurityDescriptor,
             &lpSecurityDescriptor) )
      {
        return 0;
      }
    }
    result = GetLastError();
  }
  else
  {
    result = sub_125F3E0(a1->m_pServiceMgr, dwSecurityInformation, pSercutiyInfo);
  }
  if ( result > 0 )
    result = result | 0x80070000;
  return result;
}

//----- (0122ACB0) --------------------------------------------------------
int __stdcall sub_122ACB0(CObjSecurity *a1, int a2, void *pServiceMgr, int a4, wchar_t *Src, int a6, int a7)
{
  int result; // eax

  a1->field_8 = a2;
  if ( a7 )
    a1->field_8 = a2 | 4;
  result = sub_122ACF0(&a1->field_C, Src);
  a1->field_14 = a6;
  a1->field_10 = a4;
  a1->m_pServiceMgr = pServiceMgr;
  return result;
}

//----- (0122ACF0) --------------------------------------------------------
int __cdecl sub_122ACF0(int a1, wchar_t *Src)
{
  unsigned int v2; // kr00_4
  wchar_t *v3; // eax

  if ( !a1 || !Src )
    return -2147024809;
  v2 = wcslen(Src);
  v3 = LocalAlloc(0x40u, 2 * (v2 + 1));
  *a1 = v3;
  if ( !v3 )
    return -2147024882;
  tcscpy_s(v3, v2 + 1, Src);
  return 0;
}

//----- (0122AD60) --------------------------------------------------------
int __stdcall sub_122AD60(int a1, int a2, int a3, PDWORD AccessMask)
{
  int result; // eax

  if ( *(a1 + 20) == 3 )
  {
    MapGenericMask(AccessMask, &stru_12DCC38);
    result = 0;
  }
  else if ( *(a1 + 20) == 4 )
  {
    MapGenericMask(AccessMask, &stru_12DCC58);
    result = 0;
  }
  else
  {
    if ( *(a1 + 20) == 5 )
      MapGenericMask(AccessMask, &stru_12DCC48);
    else
      MapGenericMask(AccessMask, &GenericMapping);
    result = 0;
  }
  return result;
}

//----- (0122ADD0) --------------------------------------------------------
int __stdcall sub_122ADD0(int a1, int a2, int a3, int a4)
{
  return 0;
}

//----- (0122ADE0) --------------------------------------------------------
int __stdcall sub_122ADE0(GUID *a1, int a2, int ppv)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  GUID *v5; // esi
  unsigned int v6; // edi
  bool v7; // cf
  GUID *v9; // edx
  unsigned int v10; // esi

  v3 = a2;
  v4 = a2;
  v5 = &CLSID_IUnknown;
  v6 = 12;
  while ( *v4 == v5->Data1 )
  {
    ++v4;
    v5 = (v5 + 4);
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
      *ppv = a1;
      ++*&a1->Data2;
      return 0;
    }
  }
  v9 = &IID_IObjSecurity;
  v10 = 12;
  while ( *v3 == v9->Data1 )
  {
    ++v3;
    v9 = (v9 + 4);
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
    {
      *ppv = a1;
      ++*&a1->Data2;
      return 0;
    }
  }
  *ppv = 0;
  return -2147467262;
}
// 12BC4B0: using guessed type GUID IID_IObjSecurity;
// 12C7BBC: using guessed type GUID CLSID_IUnknown;

//----- (0122AE60) --------------------------------------------------------
int __stdcall sub_122AE60(_DWORD *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = a1[1]-- == 1;
  result = a1[1];
  if ( v1 )
  {
    (*(*a1 + 40))(1);
    result = 0;
  }
  return result;
}

//----- (0122AE80) --------------------------------------------------------
int __stdcall sub_122AE80(int a1, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
{
  int result; // eax

  if ( *(a1 + 20) == 4 )
  {
    if ( SetServiceObjectSecurity(*(*(a1 + 24) + 44), dwSecurityInformation, lpSecurityDescriptor) )
      return 0;
    result = GetLastError();
  }
  else
  {
    result = sub_125F4D0(*(a1 + 24), dwSecurityInformation, lpSecurityDescriptor, 0, 0);
  }
  if ( result > 0 )
    result = result | 0x80070000;
  return result;
}

//----- (0122AEE0) --------------------------------------------------------
int __thiscall sub_122AEE0(_DWORD *this, int a2, char a3, int a4, int a5, void *a6)
{
  _DWORD *v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // eax
  int *v9; // ecx
  int *v10; // esi
  int *v11; // edx
  _DWORD *v12; // edx
  void **v13; // ecx
  _DWORD *v14; // edx
  _DWORD *v15; // esi
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // edx
  int v19; // ecx
  _DWORD *v20; // ecx
  _DWORD *v21; // ecx
  int result; // eax

  v6 = this;
  v7 = this[1];
  if ( v7 >= 0xAAAAAA9 )
  {
    sub_1221430(a6 + 4);
    j__free(a6);
    std::_Xlength_error("map/set<T> too long");
  }
  this[1] = v7 + 1;
  *(a6 + 1) = a4;
  if ( a4 == *this )
  {
    *(*this + 4) = a6;
    **this = a6;
    *(*this + 8) = a6;
  }
  else if ( a3 )
  {
    *a4 = a6;
    if ( a4 == **this )
      **this = a6;
  }
  else
  {
    *(a4 + 8) = a6;
    if ( a4 == *(*this + 8) )
      *(*this + 8) = a6;
  }
  v8 = a6;
  if ( !*(*(a6 + 1) + 12) )
  {
    do
    {
      v9 = v8[1];
      v10 = v9[1];
      v11 = *v10;
      if ( v9 == *v10 )
      {
        v11 = v10[2];
        if ( *(v11 + 12) )
        {
          if ( v8 == v9[2] )
          {
            v8 = v8[1];
            v12 = v9[2];
            v9[2] = *v12;
            if ( !*(*v12 + 13) )
              *(*v12 + 4) = v9;
            v12[1] = v9[1];
            if ( v9 == *(*v6 + 4) )
            {
              *(*v6 + 4) = v12;
            }
            else
            {
              v13 = v9[1];
              if ( v8 == *v13 )
                *v13 = v12;
              else
                v13[2] = v12;
            }
            *v12 = v8;
            v8[1] = v12;
          }
          *(v8[1] + 12) = 1;
          *(*(v8[1] + 4) + 12) = 0;
          v14 = *(v8[1] + 4);
          v15 = *v14;
          *v14 = *(*v14 + 8);
          v16 = v15[2];
          if ( !*(v16 + 13) )
            *(v16 + 4) = v14;
          v15[1] = v14[1];
          if ( v14 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v15;
            v15[2] = v14;
          }
          else
          {
            v17 = v14[1];
            if ( v14 == v17[2] )
              v17[2] = v15;
            else
              *v17 = v15;
            v15[2] = v14;
          }
LABEL_48:
          v14[1] = v15;
          continue;
        }
      }
      else if ( *(v11 + 12) )
      {
        if ( v8 == *v9 )
        {
          v8 = v8[1];
          v18 = *v9;
          *v9 = *(*v9 + 8);
          v19 = *(v18 + 8);
          if ( !*(v19 + 13) )
            *(v19 + 4) = v8;
          *(v18 + 4) = v8[1];
          if ( v8 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v18;
          }
          else
          {
            v20 = v8[1];
            if ( v8 == v20[2] )
              v20[2] = v18;
            else
              *v20 = v18;
          }
          *(v18 + 8) = v8;
          v8[1] = v18;
        }
        *(v8[1] + 12) = 1;
        *(*(v8[1] + 4) + 12) = 0;
        v14 = *(v8[1] + 4);
        v15 = v14[2];
        v14[2] = *v15;
        if ( !*(*v15 + 13) )
          *(*v15 + 4) = v14;
        v15[1] = v14[1];
        if ( v14 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v15;
        }
        else
        {
          v21 = v14[1];
          if ( v14 == *v21 )
            *v21 = v15;
          else
            v21[2] = v15;
        }
        *v15 = v14;
        goto LABEL_48;
      }
      *(v9 + 12) = 1;
      *(v11 + 12) = 1;
      *(*(v8[1] + 4) + 12) = 0;
      v8 = *(v8[1] + 4);
    }
    while ( !*(v8[1] + 12) );
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = a6;
  return result;
}

//----- (0122B100) --------------------------------------------------------
int __thiscall sub_122B100(_DWORD *this, int a2, int a3, int a4, void *a5)
{
  int v5; // ebx
  bool v6; // al
  int v7; // esi
  BSTR *v8; // ecx
  BSTR *v9; // eax
  OLECHAR *v10; // eax
  BSTR *v11; // ecx
  OLECHAR **v12; // eax
  int v13; // eax
  OLECHAR *v14; // eax
  int v15; // esi
  int *v16; // eax
  int v17; // ecx
  int result; // eax
  int v19; // edi
  void *v20; // edi
  int v21; // [esp+0h] [ebp-28h]
  _DWORD *v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  int *v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+24h] [ebp-4h]

  v24 = &v21;
  v22 = this;
  v5 = *this;
  v6 = 1;
  v25 = 0;
  LOBYTE(v23) = 1;
  v7 = *(v5 + 4);
  if ( !*(v7 + 13) )
  {
    while ( 1 )
    {
      v5 = v7;
      if ( !a3 )
      {
        v11 = *a4;
        v12 = *(v7 + 16);
        if ( *a4 == v12 )
          goto LABEL_16;
        if ( v11 )
        {
          if ( v12 )
          {
            v13 = sub_11F4730(v11, *(v7 + 16));
            goto LABEL_27;
          }
          if ( *v11 && SysStringLen(*v11) )
          {
            v13 = 1;
            goto LABEL_27;
          }
        }
        else if ( v12 )
        {
          v14 = *v12;
          if ( v14 )
          {
            if ( SysStringLen(v14) )
            {
              v13 = -1;
              goto LABEL_27;
            }
          }
        }
LABEL_16:
        v13 = 0;
LABEL_27:
        v6 = v13 < 0;
        goto LABEL_28;
      }
      v8 = *(v7 + 16);
      v9 = *a4;
      if ( v8 != *a4 )
      {
        if ( v8 )
        {
          if ( v9 )
          {
            v6 = sub_11F4730(v8, v9) >= 0;
            goto LABEL_28;
          }
          if ( *v8 && SysStringLen(*v8) )
          {
            v6 = 1;
            goto LABEL_28;
          }
        }
        else if ( v9 )
        {
          v10 = *v9;
          if ( v10 )
          {
            if ( SysStringLen(v10) )
            {
              v6 = 0;
              goto LABEL_28;
            }
          }
        }
      }
      v6 = 1;
LABEL_28:
      LOBYTE(v23) = v6;
      if ( v6 )
        v7 = *v7;
      else
        v7 = *(v7 + 8);
      if ( *(v7 + 13) )
      {
        this = v22;
        break;
      }
    }
  }
  v15 = v5;
  a3 = v5;
  if ( v6 )
  {
    if ( v5 == **this )
    {
      v16 = sub_122AEE0(this, &a3, 1, v5, a4, a5);
LABEL_36:
      v17 = *v16;
      result = a2;
      *a2 = v17;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v15 = a3;
  }
  v19 = a4;
  if ( sub_11F3C30((v15 + 16), a4) )
  {
    v16 = sub_122AEE0(v22, &a3, v23, v5, v19, a5);
    goto LABEL_36;
  }
  v20 = a5;
  sub_1221430(a5 + 4);
  j__free(v20);
  result = a2;
  *a2 = v15;
  *(a2 + 4) = 0;
  return result;
}

//----- (0122B2D0) --------------------------------------------------------
void **__thiscall sub_122B2D0(void **this, void *Src)
{
  void **v2; // esi
  CAtlStringMgr *v3; // ecx
  HMODULE v4; // eax
  int v5; // ecx

  v2 = this;
  v3 = ATL::CAtlStringMgr::GetInstance();
  if ( !v3 )
    AtlThrow(-2147467259);
  *v2 = ((v3->vtptr->GetNilString)() + 16);
  if ( !Src )
  {
    v5 = 0;
    goto LABEL_9;
  }
  if ( Src & 0xFFFF0000 )
  {
    v5 = wcslen(Src);
LABEL_9:
    sub_122C620(v2, Src, v5);
    return v2;
  }
  v4 = AtlGetStringResourceImage(Src, 0);
  if ( v4 )
    sub_122BDC0(v2, v4, Src);
  return v2;
}

//----- (0122B3A0) --------------------------------------------------------
_DWORD *__thiscall sub_122B3A0(_DWORD *this)
{
  _DWORD *v1; // esi
  CAtlStringMgr *v2; // ecx

  v1 = this;
  v2 = ATL::CAtlStringMgr::GetInstance();
  if ( !v2 )
    AtlThrow(-2147467259);
  *v1 = (v2->vtptr->GetNilString)() + 16;
  return v1;
}

//----- (0122B3D0) --------------------------------------------------------
void *__thiscall ATL::CAtlStringMgr::Clone(void *this)
{
  return this;
}

//----- (0122B3E0) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_122B3E0(_DWORD *this)
{
  volatile signed __int32 *v1; // edx
  volatile signed __int32 *result; // eax

  v1 = (*this - 16);
  result = v1 + 3;
  if ( _InterlockedDecrement(v1 + 3) <= 0 )
    result = (*(**v1 + 4))(v1);
  return result;
}

//----- (0122B460) --------------------------------------------------------
int __cdecl sub_122B460(int a1, int a2, void *a3)
{
  int v3; // ecx
  int v4; // edx
  CAtlStringMgr *v5; // eax
  int v6; // edx

  v3 = *(*a2 - 16);
  if ( !v3 || (v4 = (*(*v3 + 16))()) == 0 )
  {
    v5 = ATL::CAtlStringMgr::GetInstance();
    v4 = (v5->vtptr->Clone)(v5);
  }
  if ( !v4 )
    AtlThrow(-2147467259);
  *a1 = (*(*v4 + 12))(v4) + 16;
  if ( a3 )
    v6 = wcslen(a3);
  else
    v6 = 0;
  sub_122B9E0(a1, *a2, *(*a2 - 12), a3, v6);
  return a1;
}

//----- (0122B540) --------------------------------------------------------
void *__thiscall ATL::CAtlStringMgr::`scalar deleting destructor'(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &ATL::CAtlStringMgr::`vftable';
  byte_12E4DF4 = 0;
  if ( a2 & 1 )
    j__free(this);
  return v2;
}
// 12BC510: using guessed type void *ATL::CAtlStringMgr::`vftable';
// 12E4DF4: using guessed type char byte_12E4DF4;

//----- (0122B570) --------------------------------------------------------
void *__thiscall ATL::CWin32Help::`scalar deleting destructor'(void *this, char a2)
{
  void *v2; // esi
  bool v3; // zf

  v2 = this;
  v3 = *(this + 8) == 0;
  *this = &ATL::CWin32Heap::`vftable';
  if ( !v3 && *(this + 1) )
    HeapDestroy(*(this + 1));
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BC4F8: using guessed type void *ATL::CWin32Heap::`vftable';

//----- (0122B5B0) --------------------------------------------------------
_DWORD *__thiscall ATL::CAtlStringMgr::Allocate(int (__stdcall ****this)(_DWORD), int a2, unsigned int a3)
{
  int (__stdcall ****v3)(_DWORD); // edi
  _DWORD *result; // eax
  int v5; // esi
  unsigned int v6; // eax
  _DWORD *v7; // ecx

  v3 = this;
  if ( a2 < 0 || 0x7FFFFFFF - a2 < 1 )
    return 0;
  v5 = (a2 + 8) & 0xFFFFFFF8;
  if ( a2 + 1 > v5 )
    return 0;
  v6 = a3 * v5;
  if ( !is_mul_ok(a3, v5) )
    return 0;
  if ( v6 > 0xFFFFFFFF )
    return 0;
  if ( v6 > 0xFFFFFFEF )
    return 0;
  v7 = (**this[1])(v6 + 16);
  if ( !v7 )
    return 0;
  *v7 = v3;
  v7[2] = v5 - 1;
  result = v7;
  v7[3] = 1;
  v7[1] = 0;
  return result;
}

//----- (0122B630) --------------------------------------------------------
LPVOID __thiscall ATL::CWin32Heap::Allocate(HANDLE *this, SIZE_T dwBytes)
{
  return HeapAlloc(this[1], 0, dwBytes);
}

//----- (0122B650) --------------------------------------------------------
int __cdecl sub_122B650(int a1)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
    case 80:
      return a1;
    case 12:
      AtlThrow(-2147024882);
      return result;
    case 22:
    case 34:
      AtlThrow(-2147024809);
      return result;
    default:
      AtlThrow(-2147467259);
      return result;
  }
}

//----- (0122B6F0) --------------------------------------------------------
HMODULE __cdecl AtlGetStringResourceImage(int a1, WORD wLanguage)
{
  HINSTANCE v2; // esi
  int v3; // edi
  unsigned int v4; // ebx
  HRSRC v5; // eax

  v2 = CAtlBaseModule::GetHInstanceAt(&ATL::_AtlBaseModule, 0);
  v3 = 1;
  if ( !v2 )
    return 0;
  v4 = a1 >> 4;
  while ( 1 )
  {
    v5 = FindResourceExW(v2, 6, (v4 + 1), wLanguage);
    if ( v5 )
    {
      if ( AtlGetStringResourceImage(v2, v5, a1) )
        break;
    }
    v2 = CAtlBaseModule::GetHInstanceAt(&ATL::_AtlBaseModule, v3++);
    if ( !v2 )
      return 0;
  }
  return v2;
}

//----- (0122B760) --------------------------------------------------------
void __cdecl __noreturn AtlThrow(int a1)
{
  _CxxThrowException(&a1, &_TI1_AVCAtlException_ATL__);
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12D4740: using guessed type int _TI1_AVCAtlException_ATL__;

//----- (0122B780) --------------------------------------------------------
void __cdecl sub_122B780(HWND hWnd, LPWSTR lpCommandLine)
{
  LPWSTR v2; // esi
  void **v3; // eax
  int v4; // edx
  void **v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // edx
  LPCWSTR v9; // edx
  LPWSTR v10; // edx
  struct _STARTUPINFOW StartupInfo; // [esp+Ch] [ebp-70h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-2Ch]
  int v13; // [esp+60h] [ebp-1Ch]
  int v14; // [esp+64h] [ebp-18h]
  int v15; // [esp+68h] [ebp-14h]
  LPCWSTR lpText; // [esp+6Ch] [ebp-10h]
  int v17; // [esp+78h] [ebp-4h]

  v2 = lpCommandLine;
  if ( *lpCommandLine == 72 )
  {
    sub_11F7CC0(hWnd, lpCommandLine);
  }
  else
  {
    StartupInfo.cb = 68;
    StartupInfo.lpReserved = 0;
    memset(&StartupInfo.lpDesktop, 0, 0x3Cu);
    _mm_storeu_si128(&ProcessInformation, 0i64);
    v3 = sub_122B2D0(&v15, L"explorer /select,");
    v17 = 0;
    sub_122B460(&lpCommandLine, v3, v2);
    v4 = v15 - 16;
    LOBYTE(v17) = 2;
    if ( _InterlockedDecrement((v15 - 16 + 12)) <= 0 )
      (*(**v4 + 4))(v4);
    if ( CreateProcessW(0, lpCommandLine, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation) )
    {
      CloseHandle(ProcessInformation.hThread);
      CloseHandle(ProcessInformation.hProcess);
    }
    else
    {
      v5 = sub_122B2D0(&v13, L"Explorer could not open ");
      LOBYTE(v17) = 3;
      v6 = sub_122B460(&v14, v5, v2);
      LOBYTE(v17) = 4;
      sub_122B460(&lpText, v6, ".");
      v7 = v14 - 16;
      LOBYTE(v17) = 3;
      if ( _InterlockedDecrement((v14 - 16 + 12)) <= 0 )
        (*(**v7 + 4))(v7);
      v8 = v13 - 16;
      LOBYTE(v17) = 2;
      if ( _InterlockedDecrement((v13 - 16 + 12)) <= 0 )
        (*(**v8 + 4))(v8);
      MessageBoxW(hWnd, lpText, L"Process Explorer", 0x30u);
      v9 = lpText - 8;
      if ( _InterlockedDecrement(lpText - 1) <= 0 )
        (*(**v9 + 4))(v9);
    }
    v10 = lpCommandLine - 8;
    v17 = -1;
    if ( _InterlockedDecrement(lpCommandLine - 1) <= 0 )
      (*(**v10 + 4))(v10);
  }
}
// 12BC528: using guessed type wchar_t aExplorerSelect[18];
// 12BC54C: using guessed type wchar_t aExplorerCouldN[25];

//----- (0122B950) --------------------------------------------------------
int sub_122B950()
{
  InitializeCriticalSection(&stru_12E4DD4);
  return _beginthread(sub_11F4650, 0, 0);
}

//----- (0122B970) --------------------------------------------------------
volatile signed __int32 *__cdecl sub_122B970(volatile signed __int32 *a1)
{
  int (__fastcall ***v1)(_DWORD, volatile signed __int32 *, _DWORD, signed int); // eax
  volatile signed __int32 *v2; // edx
  volatile signed __int32 *result; // eax
  int v4; // eax
  volatile signed __int32 *v5; // edi

  v1 = (*(**a1 + 16))();
  v2 = a1 + 3;
  if ( *(a1 + 3) < 0 || v1 != *a1 )
  {
    v4 = (**v1)(v1, v2, *(a1 + 1), 2);
    v5 = v4;
    if ( !v4 )
      ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
    *(v4 + 4) = *(a1 + 1);
    memcpy_s((v4 + 16), 2 * *(a1 + 1) + 2, (a1 + 4), 2 * *(a1 + 1) + 2);
    result = v5;
  }
  else
  {
    _InterlockedExchangeAdd(v2, 1u);
    result = a1;
  }
  return result;
}

//----- (0122B9E0) --------------------------------------------------------
void *__cdecl sub_122B9E0(int a1, void *Src, int a3, void *a4, int a5)
{
  int v5; // ebx
  char *v6; // edi
  void *result; // eax

  v5 = a5 + a3;
  if ( a5 + a3 < 0 )
    goto LABEL_9;
  if ( ((*(*a1 - 8) - v5) | (1 - *(*a1 - 4))) < 0 )
    ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(a1, a5 + a3);
  v6 = *a1;
  memcpy_s(*a1, 2 * a3, Src, 2 * a3);
  memcpy_s(&v6[2 * a3], 2 * a5, a4, 2 * a5);
  if ( v5 > *(*a1 - 8) )
LABEL_9:
    AtlThrow(-2147024809);
  *(*a1 - 12) = v5;
  result = *a1;
  *(*a1 + 2 * v5) = 0;
  return result;
}

//----- (0122BA60) --------------------------------------------------------
_WORD *__thiscall sub_122BA60(_DWORD *this)
{
  _DWORD *v1; // esi
  _WORD *result; // eax
  CStringData **v3; // edx
  IAtlStringMgrVTbl **v4; // edi

  v1 = this;
  result = *this;
  v3 = (*this - 16);
  v4 = *v3;
  if ( *(*this - 12) )
  {
    if ( v3[3] >= 0 )
    {
      if ( _InterlockedDecrement(v3 + 3) <= 0 )
        ((*v3)->pStringMgr[1].vtptr)(v3);
      result = (((*v4)->GetNilString)(v4) + 16);
      *v1 = result;
    }
    else
    {
      if ( *(result - 2) < 0 )
        AtlThrow(E_INVALIDARG);
      *(result - 3) = 0;
      result = *this;
      **this = 0;
    }
  }
  return result;
}

//----- (0122BAC0) --------------------------------------------------------
volatile signed __int32 *__thiscall ATL::CSimpleStringT<wchar_t,0>::Fork(CString *this, int nLength)
{
  CString *thisString; // ebx
  CStringData *pOldData; // esi
  CAtlStringMgr *pStringMgr; // eax
  int nSizeToCopy; // edi
  CStringData *pNewData; // edx
  int dwSize; // ST0C_4
  CStringData *pszNewData; // edi
  volatile signed __int32 *result; // eax
  int nOldLength; // [esp+Ch] [ebp-4h]
  CStringData *NewData; // [esp+18h] [ebp+8h]

  thisString = this;
  // GetData()
  pOldData = this->m_pszData - 1;
  nOldLength = pOldData->nDataLength;
  pStringMgr = (pOldData->pStringMgr->vtptr->Clone)();
  nSizeToCopy = nLength;
  pNewData = pStringMgr->vtptr->Allocate(nLength, 2u);
  NewData = pNewData;
  if ( !pNewData )
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  if ( nOldLength < nSizeToCopy )
    nSizeToCopy = nOldLength;
  dwSize = 2 * (nSizeToCopy + 1);
  pszNewData = pNewData + 1;
  // CopyChars( PXSTR( pNewData->data() ), nCharsToCopy, PCXSTR( pOldData->data() ), nCharsToCopy )
  memcpy_s(&pNewData[1], dwSize, &pOldData[1], dwSize);
  NewData->nDataLength = nOldLength;
  // pOldData->Release();
  result = &pOldData->nRefs;
  if ( _InterlockedDecrement(&pOldData->nRefs) <= 0 )
    result = (pOldData->pStringMgr->vtptr->Free)(pOldData);
  thisString->m_pszData = pszNewData;
  return result;
}

//----- (0122BB40) --------------------------------------------------------
int __thiscall ATL::CAtlStringMgr::Free(_DWORD **this)
{
  return (*(*this[1] + 4))();
}

//----- (0122BB50) --------------------------------------------------------
LPVOID __thiscall ATL::CWin32Heap::Free(HANDLE *this, LPVOID lpMem)
{
  LPVOID result; // eax

  result = lpMem;
  if ( lpMem )
    result = HeapFree(this[1], 0, lpMem);
  return result;
}

//----- (0122BB70) --------------------------------------------------------
wchar_t *__cdecl sub_122BB70(wchar_t *a1, wchar_t *a2)
{
  const wchar_t *v2; // esi
  void *v3; // ebx
  _DWORD *v4; // edi
  const wchar_t **v5; // eax
  const wchar_t *v6; // eax
  _DWORD *v7; // eax
  const wchar_t *v8; // eax
  int v9; // esi
  int *v10; // ebx
  int *v11; // esi
  int *v12; // eax
  wchar_t *v13; // esi
  int v14; // eax
  const wchar_t **v16; // eax
  int v17; // [esp+4h] [ebp-10h]
  int v18; // [esp+8h] [ebp-Ch]
  int *v19; // [esp+Ch] [ebp-8h]
  void *v20; // [esp+10h] [ebp-4h]

  v2 = 0;
  if ( !a2 )
    return _wcsdup(v2);
  v3 = _wcsdup(a2);
  v20 = v3;
  _wcsupr(v3);
  EnterCriticalSection(&stru_12E4DD4);
  v4 = *gList;
  if ( *gList == gList )
    goto LABEL_27;
  while ( 1 )
  {
    v5 = *v4[2];
    if ( v5 )
      v6 = *v5;
    else
      v6 = 0;
    if ( _wcsicmp(v6, L"System") )
    {
      v7 = *v4[2];
      v8 = (v7 ? *v7 : 0);
      if ( _wcsicmp(v8, a1) )
        goto LABEL_25;
    }
    v9 = v4[2];
    bstr_t::EqualAssign(&a2, v3);
    v10 = (v9 + 4);
    v11 = sub_122C770((v9 + 4), &a2);
    if ( v11 == *v10 || sub_11F3C30(&a2, v11 + 4) )
    {
      v18 = *v10;
      v12 = &v18;
    }
    else
    {
      v19 = v11;
      v12 = &v19;
    }
    v13 = a2;
    v14 = *v12;
    v17 = v14;
    if ( a2 )
    {
      if ( !InterlockedDecrement(a2 + 2) )
      {
        if ( *v13 )
        {
          SysFreeString(*v13);
          *v13 = 0;
        }
        if ( *(v13 + 1) )
        {
          j_j__free(*(v13 + 1));
          *(v13 + 1) = 0;
        }
        j__free(v13);
      }
      v14 = v17;
      a2 = 0;
    }
    if ( v14 != *v10 )
      break;
    v3 = v20;
LABEL_25:
    v4 = *v4;
    if ( v4 == gList )
      goto LABEL_26;
  }
  v16 = *(v14 + 20);
  if ( !v16 )
  {
LABEL_26:
    v2 = 0;
    goto LABEL_27;
  }
  v2 = *v16;
LABEL_27:
  LeaveCriticalSection(&stru_12E4DD4);
  free(v20);
  return _wcsdup(v2);
}

//----- (0122BCE0) --------------------------------------------------------
CAtlStringMgr *ATL::CAtlStringMgr::GetInstance()
{
  int dword_4F4E04_copy; // eax
  HANDLE v1; // eax

  dword_4F4E04_copy = gbHeapInited;
  if ( !(gbHeapInited & 1) )
  {
    gbHeapInited |= 1u;
    v1 = GetProcessHeap();
    gWin32Heap.vtptr = &ATL::CWin32Heap::`vftable';
    gWin32Heap.m_hHeap = v1;
    LOBYTE(gWin32Heap.m_bOwnHeap) = 0;
    atexit(sub_12AA7F0);
    dword_4F4E04_copy = gbHeapInited;
  }
  if ( !(dword_4F4E04_copy & 2) )
  {
    `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.vtptr = &ATL::CAtlStringMgr::`vftable';
    gbHeapInited = dword_4F4E04_copy | 2;
    `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.m_pMemMgr = &gWin32Heap;
    `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.m_nil.nRefs = 2;
    `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.m_nil.nDataLength = 0;
    `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.m_nil.nAllocLength = 0;
    *`ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.m_nil.achNil = 0;
    `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.m_nil.pStringMgr = &`ATL::CAtlStringMgr::GetInstance'::`2'::strMgr;
    atexit(sub_12AA820);
  }
  return &`ATL::CAtlStringMgr::GetInstance'::`2'::strMgr;
}
// 12BC4F8: using guessed type void *ATL::CWin32Heap::`vftable';
// 12BC510: using guessed type void *ATL::CAtlStringMgr::`vftable';
// 12E4E04: using guessed type int gbHeapInited;

//----- (0122BD90) --------------------------------------------------------
volatile signed __int32 *__thiscall ATL::CAtlStringMgr::GetNilString(volatile signed __int32 *this)
{
  _InterlockedExchangeAdd(this + 5, 1u);
  return this + 2;
}

//----- (0122BDA0) --------------------------------------------------------
SIZE_T __thiscall ATL::CWin32Heap::GetSize(HANDLE *this, LPCVOID lpMem)
{
  return HeapSize(this[1], 0, lpMem);
}

//----- (0122BDC0) --------------------------------------------------------
int __thiscall sub_122BDC0(int *this, HMODULE hModule, int a3)
{
  int *v3; // ebx
  HRSRC v4; // eax
  unsigned __int16 *v5; // eax
  unsigned __int16 *v6; // edi
  int v7; // esi
  int v8; // ecx
  unsigned __int16 *v9; // edi
  unsigned int v10; // ecx
  int v11; // eax
  int result; // eax

  v3 = this;
  v4 = FindResourceW(hModule, ((a3 >> 4) + 1), RT_STRING);
  if ( !v4 )
    return 0;
  v5 = AtlGetStringResourceImage(hModule, v4, a3);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = *v5;
  if ( ((*(*v3 - 8) - v7) | (1 - *(*v3 - 4))) < 0 )
    ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(v3, *v5);
  v8 = *v6;
  v9 = v6 + 1;
  if ( v8 == -1 )
  {
    if ( v9 )
      v10 = wcslen(v9);
    else
      v10 = 0;
    v8 = v10 + 1;
  }
  v11 = wmemcpy_s(*v3, v7, v9, v8);
  sub_122B650(v11);
  if ( v7 > *(*v3 - 8) )
    AtlThrow(-2147024809);
  *(*v3 - 12) = v7;
  result = 1;
  *(*v3 + 2 * v7) = 0;
  return result;
}

//----- (0122BE90) --------------------------------------------------------
CStringData *__thiscall ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(CStringData **this, int nLength)
{
  int nDataLength; // esi
  CString *thisString; // edi
  CStringData *pOldData; // ecx
  CStringData *result; // eax
  signed int nAllocLength; // ecx
  int nNewLen; // ecx
  int nNewLength; // ecx

  nDataLength = nLength;
  thisString = this;
  pOldData = *this;
  if ( pOldData[-1].nDataLength > nLength )
    nDataLength = pOldData[-1].nDataLength;
  if ( pOldData[-1].nRefs > 1 )
    return ATL::CSimpleStringT<wchar_t,0>::Fork(thisString, nDataLength);
  nAllocLength = pOldData[-1].nAllocLength;
  if ( nAllocLength < nDataLength )
  {
    if ( nAllocLength <= 0x40000000 )           // 1024X1024X1024
    {
      nNewLength = nAllocLength / 2 + nAllocLength;
      if ( nNewLength < nDataLength )
        nNewLength = nDataLength;
      result = ATL::CSimpleStringT<wchar_t,0>::Reallocate(thisString, nNewLength);
    }
    else
    {
      nNewLen = nAllocLength + 0x100000;        // 1024x1024
      if ( nNewLen < nDataLength )
        nNewLen = nDataLength;
      result = ATL::CSimpleStringT<wchar_t,0>::Reallocate(thisString, nNewLen);
    }
  }
  return result;
}

//----- (0122BF00) --------------------------------------------------------
volatile signed __int32 *__cdecl sub_122BF00(OLECHAR *psz, OLECHAR *a2, OLECHAR *a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  const wchar_t *v5; // eax
  void **v6; // ebx
  void **v7; // eax
  BSTR *v8; // eax
  BSTR *v9; // esi
  BSTR v10; // eax
  void *v11; // edi
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  BSTR *v14; // eax
  BSTR *v15; // edi
  BSTR v16; // eax
  int *v17; // ebx
  int *v18; // eax
  BSTR **v19; // esi
  BSTR *v20; // eax
  void *v21; // esi
  bool v22; // zf
  OLECHAR *v23; // ebx
  BSTR *v24; // eax
  BSTR *v25; // edi
  BSTR v26; // eax
  BSTR *v27; // eax
  BSTR *v28; // ebx
  BSTR v29; // eax
  CSysProcItem *v30; // eax
  CAtlStringMgr *v31; // edx
  CAtlStringMgr *v32; // edx
  CAtlStringMgr *v33; // edx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // edx
  int v38; // edx
  int v39; // edx
  volatile signed __int32 *result; // eax
  LPARAM lParam; // [esp+10h] [ebp-34h]
  int v42; // [esp+14h] [ebp-30h]
  int v43; // [esp+18h] [ebp-2Ch]
  int v44; // [esp+1Ch] [ebp-28h]
  BSTR *v45; // [esp+24h] [ebp-20h]
  BSTR *v46; // [esp+28h] [ebp-1Ch]
  void *v47; // [esp+2Ch] [ebp-18h]
  void *v48; // [esp+30h] [ebp-14h]
  _DWORD *v49; // [esp+34h] [ebp-10h]
  int v50; // [esp+40h] [ebp-4h]

  EnterCriticalSection(&stru_12E4DD4);
  v3 = *gList;
  if ( *gList == gList )
    goto LABEL_9;
  while ( 1 )
  {
    v4 = *v3[2];
    v5 = (v4 ? *v4 : 0);
    if ( !_wcsicmp(v5, psz) )
      break;
    v3 = *v3;
    if ( v3 == gList )
      goto LABEL_9;
  }
  v6 = v3[2];
  if ( !v6 )
  {
LABEL_9:
    v7 = operator new(0xCu);
    v6 = v7;
    v48 = v7;
    v50 = 0;
    if ( v7 )
    {
      *v7 = 0;
      LOBYTE(v50) = 1;
      v7[1] = 0;
      v7[2] = 0;
      v7[1] = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
    }
    else
    {
      v6 = 0;
    }
    v49 = v6;
    v8 = operator new(0xCu);
    v9 = v8;
    v48 = v8;
    v50 = 2;
    if ( v8 )
    {
      v8[1] = 0;
      v8[2] = 1;
      v10 = SysAllocString(psz);
      *v9 = v10;
      if ( !v10 && psz )
        com_error::throw(-2147024882);
    }
    else
    {
      v9 = 0;
    }
    v50 = -1;
    if ( !v9 )
      com_error::throw(-2147024882);
    if ( v6 != &v48 )
    {
      v11 = *v6;
      if ( *v6 )
      {
        if ( !InterlockedDecrement(v11 + 2) && v11 )
        {
          if ( *v11 )
          {
            SysFreeString(*v11);
            *v11 = 0;
          }
          if ( *(v11 + 1) )
          {
            j_j__free(*(v11 + 1));
            *(v11 + 1) = 0;
          }
          j__free(v11);
        }
        *v6 = 0;
      }
      *v6 = v9;
      InterlockedIncrement(v9 + 2);
    }
    if ( !InterlockedDecrement(v9 + 2) )
    {
      if ( *v9 )
      {
        SysFreeString(*v9);
        *v9 = 0;
      }
      if ( v9[1] )
      {
        j_j__free(v9[1]);
        v9[1] = 0;
      }
      j__free(v9);
    }
    v12 = gList;
    v13 = sub_1281420(gList, *(gList + 1), &v49);
    if ( (357913940 - dword_12E4DF0) < 1 )
      std::_Xlength_error("list<T> too long");
    ++dword_12E4DF0;
    v12[1] = v13;
    *v13[1] = v13;
  }
  _wcsupr(a2);
  v14 = operator new(0xCu);
  v15 = v14;
  v48 = v14;
  v50 = 3;
  if ( v14 )
  {
    v14[1] = 0;
    v14[2] = 1;
    v16 = SysAllocString(a2);
    *v15 = v16;
    if ( !v16 && a2 )
      com_error::throw(-2147024882);
  }
  else
  {
    v15 = 0;
  }
  v50 = -1;
  v48 = v15;
  if ( !v15 )
    com_error::throw(-2147024882);
  v17 = (v6 + 1);
  v49 = v17;
  v18 = sub_122C770(v17, &v48);
  v19 = v18;
  if ( v18 != *v17 )
  {
    v20 = v18[4];
    if ( v15 == v20 )
      goto LABEL_52;
    if ( !v20 )
    {
      if ( *v15 )
      {
        SysStringLen(*v15);
        v48 = v19;
        goto LABEL_54;
      }
      goto LABEL_52;
    }
    if ( sub_11F4730(v15, v19[4]) >= 0 )
    {
LABEL_52:
      v48 = v19;
      goto LABEL_54;
    }
  }
  v48 = *v17;
LABEL_54:
  v21 = v48;
  if ( !InterlockedDecrement(v15 + 2) )
  {
    if ( *v15 )
    {
      SysFreeString(*v15);
      *v15 = 0;
    }
    if ( v15[1] )
    {
      j_j__free(v15[1]);
      v15[1] = 0;
    }
    j__free(v15);
  }
  v22 = v21 == *v17;
  v23 = a3;
  if ( v22 )
  {
    v24 = operator new(0xCu);
    v25 = v24;
    v48 = v24;
    v50 = 4;
    if ( v24 )
    {
      v24[1] = 0;
      v24[2] = 1;
      v26 = SysAllocString(a3);
      *v25 = v26;
      if ( !v26 && a3 )
        com_error::throw(-2147024882);
    }
    else
    {
      v25 = 0;
    }
    v50 = -1;
    v48 = v25;
    if ( !v25 )
      com_error::throw(-2147024882);
    v50 = 5;
    v27 = operator new(0xCu);
    v28 = v27;
    v47 = v27;
    LOBYTE(v50) = 6;
    if ( v27 )
    {
      v27[1] = 0;
      v27[2] = 1;
      v29 = SysAllocString(a2);
      *v28 = v29;
      if ( !v29 && a2 )
        com_error::throw(-2147024882);
    }
    else
    {
      v28 = 0;
    }
    LOBYTE(v50) = 5;
    v47 = v28;
    if ( !v28 )
      com_error::throw(-2147024882);
    v45 = v28;
    InterlockedIncrement(v28 + 2);
    v46 = v25;
    InterlockedIncrement(v25 + 2);
    LOBYTE(v50) = 8;
    v30 = sub_12211F0(v49, &v45);
    sub_122B100(v49, &v44, 0, &v30->dwPid, v30);
    sub_1221430(&v45);
    if ( !InterlockedDecrement(v28 + 2) )
    {
      if ( *v28 )
      {
        SysFreeString(*v28);
        *v28 = 0;
      }
      if ( v28[1] )
      {
        j_j__free(v28[1]);
        v28[1] = 0;
      }
      j__free(v28);
    }
    v50 = -1;
    if ( !InterlockedDecrement(v25 + 2) )
    {
      if ( *v25 )
      {
        SysFreeString(*v25);
        *v25 = 0;
      }
      if ( v25[1] )
      {
        j_j__free(v25[1]);
        v25[1] = 0;
      }
      j__free(v25);
    }
    v23 = a3;
  }
  LeaveCriticalSection(&stru_12E4DD4);
  v31 = ATL::CAtlStringMgr::GetInstance();
  if ( !v31 )
    AtlThrow(E_FAIL);
  lParam = (v31->vtptr->GetNilString)(v31) + 16;
  v32 = ATL::CAtlStringMgr::GetInstance();
  if ( !v32 )
    AtlThrow(-2147467259);
  v42 = (v32->vtptr->GetNilString)(v32) + 16;
  v33 = ATL::CAtlStringMgr::GetInstance();
  if ( !v33 )
    AtlThrow(-2147467259);
  v43 = (v33->vtptr->GetNilString)(v33) + 16;
  v50 = 9;
  if ( a2 )
    v34 = wcslen(a2);
  else
    v34 = 0;
  sub_122C620(&v42, a2, v34);
  if ( psz )
    v35 = wcslen(psz);
  else
    v35 = 0;
  sub_122C620(&lParam, psz, v35);
  if ( v23 )
    v36 = wcslen(v23);
  else
    v36 = 0;
  sub_122C620(&v43, v23, v36);
  SendMessageW(ghWndNewOwner, 0x7F8u, 0, &lParam);
  v37 = v43 - 16;
  v50 = -1;
  if ( _InterlockedDecrement((v43 - 16 + 12)) <= 0 )
    (*(**v37 + 4))(v37);
  v38 = v42 - 16;
  if ( _InterlockedDecrement((v42 - 16 + 12)) <= 0 )
    (*(**v38 + 4))(v38);
  v39 = lParam - 16;
  result = (lParam - 16 + 12);
  if ( _InterlockedDecrement(result) <= 0 )
    result = (*(**v39 + 4))(v39);
  return result;
}
// 12E4DF0: using guessed type int dword_12E4DF0;

//----- (0122C530) --------------------------------------------------------
CStringData *__thiscall ATL::CSimpleStringT<wchar_t,0>::Reallocate(CString *this, int nLength)
{
  CString *thisString; // edi
  CStringData *pOldData; // edx
  CStringData *pNewData; // eax
  CStringData *result; // eax

  thisString = this;
  pOldData = this->m_pszData - 1;
  if ( pOldData->nAllocLength >= nLength
    || nLength <= 0
    || (pNewData = (pOldData->pStringMgr->vtptr->Reallocate)(pOldData, nLength, 2)) == 0 )
  {
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  }
  result = pNewData + 1;
  thisString->m_pszData = result;
  return result;
}

//----- (0122C570) --------------------------------------------------------
int __thiscall ATL::CAtlStringMgr::Reallocate(_DWORD **this, int a2, int a3, unsigned int a4)
{
  int result; // eax
  int v5; // esi
  unsigned int v6; // eax

  if ( a3 < 0 || 0x7FFFFFFF - a3 < 1 )
    return 0;
  v5 = (a3 + 8) & 0xFFFFFFF8;
  if ( a3 + 1 > v5 )
    return 0;
  v6 = a4 * v5;
  if ( !is_mul_ok(a4, v5) )
    return 0;
  if ( v6 > 0xFFFFFFFF )
    return 0;
  if ( v6 > 0xFFFFFFEF )
    return 0;
  result = (*(*this[1] + 8))(a2, v6 + 16);
  if ( !result )
    return 0;
  *(result + 8) = v5 - 1;
  return result;
}

//----- (0122C5E0) --------------------------------------------------------
LPVOID __thiscall ATL::CWin32Heap::Reallocate(HANDLE *this, LPVOID lpMem, SIZE_T dwBytes)
{
  if ( !lpMem )
    return (**this)(dwBytes);
  if ( dwBytes )
    return HeapReAlloc(this[1], 0, lpMem, dwBytes);
  (*(*this + 1))(lpMem);
  return 0;
}

//----- (0122C620) --------------------------------------------------------
_WORD *__thiscall sub_122C620(void **this, void *Src, int a3)
{
  int v3; // esi
  void **v4; // edi
  _WORD *result; // eax
  void *v6; // edx
  unsigned int v7; // ebx
  _WORD *v8; // ecx
  int v9; // ebx
  unsigned int a2; // [esp+14h] [ebp+Ch]

  v3 = a3;
  v4 = this;
  if ( !a3 )
    return sub_122BA60(this);
  v6 = Src;
  if ( !Src )
    goto LABEL_16;
  v7 = (Src - *this) >> 1;
  a2 = *(*this - 3);
  if ( v3 < 0 )
    AtlThrow(-2147024809);
  if ( ((*(*this - 2) - v3) | (1 - *(*this - 1))) < 0 )
  {
    ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(this, v3);
    v6 = Src;
  }
  v8 = *v4;
  if ( v7 > a2 )
  {
    v9 = 2 * v3;
    memcpy_s(v8, 2 * *(v8 - 2), v6, 2 * v3);
  }
  else
  {
    memmove_s(v8, 2 * *(v8 - 2), &v8[v7], 2 * v3);
    v9 = 2 * v3;
  }
  if ( v3 > *(*v4 - 2) )
LABEL_16:
    AtlThrow(-2147024809);
  *(*v4 - 3) = v3;
  result = *v4;
  *(*v4 + v9) = 0;
  return result;
}

//----- (0122C6E0) --------------------------------------------------------
HGLOBAL __cdecl AtlGetStringResourceImage(HMODULE hModule, HRSRC hResInfo, int a3)
{
  HGLOBAL result; // eax
  _WORD *v4; // esi
  DWORD v5; // edx
  int v6; // ecx

  result = LoadResource(hModule, hResInfo);
  if ( result )
  {
    v4 = LockResource(result);
    if ( !v4 )
      return 0;
    v5 = v4 + SizeofResource(hModule, hResInfo);
    v6 = a3 & 0xF;
    if ( a3 & 0xF )
    {
      while ( v4 < v5 )
      {
        v4 += *v4 + 1;
        if ( !--v6 )
          goto LABEL_6;
      }
      return 0;
    }
LABEL_6:
    if ( v4 >= v5 )
      return 0;
    if ( !*v4 )
      v4 = 0;
    result = v4;
  }
  return result;
}

//----- (0122C750) --------------------------------------------------------
void __stdcall sub_122C750(void *a1)
{
  sub_1221430(a1 + 4);
  j__free(a1);
}

//----- (0122C770) --------------------------------------------------------
int *__thiscall sub_122C770(int *this, BSTR **a2)
{
  int v2; // edi
  int v3; // esi
  BSTR *v4; // ecx
  BSTR *v5; // eax
  OLECHAR *v6; // eax

  v2 = *this;
  v3 = *(*this + 4);
  while ( !*(v3 + 13) )
  {
    v4 = *(v3 + 16);
    v5 = *a2;
    if ( v4 != *a2 )
    {
      if ( v4 )
      {
        if ( v5 )
        {
          if ( sub_11F4730(v4, *a2) < 0 )
            goto LABEL_14;
        }
        else if ( *v4 )
        {
          SysStringLen(*v4);
        }
      }
      else if ( v5 )
      {
        v6 = *v5;
        if ( v6 )
        {
          if ( SysStringLen(v6) )
          {
LABEL_14:
            v3 = *(v3 + 8);
            continue;
          }
        }
      }
    }
    v2 = v3;
    v3 = *v3;
  }
  return v2;
}

//----- (0122C7E0) --------------------------------------------------------
int __cdecl sub_122C7E0(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // ecx
  int v6; // ebx
  int v7; // esi
  bool i; // zf
  int j; // esi
  int result; // eax

  v5 = a3;
  v6 = a2;
  v7 = 2 * a2 + 2;
  for ( i = v7 == a3; v7 < a3; i = v7 == a3 )
  {
    if ( a5(*(a1 + 4 * v7), *(a1 + 4 * v7 - 4)) )
      --v7;
    v5 = a3;
    *(a1 + 4 * v6) = *(a1 + 4 * v7);
    v6 = v7;
    v7 = 2 * v7 + 2;
  }
  if ( i )
  {
    *(a1 + 4 * v6) = *(a1 + 4 * v5 - 4);
    v6 = v5 - 1;
  }
  for ( j = (v6 - 1) / 2; a2 < v6; j = (j - 1) / 2 )
  {
    if ( !a5(*(a1 + 4 * j), *a4) )
      break;
    *(a1 + 4 * v6) = *(a1 + 4 * j);
    v6 = j;
  }
  result = *a4;
  *(a1 + 4 * v6) = *a4;
  return result;
}

//----- (0122C880) --------------------------------------------------------
void *__cdecl sub_122C880(void *a1, int a2, int a3)
{
  void *result; // eax
  _DWORD *v4; // esi
  _DWORD *v5; // edi
  int v6; // ebx
  _DWORD *v7; // esi
  int v8; // ST08_4
  char *v9; // [esp+4h] [ebp-8h]
  _DWORD *v10; // [esp+8h] [ebp-4h]

  result = a2;
  v4 = a1;
  if ( a1 != a2 )
  {
    v5 = a1 + 4;
    v9 = a1 + 4;
    if ( a1 + 4 != a2 )
    {
      do
      {
        v6 = *v5;
        v10 = v5;
        if ( (a3)(*v5, *v4) )
        {
          result = memmove(&v5[-(v5 - v4) + 1], v4, 4 * (v5 - v4));
          *v4 = v6;
        }
        else
        {
          v7 = v5 - 1;
          if ( (a3)(v6, *(v5 - 1)) )
          {
            do
            {
              *v5 = *v7;
              v5 = v7;
              v8 = *(v7 - 1);
              --v7;
            }
            while ( (a3)(v6, v8) );
            v10 = v5;
            v5 = v9;
          }
          result = v10;
          v4 = a1;
          *v10 = v6;
        }
        ++v5;
        v9 = v5;
      }
      while ( v5 != a2 );
    }
  }
  return result;
}

//----- (0122C930) --------------------------------------------------------
int __cdecl sub_122C930(int a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // edi
  int v4; // ecx
  int result; // eax
  int v6; // edx
  int v7; // esi
  int v8; // eax
  int v9; // edx
  int v10; // esi
  int v11; // ebx
  int v12; // [esp+4h] [ebp-8h]
  int v13; // [esp+8h] [ebp-4h]
  int v14; // [esp+14h] [ebp+8h]
  int v15; // [esp+18h] [ebp+Ch]

  v3 = a1;
  v15 = (a2 - a1) >> 2;
  v4 = v15;
  result = v4 - (v4 >> 31);
  v6 = v15 / 2;
  if ( v15 / 2 > 0 )
  {
    v7 = 2 * v6 + 2;
    do
    {
      v8 = *(v3 + 4 * v6 - 4);
      v9 = v6 - 1;
      v10 = v7 - 2;
      v14 = v9;
      v13 = v10;
      v11 = v9;
      v12 = v8;
      if ( v10 < v4 )
      {
        do
        {
          if ( a3(*(v3 + 4 * v10), *(v3 + 4 * v10 - 4)) )
            --v10;
          v4 = v15;
          *(v3 + 4 * v11) = *(v3 + 4 * v10);
          v11 = v10;
          v10 = 2 * v10 + 2;
        }
        while ( v10 < v15 );
        v9 = v14;
      }
      if ( v10 == v4 )
      {
        *(v3 + 4 * v11) = *(v3 + 4 * v4 - 4);
        v11 = v4 - 1;
      }
      result = sub_122CBC0(v3, v11, v9, &v12, a3);
      v6 = v14;
      v4 = v15;
      v7 = v13;
    }
    while ( v14 > 0 );
  }
  return result;
}

//----- (0122C9E0) --------------------------------------------------------
int __cdecl sub_122C9E0(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int))
{
  int *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // ST00_4
  int *v9; // ebx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int *v16; // edi
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int result; // eax
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // [esp-4h] [ebp-18h]
  int v28; // [esp+Ch] [ebp-8h]
  int *v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+1Ch] [ebp+8h]
  int *v31; // [esp+1Ch] [ebp+8h]

  v4 = a1;
  v5 = a3 - a1;
  v27 = *a1;
  if ( v5 <= 40 )
  {
    if ( a4(*a2, v27) )
    {
      v24 = *a2;
      *a2 = *a1;
      *a1 = v24;
    }
    result = a4(*a3, *a2);
    if ( result )
    {
      v25 = *a3;
      *a3 = *a2;
      *a2 = v25;
      result = a4(v25, *a1);
      if ( result )
      {
        v26 = *a2;
        result = *a1;
        *a2 = *a1;
        *a1 = v26;
      }
    }
  }
  else
  {
    v6 = (v5 + 1) / 8;
    v7 = 8 * v6;
    v6 *= 4;
    v8 = *(a1 + v6);
    v9 = (a1 + v6);
    v28 = v7;
    v30 = v6;
    if ( a4(v8, v27) )
    {
      v10 = *v9;
      *v9 = *v4;
      *v4 = v10;
    }
    if ( a4(*(v4 + v28), *v9) )
    {
      v11 = *(v4 + v28);
      *(v4 + v28) = *v9;
      *v9 = v11;
      if ( a4(v11, *v4) )
      {
        v12 = *v9;
        *v9 = *v4;
        *v4 = v12;
      }
    }
    v29 = (a2 - v30);
    if ( a4(*a2, *(a2 - v30)) )
    {
      v13 = *a2;
      *a2 = *v29;
      *v29 = v13;
    }
    if ( a4(*(a2 + v30), *a2) )
    {
      v14 = *(a2 + v30);
      *(a2 + v30) = *a2;
      *a2 = v14;
      if ( a4(v14, *v29) )
      {
        v15 = *a2;
        *a2 = *v29;
        *v29 = v15;
      }
    }
    v16 = (a3 - v30);
    v31 = (a3 - v28);
    if ( a4(*v16, *(a3 - v28)) )
    {
      v17 = *v16;
      *v16 = *v31;
      *v31 = v17;
    }
    if ( a4(*a3, *v16) )
    {
      v18 = *a3;
      *a3 = *v16;
      *v16 = v18;
      if ( a4(v18, *v31) )
      {
        v19 = *v16;
        *v16 = *v31;
        *v31 = v19;
      }
    }
    if ( a4(*a2, *v9) )
    {
      v20 = *a2;
      *a2 = *v9;
      *v9 = v20;
    }
    result = a4(*v16, *a2);
    if ( result )
    {
      v22 = *v16;
      *v16 = *a2;
      *a2 = v22;
      result = a4(v22, *v9);
      if ( result )
      {
        v23 = *a2;
        result = *v9;
        *a2 = *v9;
        *v9 = v23;
      }
    }
  }
  return result;
}

//----- (0122CBC0) --------------------------------------------------------
int __cdecl sub_122CBC0(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // edi
  int v6; // esi
  int result; // eax

  v5 = a2;
  v6 = (a2 - 1) / 2;
  if ( a3 >= a2 )
  {
    result = a1;
    *(a1 + 4 * a2) = *a4;
  }
  else
  {
    do
    {
      if ( !a5(*(a1 + 4 * v6), *a4) )
        break;
      *(a1 + 4 * v5) = *(a1 + 4 * v6);
      v5 = v6;
      v6 = (v6 - 1) / 2;
    }
    while ( a3 < v5 );
    result = *a4;
    *(a1 + 4 * v5) = *a4;
  }
  return result;
}

//----- (0122CC30) --------------------------------------------------------
void *__cdecl sub_122CC30(void *a1, int a2, int a3, int a4)
{
  unsigned __int8 (__cdecl *v4)(int, int); // edx
  int *v5; // esi
  int *v6; // edi
  int v7; // ecx
  int v8; // ebx
  void *result; // eax
  int v10; // [esp+Ch] [ebp-8h]
  void *v11; // [esp+10h] [ebp-4h]

  v4 = a4;
  v5 = a2;
  v6 = a1;
  v7 = (a2 - a1) >> 2;
  if ( v7 <= 32 )
    goto LABEL_8;
  v8 = a3;
  while ( v8 > 0 )
  {
    sub_122CD70(&v10, v6, v5, v4);
    v8 = v8 / 2 / 2 + v8 / 2;
    if ( ((v10 - v6) & 0xFFFFFFFC) >= ((v5 - v11) & 0xFFFFFFFC) )
    {
      result = sub_122CC30(v11, v5, v8, a4);
      v5 = v10;
    }
    else
    {
      result = sub_122CC30(v6, v10, v8, a4);
      v6 = v11;
    }
    v4 = a4;
    v7 = v5 - v6;
    if ( v7 <= 32 )
      goto LABEL_8;
  }
  if ( v7 <= 32 )
  {
LABEL_8:
    if ( v7 > 1 )
      result = sub_122C880(v6, v5, v4);
  }
  else
  {
    if ( ((v5 - v6) & 0xFFFFFFFC) > 4 )
    {
      sub_122C930(v6, v5, v4);
      v4 = a4;
    }
    result = sub_122CD10(v6, v5, v4);
  }
  return result;
}

//----- (0122CD10) --------------------------------------------------------
signed int __cdecl sub_122CD10(_DWORD *a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // esi
  signed int result; // eax
  unsigned __int8 (__cdecl *v5)(_DWORD, _DWORD); // ebx

  v3 = a2 - a1;
  result = (a2 - a1) & 0xFFFFFFFC;
  if ( result > 4 )
  {
    v5 = a3;
    do
    {
      a2 = *(a1 + v3 - 4);
      *(a1 + v3 - 4) = *a1;
      v3 -= 4;
      sub_122C7E0(a1, 0, v3 >> 2, &a2, v5);
      result = v3 & 0xFFFFFFFC;
    }
    while ( (v3 & 0xFFFFFFFC) > 4 );
  }
  return result;
}

//----- (0122CD70) --------------------------------------------------------
int **__cdecl sub_122CD70(int **a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int))
{
  int v4; // kr00_4
  int *v5; // esi
  int *v6; // edi
  int *v7; // eax
  int *v8; // edx
  int *v9; // ebx
  int *v10; // eax
  int v11; // ecx
  bool v12; // zf
  unsigned int v13; // ebx
  int *v14; // edi
  int v15; // ecx
  int *v16; // eax
  int v17; // ecx
  int *v18; // edx
  int *v19; // edi
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int v24; // ecx
  int **result; // eax
  int *v26; // [esp+Ch] [ebp-Ch]
  int *v27; // [esp+Ch] [ebp-Ch]
  int *v28; // [esp+10h] [ebp-8h]
  int v29; // [esp+14h] [ebp-4h]

  v4 = a3 - a2;
  v5 = &a2[v4 / 2];
  sub_122C9E0(a2, &a2[v4 / 2], a3 - 1, a4);
  v6 = v5 + 1;
  v29 = (v5 + 1);
  if ( a2 < v5 )
  {
    do
    {
      v26 = v5 - 1;
      if ( a4(*(v5 - 1), *v5) )
        break;
      if ( a4(*v5, *v26) )
        break;
      --v5;
    }
    while ( a2 < v26 );
    v6 = v29;
  }
  v7 = a3;
  if ( v6 < a3 )
  {
    while ( !a4(*v6, *v5) )
    {
      v12 = a4(*v5, *v6) == 0;
      v7 = a3;
      if ( v12 )
      {
        ++v6;
        if ( v6 < a3 )
          continue;
      }
      goto LABEL_12;
    }
    v7 = a3;
LABEL_12:
    v29 = v6;
  }
  v8 = v5;
  v9 = v6;
  v28 = v5;
  while ( 2 )
  {
    while ( 2 )
    {
      v27 = v9;
LABEL_15:
      if ( v9 < v7 )
      {
        do
        {
          if ( !a4(*v5, *v9) )
          {
            if ( a4(*v9, *v5) )
              break;
            v10 = v6;
            ++v6;
            if ( v10 != v9 )
            {
              v11 = *(v6 - 1);
              *(v6 - 1) = *v9;
              *v9 = v11;
            }
          }
          ++v9;
        }
        while ( v9 < a3 );
        v8 = v28;
        v29 = v6;
        v27 = v9;
      }
      v12 = v8 == a2;
      if ( v8 <= a2 )
        goto LABEL_32;
      v13 = v28;
      v14 = v28 - 1;
      while ( a4(*v14, *v5) )
      {
LABEL_28:
        v16 = a2;
        v13 -= 4;
        --v14;
        if ( a2 >= v13 )
          goto LABEL_31;
      }
      if ( !a4(*v5, *v14) )
      {
        --v5;
        if ( v5 != v14 )
        {
          v15 = *v5;
          *v5 = *v14;
          *v14 = v15;
        }
        goto LABEL_28;
      }
      v16 = a2;
LABEL_31:
      v6 = v29;
      v28 = v13;
      v8 = v13;
      v12 = v13 == v16;
      v9 = v27;
LABEL_32:
      if ( !v12 )
      {
        --v8;
        v28 = v8;
        if ( v9 != a3 )
        {
          v24 = *v9;
          *v9 = *v8;
          ++v9;
          v7 = a3;
          *v8 = v24;
          continue;
        }
        --v5;
        if ( v8 != v5 )
        {
          v21 = *v8;
          *v8 = *v5;
          *v5 = v21;
        }
        v22 = *(v6 - 1);
        --v6;
        v23 = *v5;
        *v5 = v22;
        v7 = a3;
        v29 = v6;
        *v6 = v23;
        goto LABEL_15;
      }
      break;
    }
    if ( v9 != a3 )
    {
      if ( v6 != v9 )
      {
        v17 = *v5;
        *v5 = *v6;
        *v6 = v17;
      }
      v18 = v5;
      v29 = (v6 + 1);
      ++v5;
      v19 = v9;
      ++v9;
      v20 = *v18;
      *v18 = *v19;
      v8 = v28;
      v7 = a3;
      *v19 = v20;
      v6 = v29;
      continue;
    }
    break;
  }
  result = a1;
  a1[1] = v6;
  *a1 = v5;
  return result;
}

//----- (0122CF50) --------------------------------------------------------
_DWORD *__cdecl sub_122CF50(_DWORD *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  _WORD *i; // ecx
  _DWORD *result; // eax

  for ( i = a2; i != a3; ++i )
  {
    if ( *i == *a4 )
      break;
  }
  result = a1;
  *a1 = i;
  return result;
}

//----- (0122CF80) --------------------------------------------------------
void **__thiscall sub_122CF80(void **this, void *Src, int a3, int a4)
{
  void **v4; // edi
  int v5; // eax
  int v6; // eax

  v4 = this;
  if ( !a4 )
    AtlThrow(-2147467259);
  if ( !Src && a3 )
    goto LABEL_13;
  v5 = (**a4)(a3, 2);
  if ( !v5 )
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  v6 = v5 + 16;
  *v4 = v6;
  if ( a3 < 0 || a3 > *(v6 - 8) )
LABEL_13:
    AtlThrow(-2147024809);
  *(v6 - 12) = a3;
  *(*v4 + a3) = 0;
  memcpy_s(*v4, 2 * a3, Src, 2 * a3);
  return v4;
}

//----- (0122D000) --------------------------------------------------------
_DWORD *__thiscall sub_122D000(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // esi
  CAtlStringMgr *v4; // ecx
  CAtlStringMgr *v5; // ecx
  _DWORD *result; // eax

  v3 = this;
  this[2] = a2;
  *this = &Appdomain::`vftable';
  this[3] = a3;
  this[4] = 0;
  v4 = ATL::CAtlStringMgr::GetInstance();
  if ( !v4 )
    AtlThrow(-2147467259);
  v3[5] = (v4->vtptr->GetNilString)() + 16;
  v5 = ATL::CAtlStringMgr::GetInstance();
  if ( !v5 )
    AtlThrow(-2147467259);
  v3[6] = (v5->vtptr->GetNilString)() + 16;
  result = v3;
  v3[7] = 0;
  v3[8] = 0;
  v3[9] = 0;
  return result;
}
// 12BC910: using guessed type void *Appdomain::`vftable';

//----- (0122D080) --------------------------------------------------------
void **__thiscall sub_122D080(void **this, int a2, int a3, void *a4, void *Src)
{
  void **v5; // esi
  CAtlStringMgr *v6; // edx
  CAtlStringMgr *v7; // edx
  CAtlStringMgr *v8; // edx
  CAtlStringMgr *v9; // edx
  int v10; // ecx

  v5 = this;
  *this = &Assembly::`vftable';
  v6 = ATL::CAtlStringMgr::GetInstance();
  if ( !v6 )
    AtlThrow(-2147467259);
  v5[1] = ((v6->vtptr->GetNilString)(v6) + 16);
  v5[2] = a2;
  v5[3] = a3;
  v7 = ATL::CAtlStringMgr::GetInstance();
  if ( !v7 )
    AtlThrow(-2147467259);
  v5[4] = ((v7->vtptr->GetNilString)(v7) + 16);
  v8 = ATL::CAtlStringMgr::GetInstance();
  if ( !v8 )
    AtlThrow(-2147467259);
  v5[5] = ((v8->vtptr->GetNilString)(v8) + 16);
  v9 = ATL::CAtlStringMgr::GetInstance();
  if ( !v9 )
    AtlThrow(-2147467259);
  v5[6] = ((v9->vtptr->GetNilString)(v9) + 16);
  if ( Src )
    v10 = wcslen(Src);
  else
    v10 = 0;
  sub_122C620(v5 + 5, Src, v10);
  sub_122FFF0(v5, a4);
  return v5;
}
// 12BC930: using guessed type void *Assembly::`vftable';

//----- (0122D1D0) --------------------------------------------------------
CResize *__thiscall CResize::CResize(CResize *this, HWND hWnd)
{
  CResize *v2; // esi

  v2 = this;
  this->m_hTheme = 0;
  this->vtptr = &CResizer::`vftable';
  this->m_hWnd = 0;
  this->m_WidthScale = 50;
  this->m_HeightScale = 67;
  this->m_Buffer = 0;
  this->m_BufCount = 0;
  this->m_FixedBorder = 1;
  if ( hWnd )
    CResize::HookWindow(this, hWnd);
  return v2;
}
// 12BC888: using guessed type void *CResizer::`vftable';

//----- (0122D260) --------------------------------------------------------
_DWORD *__thiscall sub_122D260(_DWORD *this)
{
  _DWORD *result; // eax

  *this = 0;
  result = this;
  this[2] = 0;
  this[3] = 1;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  return result;
}

//----- (0122D2B0) --------------------------------------------------------
_DWORD *__thiscall sub_122D2B0(_DWORD *this, int a2, __int16 a3)
{
  _DWORD *v3; // esi
  CAtlStringMgr *v4; // ecx
  CAtlStringMgr *v5; // ecx
  CAtlStringMgr *v6; // ecx
  CAtlStringMgr *v7; // ecx
  CAtlStringMgr *v8; // ecx
  _DWORD *result; // eax

  v3 = this;
  *this = &Runtime::`vftable';
  v4 = ATL::CAtlStringMgr::GetInstance();
  if ( !v4 )
    AtlThrow(-2147467259);
  v3[1] = (v4->vtptr->GetNilString)() + 16;
  v5 = ATL::CAtlStringMgr::GetInstance();
  if ( !v5 )
    AtlThrow(-2147467259);
  v3[2] = (v5->vtptr->GetNilString)() + 16;
  v6 = ATL::CAtlStringMgr::GetInstance();
  if ( !v6 )
    AtlThrow(-2147467259);
  v3[3] = (v6->vtptr->GetNilString)() + 16;
  v7 = ATL::CAtlStringMgr::GetInstance();
  if ( !v7 )
    AtlThrow(-2147467259);
  v3[4] = (v7->vtptr->GetNilString)() + 16;
  *(v3 + 10) = a3;
  v8 = ATL::CAtlStringMgr::GetInstance();
  if ( !v8 )
    AtlThrow(-2147467259);
  v3[6] = (v8->vtptr->GetNilString)() + 16;
  v3[7] = a2;
  result = v3;
  v3[8] = 0;
  v3[9] = 0;
  v3[10] = 0;
  v3[11] = 0;
  v3[12] = 0;
  v3[13] = 0;
  return result;
}
// 12BC8F0: using guessed type void *Runtime::`vftable';

//----- (0122D3B0) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_122D3B0(_DWORD *this)
{
  _DWORD *v1; // ebx
  void (__stdcall ****v2)(signed int); // esi
  int v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // eax
  volatile signed __int32 *v6; // edx
  volatile signed __int32 *v7; // edx
  volatile signed __int32 *result; // eax
  unsigned int v9; // [esp+14h] [ebp-10h]

  v1 = this;
  *this = &Appdomain::`vftable';
  v2 = this[7];
  v3 = 0;
  v4 = (this[8] - v2 + 3) >> 2;
  if ( v2 > v1[8] )
    v4 = 0;
  v9 = v4;
  if ( v4 )
  {
    v5 = v4;
    do
    {
      if ( *v2 )
      {
        (***v2)(1);
        v5 = v9;
      }
      ++v3;
      ++v2;
    }
    while ( v3 != v5 );
  }
  if ( v1[7] )
  {
    j__free(v1[7]);
    v1[7] = 0;
    v1[8] = 0;
    v1[9] = 0;
  }
  v6 = (v1[6] - 16);
  if ( _InterlockedDecrement(v6 + 3) <= 0 )
    (*(**v6 + 4))(v6);
  v7 = (v1[5] - 16);
  result = v7 + 3;
  if ( _InterlockedDecrement(v7 + 3) <= 0 )
    result = (*(**v7 + 4))(v7);
  *v1 = &CTreeListData::`vftable';
  return result;
}
// 12B414C: using guessed type void *CTreeListData::`vftable';
// 12BC910: using guessed type void *Appdomain::`vftable';

//----- (0122D4B0) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_122D4B0(_DWORD *this)
{
  _DWORD *v1; // esi
  volatile signed __int32 *v2; // ebx
  volatile signed __int32 *v3; // edx
  volatile signed __int32 *v4; // edx
  volatile signed __int32 *v5; // edx
  volatile signed __int32 *result; // eax

  v1 = this;
  v2 = (this[6] - 16);
  if ( _InterlockedDecrement(v2 + 3) <= 0 )
    (*(**v2 + 4))(v2);
  v3 = (v1[5] - 16);
  if ( _InterlockedDecrement(v3 + 3) <= 0 )
    (*(**v3 + 4))(v3);
  v4 = (v1[4] - 16);
  if ( _InterlockedDecrement(v4 + 3) <= 0 )
    (*(**v4 + 4))(v4);
  v5 = (v1[1] - 16);
  result = v5 + 3;
  if ( _InterlockedDecrement(v5 + 3) <= 0 )
    result = (*(**v5 + 4))(v5);
  *v1 = &CTreeListData::`vftable';
  return result;
}
// 12B414C: using guessed type void *CTreeListData::`vftable';

//----- (0122D530) --------------------------------------------------------
void *__thiscall CResizer::~CResizer(_DWORD *this)
{
  _DWORD *v1; // esi
  HWND v2; // ST04_4
  void *v3; // ST08_4
  void *result; // eax

  v1 = this;
  v2 = this[3];
  *this = &CResizer::`vftable';
  if ( GetWindowLongW(v2, GWL_WNDPROC) == CResizer::HookWndProc )
    SetWindowLongW(v1[3], GWL_WNDPROC, v1[2]);
  v3 = v1[14];
  v1[3] = 0;
  free(v3);
  result = v1[1];
  v1[14] = 0;
  v1[15] = 0;
  *v1 = &CThemedWindow::`vftable';
  if ( result )
    result = CloseThemeData(result);
  return result;
}
// 12B4130: using guessed type void *CThemedWindow::`vftable';
// 12BC888: using guessed type void *CResizer::`vftable';

//----- (0122D590) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_122D590(_DWORD *this)
{
  _DWORD *v1; // ebx
  void (__stdcall ****v2)(signed int); // esi
  int v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // eax
  volatile signed __int32 *v6; // edx
  volatile signed __int32 *result; // eax
  unsigned int v8; // [esp+14h] [ebp-10h]

  v1 = this;
  *this = &Process::`vftable';
  v2 = this[3];
  v3 = 0;
  v4 = (this[4] - v2 + 3) >> 2;
  if ( v2 > v1[4] )
    v4 = 0;
  v8 = v4;
  if ( v4 )
  {
    v5 = v4;
    do
    {
      if ( *v2 )
      {
        (***v2)(1);
        v5 = v8;
      }
      ++v3;
      ++v2;
    }
    while ( v3 != v5 );
  }
  if ( v1[3] )
  {
    j__free(v1[3]);
    v1[3] = 0;
    v1[4] = 0;
    v1[5] = 0;
  }
  v6 = (v1[2] - 16);
  result = v6 + 3;
  if ( _InterlockedDecrement(v6 + 3) <= 0 )
    result = (*(**v6 + 4))(v6);
  *v1 = &CTreeListData::`vftable';
  return result;
}
// 12B414C: using guessed type void *CTreeListData::`vftable';
// 12BC8D0: using guessed type void *Process::`vftable';

//----- (0122D670) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_122D670(_DWORD *this)
{
  _DWORD *v1; // esi
  void (__stdcall ****v2)(signed int); // edi
  int v3; // ebx
  unsigned int v4; // ecx
  unsigned int v5; // eax
  void (__stdcall ****v6)(signed int); // edi
  int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // eax
  volatile signed __int32 *v10; // edx
  volatile signed __int32 *v11; // edx
  volatile signed __int32 *v12; // edx
  volatile signed __int32 *v13; // edx
  volatile signed __int32 *v14; // edx
  volatile signed __int32 *result; // eax
  unsigned int v16; // [esp+14h] [ebp-10h]
  unsigned int v17; // [esp+14h] [ebp-10h]

  v1 = this;
  *this = &Runtime::`vftable';
  v2 = this[8];
  v3 = 0;
  v4 = (this[9] - v2 + 3) >> 2;
  if ( v2 > v1[9] )
    v4 = 0;
  v16 = v4;
  if ( v4 )
  {
    v5 = v4;
    do
    {
      if ( *v2 )
      {
        (***v2)(1);
        v5 = v16;
      }
      ++v3;
      ++v2;
    }
    while ( v3 != v5 );
  }
  v6 = v1[11];
  v7 = 0;
  v8 = (v1[12] - v6 + 3) >> 2;
  if ( v6 > v1[12] )
    v8 = 0;
  v17 = v8;
  if ( v8 )
  {
    v9 = v8;
    do
    {
      if ( *v6 )
      {
        (***v6)(1);
        v9 = v17;
      }
      ++v7;
      ++v6;
    }
    while ( v7 != v9 );
  }
  if ( v1[11] )
  {
    j__free(v1[11]);
    v1[11] = 0;
    v1[12] = 0;
    v1[13] = 0;
  }
  if ( v1[8] )
  {
    j__free(v1[8]);
    v1[8] = 0;
    v1[9] = 0;
    v1[10] = 0;
  }
  v10 = (v1[6] - 16);
  if ( _InterlockedDecrement(v10 + 3) <= 0 )
    (*(**v10 + 4))(v10);
  v11 = (v1[4] - 16);
  if ( _InterlockedDecrement(v11 + 3) <= 0 )
    (*(**v11 + 4))(v11);
  v12 = (v1[3] - 16);
  if ( _InterlockedDecrement(v12 + 3) <= 0 )
    (*(**v12 + 4))(v12);
  v13 = (v1[2] - 16);
  if ( _InterlockedDecrement(v13 + 3) <= 0 )
    (*(**v13 + 4))(v13);
  v14 = (v1[1] - 16);
  result = v14 + 3;
  if ( _InterlockedDecrement(v14 + 3) <= 0 )
    result = (*(**v14 + 4))(v14);
  *v1 = &CTreeListData::`vftable';
  return result;
}
// 12B414C: using guessed type void *CTreeListData::`vftable';
// 12BC8F0: using guessed type void *Runtime::`vftable';

//----- (0122D840) --------------------------------------------------------
void **__thiscall sub_122D840(void **this, void **a2)
{
  void **v2; // esi
  volatile signed __int32 *v3; // edi
  volatile signed __int32 *v4; // edx
  volatile signed __int32 *v5; // eax
  volatile signed __int32 *v7; // [esp+10h] [ebp+8h]

  v2 = this;
  v3 = (*this - 16);
  v4 = (*a2 - 16);
  if ( v4 == v3 )
    return v2;
  if ( *(v3 + 3) < 0 || *v4 != *v3 )
  {
    sub_122C620(this, *a2, *(*a2 - 3));
    return v2;
  }
  v5 = sub_122B970(v4);
  v7 = v5;
  if ( _InterlockedDecrement(v3 + 3) <= 0 )
  {
    (*(**v3 + 4))(v3);
    v5 = v7;
  }
  *v2 = (v5 + 4);
  return v2;
}

//----- (0122D8B0) --------------------------------------------------------
void *__thiscall sub_122D8B0(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_122D3B0(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0122D8E0) --------------------------------------------------------
void *__thiscall sub_122D8E0(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_122D4B0(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0122D910) --------------------------------------------------------
void *__thiscall sub_122D910(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_122D590(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0122D940) --------------------------------------------------------
void *__thiscall sub_122D940(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_122D670(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0122D970) --------------------------------------------------------
int __thiscall sub_122D970(_DWORD *this, _DWORD *a2)
{
  int v2; // edx
  void **v3; // eax
  CTreeList *v4; // edi
  void *v5; // ebx
  CTreeList *v6; // esi
  unsigned int v7; // esi
  void **v8; // edi
  int v9; // eax
  CTreeList *v10; // ecx
  int v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // esi
  void **v14; // eax
  void *v15; // edi
  CTreeList *v16; // eax
  CTreeList *v17; // ebx
  unsigned int v18; // esi
  void **v19; // edi
  int v20; // eax
  CTreeList *v21; // ecx
  int v22; // ebx
  unsigned int v23; // eax
  unsigned int v24; // esi
  _DWORD *v26; // [esp+0h] [ebp-20h]
  void ***v27; // [esp+4h] [ebp-1Ch]
  CTreeList *v28; // [esp+8h] [ebp-18h]
  int v29; // [esp+Ch] [ebp-14h]
  CTreeList *v30; // [esp+10h] [ebp-10h]
  void **v31; // [esp+14h] [ebp-Ch]
  void **v32; // [esp+18h] [ebp-8h]
  CTreeList *a2a; // [esp+1Ch] [ebp-4h]

  v26 = this;
  v2 = this[6];
  v3 = *(v2 + 12);
  v31 = v3;
  if ( v3 != *(v2 + 16) )
  {
    v4 = a2;
    while ( 1 )
    {
      v27 = *v3;
      v5 = *v3;
      v6 = sub_121D7E0(v4, 0, *v3, 0, 0);
      a2a = v6;
      sub_121BF00(v4, v6, 1);
      if ( *(v5 + 10) == -3 )
        break;
      v14 = *(v5 + 8);
      v32 = v14;
      if ( v14 != *(v5 + 9) )
      {
        do
        {
          v15 = *v14;
          v16 = sub_121D7E0(a2, v6, *v14, 0, 0);
          v17 = v16;
          v29 = v16;
          sub_121BF00(a2, v16, 1);
          sub_122CC30(*(v15 + 7), *(v15 + 8), (*(v15 + 8) - *(v15 + 7)) >> 2, sub_122E7A0);
          v18 = *(v15 + 8);
          v19 = *(v15 + 7);
          v20 = sub_121CA50(v17);
          v21 = v20;
          v28 = v20;
          v22 = 0;
          v23 = (v18 - v19 + 3) >> 2;
          if ( v19 > v18 )
            v23 = 0;
          if ( v23 )
          {
            v24 = v23;
            do
            {
              sub_121D7E0(v21, v29, *v19, 0, 0);
              v21 = v28;
              ++v19;
              ++v22;
            }
            while ( v22 != v24 );
          }
          v14 = v32 + 1;
          v6 = a2a;
          v32 = v14;
        }
        while ( v14 != v27[9] );
        goto LABEL_17;
      }
LABEL_18:
      v3 = v31 + 1;
      v31 = v3;
      if ( v3 == *(v26[6] + 16) )
        return 0;
    }
    sub_122CC30(*(v5 + 11), *(v5 + 12), (*(v5 + 12) - *(v5 + 11)) >> 2, sub_122E7A0);
    v7 = *(v5 + 12);
    v8 = *(v5 + 11);
    v9 = sub_121CA50(a2a);
    v10 = v9;
    v30 = v9;
    v11 = 0;
    v12 = (v7 - v8 + 3) >> 2;
    if ( v8 > v7 )
      v12 = 0;
    if ( v12 )
    {
      v13 = v12;
      do
      {
        sub_121D7E0(v10, a2a, *v8, 0, 0);
        v10 = v30;
        ++v8;
        ++v11;
      }
      while ( v11 != v13 );
    }
LABEL_17:
    v4 = a2;
    goto LABEL_18;
  }
  return 0;
}

//----- (0122DB10) --------------------------------------------------------
int __cdecl sub_122DB10(wchar_t *Dst, rsize_t SizeInWords, int a3)
{
  return sub_122E970(Dst, SizeInWords, a3, &unk_12DD0F8, 3);
}

//----- (0122DB40) --------------------------------------------------------
CStringData *__thiscall sub_122DB40(int *this, wchar_t *Src)
{
  CStringData *result; // eax

  if ( Src )
    result = sub_122DB80(this, Src, wcslen(Src));
  else
    result = sub_122DB80(this, 0, 0);
  return result;
}

//----- (0122DB80) --------------------------------------------------------
CStringData *__thiscall sub_122DB80(int *this, wchar_t *Src, size_t MaxCount)
{
  int *v3; // edi
  unsigned int v4; // ebx
  int v5; // esi
  size_t v6; // edx
  int v7; // esi
  wchar_t *v8; // ecx
  CStringData *result; // eax
  unsigned int v10; // [esp+Ch] [ebp-4h]
  size_t MaxCounta; // [esp+1Ch] [ebp+Ch]

  v3 = this;
  v4 = (Src - *this) >> 1;
  v5 = *(*this - 12);
  v10 = *(*this - 12);
  if ( (MaxCount & 0x80000000) != 0 )
    goto LABEL_18;
  if ( Src )
  {
    MaxCounta = wcsnlen(Src, MaxCount);
    v6 = MaxCounta;
  }
  else
  {
    v6 = 0;
    MaxCounta = 0;
  }
  if ( (0x7FFFFFFF - v6) < v5 )
    AtlThrow(-2147024809);
  v7 = v6 + v5;
  if ( v7 < 0 )
    AtlThrow(-2147024809);
  if ( ((*(*v3 - 8) - v7) | (1 - *(*v3 - 4))) < 0 )
  {
    ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(v3, v7);
    v6 = MaxCounta;
  }
  v8 = (*v3 + 2 * v4);
  if ( v4 > v10 )
    v8 = Src;
  memcpy_s((*v3 + 2 * v10), 2 * v6, v8, 2 * v6);
  if ( v7 > *(*v3 - 8) )
LABEL_18:
    AtlThrow(-2147024809);
  *(*v3 - 12) = v7;
  result = *v3;
  *(*v3 + 2 * v7) = 0;
  return result;
}

//----- (0122DC50) --------------------------------------------------------
int __cdecl sub_122DC50(wchar_t *Dst, rsize_t SizeInWords, int a3)
{
  return sub_122E970(Dst, SizeInWords, a3, &unk_12DD110, 4);
}

//----- (0122DC80) --------------------------------------------------------
int __thiscall CResize::HookWindow(CResize *pThis, HWND hWnd)
{
  CResize *this; // edi
  HWND hWnd1; // esi
  const WCHAR *szThemeName; // eax
  int result; // eax
  RECT Rect; // [esp+8h] [ebp-14h]

  this = pThis;
  pThis->m_hWnd = hWnd;
  SetPropW(hWnd, L"ResizerClass", pThis);
  this->m_WndProc = GetWindowLongW(hWnd, GWL_WNDPROC);
  SetWindowLongW(hWnd, GWL_WNDPROC, CResizer::HookWndProc);
  hWnd1 = this->m_hWnd;
  if ( this->m_hTheme )
    CloseThemeData(this->m_hTheme);
  this->m_hTheme = 0;
  if ( *IsThemeActive && IsThemeActive() )
  {
    szThemeName = (this->vtptr->GetTitle)(this);
    this->m_hTheme = OpenThemeData(hWnd1, szThemeName);
  }
  GetWindowRect(this->m_hWnd, &Rect);
  this->m_nWidth = Rect.right - Rect.left;
  this->m_nHeight = Rect.bottom - Rect.top;
  this->m_nWidth2 = this->m_nWidth;
  result = this->m_nHeight;
  this->m_nHeight2 = result;
  return result;
}

//----- (0122DD40) --------------------------------------------------------
ULONG __userpurge sub_122DD40@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  PE_EVENT_TRACE_PROPERTIES *v5; // eax
  PE_EVENT_TRACE_PROPERTIES *EventTraceProp; // ebx
  ULONG v8; // esi
  GUID *v9; // [esp-4h] [ebp-24h]
  char *v10; // [esp+0h] [ebp-20h]
  ULONG64 TraceHandle; // [esp+4h] [ebp-1Ch]
  GUID Guid; // [esp+Ch] [ebp-14h]

  *(a1 + 12) = a5;
  v10 = a1;
  TraceHandle = 0i64;
  Guid.Data1 = 0;
  *&Guid.Data2 = 0i64;
  *&Guid.Data4[4] = 0;
  v9 = &Guid;
  if ( a5 )
    GUIDFromString(L"A669021C-C450-4609-A035-5AF59AF4DF18", *&v9);
  else
    GUIDFromString(L"E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4", *&v9);
  v5 = malloc(4216u);
  EventTraceProp = v5;
  if ( !v5 )
    return 14;
  memset(v5, 0, 4216u);
  EventTraceProp->Wnode.BufferSize = 4216;
  EventTraceProp->Wnode.Flags = 0x20000;
  EventTraceProp->LogFileMode = 0x1000100;
  EventTraceProp->LoggerNameOffset = 120;
  EventTraceProp->LogFileNameOffset = 2168;
  tcscpy_s(EventTraceProp->szSessionName, 1024u, L"ProcExpLogger");
  StartTraceW(&TraceHandle, EventTraceProp->szSessionName, EventTraceProp);
  ControlTraceW(0i64, EventTraceProp->szSessionName, EventTraceProp, 0);
  TraceHandle = EventTraceProp->Wnode.u.HistoricalContext;
  EnableTraceEx(&Guid, 0, TraceHandle, HIDWORD(TraceHandle), 1, 4, 0x48, 0, 0, 0, 0, 0, a2, a3);
  sub_122F840(v10, EventTraceProp->szSessionName);
  TraceHandle = 0i64;
  v8 = ControlTraceW(0i64, EventTraceProp->szSessionName, EventTraceProp, 1u);
  free(EventTraceProp);
  return v8;
}
// 122DD40: could not find valid save-restore pair for edi
// 122DD40: could not find valid save-restore pair for esi
// 12BC960: using guessed type wchar_t aE13c0d23Ccbc4e[37];

//----- (0122DE80) --------------------------------------------------------
int __userpurge sub_122DE80@<eax>(int a1@<edi>, int *a2)
{
  a2[2] = sub_122DD40(*a2, a1, a2, **a2, a2[1]);
  return 0;
}

//----- (0122DEA0) --------------------------------------------------------
signed int __thiscall sub_122DEA0(void *this, int a2, DWORD ThreadId)
{
  void *v3; // esi
  signed int result; // eax
  int v5; // [esp+4h] [ebp-Ch]
  DWORD v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  v6 = ThreadId;
  v5 = this;
  v3 = _beginthreadex(0, 0, sub_122DE80, &v5, 0, &ThreadId);
  if ( WaitForSingleObject(v3, 0x3A98u) == 258 )
  {
    TerminateThread(v3, 1u);
    CloseHandle(v3);
    result = 1460;
  }
  else
  {
    CloseHandle(v3);
    result = v7;
  }
  return result;
}

//----- (0122DF10) --------------------------------------------------------
signed int __thiscall sub_122DF10(int *this)
{
  int *v1; // edi
  void (__stdcall ***v2)(signed int); // ecx
  signed int v3; // ebx
  Process *process; // esi
  int v5; // eax
  CAtlStringMgr *v6; // ecx
  __m128i v7; // xmm0
  HMODULE v8; // eax
  HINSTANCE v9; // esi
  HWND v10; // eax
  HCURSOR v11; // eax
  LONG v12; // ecx
  int v13; // ST10_4
  int v14; // ecx
  HWND v15; // ST00_4
  int v16; // eax
  Process *v17; // esi
  char v18; // al
  void **v19; // eax
  void **v20; // eax
  void **v21; // eax
  Process *pTreeList; // [esp+10h] [ebp-68h]
  struct tagRECT Rect; // [esp+14h] [ebp-64h]
  struct tagRECT rc; // [esp+24h] [ebp-54h]
  struct tagRECT rcDst; // [esp+34h] [ebp-44h]
  const wchar_t *v27; // [esp+44h] [ebp-34h]
  int v28; // [esp+48h] [ebp-30h]
  char v29; // [esp+4Ch] [ebp-2Ch]
  const WCHAR *v30; // [esp+50h] [ebp-28h]
  int v31; // [esp+54h] [ebp-24h]
  char v32; // [esp+58h] [ebp-20h]
  const WCHAR *v33; // [esp+5Ch] [ebp-1Ch]
  int v34; // [esp+60h] [ebp-18h]
  char v35; // [esp+64h] [ebp-14h]
  int v36; // [esp+74h] [ebp-4h]

  v1 = this;
  v2 = this[6];
  v3 = 0;
  if ( v2 )
  {
    (**v2)(1);
    v1[6] = 0;
  }
  process = operator new(0x18u);
  pTreeList = process;
  v36 = 0;
  if ( process )
  {
    v5 = *v1;
    LOBYTE(v36) = 1;
    process->vtptr = &Process::`vftable';
    process->field_4 = v5;
    v6 = ATL::CAtlStringMgr::GetInstance();
    if ( v6 == 0 )
      AtlThrow(E_FAIL);
    process->field_8 = (v6->vtptr->GetNilString)() + 16;
    process->field_C = 0;
    process->field_10 = 0;
    process->field_14 = 0;
  }
  else
  {
    process = 0;
  }
  v7 = _mm_load_si128(&stru_12BCB40);
  v36 = -1;
  v1[6] = process;
  _mm_storeu_si128(&rc, v7);
  v8 = GetModuleHandle(0);
  v9 = v8;
  v10 = CreateTreeListView(v1[2], v8, 0, 1350631424, &rc);
  v1[1] = v10;
  pTreeList = GetTreeListCtrl(v10);
  CTreeList::RestoreScrollbars(pTreeList, 0);
  v11 = LoadCursorW(v9, 0x6A);
  CTreeList::SetSplitterCursor(pTreeList, v11);
  sub_121BDA0(pTreeList, 1);
  GetClientRect(v1[2], &Rect);
  CopyRect(&rcDst, &Rect);
  v12 = rcDst.right - 10;
  rcDst.bottom -= 10;
  rcDst.right = v12;
  v13 = rcDst.bottom - (rcDst.top + 10);
  v14 = v12 - (rcDst.left + 10);
  rcDst.left += 10;
  v15 = v1[1];
  rcDst.top += 10;
  MoveWindow(v15, rcDst.left, rcDst.top, v14, v13, 1);
  v16 = 800;
  v17 = pTreeList;
  if ( rcDst.right - rcDst.left > 800 )
    v16 = rcDst.right - rcDst.left;
  v27 = L"Structure";
  v34 = v16;
  v28 = 200;
  v29 = 0;
  v30 = L"Flags";
  v31 = 80;
  v32 = 0;
  v33 = L"Path";
  v35 = 0;
  sub_121D310(pTreeList, &v27, 3);
  if ( !sub_122EC70(*v1, &pTreeList) )
  {
    v18 = pTreeList;
    if ( pTreeList & 1 )
    {
      v19 = sub_122EBA0(v1[6], *v1, 0xFFFF);
      sub_122C620(v19 + 6, L"v1.0.3705", 9);
      v18 = pTreeList;
    }
    if ( v18 & 2 )
    {
      v20 = sub_122EBA0(v1[6], *v1, 0xFFFE);
      sub_122C620(v20 + 6, L"v1.1.4322", 9);
      v18 = pTreeList;
    }
    if ( v18 & 4 )
    {
      v21 = sub_122EBA0(v1[6], *v1, 0xFFFD);
      sub_122C620(v21 + 6, L"v2.0.50727", 10);
      v3 = sub_122DEA0(v1, *v1, 0);
      if ( v3 )
        return v3;
      v18 = pTreeList;
    }
    if ( !(v18 & 8) || (v3 = sub_122DEA0(v1, *v1, 1u)) == 0 )
      sub_122D970(v1, v17);
  }
  return v3;
}
// 12BC8D0: using guessed type void *Process::`vftable';
// 12BCA34: using guessed type wchar_t aStructure[10];
// 12BCA48: using guessed type wchar_t aV103705[10];
// 12BCA5C: using guessed type wchar_t aV114322[10];
// 12BCA70: using guessed type wchar_t aV2050727[11];
// 12BCB40: using guessed type __m128d stru_12BCB40;

//----- (0122E1A0) --------------------------------------------------------
int __stdcall ProcCLRWndProc(HWND hWnd, int a2, WPARAM a3, int a4)
{
  LONG v4; // esi
  int v5; // eax
  HGLOBAL v6; // ebx
  wchar_t *v7; // edi
  HWND v8; // ST38_4
  LRESULT v9; // eax
  HWND v10; // ST38_4
  unsigned int v11; // kr00_4
  unsigned int v12; // kr04_4
  wchar_t *v13; // ecx
  wchar_t v14; // ax
  int v15; // esi
  rsize_t v16; // esi
  HWND v17; // eax
  HWND v19; // ST2C_4
  CTreeList *v20; // eax
  int v21; // eax
  int v22; // eax
  HWND v23; // ST3C_4
  HWND v24; // eax
  HWND v25; // esi
  HWND v26; // eax
  LONG v27; // edi
  CResize *v28; // eax
  _DWORD *v29; // eax
  int *v30; // ebx
  HCURSOR v31; // eax
  HCURSOR v32; // esi
  HWND v33; // eax
  WPARAM v34; // [esp-8h] [ebp-827Ch]
  LPARAM lParam; // [esp+10h] [ebp-8264h]
  WPARAM wParam; // [esp+14h] [ebp-8260h]
  int v37; // [esp+18h] [ebp-825Ch]
  wchar_t *v38; // [esp+24h] [ebp-8250h]
  int v39; // [esp+28h] [ebp-824Ch]
  __int16 *v40; // [esp+44h] [ebp-8230h]
  int v41; // [esp+48h] [ebp-822Ch]
  struct tagPOINT Point; // [esp+4Ch] [ebp-8228h]
  WPARAM v43; // [esp+54h] [ebp-8220h]
  HWND hDlg; // [esp+58h] [ebp-821Ch]
  wchar_t v45; // [esp+5Ch] [ebp-8218h]
  wchar_t v46; // [esp+405Ch] [ebp-4218h]
  __int16 v47; // [esp+405Eh] [ebp-4216h]
  wchar_t Src; // [esp+805Ch] [ebp-218h]
  int v49; // [esp+8270h] [ebp-4h]

  hDlg = hWnd;
  v4 = GetWindowLongW(hWnd, -21);
  Point.y = v4;
  memset(&wParam, 0, 0x30u);
  if ( a2 > 0x4E )
  {
    if ( a2 == 272 )
    {
      v25 = hDlg;
      v26 = GetParent(hDlg);
      v27 = GetWindowLongW(v26, -21);
      v28 = operator new(0x40u);
      Point.y = v28;
      v49 = 0;
      if ( v28 )
        CResize::CResize(v28, v25);
      v49 = -1;
      ResizeTab(v25);
      if ( IsBuiltinAndAnministrative() && GetVersion() >= 6u )
      {
        v29 = operator new(0x28u);
        if ( v29 )
          v30 = sub_122D260(v29);
        else
          v30 = 0;
        v30[2] = v25;
        *v30 = *(*(v27 + 4) + 68);
        v31 = LoadCursorW(0, 0x7F02);
        v32 = SetCursor(v31);
        sub_122DF10(v30);
        SendMessageW(v30[1], 0x30u, ghDefaultFont, 0);
        SetCursor(v32);
        v25 = hDlg;
      }
      else
      {
        v30 = 0;
      }
      v33 = GetDlgItem(v25, 1610);
      ShowWindow(v33, v30 == 0);
      SetWindowLongW(v25, -21, v30);
      return 1;
    }
    if ( a2 == 273 )
    {
      switch ( a3 )
      {
        case 0x9C41u:
          v34 = 40014;
          goto LABEL_35;
        case 0x9C42u:
          SetEvent(ghEventRefreshSearchResult);
          return 0;
        case 0x9C9Cu:
        case 0x9C9Du:
          v34 = a3;
LABEL_35:
          v24 = GetParent(hDlg);
          PostMessageW(v24, 0x111u, v34, 0);
          return 0;
        default:
          return 0;
      }
    }
    return 0;
  }
  if ( a2 != 78 )
  {
    if ( a2 == 2 )
    {
      if ( v4 )
      {
        if ( *(v4 + 28) )
        {
          j__free(*(v4 + 28));
          *(v4 + 28) = 0;
          *(v4 + 32) = 0;
          *(v4 + 36) = 0;
        }
        j__free(v4);
      }
      return 1;
    }
    if ( a2 == 5 )
    {
      if ( v4 )
        sub_1230130(v4);
      return 1;
    }
    return 0;
  }
  v5 = *(a4 + 8);
  if ( v5 != 2004 )
  {
    if ( v5 == 2005 )
    {
      if ( !*(a4 + 20) )
      {
        GetCursorPos(&Point);
        Point.y += 20;
        v19 = *a4;
        Point.x += 10;
        SetWindowPos(v19, 0, Point.x, Point.y, 0, 0, 0x15u);
        return 0;
      }
    }
    else if ( v5 == -155 && *(a4 + 12) == 67 )
    {
      if ( GetKeyState(162) )
      {
        v6 = 0;
        v7 = 0;
        v8 = *(v4 + 4);
        v41 = 0;
        v9 = SendMessageW(v8, 0x100Cu, wParam, 2);
        v43 = v9;
        if ( v9 != -1 )
        {
          do
          {
            v37 = 0;
            v38 = &Src;
            v10 = *(v4 + 4);
            v39 = 260;
            SendMessageW(v10, 0x1073u, v9, &lParam);
            v37 = 1;
            v38 = &v45;
            v39 = 0x2000;
            SendMessageW(*(v4 + 4), 0x1073u, v43, &lParam);
            v37 = 2;
            v38 = &v46;
            v39 = 0x2000;
            SendMessageW(*(v4 + 4), LVM_GETITEMTEXTW, v43, &lParam);
            v11 = wcslen(&Src);
            v12 = wcslen(&v45);
            v13 = &v46;
            v40 = &v47;
            do
            {
              v14 = *v13;
              ++v13;
            }
            while ( v14 );
            v15 = v11 + ((v13 - v40) >> 1) + v12 + v41 + 5;
            v41 += v11 + ((v13 - v40) >> 1) + v12 + 5;
            if ( v7 )
            {
              v6 = GlobalReAlloc(v6, 2 * v15 + 2, 0);
              v7 = GlobalLock(v6);
            }
            else
            {
              v6 = GlobalAlloc(0x2002u, 2 * v15 + 2);
              v7 = GlobalLock(v6);
              *v7 = 0;
            }
            v16 = v15 + 1;
            wcscat_s(v7, v16, &Src);
            wcscat_s(v7, v16, L"\t");
            wcscat_s(v7, v16, &v45);
            wcscat_s(v7, v16, L"\t");
            wcscat_s(v7, v16, &v46);
            wcscat_s(v7, v16, L"\r\n");
            GlobalUnlock(v6);
            v4 = Point.y;
            v9 = SendMessageW(*(Point.y + 4), 0x100Cu, v43, 2);
            v43 = v9;
          }
          while ( v9 != -1 );
          if ( v6 )
          {
            v17 = GetParent(hDlg);
            if ( OpenClipboard(v17) )
            {
              EmptyClipboard();
              SetClipboardData(0xDu, v6);
              CloseClipboard();
              return 0;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( *(a4 + 20) || !v4 )
    return 0;
  v20 = GetTreeListCtrl(*(v4 + 4));
  CTreeList::GetTooltipTreeList(v20);
  v21 = sub_121C420(*(a4 + 16));
  v22 = (*(*v21 + 24))(v21);
  v23 = hDlg;
  **(a4 + 24) = v22;
  SetWindowLongW(v23, 0, 1);
  return 1;
}

//----- (0122E780) --------------------------------------------------------
BOOL __cdecl sub_122E780(int a1, int a2)
{
  return *(a1 + 16) < *(a2 + 16);
}

//----- (0122E7A0) --------------------------------------------------------
bool __cdecl sub_122E7A0(int a1, int a2)
{
  return _wcsnicmp(*(a1 + 4), *(a2 + 4), 0x400u) < 0;
}

//----- (0122E7D0) --------------------------------------------------------
LRESULT __thiscall CResizer::HandleMessage(WNDPROC *this, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  return CallWindowProcW(this[2], hWnd, Msg, wParam, lParam);
}

//----- (0122E7F0) --------------------------------------------------------
int __stdcall EventCallback_0(int a1)
{
  return sub_122F0A0(*(a1 + 96), a1);
}

//----- (0122E810) --------------------------------------------------------
int __thiscall sub_122E810(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  int *v5; // ebx
  int *v6; // edi
  int v8; // [esp+Ch] [ebp-4h]

  v3 = this[9];
  v4 = this[8];
  v8 = v3;
  if ( v4 == v3 )
    return 0;
  while ( 1 )
  {
    v5 = *(*v4 + 32);
    v6 = *(*v4 + 28);
    if ( v6 != v5 )
    {
      do
      {
        if ( sub_122F710(*v6, a2, a3) )
          break;
        ++v6;
      }
      while ( v6 != v5 );
      v3 = v8;
      if ( v6 != v5 )
        break;
    }
    v4 += 4;
    if ( v4 == v3 )
      return 0;
  }
  return *v6;
}

//----- (0122E870) --------------------------------------------------------
ResizeInfo *__thiscall CResize::InitResizeBuffer(CResize *pResize, HWND hWnd, int nCount)
{
  CResize *pResize1; // ebx
  ResizeInfo *result; // eax
  int count; // edx
  int idx; // ecx
  ResizeInfo *pBuff; // edi
  HWND v8; // eax
  CResizeBuffer *pBuf; // edx
  int Count; // eax
  CResizeBuffer *pInfo; // ebx
  CResize *pResize2; // [esp+8h] [ebp-4h]

  pResize1 = pResize;
  pResize2 = pResize;
  if ( !hWnd )
    return 0;
  count = pResize->m_BufCount;
  idx = 0;
  if ( count <= 0 )
  {
__returnNULL:
    if ( nCount )
    {
      pResize1->m_BufCount = count + 1;
      pBuf = realloc(pResize1->m_Buffer, 0x38 * (count + 1));
      if ( !pBuf )
      {
        nCount = 8;
        _CxxThrowException(&nCount, &_TI1J);
      }
      Count = pResize1->m_BufCount;
      pResize1->m_Buffer = pBuf;
      pInfo = &pBuf[Count];
      pInfo[-1].hWnd = hWnd;
      pInfo[-1].Width = stru_12BCB50;
      pInfo[-1].Height = stru_12BCB50;
      GetWindowRect(hWnd, &pInfo[-1u].Rect);
      ScreenToClient(pResize2->m_hWnd, &pInfo[-1].Rect);
      ScreenToClient(pResize2->m_hWnd, &pInfo[-1].Rect.right);
      result = &pInfo[-1];
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    pBuff = pResize1->m_Buffer;
    v8 = &pBuff->hWnd;
    while ( *v8 != hWnd )
    {
      ++idx;
      // pBuff++ //14表示14个DWORD,即56个字节=sizeof(CResizeBuffer)
      v8 += 14;
      if ( idx >= count )
        goto __returnNULL;
    }
    result = &pBuff[idx];
  }
  return result;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12D4A54: using guessed type int _TI1J;

//----- (0122E970) --------------------------------------------------------
int __cdecl sub_122E970(wchar_t *Dst, rsize_t SizeInWords, int a3, int a4, int a5)
{
  int result; // eax
  char v6; // cl
  int v7; // esi
  int v8; // edx

  result = 0;
  *Dst = 0;
  if ( a3 )
  {
    v6 = 1;
    result = a5;
    v7 = 0;
    if ( a5 > 0 )
    {
      result = a4;
      v8 = a5;
      do
      {
        if ( a3 & *(result + 8 * v7) )
        {
          if ( !v6 )
          {
            wcscat_s(Dst, SizeInWords, L", ");
            result = a4;
          }
          wcscat_s(Dst, SizeInWords, *(result + 8 * v7 + 4));
          result = a4;
          v8 = a5;
          v6 = 0;
        }
        ++v7;
      }
      while ( v7 < v8 );
    }
  }
  return result;
}

//----- (0122E9F0) --------------------------------------------------------
__int16 __thiscall sub_122E9F0(_WORD *this)
{
  _WORD *v1; // eax
  bool v2; // zf

  v1 = this + 6;
  if ( this[6] )
  {
    do
    {
      v2 = v1[1] == 0;
      ++v1;
    }
    while ( !v2 );
  }
  return v1[3];
}

//----- (0122EA10) --------------------------------------------------------
__int16 __thiscall sub_122EA10(_WORD *this)
{
  _WORD *v1; // eax
  bool v2; // zf

  v1 = this + 14;
  if ( this[14] )
  {
    do
    {
      v2 = v1[1] == 0;
      ++v1;
    }
    while ( !v2 );
  }
  return v1[1];
}

//----- (0122EA30) --------------------------------------------------------
__int16 __thiscall sub_122EA30(_WORD *this)
{
  _WORD *i; // eax
  _WORD *v2; // eax
  bool v3; // zf

  for ( i = this + 12; *i; ++i )
    ;
  v2 = i + 1;
  if ( *v2 )
  {
    do
    {
      v3 = v2[1] == 0;
      ++v2;
    }
    while ( !v3 );
  }
  return v2[1];
}

//----- (0122EA70) --------------------------------------------------------
int __thiscall CTreeList::GetTooltipLeftHeader(CTreeList *this)
{
  return this->m_hWndTooltipOfLeftHeader;
}

//----- (0122EA80) --------------------------------------------------------
WCHAR **sub_122EA80()
{
  return gpszTargetName;
}

//----- (0122EA90) --------------------------------------------------------
int __thiscall sub_122EA90(_WORD *this)
{
  _WORD *v1; // eax
  bool v2; // zf

  v1 = this + 6;
  if ( this[6] )
  {
    do
    {
      v2 = v1[1] == 0;
      ++v1;
    }
    while ( !v2 );
  }
  return *(v1 + 1);
}

//----- (0122EAB0) --------------------------------------------------------
_WORD *__thiscall sub_122EAB0(_WORD *this)
{
  _WORD *i; // eax

  for ( i = this + 12; *i; ++i )
    ;
  return i + 1;
}

//----- (0122EAD0) --------------------------------------------------------
_DWORD *__thiscall sub_122EAD0(_DWORD *this, int a2, _DWORD *a3)
{
  int *v3; // esi
  int *v4; // edi
  _DWORD *v5; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // [esp+14h] [ebp-10h]

  v3 = this[9];
  v4 = this[8];
  v5 = a3;
  v9 = this + 8;
  if ( v4 != v3 )
  {
    do
    {
      if ( sub_122F710(*v4, a2, v5) )
        break;
      ++v4;
    }
    while ( v4 != v3 );
    if ( v4 != v3 )
      return *v4;
  }
  v7 = operator new(0x28u);
  if ( v7 )
    v8 = sub_122D000(v7, a2, v5);
  else
    v8 = 0;
  a3 = v8;
  sub_12308F0(v9, &a3);
  return a3;
}

//----- (0122EBA0) --------------------------------------------------------
_DWORD *__thiscall sub_122EBA0(_DWORD *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // ebx
  int *v4; // esi
  int *v5; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v9; // [esp+10h] [ebp-18h]
  __int16 v10; // [esp+14h] [ebp-14h]
  void *v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+24h] [ebp-4h]

  v3 = this + 3;
  v4 = this[4];
  v5 = this[3];
  v9 = a2;
  v10 = a3;
  if ( v5 != v4 )
  {
    do
    {
      if ( sub_122F730(*v5, &v9) )
        break;
      ++v5;
    }
    while ( v5 != v4 );
    if ( v5 != v4 )
      return *v5;
  }
  v7 = operator new(0x38u);
  v11 = v7;
  v12 = 0;
  if ( v7 )
    v8 = sub_122D2B0(v7, a2, a3);
  else
    v8 = 0;
  a3 = v8;
  v12 = -1;
  sub_12308F0(v3, &a3);
  return a3;
}

//----- (0122EC70) --------------------------------------------------------
int __cdecl sub_122EC70(DWORD th32ProcessID, int a2)
{
  int v2; // esi
  HANDLE v3; // eax
  void *v4; // edi
  int result; // eax
  char v6; // bl
  wchar_t *v7; // eax
  wchar_t *v8; // eax
  int v9; // edx
  __int16 *v10; // ecx
  int v11; // ebx
  __int16 v12; // ax
  int v13; // eax
  char v14; // [esp+13h] [ebp-42Dh]
  MODULEENTRY32W me; // [esp+14h] [ebp-42Ch]

  v2 = 0;
  v14 = 0;
  *a2 = 0;
  do
  {
    v3 = CreateToolhelp32Snapshot(0x18u, th32ProcessID);
    v4 = v3;
  }
  while ( v3 == 24 );
  if ( v3 == -1 )
    return 0;
  me.dwSize = 1064;
  if ( !Module32FirstW(v3, &me) )
  {
    CloseHandle(v4);
    result = GetLastError();
    if ( result > 0 )
      result = result | 0x80070000;
    return result;
  }
  do
  {
    if ( wcsstr(me.szModule, L"mscorlib") )
    {
      v6 = 1;
      v14 = 1;
      continue;
    }
    if ( !_wcsicmp(me.szModule, L"clr.dll")
      || !_wcsicmp(me.szModule, L"mscorwks.dll")
      || !_wcsicmp(me.szModule, L"mscorsvr.dll") )
    {
      v7 = wcsrchr(me.szExePath, '\\');
      if ( v7 )
      {
        *v7 = 0;
        v8 = wcsrchr(me.szExePath, '\\');
        if ( v8 )
        {
          v9 = (v8 + 1);
          v10 = (v8 + 1);
          v11 = (v8 + 2);
          do
          {
            v12 = *v10;
            ++v10;
          }
          while ( v12 );
          if ( ((v10 - v11) >> 1) >= 4 )
          {
            v13 = *(v9 + 2);
            if ( v13 != '1' )
              goto LABEL_22;
            if ( *(v9 + 6) == '0' )
            {
              v2 |= 1u;
            }
            else
            {
              if ( *(v9 + 6) != '1' )
              {
LABEL_22:
                if ( v13 == '2' )
                {
                  v2 |= 4u;
                }
                else if ( v13 == '4' || v13 == '5' || v13 == '6' || v13 == '7' )
                {
                  v2 |= 8u;
                }
                goto LABEL_29;
              }
              v2 |= 2u;
            }
          }
        }
      }
    }
LABEL_29:
    v6 = v14;
  }
  while ( Module32NextW(v4, &me) );
  CloseHandle(v4);
  if ( v6 && v2 )
    *a2 = v2;
  return 0;
}

//----- (0122EE50) --------------------------------------------------------
wchar_t *__thiscall sub_122EE50(_DWORD *this, int a2, int a3, wchar_t *Dst, int a5)
{
  wchar_t *result; // eax

  if ( a3 )
  {
    if ( a3 == 1 )
    {
      result = this[5];
    }
    else
    {
      result = Dst;
      *Dst = 0;
    }
  }
  else
  {
    swprintf_s(Dst, *a5, L"Appdomain: %s", this[6]);
    result = Dst;
  }
  return result;
}

//----- (0122EEA0) --------------------------------------------------------
wchar_t *__thiscall sub_122EEA0(int this, int a2, int a3, wchar_t *Dst, int a5)
{
  wchar_t *v5; // edi
  int v6; // eax
  volatile signed __int32 *v7; // eax
  wchar_t *v8; // esi
  void **v9; // eax
  int v10; // edx
  volatile signed __int32 *v11; // esi

  v5 = Dst;
  *Dst = 0;
  switch ( a3 )
  {
    case 0:
      return *(this + 4);
    case 1:
      wcscat_s(v5, *a5, *(this + 20));
      break;
    case 2:
      v6 = *(this + 24);
      if ( *(v6 - 12) )
      {
        v7 = sub_122B970((v6 - 16));
        v8 = (v7 + 4);
        Dst = (v7 + 4);
        if ( *a5 < *(v7 + 1) + 1 )
        {
          v9 = sub_122F790(&Dst, &a3, 0, *a5 - 4);
          sub_122D840(&Dst, v9);
          v10 = a3 - 16;
          if ( _InterlockedDecrement((a3 - 16 + 12)) <= 0 )
            (*(**v10 + 4))(v10);
          sub_122DB40(&Dst, L"...");
          v8 = Dst;
        }
        wcscat_s(v5, *a5, v8);
        v11 = (v8 - 8);
        if ( _InterlockedDecrement(v11 + 3) <= 0 )
        {
          (*(**v11 + 4))(v11);
          return v5;
        }
      }
      break;
  }
  return v5;
}

//----- (0122EFF0) --------------------------------------------------------
wchar_t *__thiscall sub_122EFF0(int this, int a2, int a3, wchar_t *Dst, int a5)
{
  int v6; // eax
  wchar_t *v7; // esi
  int v8; // [esp-4h] [ebp-8h]

  if ( a3 )
  {
    if ( a3 != 1 || *(this + 20) == -3 )
    {
      *Dst = 0;
      return Dst;
    }
    v6 = *(this + 8);
    v8 = *(this + 12);
    v7 = Dst;
    if ( *(v6 - 12) )
    {
      swprintf_s(Dst, *a5, L"%s, %s", v6, v8);
      return Dst;
    }
    swprintf_s(Dst, *a5, L"%s", v8);
  }
  else
  {
    v7 = Dst;
    swprintf_s(Dst, *a5, L"CLR %s", *(this + 24));
  }
  return v7;
}

//----- (0122F070) --------------------------------------------------------
wchar_t *__stdcall sub_122F070(int a1, int a2, wchar_t *Dst, int a4)
{
  swprintf_s(Dst, *a4, gpszTargetName);
  return Dst;
}

//----- (0122F090) --------------------------------------------------------
const wchar_t *CResizer::GetName()
{
  return L"status";
}
// 12BC890: using guessed type wchar_t aStatus[7];

//----- (0122F0A0) --------------------------------------------------------
int __thiscall sub_122F0A0(_DWORD *this, int a2)
{
  _DWORD *v2; // ebx
  int v3; // edx
  void **v4; // edi
  int v5; // esi
  int v6; // eax
  unsigned __int16 *v7; // esi
  void **v8; // eax
  int v9; // edi
  _WORD *v10; // ebx
  wchar_t *v11; // eax
  int v12; // eax
  void **v13; // eax
  _DWORD *v14; // ecx
  int v15; // eax
  void **v16; // eax
  void *v17; // ecx
  void **v18; // edi
  bool v19; // zf
  void *v20; // eax
  int v21; // ebx
  int v22; // edi
  int v23; // esi
  void **v24; // esi
  void **v25; // ebx
  int v26; // ebx
  int v27; // edi
  _DWORD *v28; // esi
  unsigned __int16 v29; // ax
  _DWORD *v30; // eax
  void **v31; // esi
  void *v32; // ST18_4
  int v33; // ebx
  int v34; // edi
  _DWORD *v35; // esi
  unsigned __int16 v36; // ax
  _DWORD *v37; // eax
  _DWORD *v38; // edi
  void *v39; // esi
  void **v40; // eax
  void *v41; // ST14_4
  char v42; // bl
  void **v43; // esi
  int v44; // esi
  unsigned __int16 v45; // ax
  _DWORD *v46; // eax
  void **v47; // edi
  _WORD *v48; // eax
  void *v49; // ST18_4
  _DWORD *v50; // eax
  _DWORD *v51; // eax
  void *v52; // esi
  void *v54; // [esp+10h] [ebp-1834h]
  void *v55; // [esp+14h] [ebp-1830h]
  void *v56; // [esp+18h] [ebp-182Ch]
  void *v57; // [esp+1Ch] [ebp-1828h]
  void *v58; // [esp+20h] [ebp-1824h]
  void **v59; // [esp+24h] [ebp-1820h]
  int v60; // [esp+28h] [ebp-181Ch]
  void **v61; // [esp+2Ch] [ebp-1818h]
  wchar_t *v62; // [esp+30h] [ebp-1814h]
  wchar_t v63; // [esp+34h] [ebp-1810h]
  wchar_t Dst; // [esp+834h] [ebp-1010h]
  wchar_t Src; // [esp+1034h] [ebp-810h]
  int v66; // [esp+1840h] [ebp-4h]

  v2 = this;
  v58 = this;
  v61 = 0;
  v3 = this[6];
  v62 = v3;
  v4 = *(a2 + 12);
  v5 = *(a2 + 40);
  v6 = *(a2 + 45);
  v59 = v4;
  if ( v4 == *(v3 + 4) )
  {
    if ( this[3] )
    {
      switch ( v5 )
      {
        case 145:
          v50 = **(a2 + 92);
          v60 = **(a2 + 92);
          v51 = sub_122EBA0(v3, v4, v50);
          sub_12301B0(v51);
          v52 = v2[8];
          sub_122CF50(&v58, v2[7], v2[8], &v60);
          if ( v58 != v52 )
            sub_1230840(v2 + 7, &v60, v58);
          v19 = v2[7] == v2[8];
          goto LABEL_36;
        case 153:
          v44 = *(a2 + 92);
          v45 = sub_122EA30(*(a2 + 92));
          v46 = sub_122EBA0(v62, v4, v45);
          v47 = sub_122E810(v46, *(v44 + 8), *(v44 + 12));
          if ( !v47 )
            return 0;
          if ( *(v44 + 16) & 2 )
            v48 = sub_122EAB0(v44);
          else
            v48 = (v44 + 24);
          v49 = *sub_122B2D0(&v57, v48);
          v66 = 8;
          sub_12300E0(v47, v49);
          v14 = &v57;
          goto LABEL_32;
        case 155:
          v33 = *(a2 + 92);
          v34 = *(v33 + 8);
          v35 = *(v33 + 12);
          v58 = *v33;
          v60 = *(v33 + 4);
          v36 = sub_122EA10(v33);
          v37 = sub_122EBA0(v62, v59, v36);
          v38 = sub_122EAD0(v37, v34, v35);
          sub_122DC50(&Src, 0x400u, *(v33 + 24));
          v39 = operator new(0x20u);
          v56 = v39;
          v66 = 5;
          if ( v39 )
          {
            v40 = sub_122B2D0(&v55, (v33 + 28));
            LOBYTE(v66) = 6;
            v41 = *v40;
            v42 = 1;
            v61 = 1;
            v43 = sub_122D080(v39, v58, v60, v41, &Src);
          }
          else
          {
            v42 = v61;
            v43 = 0;
          }
          v66 = -1;
          if ( v42 & 1 )
            sub_122B3E0(&v55);
          v60 = v43;
          sub_12308F0(v38 + 7, &v60);
          break;
        case 157:
          v26 = *(a2 + 92);
          v27 = *v26;
          v28 = *(v26 + 4);
          v29 = sub_122E9F0(v26);
          v30 = sub_122EBA0(v62, v59, v29);
          v31 = sub_122EAD0(v30, v27, v28);
          v31[4] = sub_122EA90(v26);
          v32 = *sub_122B2D0(&v54, (v26 + 12));
          v66 = 4;
          sub_12300E0(v31, v32);
          v66 = -1;
          sub_122B3E0(&v54);
          sub_122DB10(&Src, 0x400u, *(v26 + 8));
          sub_122FEB0(v31, &Src);
          break;
        case 187:
          v61 = *(a2 + 92);
          v20 = *v61;
          v21 = *(v61 + 7);
          v22 = *(v61 + 8);
          v23 = *(v61 + 9);
          v60 = *(v61 + 6);
          v56 = v20;
          v59 = sub_122EBA0(v62, v59, v20);
          sub_122FF00(v59, v61 + 25);
          sub_1230880(v58 + 7, &v56);
          swprintf_s(&Dst, 0x400u, L"v%u.%u.%u.%u", v60, v21, v22, v23);
          v24 = v59;
          sub_12300E0(v59, &Dst);
          v25 = v61;
          sub_122E970(&v63, 0x400u, v61[5], &unk_12DD178, 15);
          sub_122FF50(v24, &v63);
          sub_12301D0(&Src, 0x400u, *(v25 + 24));
          sub_122FFA0(v24, &Src);
          break;
        default:
          return 0;
      }
    }
    else if ( !v5 )
    {
      if ( v6 == 35 )
      {
        v7 = *(a2 + 92);
        v8 = sub_122EBA0(v3, v4, 0xFFFD);
        v9 = *v7;
        v10 = v7 + 12;
        v59 = v8;
        sub_122B2D0(&v62, v7 + 12);
        v66 = 0;
        v11 = wcsrchr(v62, 0x5Cu);
        if ( v11 )
        {
          v12 = v11 - v62;
          if ( v12 >= 0 )
          {
            v13 = sub_122F760(&v62, &v61, v12 + 1);
            LOBYTE(v66) = 1;
            sub_122D840(&v62, v13);
            LOBYTE(v66) = 0;
            sub_122B3E0(&v61);
          }
        }
        v14 = &v62;
        if ( *(v62 - 3) )
        {
          v15 = sub_122FE80(&v62, 0x2Eu);
          if ( v15 >= 0 )
          {
            v16 = sub_122F790(&v62, &v61, 0, v15);
            LOBYTE(v66) = 2;
            sub_122D840(&v62, v16);
            LOBYTE(v66) = 0;
            sub_122B3E0(&v61);
          }
          sub_122E970(&Dst, 0x400u, v7[8], &unk_12DD130, 4);
          v17 = operator new(0x20u);
          v57 = v17;
          LOBYTE(v66) = 3;
          if ( v17 )
            v18 = sub_122D080(v17, v9, v9 >> 31, gpszTargetName, &Dst);
          else
            v18 = 0;
          LOBYTE(v66) = 0;
          sub_122FF00(v18, v62);
          if ( *(v7 + 4) & 2 )
            v10 = sub_122EAB0(v7);
          sub_12300E0(v18, v10);
          v61 = v18;
          sub_12308F0(v59 + 11, &v61);
          sub_122B3E0(&v62);
        }
        else
        {
LABEL_32:
          sub_122B3E0(v14);
        }
      }
      else
      {
        v19 = v6 == 14;
LABEL_36:
        if ( v19 )
          CloseTrace(*(v2 + 2));
      }
    }
  }
  return 0;
}

//----- (0122F690) --------------------------------------------------------
int __cdecl sub_122F690(WCHAR *a1)
{
  signed int v1; // edi
  int ret; // esi
  signed int i; // edx
  unsigned int chr; // eax
  int v5; // eax

  v1 = 1;
  ret = 0;
  for ( i = wcslen(a1) - 1; i >= 0; --i )
  {
    chr = a1[i];
    if ( (chr == 'x' || chr == 'X') && a1[i - 1] == '0' )
      return ret;
    if ( chr < '0' || chr > '9' )
    {
      if ( chr < 'a' || chr > 'f' )
      {
        if ( chr < 'A' || chr > 'F' )
          continue;
        v5 = chr - '7';
      }
      else
      {
        v5 = chr - 'W';
      }
    }
    else
    {
      v5 = chr - '0';
    }
    ret |= v5 * v1;
    v1 *= 16;
  }
  return ret;
}

//----- (0122F710) --------------------------------------------------------
bool __cdecl sub_122F710(int a1, int a2, int a3)
{
  return *(a1 + 8) == a2 && *(a1 + 12) == a3;
}

//----- (0122F730) --------------------------------------------------------
bool __cdecl sub_122F730(int a1, int a2)
{
  return *(a1 + 28) == *a2 && *(a1 + 20) == *(a2 + 4);
}

//----- (0122F760) --------------------------------------------------------
void **__thiscall sub_122F760(_DWORD *this, void **a2, int a3)
{
  sub_122F790(this, a2, a3, *(*this - 12) - a3);
  return a2;
}

//----- (0122F790) --------------------------------------------------------
void **__thiscall sub_122F790(_DWORD *this, void **a2, int a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // ebx
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  volatile signed __int32 *v9; // ecx
  void **result; // eax
  int v11; // ecx
  int v12; // eax
  CAtlStringMgr *v13; // eax

  v4 = a4;
  v5 = this;
  v6 = a3;
  if ( a3 < 0 )
    v6 = 0;
  if ( a4 < 0 )
    v4 = 0;
  if ( 0x7FFFFFFF - v6 < v4 )
    AtlThrow(-2147024362);
  v7 = *this;
  v8 = *(*this - 12);
  if ( v6 + v4 > v8 )
    v4 = v8 - v6;
  if ( v6 > v8 )
    v4 = 0;
  if ( v6 || v4 != v8 )
  {
    v11 = *(v7 - 16);
    if ( !v11 || (v12 = (*(*v11 + 16))()) == 0 )
    {
      v13 = ATL::CAtlStringMgr::GetInstance();
      v12 = (v13->vtptr->Clone)(v13);
    }
    sub_122CF80(a2, (*v5 + 2 * v6), v4, v12);
    result = a2;
  }
  else
  {
    v9 = sub_122B970((v7 - 16)) + 4;
    result = a2;
    *a2 = v9;
  }
  return result;
}

//----- (0122F840) --------------------------------------------------------
signed int __thiscall sub_122F840(char *this, WCHAR *a2)
{
  char *v2; // edi
  int v3; // edi
  TRACEHANDLE v4; // rax
  signed int result; // eax
  struct _EVENT_TRACE_LOGFILEW Logfile; // [esp+8h] [ebp-1A4h]

  v2 = this;
  memset(&Logfile.LoggerName, 0, 0x19Cu);
  Logfile.Context = v2;
  Logfile.LogFileName = 0;
  Logfile.LoggerName = a2;
  v3 = (v2 + 16);
  Logfile.u.LogFileMode = 0x10000100;
  Logfile.BufferCallback = BufferCallback;
  Logfile.u2.EventCallback = EventCallback_0;
  v4 = OpenTraceW(&Logfile);
  *v3 = v4;
  if ( v4 == 0xFFFFFFFF )
  {
    result = GetLastError();
    if ( result > 0 )
      result = result | 0x80070000;
    *v3 = 0;
    *(v3 + 4) = 0;
  }
  else
  {
    result = ProcessTrace(v3, 1u, 0, 0);
    if ( result )
    {
      result = GetLastError();
      if ( result > 0 )
        result = result | 0x80070000;
    }
  }
  return result;
}

//----- (0122F920) --------------------------------------------------------
BOOL __stdcall EnumFunc(HWND hWnd, CResize *pResizer)
{
  double dbYYRatio; // xmm0_8
  int Height; // ecx
  int Width; // esi
  int nHeight; // eax
  int btn; // eax
  int bottom; // edx
  int top; // esi
  double dyRatio2; // xmm5_8
  double dyRatio1; // xmm3_8
  CResizeBuffer *BufCount; // ecx
  HWND *v12; // eax
  int v13; // eax
  int v14; // eax
  LONG v15; // eax
  double v16; // xmm1_8
  int v17; // eax
  int v18; // eax
  double dbYRatio; // [esp+10h] [ebp-244h]
  int nHeight1; // [esp+18h] [ebp-23Ch]
  int Width1; // [esp+1Ch] [ebp-238h]
  double dXXRatio; // [esp+20h] [ebp-234h]
  double dbXRatio; // [esp+28h] [ebp-22Ch]
  LONG right; // [esp+30h] [ebp-224h]
  char NoSysBtn; // [esp+37h] [ebp-21Dh]
  RECT rect; // [esp+38h] [ebp-21Ch]
  TCHAR ClassName[260]; // [esp+48h] [ebp-20Ch]

  NoSysBtn = 1;
  if ( GetParent(hWnd) == pResizer->m_hWnd )
  {
    GetWindowRect(hWnd, &rect);
    ScreenToClient(pResizer->m_hWnd, &rect);
    ScreenToClient(pResizer->m_hWnd, &rect.right);
    dbYYRatio = 0.0;
    Height = pResizer->m_nHeight * pResizer->m_HeightScale;
    Width = pResizer->m_nWidth * pResizer->m_WidthScale / 100;
    Width1 = Width;
    nHeight = Height / 100;
    nHeight1 = Height / 100;
    if ( rect.left >= Width )
      dbXRatio = doubleOnePointZero;
    else
      dbXRatio = 0.0;
    if ( rect.right >= Width )
      dXXRatio = doubleOnePointZero;
    else
      dXXRatio = 0.0;
    if ( rect.top >= nHeight )
      dbYRatio = doubleOnePointZero;
    else
      dbYRatio = 0.0;
    if ( rect.bottom >= nHeight )
      dbYYRatio = doubleOnePointZero;
    *ClassName = 0;
    memset(&ClassName[2], 0, 518u);
    GetClassNameW(hWnd, ClassName, _MAX_PATH);
    if ( !_wcsicmp(ClassName, L"Button") )
    {
      btn = GetWindowLongW(hWnd, GWL_STYLE) & 0xF;
      if ( !btn || btn == BS_DEFPUSHBUTTON || btn == BS_OWNERDRAW || btn == BS_USERBUTTON )
        NoSysBtn = 0;
    }
    if ( !_wcsicmp(ClassName, L"Static") )
      InvalidateRect(hWnd, FALSE, FALSE);
    bottom = rect.bottom;
    top = rect.top;
    right = rect.right;
    if ( NoSysBtn )
    {
      dyRatio1 = dbYYRatio;
      dyRatio2 = dbYRatio;
    }
    else
    {
      if ( Width1 - rect.left < rect.right - Width1 )
        dbXRatio = dXXRatio;
      else
        dXXRatio = dbXRatio;
      if ( nHeight1 - rect.top < rect.bottom - nHeight1 )
      {
        dyRatio1 = dbYYRatio;
        dyRatio2 = dbYYRatio;
      }
      else
      {
        dyRatio2 = dbYRatio;
        dyRatio1 = dbYRatio;
      }
    }
    BufCount = 0;
    if ( hWnd )
    {
      if ( pResizer->m_BufCount <= 0 )
      {
LABEL_34:
        BufCount = 0;
      }
      else
      {
        v12 = &pResizer->m_Buffer->hWnd;
        while ( *v12 != hWnd )
        {
          BufCount = (BufCount + 1);
          v12 += 14;
          if ( BufCount >= pResizer->m_BufCount )
            goto LABEL_34;
        }
        BufCount = &pResizer->m_Buffer[BufCount];
        if ( BufCount )
        {
          if ( BufCount->Width.m128d_f64[0] >= 0.0 )
            dbXRatio = BufCount->Width.m128d_f64[0];
          if ( BufCount->Width.m128d_f64[1] >= 0.0 )
            dXXRatio = BufCount->Width.m128d_f64[1];
          if ( BufCount->Height.m128d_f64[0] >= 0.0 )
            dyRatio2 = BufCount->Height.m128d_f64[0];
          if ( BufCount->Height.m128d_f64[1] >= 0.0 )
            dyRatio1 = BufCount->Height.m128d_f64[1];
        }
      }
    }
    if ( dbXRatio != 0.0 )
    {
      v13 = pResizer->m_nWidth1;
      if ( dbXRatio == 1.0 )
        rect.left += v13 - pResizer->m_nWidth;
      else
        rect.left = ((v13 - pResizer->m_nWidth2) * BufCount->Width.m128d_f64[0] + BufCount->Rect.left);
    }
    if ( dXXRatio != 0.0 )
    {
      v14 = pResizer->m_nWidth1;
      if ( dXXRatio == 1.0 )
      {
        right = v14 - pResizer->m_nWidth + rect.right;
        v15 = v14 - pResizer->m_nWidth + rect.right;
      }
      else
      {
        v16 = (v14 - pResizer->m_nWidth2) * BufCount->Width.m128d_f64[1] + BufCount->Rect.right;
        v15 = v16;
        right = v16;
      }
      rect.right = v15;
    }
    if ( dyRatio2 != 0.0 )
    {
      v17 = pResizer->m_nHeight1;
      if ( dyRatio2 == 1.0 )
        top = v17 - pResizer->m_nHeight + rect.top;
      else
        top = ((v17 - pResizer->m_nHeight2) * BufCount->Height.m128d_f64[0] + BufCount->Rect.top);
      rect.top = top;
    }
    if ( dyRatio1 == 4.0 )
    {
      bottom = top + BufCount->Rect.bottom - BufCount->Rect.top;
    }
    else
    {
      if ( dyRatio1 == 0.0 )
      {
LABEL_65:
        pResizer->m_hDWP = DeferWindowPos(
                             pResizer->m_hDWP,
                             hWnd,
                             0,
                             rect.left,
                             top,
                             right - rect.left,
                             bottom - top,
                             SWP_NOZORDER);
        return 1;
      }
      v18 = pResizer->m_nHeight1;
      if ( dyRatio1 == 1.0 )
        bottom = v18 - pResizer->m_nHeight + rect.bottom;
      else
        bottom = ((v18 - pResizer->m_nHeight2) * BufCount->Height.m128d_f64[1] + BufCount->Rect.bottom);
    }
    rect.bottom = bottom;
    goto LABEL_65;
  }
  return 1;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCB38: using guessed type double doubleFourPointZero;

//----- (0122FD80) --------------------------------------------------------
int __thiscall CResizer::Refresh(CResize *pResizerData)
{
  CResize *pResizer; // ebx
  int result; // eax
  HDWP v3; // eax
  HWND hWnd; // ST00_4
  int cxScroll; // edi
  int cyScroll; // eax
  LONG top; // ecx
  int nHeight; // ST08_4
  int nWidth; // eax
  HWND m_hWnd; // ST00_4
  RECT rcDst; // [esp+4h] [ebp-44h]
  RECT rc; // [esp+14h] [ebp-34h]
  RECT rect; // [esp+24h] [ebp-24h]
  RECT rcSrc; // [esp+34h] [ebp-14h]

  pResizer = pResizerData;
  if ( pResizerData->m_nHeight != pResizerData->m_nHeight1
    || (result = pResizerData->m_nWidth, result != pResizerData->m_nWidth1) )
  {
    v3 = BeginDeferWindowPos(SWP_NOREPOSITION);
    hWnd = pResizer->m_hWnd;
    pResizer->m_hDWP = v3;
    // 刷新所有子窗口
    EnumChildWindows(hWnd, EnumFunc, pResizer);
    EndDeferWindowPos(pResizer->m_hDWP);
    GetClientRect(pResizer->m_hWnd, &rect);
    cxScroll = GetSystemMetrics(SM_CXHSCROLL);
    cyScroll = GetSystemMetrics(SM_CYVSCROLL);
    rcSrc.left = rect.right - cxScroll;
    top = rect.bottom - cyScroll;
    rcSrc.right = rect.right;
    nHeight = pResizer->m_nHeight - pResizer->m_nHeight1;
    nWidth = pResizer->m_nWidth - pResizer->m_nWidth1;
    rcSrc.top = top;
    rcSrc.bottom = rect.bottom;
    _mm_storeu_si128(&rc, _mm_loadu_si128(&rcSrc));
    OffsetRect(&rc, nWidth, nHeight);
    UnionRect(&rcDst, &rc, &rcSrc);
    InvalidateRect(pResizer->m_hWnd, &rcDst, TRUE);
    m_hWnd = pResizer->m_hWnd;
    pResizer->m_nWidth = pResizer->m_nWidth1;
    pResizer->m_nHeight = pResizer->m_nHeight1;
    result = InvalidateRect(m_hWnd, NULL, TRUE);
  }
  return result;
}

//----- (0122FE80) --------------------------------------------------------
int __thiscall sub_122FE80(const wchar_t **this, wchar_t a2)
{
  const wchar_t **v2; // esi
  wchar_t *v3; // eax
  int result; // eax

  v2 = this;
  v3 = wcsrchr(*this, a2);
  if ( v3 )
    result = v3 - *v2;
  else
    result = -1;
  return result;
}

//----- (0122FEB0) --------------------------------------------------------
_WORD *__thiscall sub_122FEB0(void **this, void *Src)
{
  _WORD *result; // eax

  if ( Src )
    result = sub_122C620(this + 5, Src, wcslen(Src));
  else
    result = sub_122C620(this + 5, 0, 0);
  return result;
}

//----- (0122FF00) --------------------------------------------------------
_WORD *__thiscall sub_122FF00(void **this, void *Src)
{
  _WORD *result; // eax

  if ( Src )
    result = sub_122C620(this + 1, Src, wcslen(Src));
  else
    result = sub_122C620(this + 1, 0, 0);
  return result;
}

//----- (0122FF50) --------------------------------------------------------
_WORD *__thiscall sub_122FF50(void **this, void *Src)
{
  _WORD *result; // eax

  if ( Src )
    result = sub_122C620(this + 2, Src, wcslen(Src));
  else
    result = sub_122C620(this + 2, 0, 0);
  return result;
}

//----- (0122FFA0) --------------------------------------------------------
_WORD *__thiscall sub_122FFA0(void **this, void *Src)
{
  _WORD *result; // eax

  if ( Src )
    result = sub_122C620(this + 3, Src, wcslen(Src));
  else
    result = sub_122C620(this + 3, 0, 0);
  return result;
}

//----- (0122FFF0) --------------------------------------------------------
int __thiscall sub_122FFF0(void **this, void *Src)
{
  void **v2; // edi
  unsigned __int16 *v3; // esi
  int v4; // edx
  void **v5; // edi
  int v6; // ecx
  int result; // eax
  void **v8; // eax
  char *v9; // edx

  v2 = this;
  v3 = Src;
  if ( Src )
    v4 = wcslen(Src);
  else
    v4 = 0;
  sub_122C620(this + 4, Src, v4);
  v5 = v2 + 1;
  if ( v3 )
    v6 = wcslen(v3);
  else
    v6 = 0;
  sub_122C620(v5, v3, v6);
  result = *v5;
  if ( *(*v5 - 3) > 0 )
  {
    result = wcschr(result, 0x2Cu);
    if ( result )
    {
      result = (result - *v5) >> 1;
      if ( result >= 0 )
      {
        v8 = sub_122F790(v5, &Src, 0, result);
        sub_122D840(v5, v8);
        v9 = Src - 16;
        result = Src - 4;
        if ( _InterlockedDecrement(result) <= 0 )
          result = (*(**v9 + 4))(v9);
      }
    }
  }
  return result;
}

//----- (012300E0) --------------------------------------------------------
_WORD *__thiscall sub_12300E0(void **this, void *Src)
{
  _WORD *result; // eax

  if ( Src )
    result = sub_122C620(this + 6, Src, wcslen(Src));
  else
    result = sub_122C620(this + 6, 0, 0);
  return result;
}

//----- (01230130) --------------------------------------------------------
int __thiscall sub_1230130(HWND *this)
{
  HWND *v1; // edi
  LONG v2; // ecx
  int v3; // ST10_4
  int v4; // ecx
  HWND v5; // ST00_4
  struct tagRECT Rect; // [esp+8h] [ebp-24h]
  struct tagRECT rcDst; // [esp+18h] [ebp-14h]

  v1 = this;
  GetClientRect(this[2], &Rect);
  CopyRect(&rcDst, &Rect);
  v2 = rcDst.right - 10;
  rcDst.bottom -= 10;
  rcDst.right = v2;
  v3 = rcDst.bottom - (rcDst.top + 10);
  v4 = v2 - (rcDst.left + 10);
  rcDst.left += 10;
  v5 = v1[1];
  rcDst.top += 10;
  MoveWindow(v5, rcDst.left, rcDst.top, v4, v3, 1);
  return rcDst.right - rcDst.left;
}

//----- (012301B0) --------------------------------------------------------
void *__thiscall sub_12301B0(int this)
{
  return sub_122CC30(*(this + 32), *(this + 36), (*(this + 36) - *(this + 32)) >> 2, sub_122E780);
}

//----- (012301D0) --------------------------------------------------------
int __cdecl sub_12301D0(wchar_t *Dst, rsize_t SizeInWords, int a3)
{
  return sub_122E970(Dst, SizeInWords, a3, &unk_12DD150, 5);
}

//----- (01230200) --------------------------------------------------------
int __cdecl GUIDFromString(wchar_t *Src, GUID a2)
{
  signed int v2; // edi
  const wchar_t *v3; // ebx
  signed int v4; // esi
  const wchar_t *v5; // edi
  int result; // eax
  wchar_t Dst; // [esp+14h] [ebp-18h]
  __int16 v8; // [esp+18h] [ebp-14h]
  __int16 v9; // [esp+1Ch] [ebp-10h]
  __int16 v10; // [esp+24h] [ebp-8h]

  wcsncpy_s(&Dst, 0xAu, Src, 8u);
  v10 = 0;
  *a2.Data1 = sub_122F690(&Dst);
  wcsncpy_s(&Dst, 0xAu, Src + 9, 4u);
  v9 = 0;
  *(a2.Data1 + 4) = sub_122F690(&Dst);
  wcsncpy_s(&Dst, 0xAu, Src + 14, 4u);
  v9 = 0;
  *(a2.Data1 + 6) = sub_122F690(&Dst);
  v2 = 0;
  v3 = Src + 19;
  do
  {
    wcsncpy_s(&Dst, 0xAu, v3, 2u);
    v8 = 0;
    *(a2.Data1 + 8 + v2++) = sub_122F690(&Dst);
    v3 += 2;
  }
  while ( v2 < 2 );
  v4 = 2;
  v5 = Src + 24;
  do
  {
    wcsncpy_s(&Dst, 10u, v5, 2u);
    v8 = 0;
    result = sub_122F690(&Dst);
    *(a2.Data1 + 8 + v4++) = result;
    v5 += 2;
  }
  while ( v4 < 8 );
  return result;
}

//----- (01230310) --------------------------------------------------------
LRESULT __stdcall CResizer::HookWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LPARAM v4; // esi
  CResize *pResizerData; // eax
  WPARAM v6; // edx
  CResize *this; // edi
  UINT message; // eax
  LRESULT result; // eax
  int Width; // edx
  int Height; // ecx
  bool v12; // sf
  unsigned __int8 v13; // of
  const WCHAR *v14; // eax
  LRESULT res; // edi
  POINT pt; // ST10_8
  LONG v17; // ecx
  void *v18; // eax
  LRESULT (__stdcall *OldWndProc)(HWND, UINT, WPARAM, LPARAM); // esi
  HDC hdc; // [esp+Ch] [ebp-5Ch]
  struct tagPAINTSTRUCT Paint; // [esp+14h] [ebp-54h]
  struct tagRECT Rect; // [esp+54h] [ebp-14h]

  v4 = lParam;
  pResizerData = GetPropW(hWnd, L"ResizerClass");
  v6 = wParam;
  this = pResizerData;
  message = Msg;
  switch ( Msg )
  {
    case WM_DESTROY:
      OldWndProc = this->m_WndProc;
      SetWindowLongW(hWnd, GWL_WNDPROC, this->m_WndProc);
      CResizer::~CResizer(this);
      j__free(this);
      return CallWindowProcW(OldWndProc, hWnd, Msg, wParam, lParam);
    case WM_SIZE:
      if ( !this->m_FixedBorder || wParam != SIZE_MAXIMIZED && wParam )
        goto LABEL_13;
      if ( GetWindowRect(hWnd, &Rect) )
      {
        Width = Rect.right - Rect.left;
        Height = Rect.bottom - Rect.top;
        if ( Rect.right - Rect.left < this->m_nWidth2 )
          Width = this->m_nWidth2;
        v13 = __OFSUB__(Height, this->m_nHeight2);
        v12 = Height - this->m_nHeight2 < 0;
        this->m_nWidth1 = Width;
        if ( v12 ^ v13 )
          Height = this->m_nHeight2;
        this->m_nHeight1 = Height;
        CResizer::Refresh(this);
      }
      goto LABEL_12;
    case WM_PAINT:
      if ( !(GetWindowLongW(hWnd, GWL_STYLE) & WS_CHILD) && !IsZoomed(hWnd) )
      {
        hdc = BeginPaint(hWnd, &Paint);
        GetClientRect(hWnd, &Rect);
        Rect.left = Rect.right - GetSystemMetrics(SM_CXHSCROLL);
        v17 = Rect.bottom - GetSystemMetrics(SM_CYVSCROLL);
        v18 = this->m_hTheme;
        Rect.top = v17;
        if ( v18 )
          DrawThemeBackground(v18, hdc, SBP_THUMBBTNVERT, 0, &Rect, 0);
        else
          DrawFrameControl(hdc, &Rect, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
        EndPaint(hWnd, &Paint);
        v4 = lParam;
      }
LABEL_12:
      message = Msg;
      goto LABEL_13;
    case WM_GETMINMAXINFO:
      *(lParam + 24) = this->m_nWidth2;
      *(lParam + 28) = this->m_nHeight2;
      result = 0;
      break;
    case WM_NCHITTEST:
      res = CallWindowProcW(this->m_WndProc, hWnd, Msg, wParam, lParam);
      if ( GetWindowLongW(hWnd, GWL_STYLE) & WS_CHILD
        || res != HTCLIENT
        || IsZoomed(hWnd)
        || (GetWindowRect(hWnd, &Rect),
            Rect.left = Rect.right - GetSystemMetrics(SM_CXHSCROLL),
            Rect.top = Rect.bottom - GetSystemMetrics(SM_CYVSCROLL),
            pt.y = SHIWORD(lParam),
            pt.x = lParam,
            !PtInRect(&Rect, pt)) )
      {
        result = res;
      }
      else
      {
        result = HTBOTTOMRIGHT;
      }
      break;
    default:
LABEL_13:
      if ( message == WM_THEMECHANGED )
      {
        if ( this->m_hTheme )
          CloseThemeData(this->m_hTheme);
        this->m_hTheme = 0;
        if ( *IsThemeActive )
        {
          if ( IsThemeActive() )
          {
            v14 = (this->vtptr->GetTitle)(this);
            this->m_hTheme = OpenThemeData(hWnd, v14);
          }
        }
      }
      result = (this->vtptr->WndProc)(this, v6, hWnd, Msg, wParam, v4);
      break;
  }
  return result;
}

//----- (01230650) --------------------------------------------------------
char *__thiscall sub_1230650(const void **this, unsigned int a2)
{
  unsigned int v2; // ebx
  char *v3; // esi
  const void **v4; // edi
  char *result; // eax
  int v6; // [esp+14h] [ebp+8h]

  v2 = a2;
  v3 = 0;
  v4 = this;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFF || (v3 = operator new(2 * a2)) == 0 )
      std::bad_alloc::bad_alloc();
  }
  memmove(v3, *v4, (v4[1] - *v4) & 0xFFFFFFFE);
  v6 = (v4[1] - *v4) >> 1;
  if ( *v4 )
    j__free(*v4);
  *v4 = v3;
  v4[2] = &v3[2 * v2];
  result = &v3[2 * v6];
  v4[1] = result;
  return result;
}

//----- (012306D0) --------------------------------------------------------
char *__thiscall sub_12306D0(const void **this, unsigned int a2)
{
  unsigned int v2; // ebx
  char *v3; // esi
  const void **v4; // edi
  char *result; // eax
  int v6; // [esp+14h] [ebp+8h]

  v2 = a2;
  v3 = 0;
  v4 = this;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFF || (v3 = operator new(4 * a2)) == 0 )
      std::bad_alloc::bad_alloc();
  }
  memmove(v3, *v4, (v4[1] - *v4) & 0xFFFFFFFC);
  v6 = (v4[1] - *v4) >> 2;
  if ( *v4 )
    j__free(*v4);
  *v4 = v3;
  v4[2] = &v3[4 * v2];
  result = &v3[4 * v6];
  v4[1] = result;
  return result;
}

//----- (01230750) --------------------------------------------------------
unsigned int __thiscall sub_1230750(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx

  v2 = *(this + 4);
  result = (*(this + 8) - v2) >> 1;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 1;
    if ( 0x7FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(this + 8) - *this) >> 1;
    if ( 0x7FFFFFFF - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v5 )
        v8 = v5;
      result = sub_1230650(this, v8);
    }
    else
    {
      v7 = 0;
      if ( v5 > 0 )
        v7 = v5;
      result = sub_1230650(this, v7);
    }
  }
  return result;
}

//----- (012307C0) --------------------------------------------------------
unsigned int __thiscall sub_12307C0(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx

  v2 = *(this + 4);
  result = (*(this + 8) - v2) >> 2;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 2;
    if ( 0x3FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(this + 8) - *this) >> 2;
    if ( 0x3FFFFFFF - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v5 )
        v8 = v5;
      result = sub_12306D0(this, v8);
    }
    else
    {
      v7 = 0;
      if ( v5 > 0 )
        v7 = v5;
      result = sub_12306D0(this, v7);
    }
  }
  return result;
}

//----- (01230840) --------------------------------------------------------
int __thiscall sub_1230840(_DWORD *this, int a2, void *a3)
{
  _DWORD *v3; // edi
  int result; // eax

  v3 = this;
  memmove(a3, a3 + 2, (this[1] - (a3 + 2)) & 0xFFFFFFFE);
  result = a2;
  v3[1] -= 2;
  *a2 = a3;
  return result;
}

//----- (01230880) --------------------------------------------------------
__int16 __thiscall sub_1230880(_DWORD *this, _WORD *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // eax
  int v4; // edi
  _WORD *v5; // ecx
  _WORD *v6; // ecx

  v2 = this;
  v3 = this[1];
  if ( a2 >= v3 || *this > a2 )
  {
    if ( v3 == this[2] )
      LOWORD(v3) = sub_1230750(this, 1u);
    v6 = v2[1];
    if ( v6 )
    {
      LOWORD(v3) = *a2;
      *v6 = *a2;
    }
    goto LABEL_11;
  }
  v4 = (a2 - *this) >> 1;
  if ( v3 == this[2] )
    LOWORD(v3) = sub_1230750(this, 1u);
  v5 = v2[1];
  if ( !v5 )
  {
LABEL_11:
    v2[1] += 2;
    return v3;
  }
  LOWORD(v3) = *(*v2 + 2 * v4);
  *v5 = v3;
  v2[1] += 2;
  return v3;
}

//----- (012308F0) --------------------------------------------------------
CStringData *__thiscall sub_12308F0(void *this, SystemMenuData *pMenuData)
{
  _DWORD *v2; // esi
  CStringData *result; // eax
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx

  v2 = this;
  result = *(this + 1);
  if ( pMenuData >= result || *this > pMenuData )
  {
    if ( result == *(this + 2) )
      result = sub_12307C0(this, 1u);
    v6 = v2[1];
    if ( v6 )
    {
      result = *&pMenuData->SystemAdministrative;
      *v6 = *&pMenuData->SystemAdministrative;
    }
  }
  else
  {
    v4 = (pMenuData - *this) >> 2;
    if ( result == *(this + 2) )
      result = sub_12307C0(this, 1u);
    v5 = v2[1];
    if ( v5 )
    {
      result = *(*v2 + 4 * v4);
      *v5 = result;
      v2[1] += 4;
      return result;
    }
  }
  v2[1] += 4;
  return result;
}

//----- (01230960) --------------------------------------------------------
bool __cdecl sub_1230960(#1077 *a1)
{
  DWORD v1; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  v1 = *(a1 + 17);
  if ( !v1 || !EnableTraceEx )
    return 0;
  sub_122EC70(v1, &v3);
  return v3 != 0;
}

//----- (012309A0) --------------------------------------------------------
int __cdecl sub_12309A0(wchar_t *Dst, int a2, __int64 a3)
{
  int result; // eax

  if ( gbShowCpuFractions )
    result = swprintf_s(Dst, 0x20u, L"%s%0.2f%%", a2, a3);
  else
    result = swprintf_s(Dst, 0x20u, L"%s%0.0f%%", a2, a3);
  return result;
}
// 12E96C9: using guessed type char gbShowCpuFractions;

//----- (012309F0) --------------------------------------------------------
int __cdecl sub_12309F0(wchar_t *Dst, int a2, __int64 a3)
{
  int result; // eax

  if ( gbShowCpuFractions )
    result = swprintf_s(Dst, 0x400u, L"%s%0.2f%%", a2, a3);
  else
    result = swprintf_s(Dst, 0x400u, L"%s%0.0f%%", a2, a3);
  return result;
}
// 12E96C9: using guessed type char gbShowCpuFractions;

//----- (01230A40) --------------------------------------------------------
errno_t __cdecl sub_1230A40(wchar_t *a1, int a2, __int64 a3)
{
  return sub_1232410(a1, 0x400u, a2, a3);
}

//----- (01230A70) --------------------------------------------------------
int FormatTex(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x400u, Format, ArgList);
}

//----- (01230A90) --------------------------------------------------------
int __thiscall sub_1230A90(_DWORD *this, int a2, int a3, int a4, int a5, unsigned int a6, int a7)
{
  char v7; // al
  int v8; // edx
  int v9; // edi
  int v10; // ebx
  int v11; // esi
  int result; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ebx
  int v16; // eax
  bool v17; // zf
  int v18; // [esp+Ch] [ebp-10h]
  int v19; // [esp+10h] [ebp-Ch]
  int v20; // [esp+14h] [ebp-8h]
  _DWORD *v21; // [esp+18h] [ebp-4h]
  signed int v22; // [esp+24h] [ebp+8h]
  signed int v23; // [esp+28h] [ebp+Ch]
  int v24; // [esp+2Ch] [ebp+10h]
  int v25; // [esp+30h] [ebp+14h]
  int v26; // [esp+30h] [ebp+14h]
  int v27; // [esp+30h] [ebp+14h]

  v7 = a7;
  v21 = this;
  if ( a7 )
  {
    v7 = a7;
    v20 = (a6 + (256 - a6) / 2) | (((BYTE1(a6) + (256 - BYTE1(a6)) / 2) | ((BYTE2(a6) + (256 - BYTE2(a6)) / 2) << 8)) << 8);
    v8 = (a6 + (256 - a6) / 2) | (((BYTE1(a6) + (256 - BYTE1(a6)) / 2) | ((BYTE2(a6) + (256 - BYTE2(a6)) / 2) << 8)) << 8);
  }
  else
  {
    v8 = a7;
    v20 = a7;
  }
  v9 = a2;
  v10 = a4 - a2;
  v11 = a3;
  v25 = a5 - a3;
  if ( v7 )
    sub_1230E50(this, a3, a2, a3, this[1], v8, 0);
  else
    *(this[4] + 4 * (a3 + a2 * this[2])) = (a6 & 0xFF00) | (a6 << 16) | (a6 >> 16) & 0xFF;
  if ( v10 >= 0 )
  {
    v22 = 1;
  }
  else
  {
    v22 = -1;
    v10 = -v10;
  }
  result = v25;
  if ( v25 >= 0 )
  {
    v23 = 1;
  }
  else
  {
    v23 = -1;
    result = -v25;
  }
  v13 = 2 * v10;
  v14 = 2 * result;
  v19 = 2 * v10;
  v18 = 2 * result;
  if ( 2 * result < 2 * v10 )
  {
    if ( v10 > 0 )
    {
      v27 = v10;
      do
      {
        v9 += v22;
        v10 += v14;
        if ( v10 > v13 )
        {
          v11 += v23;
          v10 -= v13;
        }
        if ( a7 )
        {
          LOBYTE(result) = sub_1230E50(v21, v11, v9, v11, v21[1], v20, 0);
        }
        else
        {
          result = v21[4];
          *(result + 4 * (v11 + v9 * v21[2])) = (a6 & 0xFF00) | (a6 << 16) | (a6 >> 16) & 0xFF;
        }
        v17 = v27-- == 1;
        v13 = v19;
        v14 = v18;
      }
      while ( !v17 );
    }
  }
  else if ( result > 0 )
  {
    v15 = result;
    v24 = result;
    do
    {
      v11 += v23;
      v16 = v13 + result;
      v26 = v16;
      if ( v16 > v14 )
      {
        v9 += v22;
        v26 = v16 - v14;
      }
      if ( a7 )
      {
        sub_1230E50(v21, v11, v9, v11, v21[1], v20, 0);
        v15 = v24;
      }
      else
      {
        *(v21[4] + 4 * (v11 + v9 * v21[2])) = (a6 & 0xFF00) | (a6 << 16) | (a6 >> 16) & 0xFF;
      }
      result = v26;
      --v15;
      v13 = v19;
      v14 = v18;
      v24 = v15;
    }
    while ( v15 );
  }
  return result;
}

//----- (01230CA0) --------------------------------------------------------
char __thiscall sub_1230CA0(void **this, LONG a2, signed int a3)
{
  void **v3; // ST24_4
  HDC v4; // ebx
  HDC v5; // eax
  void *v6; // ST14_4
  BITMAPINFO bmi; // [esp+10h] [ebp-2Ch]

  v3 = this;
  v4 = GetDC(0);
  _mm_storeu_si128(&bmi.bmiHeader.biWidth, 0i64);
  bmi.bmiHeader.biClrImportant = 0;
  bmi.bmiHeader.biSize = 40;
  bmi.bmiHeader.biHeight = -a3;
  bmi.bmiHeader.biWidth = a2;
  *&bmi.bmiHeader.biPlanes = 2097153;
  _mm_storeu_si128(&bmi.bmiHeader.biSizeImage, 0i64);
  bmi.bmiHeader.biClrUsed = 0;
  bmi.bmiHeader.biCompression = 0;
  bmi.bmiHeader.biSizeImage = 0;
  *v3 = CreateDIBSection(v4, &bmi, 0, v3 + 4, 0, 0);
  v3[1] = a3;
  v3[2] = a2;
  v5 = CreateCompatibleDC(v4);
  v6 = *v3;
  v3[3] = v5;
  SelectObject(v5, v6);
  ReleaseDC(0, v4);
  return 1;
}

//----- (01230D60) --------------------------------------------------------
char __thiscall sub_1230D60(CBitmap *Bitmap, _DWORD *a2, unsigned int a3)
{
  _DWORD *v3; // edx
  int v4; // esi
  CBitmap *v5; // ebx
  int v6; // eax
  int v7; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int i; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]
  int v16; // [esp+1Ch] [ebp+8h]

  v3 = a2;
  v4 = 0;
  v5 = Bitmap;
  if ( *a2 > 0 )
    v4 = *a2;
  v6 = a2[1];
  v7 = Bitmap->field_8;
  v15 = v4;
  if ( a2[2] < v7 )
    v7 = a2[2];
  v8 = 0;
  v16 = v7;
  if ( v6 > 0 )
    v8 = v6;
  v9 = v3[3];
  v10 = v5->field_4;
  if ( v9 < v10 )
    v10 = v9;
  for ( i = v10; v8 < v10; ++v8 )
  {
    v11 = v4;
    if ( v4 < v7 )
    {
      do
      {
        v12 = v11++ + v8 * v5->field_8;
        *(v5[1].field_4 + 4 * v12) = (a3 & 0xFF00) | (a3 << 16) | (a3 >> 16) & 0xFF;
        v7 = v16;
      }
      while ( v11 < v16 );
      v4 = v15;
      v10 = i;
    }
  }
  return 1;
}

//----- (01230E00) --------------------------------------------------------
int __cdecl sub_1230E00(wchar_t *Dst, size_t SizeInWords, int a3, __int64 a4)
{
  int result; // eax

  if ( gbShowCpuFractions )
    result = swprintf_s(Dst, SizeInWords, L"%s%0.2f%%", a3, a4);
  else
    result = swprintf_s(Dst, SizeInWords, L"%s%0.0f%%", a3, a4);
  return result;
}
// 12E96C9: using guessed type char gbShowCpuFractions;

//----- (01230E50) --------------------------------------------------------
char __thiscall sub_1230E50(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // eax
  _DWORD *v8; // esi
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // edi
  int v14; // edi
  int v15; // ebx

  v7 = a2;
  v8 = this;
  if ( a2 >= 0 )
  {
    v9 = this[2];
    if ( a2 >= v9 )
      v7 = v9 - 1;
  }
  else
  {
    v7 = 0;
  }
  v10 = a4;
  if ( a4 >= 0 )
  {
    v11 = v8[2];
    if ( a4 >= v11 )
      v10 = v11 - 1;
  }
  else
  {
    v10 = 0;
  }
  v12 = a3;
  if ( a3 >= 0 )
  {
    v13 = v8[1];
    if ( a3 >= v13 )
      v12 = v13 - 1;
  }
  else
  {
    v12 = 0;
  }
  v14 = a5;
  if ( a5 >= 0 )
  {
    v15 = v8[1];
    if ( a5 >= v15 )
      v14 = v15 - 1;
  }
  else
  {
    v14 = 0;
  }
  sub_1230A90(v8, v12, v7, v14, v10, a6, a7);
  return 1;
}

//----- (01230ED0) --------------------------------------------------------
char __thiscall sub_1230ED0(_DWORD *this, int a2, int a3, int a4, int a5, unsigned int a6, char a7)
{
  int v7; // esi
  _DWORD *v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // ecx
  int v15; // edx
  unsigned int v16; // ecx
  int v17; // edx
  int v18; // ecx
  unsigned int v20; // ecx
  int v21; // edx
  int v22; // ecx

  v7 = a2;
  v8 = this;
  if ( a2 >= 0 )
  {
    v9 = this[2];
    if ( a2 >= v9 )
      v7 = v9 - 1;
  }
  else
  {
    v7 = 0;
  }
  v10 = a4;
  if ( a4 >= 0 )
  {
    v11 = this[2];
    if ( a4 < v11 )
      goto LABEL_10;
    v10 = v11 - 1;
  }
  else
  {
    v10 = 0;
  }
  a4 = v10;
LABEL_10:
  v12 = a3;
  if ( a3 >= 0 )
  {
    v13 = v8[1];
    if ( a3 >= v13 )
      v12 = v13 - 1;
  }
  else
  {
    v12 = 0;
  }
  v14 = a5;
  if ( a5 >= 0 )
  {
    v15 = v8[1];
    if ( a5 < v15 )
      goto LABEL_19;
    v14 = v15 - 1;
  }
  else
  {
    v14 = 0;
  }
  a5 = v14;
LABEL_19:
  if ( v7 != v10 )
  {
    if ( v7 < v10 )
    {
      do
      {
        if ( a7 )
          v20 = (a6 >> 1) | (((BYTE1(a6) | ((BYTE2(a6) & 0xFE) << 8)) & 0xFFFE) << 7);
        else
          v20 = a6;
        v21 = (v20 & 0xFF00) | (v20 << 16) | (v20 >> 16) & 0xFF;
        v22 = v7++ + v12 * v8[2];
        *(v8[4] + 4 * v22) = v21;
      }
      while ( v7 < a4 );
    }
    return 1;
  }
  if ( v12 >= v14 )
    return 1;
  do
  {
    if ( a7 )
      v16 = (a6 >> 1) | (((BYTE1(a6) | ((BYTE2(a6) & 0xFE) << 8)) & 0xFFFE) << 7);
    else
      v16 = a6;
    v17 = (v16 & 0xFF00) | (v16 << 16) | (v16 >> 16) & 0xFF;
    v18 = v12++ * v8[2];
    *(v8[4] + 4 * (v7 + v18)) = v17;
  }
  while ( v12 < a5 );
  return 1;
}

//----- (01231020) --------------------------------------------------------
void __cdecl UpdateText(ProcessorInfo *ProcessorsInfo, FILETIME TimeLastRefresh, __int64 dbMaxValue, __int64 dbMaxValue1, wchar_t *string)
{
  wchar_t *v5; // ebx
  PDWORD ScreenData; // edx
  int PosLast; // ecx
  int v8; // ecx
  PDWORD v9; // eax
  int v10; // ecx
  __int64 v11; // [esp+4h] [ebp-8h]

  if ( ProcessorsInfo )
  {
    v11 = dbMaxValue;
    if ( ProcessorsInfo->ID )
    {
      if ( *&dbMaxValue > *&ProcessorsInfo->m_dbMaxValue )
        *&ProcessorsInfo->m_dbMaxValue = *&dbMaxValue * 1.200000047683716;
    }
    else if ( *&dbMaxValue <= *&ProcessorsInfo->m_dbMaxValue )
    {
      if ( *&dbMaxValue < 0.0 )
        v11 = 0i64;
    }
    else
    {
      v11 = *&ProcessorsInfo->m_dbMaxValue;
    }
    if ( *&dbMaxValue1 <= *&ProcessorsInfo->m_Buffer[0].m_dbMaxValue )
    {
      if ( *&dbMaxValue1 < 0.0 )
        *&dbMaxValue1 = 0.0;
    }
    else
    {
      *&dbMaxValue1 = gdbMaxValue;
    }
    // 更换数据
    v5 = _wcsdup(string);
    EnterCriticalSection(&ProcessorsInfo->m_Lock);
    ScreenData = ProcessorsInfo->m_ScreenData;
    if ( ScreenData )
    {
      PosLast = ProcessorsInfo->mPosLast;
      if ( ScreenData[PosLast] )
        free(ScreenData[PosLast]);
      v8 = ProcessorsInfo->mPosLast;
      v9 = ProcessorsInfo->m_ScreenData;
      if ( string )
        v9[v8] = v5;
      else
        v9[v8] = 0;
    }
    *(*&ProcessorsInfo->m_Time.wHour + 4 * ProcessorsInfo->mPosLast) = (*&TimeLastRefresh
                                                                      - *&ProcessorsInfo->m_Time.wYear)
                                                                     / 10000000;
    *(ProcessorsInfo->m_Buffer[0].field_4 + 8 * ProcessorsInfo->mPosLast) = v11;
    v10 = ProcessorsInfo->m_Buffer[1].field_4;
    if ( v10 )
      *(v10 + 8 * ProcessorsInfo->mPosLast) = *&dbMaxValue1;
    if ( ++ProcessorsInfo->mPosLast >= gScreenWidth )
      ProcessorsInfo->mPosLast = 0;
    LeaveCriticalSection(&ProcessorsInfo->m_Lock);
  }
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E4E28: using guessed type int gScreenWidth;

//----- (01231160) --------------------------------------------------------
ProcessorInfo *__cdecl InitProcessorScreenData(int dwProcessorNumber, int ProcessorCount, int fZero)
{
  DWORD dwNumberOfProcessor; // edi
  ProcessorInfo *pBuf; // eax
  DWORD *pScreenData; // ebx
  DWORD *ScreenDataPtr; // eax
  void *v7; // eax
  DWORD *v8; // esi
  int count; // edi
  void *screenbuffer; // eax
  FILETIME *lpSystemTimeAsFileTime; // [esp+4h] [ebp-8h]
  ProcessorInfo *ProcessorInfo; // [esp+8h] [ebp-4h]

  dwNumberOfProcessor = dwProcessorNumber;
  pBuf = malloc(0x898 * dwProcessorNumber);
  ProcessorInfo = pBuf;
  if ( dwProcessorNumber > 0 )
  {
    lpSystemTimeAsFileTime = &pBuf->m_Time;
    pScreenData = &pBuf->m_ScreenData;
    do
    {
      memset(pScreenData - 0x218, 0, 0x898u);
      ProcessorInfo->ProcessorCount = ProcessorCount;
      InitializeCriticalSection((pScreenData - 0x218));// ProcessorInfo->mLock
      GetSystemTimeAsFileTime(lpSystemTimeAsFileTime);// ProcessorInfo->m_Time
      ScreenDataPtr = malloc(4 * gScreenWidth);
      pScreenData[3] = ScreenDataPtr;           // ProcessorInfo->m_ScreenData2
      memset(ScreenDataPtr, 0, 4 * gScreenWidth);
      if ( fZero )
      {
        v7 = malloc(4 * gScreenWidth);
        *pScreenData = v7;                      // ProcessorInfo->m_ScreenData
        memset(v7, 0, 4 * gScreenWidth);
      }
      if ( ProcessorCount > 0 )
      {
        v8 = pScreenData - 0x20B;               // ProcessorInfo->m_Buffer[0]
        count = ProcessorCount;
        do
        {
          screenbuffer = malloc(8 * gScreenWidth);
          *v8 = screenbuffer;
          memset(screenbuffer, 0, 8 * gScreenWidth);
          v8 += 6;
          --count;
        }
        while ( count );
        dwNumberOfProcessor = dwProcessorNumber;
      }
      pScreenData += 0x226;                     // ProcessorInfo++
      dwProcessorNumber = --dwNumberOfProcessor;
    }
    while ( dwNumberOfProcessor );
    pBuf = ProcessorInfo;
  }
  return pBuf;
}
// 12E4E28: using guessed type int gScreenWidth;

//----- (01231280) --------------------------------------------------------
void __cdecl sub_1231280(void *a1, int a2)
{
  _DWORD *v2; // edi
  void **v3; // ebx
  int v4; // ecx
  int i; // esi
  int v6; // esi
  void **v7; // edi
  bool v8; // zf
  void **v9; // [esp+4h] [ebp-4h]

  v2 = a1;
  if ( a1 )
  {
    if ( a2 > 0 )
    {
      v3 = (a1 + 2144);
      v9 = (a1 + 2144);
      do
      {
        free(v3[3]);
        if ( *v3 )
        {
          v4 = gScreenWidth;
          for ( i = 0; i < v4; ++i )
          {
            if ( *(*v3 + i) )
            {
              free(*(*v3 + i));
              v4 = gScreenWidth;
            }
          }
          free(*v3);
        }
        v6 = 0;
        if ( v2[7] > 0 )
        {
          v7 = v3 - 523;
          do
          {
            free(*v7);
            ++v6;
            v7 += 6;
          }
          while ( v6 < *(a1 + 7) );
          v3 = v9;
          v2 = a1;
        }
        DeleteCriticalSection((v3 - 536));
        v3 += 550;
        v8 = a2-- == 1;
        v9 = v3;
      }
      while ( !v8 );
    }
    free(v2);
  }
}
// 12E4E28: using guessed type int gScreenWidth;

//----- (01231340) --------------------------------------------------------
HWND __cdecl CreateGraphWindowInDlg(HWND hDlg, int uCtrlId, int lParam)
{
  HWND v3; // eax
  HWND v4; // eax
  HWND result; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v3 = GetDlgItem(hDlg, uCtrlId);
  GetWindowRect(v3, &Rect);
  MapWindowPoints(0, hDlg, &Rect, 2u);
  v4 = GetDlgItem(hDlg, uCtrlId);
  DestroyWindow(v4);
  if ( uCtrlId == IDC_SYSTEMINFOSUMETW_STATIC8
    || uCtrlId == IDC_SYSTEMINFOSUMETW_STATIC1
    || uCtrlId == IDC_SYSTEMINFOSUMETW_STATIC3
    || uCtrlId == IDC_SYSTEMINFOSUMETW_STATIC10
    || uCtrlId == IDC_SYSTEMINFOSUMETW_STATIC12
    || uCtrlId == IDC_SYSTEMINFOGPU_STATIC_STATIC3
    || uCtrlId == IDC_SYSTEMINFOGPU_STATIC_STATIC5
    || uCtrlId == IDD_PROCGPU_CTRL_STATIC7
    || uCtrlId >= 0x7D0 && uCtrlId < 0x9C4
    || uCtrlId >= 0x9C5 && uCtrlId < 0xA28 )
  {
    // 曲线图
    result = CreateWindowExW(
               0,
               L"CpuGraphClassGraph",
               gpszTargetName,
               // WS_VISIBLE|WS_CHILD
               0x50000000u,
               Rect.left,
               Rect.top,
               Rect.right - Rect.left,
               Rect.bottom - Rect.top,
               hDlg,
               uCtrlId,
               ghInstance,
               lParam);
  }
  else
  {
    // 直方图
    result = CreateWindowExW(
               0,
               L"CpuGraphClassChart",
               gpszTargetName,
               0x50000000u,                     // WS_VISIBLE|WS_CHILD
               Rect.left,
               Rect.top,
               Rect.right - Rect.left,
               Rect.bottom - Rect.top,
               hDlg,
               uCtrlId,
               ghInstance,
               lParam);
  }
  return result;
}
// 12BCB88: using guessed type wchar_t aCpugraphclassc[19];

//----- (01231470) --------------------------------------------------------
HGDIOBJ __cdecl sub_1231470(LPCRITICAL_SECTION lpCriticalSection, int a2, int a3)
{
  LONG v3; // edi
  int v4; // esi
  bool v5; // zf
  bool v6; // sf
  unsigned __int8 v7; // of
  double v8; // xmm0_8
  __int64 v9; // xmm0_8
  __int64 v10; // xmm0_8
  double v11; // xmm0_8
  int v12; // eax
  DWORD v13; // eax
  LONG v14; // edi
  LONG v15; // ecx
  int v16; // ebx
  double v17; // xmm2_8
  int v18; // edx
  double v19; // xmm3_8
  double v20; // xmm1_8
  LPCRITICAL_SECTION v21; // eax
  LONG v22; // ecx
  LONG v23; // edi
  unsigned int v24; // edx
  unsigned int *v25; // ecx
  int v26; // eax
  int v27; // esi
  int v28; // edi
  int v29; // eax
  HBRUSH v30; // eax
  HBRUSH v31; // esi
  HGDIOBJ v32; // eax
  COLORREF v33; // eax
  HGDIOBJ result; // eax
  const wchar_t *v35; // [esp+4h] [ebp-108h]
  double v36; // [esp+14h] [ebp-F8h]
  int v37[2]; // [esp+1Ch] [ebp-F0h]
  unsigned int v38; // [esp+24h] [ebp-E8h]
  LONG v39; // [esp+28h] [ebp-E4h]
  HDC v40; // [esp+2Ch] [ebp-E0h]
  int *v41; // [esp+30h] [ebp-DCh]
  int v42; // [esp+34h] [ebp-D8h]
  double v43; // [esp+38h] [ebp-D4h]
  LONG v44; // [esp+40h] [ebp-CCh]
  LPCRITICAL_SECTION v45; // [esp+44h] [ebp-C8h]
  HGDIOBJ ho; // [esp+48h] [ebp-C4h]
  int cy; // [esp+4Ch] [ebp-C0h]
  int v48; // [esp+50h] [ebp-BCh]
  HDC hdc; // [esp+54h] [ebp-B8h]
  void *v50; // [esp+58h] [ebp-B4h]
  __int64 v51; // [esp+5Ch] [ebp-B0h]
  unsigned int *v52; // [esp+64h] [ebp-A8h]
  struct tagRECT rc; // [esp+68h] [ebp-A4h]
  RECT v54; // [esp+78h] [ebp-94h]
  wchar_t Dst; // [esp+88h] [ebp-84h]
  WCHAR chText; // [esp+C8h] [ebp-44h]

  v40 = a2;
  v45 = lpCriticalSection;
  v3 = *(a3 + 8) - *a3;
  v42 = *(a3 + 12) - *(a3 + 4);
  v41 = a3;
  cy = 0;
  v48 = 0;
  hdc = 0;
  ho = 0;
  v39 = v3;
  sub_1230CA0(&ho, v3, v42);
  EnterCriticalSection(lpCriticalSection);
  v4 = &lpCriticalSection[1].DebugInfo[-1].Spare[1] + 3;
  if ( v4 < 0 )
    v4 = gScreenWidth - 1;
  v7 = __OFSUB__(lpCriticalSection[1].LockCount, 1);
  v5 = lpCriticalSection[1].LockCount == 1;
  v6 = lpCriticalSection[1].LockCount - 1 < 0;
  v51 = *(lpCriticalSection[2].LockCount + 8 * v4);
  if ( (v6 ^ v7) | v5 )
    v8 = v36;
  else
    v8 = *(lpCriticalSection[3].LockCount + 8 * v4);
  v43 = v8;
  LeaveCriticalSection(lpCriticalSection);
  switch ( lpCriticalSection[1].RecursionCount )
  {
    case 0:
    case 4:
      v9 = v51;
      if ( lpCriticalSection[1].LockCount != 1 && *&v51 <= v43 )
        v9 = *&v43;
      sub_12309A0(&chText, gpszTargetName, v9);
      goto LABEL_18;
    case 1:
    case 3:
    case 5:
    case 6:
    case 7:
      tcscpy_s(&Dst, 0x20u, L" KB");
      v10 = v51;
      if ( *&v51 <= 1048576.0 )
      {
        if ( *&v51 <= 1024.0 )
          goto LABEL_16;
        v11 = *&v51 * 0.0009765625;
        v35 = L" MB";
      }
      else
      {
        v11 = *&v51 * 0.00000095367431640625;
        v35 = L" GB";
      }
      *&v51 = v11;
      tcscpy_s(&Dst, 0x20u, v35);
      v10 = v51;
LABEL_16:
      swprintf_s(&chText, 0x20u, L"%s%0.1f", gpszTargetName, v10, HIDWORD(v10));
      wcscat_s(&chText, 0x20u, &Dst);
LABEL_18:
      SetBkColor(hdc, 0);
      SetTextColor(hdc, 0);
      v12 = DrawTextW(hdc, &chText, -1, &rc, 0x400u);
      v54.top = 0;
      v54.left = (v3 / 3.0 * 0.5);
      v54.right = v3 - v54.left;
      HIDWORD(v51) = v42 - v12;
      v54.bottom = v42 - v12 - 2;
      v13 = GetSysColor(5);
      if ( v50 && cy * v48 )
        memset32(v50, (v13 & 0xFF00) | (v13 << 16) | (v13 >> 16) & 0xFF, cy * v48);
      sub_1230D60(&ho, &v54, gColorGraphBackground);
      v14 = lpCriticalSection[1].LockCount;
      v15 = 0;
      v16 = v54.top;
      v44 = v54.top;
      if ( v14 > 0 )
      {
        v17 = v54.bottom;
        v18 = &v45[1].LockSemaphore;
        v19 = (v54.bottom - v54.top);
        do
        {
          v20 = *(*(v18 + 12) + 8 * v4) / *v18;
          v18 += 24;
          v37[v15++] = (v17 - v20 * v19);
        }
        while ( v15 < v14 );
      }
      if ( v16 < v54.bottom )
      {
        v21 = v45;
        v22 = v54.bottom;
        while ( 1 )
        {
          v23 = 0;
          v24 = 8553090;
          if ( v21[1].LockCount > 0 )
            break;
LABEL_52:
          v44 = ++v16;
          if ( v16 >= v22 )
            goto LABEL_53;
        }
        v25 = &v21[2];
        v52 = &v21[2];
        do
        {
          v26 = v37[v23];
          if ( v16 >= v26 )
          {
            v24 = *v25;
            HIDWORD(v43) = *v25;
            if ( v16 > v26 + 1 )
            {
              v38 = v24 >> 8;
              v25 = v52;
              v16 = v44;
              v24 = (((BYTE1(v24) + (256 - BYTE1(v24)) / 2) | ((BYTE2(v24) + (256 - BYTE2(v24)) / 2) << 8)) << 8) | (BYTE4(v43) + (256 - BYTE4(v43)) / 2);
            }
          }
          v21 = v45;
          ++v23;
          v25 += 6;
          v52 = v25;
        }
        while ( v23 < v45[1].LockCount );
        if ( v24 == 8553090 )
        {
LABEL_51:
          v22 = v54.bottom;
          goto LABEL_52;
        }
        v27 = v54.left;
        v28 = v16;
        v29 = v54.right;
        v52 = v16;
        if ( v54.left >= 0 )
        {
          if ( v54.left >= v48 )
            v27 = v48 - 1;
        }
        else
        {
          v27 = 0;
        }
        if ( v54.right >= 0 )
        {
          if ( v54.right >= v48 )
            v29 = v48 - 1;
        }
        else
        {
          v29 = 0;
        }
        if ( v16 >= 0 )
        {
          if ( v16 < cy )
          {
LABEL_46:
            if ( v16 >= 0 )
            {
              if ( v16 >= cy )
                v28 = cy - 1;
            }
            else
            {
              v28 = 0;
            }
            sub_1230A90(&ho, v52, v27, v28, v29, v24, 0);
            v21 = v45;
            goto LABEL_51;
          }
          v52 = (cy - 1);
        }
        else
        {
          v52 = 0;
        }
        v16 = v44;
        goto LABEL_46;
      }
LABEL_53:
      v30 = CreateSolidBrush(0x828282u);
      ++v54.right;
      v31 = v30;
      FrameRect(hdc, &v54, v30);
      DeleteObject(v31);
      rc.top = HIDWORD(v51);
      rc.bottom = v42;
      rc.left = 0;
      rc.right = v39;
      v32 = GetStockObject(17);
      SelectObject(hdc, v32);
      v33 = GetSysColor(5);
      SetBkColor(hdc, v33);
      SetTextColor(hdc, 0);
      DrawTextW(hdc, &chText, -1, &rc, 5u);
      BitBlt(v40, *v41, v41[1], v48, cy, hdc, 0, 0, 0xCC0020u);
      if ( hdc )
        DeleteDC(hdc);
      result = ho;
      if ( ho )
        result = DeleteObject(ho);
      return result;
    case 2:
    case 8:
    case 9:
      sub_1243C40(&chText, 0x20u, COERCE__INT64(*&v51 - v43 + v43));
      goto LABEL_18;
    default:
      goto LABEL_18;
  }
}
// 12BCBE0: using guessed type wchar_t aGb[4];
// 12E4E28: using guessed type int gScreenWidth;
// 1231470: using guessed type int var_F0[2];

//----- (01231A60) --------------------------------------------------------
HICON __cdecl PEDrawIcon(ProcessorInfo *pInfo, HDC hdc, int *nValue128, COLORREF clrBack, int a5, double a6)
{
  HDC v6; // eax
  LONG v7; // ebx
  signed int v8; // edx
  COLORREF clrBackground; // ecx
  void (__stdcall *DeleteObject)(HGDIOBJ); // edi
  unsigned int v11; // ecx
  ProcessorInfo *v12; // edi
  int v13; // ecx
  int v14; // edx
  int *i; // esi
  bool v16; // sf
  unsigned __int8 v17; // of
  unsigned int v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // eax
  int v22; // edx
  int v23; // edi
  int v24; // esi
  double v25; // xmm2_8
  double v26; // xmm1_8
  double v27; // xmm1_8
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // eax
  LONG v32; // eax
  int v33; // edi
  int v34; // esi
  int v35; // edx
  int v36; // edx
  int v37; // edi
  int v38; // edx
  int v39; // esi
  double v40; // xmm1_8
  double v41; // xmm1_8
  double v42; // xmm1_8
  int v43; // edi
  int v44; // eax
  int v45; // esi
  int v46; // edx
  int v47; // ecx
  int v48; // ebx
  int v49; // ecx
  int v50; // edx
  int *v51; // edi
  HBRUSH v52; // esi
  HICON v53; // esi
  ICONINFO piconinfo; // [esp+Ch] [ebp-80h]
  HDC hdc1; // [esp+20h] [ebp-6Ch]
  _DWORD *v57; // [esp+24h] [ebp-68h]
  int v58; // [esp+28h] [ebp-64h]
  double v59; // [esp+2Ch] [ebp-60h]
  int v60; // [esp+34h] [ebp-58h]
  int v61; // [esp+38h] [ebp-54h]
  int v62; // [esp+3Ch] [ebp-50h]
  int *v63; // [esp+40h] [ebp-4Ch]
  int v64; // [esp+44h] [ebp-48h]
  int v65; // [esp+48h] [ebp-44h]
  int v66; // [esp+4Ch] [ebp-40h]
  HGDIOBJ ho; // [esp+50h] [ebp-3Ch]
  int cy; // [esp+54h] [ebp-38h]
  int v69; // [esp+58h] [ebp-34h]
  HDC hDC; // [esp+5Ch] [ebp-30h]
  void *v71; // [esp+60h] [ebp-2Ch]
  LONG v72; // [esp+64h] [ebp-28h]
  int v73; // [esp+68h] [ebp-24h]
  int *v74; // [esp+6Ch] [ebp-20h]
  int *v75; // [esp+70h] [ebp-1Ch]
  int v76; // [esp+74h] [ebp-18h]
  RECT rc; // [esp+78h] [ebp-14h]
  COLORREF clrBacka; // [esp+A0h] [ebp+14h]

  v6 = 0;
  v63 = nValue128;
  v7 = nValue128[2] - *nValue128;
  v8 = nValue128[3] - nValue128[1];
  clrBackground = clrBack;
  if ( clrBack == -1 )
    clrBackground = gColorGraphBackground;
  hdc1 = hdc;
  cy = 0;
  v69 = 0;
  hDC = 0;
  ho = 0;
  v73 = v7;
  v72 = v8;
  v59 = 0.0;
  clrBacka = clrBackground;
  DeleteObject = ::DeleteObject;
  if ( hdc && (!v7 || !v8) )
    goto LABEL_111;
  sub_1230CA0(&ho, v7, v8);
  v11 = cy * v69;
  if ( v71 && v11 )
    memset32(v71, (clrBacka & 0xFF00) | (clrBacka << 16) | (clrBacka >> 16) & 0xFF, v11);
  v12 = pInfo;
  v13 = gScreenWidth;
  v62 = pInfo->mPosLast - 1;
  if ( v62 < 0 )
    v62 = gScreenWidth - 1;
  v14 = 0;
  for ( i = &pInfo->m_Buffer[0].field_4; ; i += 6 )
  {
    v75 = i;
    v17 = __OFSUB__(v14, v12->ProcessorCount);
    v16 = v14 - v12->ProcessorCount < 0;
    v65 = v14;
    if ( !(v16 ^ v17) )
      break;
    v18 = *(i - 1);
    v74 = *(i - 1);
    if ( clrBacka && v73 <= 20 && v72 <= 20 )
    {
      v19 = v18;
      v20 = v18 >> 16;
      v21 = v19 >> 8;
      if ( v21 <= v20 )
        v74 = (v74 < v20 ? 16711680 : 255);
      else
        v74 = (v74 < v21 ? 65280 : 255);
    }
    v22 = 0;
    v23 = -1;
    v66 = 0;
    if ( v13 > 0 )
    {
      v24 = 0;
      v64 = 0;
      v76 = v73 - 1;
      do
      {
        if ( v24 >= v73 + 1 )
          break;
        v25 = *(*v75 + 8 * ((v62 + v13 - v22) % v13));
        if ( v25 > v59 )
          v59 = *(*v75 + 8 * ((v62 + v13 - v22) % v13));
        if ( a6 == 0.0 )
          v26 = v25 / *(v75 - 3);
        else
          v26 = v25 / a6;
        v27 = v26 * v72;
        v28 = v72 - v27;
        if ( v23 != -1 && v25 != 0.0 )
        {
          v29 = v76;
          v30 = v72 - v27;
          v31 = v76 + 2;
          if ( v76 >= 0 )
          {
            if ( v76 >= v69 )
              v29 = v69 - 1;
          }
          else
          {
            v29 = 0;
          }
          if ( v31 >= 0 )
          {
            if ( v31 >= v69 )
              v31 = v69 - 1;
          }
          else
          {
            v31 = 0;
          }
          if ( v28 >= 0 )
          {
            if ( v28 >= cy )
              v30 = cy - 1;
          }
          else
          {
            v30 = 0;
          }
          if ( v23 >= 0 )
          {
            if ( v23 >= cy )
              v23 = cy - 1;
          }
          else
          {
            v23 = 0;
          }
          sub_1230A90(&ho, v30, v29, v23, v31, v74, 1);
          v13 = gScreenWidth;
        }
        v23 = v28;
        v22 = v66 + 1;
        v76 -= 2;
        v24 = v64 + 2;
        v66 = v22;
        v64 += 2;
      }
      while ( v22 < v13 );
      i = v75;
    }
    v12 = pInfo;
    v14 = v65 + 1;
  }
  v32 = v72;
  if ( v72 > 60 )
  {
    v33 = 0;
    if ( v63[3] > 0 )
    {
      v34 = 0;
      do
      {
        if ( v34 >= v32 )
          break;
        if ( !(v33 % 15) )
          sub_1230ED0(&ho, 0, v34, v73, v34, 0x828282u, 0);
        ++v33;
        v34 += 2;
        v32 = v72;
      }
      while ( v33 < v63[3] );
      v13 = gScreenWidth;
    }
    v12 = pInfo;
  }
  v35 = v12->ProcessorCount;
  while ( 1 )
  {
    v36 = v35 - 1;
    v61 = v36;
    if ( v36 < 0 )
      break;
    v37 = v12->ProcessorCount - v36 - 1;
    v76 = -1;
    v38 = 0;
    v66 = v37;
    v64 = 0;
    if ( v13 > 0 )
    {
      v39 = 0;
      v60 = 0;
      v74 = (v73 - 1);
      while ( 1 )
      {
        if ( v39 >= v73 + 1 )
          goto LABEL_108;
        v40 = *(pInfo->m_Buffer[v37].field_4 + 8 * ((v62 + v13 - v38) % v13));
        if ( v40 > v59 )
          v59 = *(pInfo->m_Buffer[v37].field_4 + 8 * ((v62 + v13 - v38) % v13));
        v41 = a6 == 0.0 ? v40 / *(&pInfo->m_dbMaxValue + 3 * v37) : v40 / a6;
        v42 = v41 * v72;
        v43 = v72 - v42;
        v44 = v76;
        v65 = v72 - v42;
        if ( v76 != -1 )
          break;
LABEL_107:
        v74 = (v74 - 2);
        v39 = v60 + 2;
        v37 = v66;
        v76 = v65;
        v38 = v64 + 1;
        v60 += 2;
        v64 = v38;
        if ( v38 >= v13 )
          goto LABEL_108;
      }
      v75 = v74;
      v45 = v74 + 2;
      v57 = (v74 + 2);
      v46 = v72 - v42;
      v58 = pInfo->m_Buffer[v66].m_Color;
      v47 = v76;
      if ( v74 < 0 )
      {
        v75 = 0;
        goto LABEL_73;
      }
      if ( v74 >= v69 )
      {
        v75 = (v69 - 1);
LABEL_73:
        v44 = v76;
      }
      if ( v45 >= 0 )
      {
        if ( v45 < v69 )
          v48 = v57;
        else
          v48 = v69 - 1;
      }
      else
      {
        v48 = 0;
      }
      if ( v43 >= 0 )
      {
        if ( v43 >= cy )
          v46 = cy - 1;
      }
      else
      {
        v46 = 0;
      }
      if ( v44 >= 0 )
      {
        if ( v44 >= cy )
          v47 = cy - 1;
      }
      else
      {
        v47 = 0;
      }
      sub_1230A90(&ho, v46, v75, v47, v48, v58, 0);
      v49 = v43 + 1;
      if ( v43 + 1 < v72 )
      {
        v50 = v76 + 1;
        v75 = v74;
        if ( v74 < 0 )
        {
          v51 = 0;
          goto LABEL_92;
        }
        if ( v74 >= v69 )
        {
          v51 = (v69 - 1);
LABEL_92:
          v75 = v51;
        }
        if ( v45 >= 0 )
        {
          if ( v45 >= v69 )
            v45 = v69 - 1;
        }
        else
        {
          v45 = 0;
        }
        if ( v49 >= 0 )
        {
          if ( v49 >= cy )
            v49 = cy - 1;
        }
        else
        {
          v49 = 0;
        }
        if ( v50 >= 0 )
        {
          if ( v50 >= cy )
            v50 = cy - 1;
        }
        else
        {
          v50 = 0;
        }
        sub_1230A90(&ho, v49, v75, v50, v45, pInfo->m_Buffer[v66].m_Color, 0);
      }
      v13 = gScreenWidth;
      goto LABEL_107;
    }
LABEL_108:
    v35 = v61;
    v12 = pInfo;
  }
  v52 = CreateSolidBrush(0x828282u);
  rc.left = 0;
  rc.right = v73;
  rc.bottom = v72;
  rc.top = 0;
  FrameRect(hDC, &rc, v52);
  DeleteObject = ::DeleteObject;
  ::DeleteObject(v52);
  if ( hdc1 )
  {
    BitBlt(hdc1, *v63, v63[1], v69, cy, hDC, 0, 0, 0xCC0020u);
    v6 = hDC;
LABEL_111:
    v53 = 0;
    goto LABEL_113;
  }
  piconinfo.hbmColor = ho;
  piconinfo.hbmMask = ho;
  piconinfo.fIcon = 1;
  piconinfo.xHotspot = 0;
  piconinfo.yHotspot = 0;
  v53 = CreateIconIndirect(&piconinfo);
  v6 = hDC;
LABEL_113:
  if ( v6 )
    DeleteDC(v6);
  if ( ho )
    DeleteObject(ho);
  return v53;
}
// 12E4E28: using guessed type int gScreenWidth;

//----- (01231FD0) --------------------------------------------------------
char *__cdecl sub_1231FD0(float a1, HDC a2, int *a3, COLORREF a4)
{
  char *result; // eax
  signed int v5; // ecx
  COLORREF v6; // ebx
  unsigned int v7; // ecx
  float v8; // xmm0_4
  LONG v9; // edi
  float v10; // xmm0_4
  LONG v11; // ebx
  HBRUSH v12; // esi
  int a2a; // [esp+8h] [ebp-64h]
  int v14; // [esp+Ch] [ebp-60h]
  char *v15; // [esp+10h] [ebp-5Ch]
  int v16; // [esp+14h] [ebp-58h]
  struct _FILETIME FileTime; // [esp+18h] [ebp-54h]
  int *v18; // [esp+20h] [ebp-4Ch]
  char *v19; // [esp+24h] [ebp-48h]
  int v20; // [esp+28h] [ebp-44h]
  HDC hdc; // [esp+2Ch] [ebp-40h]
  HGDIOBJ ho; // [esp+30h] [ebp-3Ch]
  int cy; // [esp+34h] [ebp-38h]
  int v24; // [esp+38h] [ebp-34h]
  HDC hDC; // [esp+3Ch] [ebp-30h]
  void *v26; // [esp+40h] [ebp-2Ch]
  float v27; // [esp+44h] [ebp-28h]
  struct _SYSTEMTIME SystemTime; // [esp+48h] [ebp-24h]
  RECT rc; // [esp+58h] [ebp-14h]

  v27 = a1;
  result = (a3[2] - *a3);
  v5 = a3[3] - a3[1];
  v6 = a4;
  if ( a4 == -1 )
    v6 = gColorGraphBackground;
  hdc = a2;
  v18 = a3;
  cy = 0;
  v24 = 0;
  hDC = 0;
  ho = 0;
  v19 = result;
  v20 = v5;
  if ( !a2 || result && v5 )
  {
    sub_1230CA0(&ho, result, v5);
    v7 = cy * v24;
    if ( v26 && v7 )
      memset32(v26, (v6 & 0xFF00) | (v6 << 16) | (v6 >> 16) & 0xFF, v7);
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v14 = 0;
    v8 = (*&FileTime - *LODWORD(v27));
    v27 = v8;
    v9 = v19;
    v10 = (*&FileTime - *&gProcessorCreateTime);
    v11 = v20;
    v15 = v19;
    v16 = v20;
    a2a = &v19[-((v27 / v10) * v19)];
    sub_1230D60(&ho, &a2a, 0x9ECA9Eu);
    v12 = CreateSolidBrush(0x828282u);
    rc.left = 0;
    rc.top = 0;
    rc.right = v9;
    rc.bottom = v11;
    FrameRect(hDC, &rc, v12);
    DeleteObject(v12);
    BitBlt(hdc, *v18, v18[1], v24, cy, hDC, 0, 0, 0xCC0020u);
    if ( hDC )
      DeleteDC(hDC);
    result = ho;
    if ( ho )
      result = DeleteObject(ho);
  }
  return result;
}
// 12EB1C0: using guessed type FILETIME gProcessorCreateTime;

//----- (012321A0) --------------------------------------------------------
int __cdecl GetPalletteInfo(CGraphData *pData, int *Red, int *Green)
{
  int cxx; // edi

  EnterCriticalSection(&pData->m_Lock);
  cxx = pData->field_18 - 1;
  if ( cxx < 0 )
    cxx = gScreenWidth - 1;
  *Red = *(pData->field_34 + 8 * cxx);
  if ( Green && pData->field_1C > 1 )
    *Green = *(pData->field_4C + 8 * cxx);
  LeaveCriticalSection(&pData->m_Lock);
  return cxx;
}
// 12E4E28: using guessed type int gScreenWidth;

//----- (01232200) --------------------------------------------------------
int __cdecl sub_1232200(char a1, wchar_t *a2, size_t SizeInWords, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // al
  char v7; // dl
  int v8; // esi
  __int64 v9; // xmm3_8
  __int64 v10; // xmm0_8
  __int64 v11; // xmm1_8
  __int64 v12; // xmm4_8
  __int64 v13; // xmm2_8
  double v14; // xmm0_8
  double v15; // xmm1_8
  signed int v16; // edi
  size_t v17; // ecx
  double v18; // xmm0_8
  int v19; // eax
  const wchar_t *v20; // eax
  char v22; // [esp+1Eh] [ebp-1Eh]
  char v23; // [esp+1Fh] [ebp-1Dh]
  __int64 v24; // [esp+20h] [ebp-1Ch]
  double v25; // [esp+28h] [ebp-14h]
  __int64 v26; // [esp+30h] [ebp-Ch]

  v6 = 0;
  v7 = 0;
  v22 = 0;
  v8 = 0;
  v23 = 0;
  if ( !a1 )
    return sub_1243C40(a2, SizeInWords, COERCE__INT64(*&a4 + *&a5));
  v9 = a6;
  v10 = a5;
  if ( *&a6 <= *&a5 )
    v11 = a6;
  else
    v11 = a5;
  if ( *&a5 <= *&a6 )
    v10 = a6;
  v12 = a4;
  if ( *&v10 <= *&a4 )
    v13 = v10;
  else
    v13 = a4;
  if ( *&a4 > *&v10 )
    v10 = a4;
  v24 = v10;
  v14 = *&v13;
  if ( *&v11 <= *&v13 )
    v13 = v11;
  if ( v14 <= *&v11 )
    v14 = *&v11;
  v15 = *&dbl_12BCDD8;
  *a2 = 0;
  v16 = 0;
  v17 = SizeInWords;
  v25 = v14;
  v26 = v13;
  do
  {
    v18 = *(&v24 + v16);
    if ( v18 != v15 )
    {
      if ( v8 > 0 )
      {
        v18 = *(&v24 + v16);
        v9 = a6;
        v8 += swprintf_s(&a2[v8], v17 - v8, L"\n");
        v15 = *&dbl_12BCDD8;
        v12 = a4;
        v17 = SizeInWords;
        v6 = v22;
        v7 = v23;
      }
      if ( v18 != *&a5 || v7 )
      {
        if ( v18 != *&v12 || v6 )
        {
          v19 = swprintf_s(&a2[v8], v17 - v8, L"O: ");
        }
        else
        {
          v20 = L"R";
          if ( *&v9 == v15 )
            v20 = L"R+O";
          v19 = swprintf_s(&a2[v8], v17 - v8, L"%s: ", v20);
          v22 = 1;
        }
      }
      else
      {
        v19 = swprintf_s(&a2[v8], v17 - v8, L"W: ");
        v23 = 1;
      }
      v9 = a6;
      v15 = *&dbl_12BCDD8;
      v8 += sub_1243C40(&a2[v19 + v8], SizeInWords - (v19 + v8), *(&v24 + v16)) + v19;
      v12 = a4;
      v17 = SizeInWords;
      v6 = v22;
      v7 = v23;
    }
    ++v16;
  }
  while ( v16 < 3 );
  return v8;
}
// 12BCBB8: using guessed type wchar_t aR[2];
// 12BCBBC: using guessed type wchar_t aRO[4];

//----- (01232410) --------------------------------------------------------
errno_t __cdecl sub_1232410(wchar_t *a1, rsize_t SizeInWords, int a3, __int64 a4)
{
  double v4; // xmm0_8
  const wchar_t *v6; // [esp+4h] [ebp-50h]
  wchar_t Dst; // [esp+10h] [ebp-44h]

  tcscpy_s(&Dst, 0x20u, L" KB");
  v4 = *&a4;
  if ( *&a4 > 1048576.0 )
  {
    v4 = *&a4 * 0.00000095367431640625;
    v6 = L" GB";
LABEL_5:
    tcscpy_s(&Dst, 0x20u, v6);
    goto LABEL_6;
  }
  if ( *&a4 > 1024.0 )
  {
    v4 = *&a4 * 0.0009765625;
    v6 = L" MB";
    goto LABEL_5;
  }
LABEL_6:
  swprintf_s(a1, SizeInWords, L"%s%0.1f", a3, LODWORD(v4), HIDWORD(v4));
  return wcscat_s(a1, SizeInWords, &Dst);
}
// 12BCBE0: using guessed type wchar_t aGb[4];

//----- (012324C0) --------------------------------------------------------
void __cdecl sub_12324C0(int a1)
{
  wchar_t *v1; // edi
  __int16 v2; // si
  int v3; // esi
  int v4; // edx
  _DWORD *v5; // edx
  int v6; // eax
  __int16 *v7; // ecx
  __int16 v8; // ax
  wchar_t *v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  __int16 *v13; // ecx
  __int16 v14; // ax
  int v15; // ecx
  const wchar_t *v16; // eax
  int v17; // ecx
  __int64 v18; // ST14_8
  __int64 v19; // [esp+10h] [ebp-2D4h]
  int v20; // [esp+14h] [ebp-2D0h]
  int v21; // [esp+14h] [ebp-2D0h]
  struct _FILETIME LocalFileTime; // [esp+24h] [ebp-2C0h]
  FILETIME FileTime; // [esp+2Ch] [ebp-2B8h]
  int v24; // [esp+34h] [ebp-2B0h]
  struct _SYSTEMTIME SystemTime; // [esp+38h] [ebp-2ACh]
  struct tagRECT Rect; // [esp+48h] [ebp-29Ch]
  wchar_t Dst; // [esp+58h] [ebp-28Ch]
  WCHAR TimeStr; // [esp+260h] [ebp-84h]

  v1 = (a1 + 4);
  *(a1 + 4) = 0;
  GetClientRect(*a1, &Rect);
  v2 = *(a1 + 2052);
  if ( (Rect.right - v2 - 1) / 2 <= gScreenWidth )
  {
    EnterCriticalSection(*(a1 + 2056));
    v3 = (*(*(a1 + 2056) + 24) - (Rect.right - *(a1 + 2052)) / 2 + gScreenWidth - 1) % gScreenWidth;
    v4 = *(a1 + 2056);
    if ( !*(*(v4 + 2156) + 4 * v3) )
    {
LABEL_52:
      LeaveCriticalSection(*(a1 + 2056));
      *(a1 + 2052) += 20;
      *(a1 + 2054) += 20;
      goto LABEL_53;
    }
    switch ( *(v4 + 32) )
    {
      case 0:
        FormatTex(v1, L"CPU\n");
        break;
      case 2:
        FormatTex(v1, L"I/O\n");
        break;
      case 4:
        FormatTex(v1, L"GPU\n");
        break;
      case 8:
        FormatTex(v1, L"Disk\n");
        break;
      case 9:
        FormatTex(v1, L"Network\n");
        break;
      default:
        break;
    }
    v5 = *(a1 + 2056);
    if ( v5[536] )
    {
      v6 = v5[8];
      if ( !v6 || v6 == 4 )
      {
        v7 = (a1 + 4);
        v24 = a1 + 6;
        do
        {
          v8 = *v7;
          ++v7;
        }
        while ( v8 );
        sub_1230E00((a1 + 4 + 2 * ((v7 - v24) >> 1)), 1024 - ((v7 - v24) >> 1), gpszTargetName, *(v5[13] + 8 * v3));
        wcscat_s(v1, 0x400u, L"\n");
      }
      v9 = *(*(*(a1 + 2056) + 2144) + 4 * v3);
      if ( !v9 || !*v9 )
        goto LABEL_51;
    }
    else
    {
      if ( !v5[543] )
      {
        *v1 = 0;
        if ( *(v5[539] + 4 * v3) )
        {
          v15 = v5[8];
          switch ( v15 )
          {
            case 0:
            case 4:
              v16 = L"GPU\n";
              v19 = *(v5[13] + 8 * v3);
              if ( v15 != 4 )
                v16 = L"CPU\n";
              sub_12309F0(v1, v16, v19);
              break;
            case 1:
              sub_1230A40(v1, L"System Commit\n", *(v5[13] + 8 * v3));
              break;
            case 2:
              FormatTex(v1, L"I/O\n");
              goto LABEL_48;
            case 3:
              sub_1230A40(v1, L"Physical Memory\n", *(v5[13] + 8 * v3));
              break;
            case 5:
              sub_1230A40(v1, L"GPU System Memory\n", *(v5[13] + 8 * v3));
              break;
            case 6:
              sub_1230A40(v1, L"GPU Dedicated Memory\n", *(v5[13] + 8 * v3));
              break;
            case 7:
              sub_1230A40(v1, L"GPU Committed Memory\n", *(v5[13] + 8 * v3));
              break;
            case 8:
              FormatTex(v1, L"Disk\n");
              goto LABEL_48;
            case 9:
              FormatTex(v1, L"Network\n");
LABEL_48:
              v17 = *(a1 + 2056);
              v18 = *(*(v17 + 76) + 8 * v3);
              sub_1232200(1, v1, 0x400u, COERCE__INT64(*(*(v17 + 52) + 8 * v3) - *&v18), v18, dbl_12BCDD8);
              break;
            default:
              break;
          }
          if ( *v1 )
            wcscat_s(v1, 0x400u, L"\n");
        }
        goto LABEL_51;
      }
      v20 = v5[542];
      if ( v5[8] == 4 )
      {
        FormatTex(v1, L"GPU Engine %d: ", v20);
      }
      else
      {
        v10 = FormatTex(v1, L"CPU %d", v20);
        v11 = *(a1 + 2056);
        v12 = *(v11 + 2160);
        if ( v12 != -1 )
        {
          v21 = *(v11 + 2164);
          if ( v12 == 1 )
            swprintf_s((a1 + 4 + 2 * v10), 1024 - v10, L" (Node %d)", v21);
          else
            swprintf_s((a1 + 4 + 2 * v10), 1024 - v10, L" (Core %d)", v21);
        }
      }
      wcscat_s(v1, 0x400u, L" ");
      v13 = (a1 + 4);
      do
      {
        v14 = *v13;
        ++v13;
      }
      while ( v14 );
      sub_1230E00(
        (a1 + 4 + 2 * ((v13 - a1 - 6) >> 1)),
        1024 - ((v13 - a1 - 6) >> 1),
        gpszTargetName,
        *(*(*(a1 + 2056) + 52) + 8 * v3));
      if ( !*(*(*(*(a1 + 2056) + 2172) + 2144) + 4 * v3) )
      {
LABEL_51:
        FileTime = (*(*(a1 + 2056) + 2148) + 10000000i64 * *(*(*(a1 + 2056) + 2156) + 4 * v3));
        FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
        FileTimeToSystemTime(&LocalFileTime, &SystemTime);
        GetTimeFormatW(0x400u, 0, &SystemTime, 0, &TimeStr, 64);
        wcscat_s(v1, 0x400u, &TimeStr);
        goto LABEL_52;
      }
      if ( *v1 )
        wcscat_s(v1, 0x400u, L"\n");
      tcscpy_s(&Dst, 0x104u, *(*(*(*(a1 + 2056) + 2172) + 2144) + 4 * v3));
      if ( wcschr(&Dst, 0xAu) )
        *wcschr(&Dst, 0xAu) = 32;
      v9 = &Dst;
    }
    wcscat_s(v1, 0x400u, v9);
    wcscat_s(v1, 0x400u, L"\n");
    goto LABEL_51;
  }
  *(a1 + 2054) += 10;
  *(a1 + 2052) = v2 + 10;
LABEL_53:
  *(a1 + 2060) = 1;
}
// 12BCC54: using guessed type wchar_t aCpu[5];
// 12BCC9C: using guessed type wchar_t aNodeD[11];
// 12BCCCC: using guessed type wchar_t aPhysicalMemory[17];
// 12BCCF0: using guessed type wchar_t aSystemCommit[15];
// 12BCD10: using guessed type wchar_t aGpuDedicatedMe[22];
// 12BCD3C: using guessed type wchar_t aGpuSystemMemor[19];
// 12BCD64: using guessed type wchar_t aGpuCommittedMe[22];
// 12E4E28: using guessed type int gScreenWidth;

//----- (01232A70) --------------------------------------------------------
int __cdecl IsFocusWindow(HWND hWnd)
{
  HWND hWndParent; // esi
  HWND hParentWnd; // edi
  HWND hFocus; // eax
  int result; // eax
  HWND v5; // [esp+Ch] [ebp-4h]

  hWndParent = hWnd;
  if ( GetParent(hWnd) )
  {
    hWndParent = GetParent(hWnd);
    hParentWnd = GetParent(hWndParent);
  }
  else
  {
    hParentWnd = v5;
  }
  if ( !IsWindowVisible(hWndParent) )
    goto __returnFALSE;
  for ( hFocus = GetFocus(); hWndParent != hFocus; hFocus = GetParent(hFocus) )
  {
    if ( hParentWnd == hFocus )
      break;
    if ( !hFocus )
      goto __returnFALSE;
  }
  if ( hFocus && (hWndParent == hFocus || hParentWnd == hFocus) )
    result = 1;
  else
__returnFALSE:
    result = 0;
  return result;
}

//----- (01232AE0) --------------------------------------------------------
LPBYTE __thiscall sub_1232AE0(LPBYTE lpData, HKEY phkResult)
{
  HKEY v2; // eax
  LPBYTE v3; // edi
  const WCHAR *v4; // esi
  const WCHAR *v5; // ebx
  BYTE *v7; // eax
  void *v8; // ecx
  const WCHAR *v9; // esi
  int i; // ebx
  unsigned int v11; // eax
  const WCHAR *v12; // esi
  DWORD cbData; // [esp+Ch] [ebp-8h]
  DWORD v14; // [esp+10h] [ebp-4h]

  v2 = phkResult;
  v3 = lpData;
  *lpData = 0;
  *(lpData + 1) = 0;
  *(lpData + 2) = 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return v3;
    v4 = L"Explain 009";
    v5 = L"Last Help";
  }
  else
  {
    v4 = L"Counter 009";
    v5 = L"Last Counter";
  }
  phkResult = 0;
  cbData = 4;
  if ( !RegOpenKeyExW(
          HKEY_LOCAL_MACHINE,
          L"software\\microsoft\\windows nt\\currentversion\\perflib",
          0,
          0x20019u,
          &phkResult) )
  {
    if ( RegQueryValueExW(phkResult, v5, 0, 0, v3, &cbData) )
    {
      RegCloseKey(phkResult);
      return v3;
    }
    RegCloseKey(phkResult);
    if ( !RegQueryValueExW(HKEY_PERFORMANCE_DATA, v4, 0, 0, 0, &v14) )
    {
      v7 = operator new[](2 * v14);
      *(v3 + 2) = v7;
      if ( RegQueryValueExW(HKEY_PERFORMANCE_DATA, v4, 0, 0, v7, &v14)
        || (v8 = operator new[](4 * (*v3 + 1)), (*(v3 + 1) = v8) == 0) )
      {
        j_j__free(*(v3 + 2));
        return v3;
      }
      memset(v8, 0, 4 * *v3 + 4);
      v9 = *(v3 + 2);
      for ( i = lstrlenW(*(v3 + 2)); i; i = lstrlenW(v9) )
      {
        v11 = _wtoi(v9);
        if ( v11 > *v3 )
          break;
        v12 = &v9[i + 1];
        *(*(v3 + 1) + 4 * v11) = v12;
        v9 = &v12[lstrlenW(v12) + 1];
      }
    }
  }
  return v3;
}
// 12BCE14: using guessed type wchar_t aExplain009[12];
// 12BCE2C: using guessed type wchar_t aLastHelp[10];

//----- (01232C80) --------------------------------------------------------
void __thiscall sub_1232C80(void **this)
{
  void **v1; // esi
  void *v2; // ST00_4

  v1 = this;
  j_j__free(this[1]);
  v2 = v1[2];
  v1[1] = 0;
  j_j__free(v2);
  v1[2] = 0;
  *v1 = 0;
}

//----- (01232CB0) --------------------------------------------------------
int __thiscall sub_1232CB0(_DWORD *this, LPCWSTR lpsz)
{
  _DWORD *v2; // edi
  signed int v3; // esi

  v2 = this;
  if ( IsBadStringPtrW(lpsz, 0xFFFFFFFF) || !*v2 || !v2[1] )
    return 0;
  v3 = 1;
  if ( *v2 < 1u )
    return 0;
  while ( !*(v2[1] + 4 * v3) || _wcsicmp(lpsz, *(v2[1] + 4 * v3)) )
  {
    if ( ++v3 > *v2 )
      return 0;
  }
  return v3;
}

//----- (01232D20) --------------------------------------------------------
int __thiscall sub_1232D20(unsigned int *this, unsigned int a2)
{
  int result; // eax

  if ( a2 <= *this )
    result = *(this[1] + 4 * a2);
  else
    result = 0;
  return result;
}

//----- (01232D40) --------------------------------------------------------
LRESULT __cdecl MSGHANDLER::HandleCommand(MSGHANDLER *pMsgHandler, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  int nIndex; // ecx
  MSGFUNC *pMsgFuncs; // esi
  LRESULT result; // eax

  nIndex = 0;
  pMsgFuncs = pMsgHandler->MsgFuncs;
  if ( pMsgHandler->Number <= 0 )
  {
LABEL_4:
    switch ( pMsgHandler->dwWndType )
    {
      case NormalWindow:
        result = DefWindowProcW(hWnd, WM_COMMAND, wParam, lParam);
        break;
      case Dialog:
        result = DefDlgProcW(hWnd, WM_COMMAND, wParam, lParam);
        break;
      case MdiChild:
        result = DefMDIChildProcW(hWnd, WM_COMMAND, wParam, lParam);
        break;
      case FrameWindow:
        result = DefFrameProcW(hWnd, 0, WM_COMMAND, wParam, lParam);
        break;
      default:
        result = 0;
        break;
    }
  }
  else
  {
    while ( LOWORD(pMsgFuncs[nIndex].Msg) != wParam )
    {
      if ( ++nIndex >= pMsgHandler->Number )
        goto LABEL_4;
    }
    result = (pMsgFuncs[nIndex].Handler)(hWnd, wParam, wParam >> 16, lParam);
  }
  return result;
}

//----- (01232E00) --------------------------------------------------------
LRESULT __cdecl MSGHANDLER::HandleMessage(MSGHANDLER *pMsgHandler, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int Index; // eax
  MSGFUNC *pMsgFuncs; // esi
  LRESULT result; // eax

  Index = 0;
  pMsgFuncs = pMsgHandler->MsgFuncs;
  if ( pMsgHandler->Number <= 0 )
  {
LABEL_4:
    switch ( pMsgHandler->dwWndType )
    {
      case NormalWindow:
        result = DefWindowProcW(hWnd, Msg, wParam, lParam);
        break;
      case Dialog:
        result = DefDlgProcW(hWnd, Msg, wParam, lParam);
        break;
      case MdiChild:
        result = DefMDIChildProcW(hWnd, Msg, wParam, lParam);
        break;
      case FrameWindow:
        result = DefFrameProcW(hWnd, NULL, Msg, wParam, lParam);
        break;
      default:
        result = 0;
        break;
    }
  }
  else
  {
    while ( pMsgFuncs[Index].Msg != Msg )
    {
      if ( ++Index >= pMsgHandler->Number )
        goto LABEL_4;
    }
    result = (pMsgFuncs[Index].Handler)(hWnd, Msg, wParam, lParam);
  }
  return result;
}

//----- (01232EC0) --------------------------------------------------------
char __cdecl CDriver::LoadFromResource(LPCTSTR lpszResName, const TCHAR *lpszFileName)
{
  HRSRC hResc; // eax
  HRSRC hResc_; // edi
  HGLOBAL hResGlobal; // esi
  DWORD dwSize; // edi
  const void *pBuffer; // esi
  FILE *p; // [esp+4h] [ebp-4h]

  hResc = FindResourceW(NULL, lpszResName, L"BINRES");
  hResc_ = hResc;
  if ( !hResc )
    return 0;
  hResGlobal = LoadResource(NULL, hResc);
  dwSize = SizeofResource(NULL, hResc_);
  pBuffer = LockResource(hResGlobal);
  if ( _wfopen_s(&p, lpszFileName, L"wb") )
    return FALSE;
  fwrite(pBuffer, 1u, dwSize, p);
  fclose(p);
  return TRUE;
}

//----- (01232F50) --------------------------------------------------------
BOOL __cdecl CDriver::OpenEx(TCHAR *lpszName, TCHAR *lpszPathName, HANDLE *pHandles)
{
  BOOL result; // eax
  HMODULE hModule; // eax
  void (__stdcall *RtlInitUnicodeString)(); // eax
  HMODULE hNTDllHandle; // eax
  int (__stdcall *RtlNtStatusToDosError)(); // eax
  HMODULE v8; // eax
  DWORD dwError; // eax
  HANDLE DriverHandle; // eax
  UNICODE_STRING strDriverName; // [esp+8h] [ebp-A40h]
  TCHAR *pszPathName; // [esp+10h] [ebp-A38h]
  HKEY hKey; // [esp+14h] [ebp-A34h]
  int dwData; // [esp+18h] [ebp-A30h]
  TCHAR szDriverName[260]; // [esp+1Ch] [ebp-A2Ch]
  TCHAR szName[260]; // [esp+224h] [ebp-824h]
  TCHAR szFileName[260]; // [esp+42Ch] [ebp-61Ch]
  TCHAR szKeyName[260]; // [esp+634h] [ebp-414h]
  TCHAR szSubKeyName[260]; // [esp+83Ch] [ebp-20Ch]

  pszPathName = lpszPathName;
  TmAdjustPrivilege(L"SeLoadDriverPrivilege");
  stprintf(szSubKeyName, L"System\\CurrentControlSet\\Services\\%s", lpszName);
  if ( RegCreateKey(HKEY_LOCAL_MACHINE, szSubKeyName, &hKey) )
    return 0;
  dwData = 1;
  RegSetValueEx(hKey, L"Type", 0, 4u, &dwData, 4u);
  dwData = 1;
  RegSetValueEx(hKey, L"ErrorControl", 0, 4u, &dwData, 4u);
  dwData = 3;
  RegSetValueEx(hKey, L"Start", 0, 4u, &dwData, 4u);
  stprintf(szName, L"\\??\\%s", pszPathName);
  RegSetValueEx(hKey, L"ImagePath", 0, 1u, szName, 2 * wcslen(szName));
  RegCloseKey(hKey);
  hModule = GetModuleHandle(L"ntdll.dll");
  pszPathName = GetProcAddress(hModule, "NtLoadDriver");
  stprintf(szDriverName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s", lpszName);
  RtlInitUnicodeString = ::RtlInitUnicodeString;
  if ( !::RtlInitUnicodeString )
  {
    hNTDllHandle = GetModuleHandle(L"ntdll.dll");
    RtlInitUnicodeString = GetProcAddress(hNTDllHandle, "RtlInitUnicodeString");
    ::RtlInitUnicodeString = RtlInitUnicodeString;
  }
  RtlInitUnicodeString();
  pszPathName = (pszPathName)(&strDriverName);
  stprintf(szKeyName, L"%s\\Enum", szSubKeyName);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);
  stprintf(szKeyName, L"%s\\Security", szSubKeyName);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKeyName);
  if ( pszPathName && pszPathName != STATUS_IMAGE_ALREADY_LOADED )
  {
    RtlNtStatusToDosError = RtlNtStatusToDosError_0;
    if ( !RtlNtStatusToDosError_0 )
    {
      v8 = GetModuleHandle(L"ntdll.dll");
      RtlNtStatusToDosError = GetProcAddress(v8, "RtlNtStatusToDosError");
      RtlNtStatusToDosError_0 = RtlNtStatusToDosError;
    }
    dwError = RtlNtStatusToDosError();
    SetLastError(dwError);
    result = 0;
  }
  else
  {
    stprintf(szFileName, L"\\\\.\\%s", lpszName);
    DriverHandle = CreateFile(szFileName, 0xC0000000, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    *pHandles = DriverHandle;
    if ( DriverHandle == INVALID_HANDLE_VALUE )
    {
      stprintf(szFileName, L"\\\\.\\Global\\%s", lpszName);
      *pHandles = CreateFile(szFileName, 0xC0000000, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    result = *pHandles + 1 != NULL;
  }
  return result;
}
// 12E4E2C: using guessed type int RtlNtStatusToDosError_0;
// 12E4E30: using guessed type int RtlInitUnicodeString;

//----- (01233260) --------------------------------------------------------
BOOL __cdecl CDriver::Open(TCHAR *ArgList, HANDLE *phHandle)
{
  HANDLE Handle; // eax
  TCHAR FileName[260]; // [esp+8h] [ebp-20Ch]

  stprintf(FileName, L"\\\\.\\%s", ArgList);
  Handle = CreateFile(FileName, 0xC0000000, 0, 0, 3u, FILE_ATTRIBUTE_NORMAL, 0);
  *phHandle = Handle;
  if ( Handle == INVALID_HANDLE_VALUE )
  {
    stprintf(FileName, L"\\\\.\\Global\\%s", ArgList);
    *phHandle = CreateFile(FileName, 0xC0000000, 0, 0, 3u, FILE_ATTRIBUTE_NORMAL, 0);
  }
  return *phHandle + 1 != NULL;
}

//----- (01233310) --------------------------------------------------------
CList *__stdcall CList::Append(CList *pList, _DWORD *a2, _DWORD *a3)
{
  CList *result; // eax

  result = sub_1234360(pList, a2);
  if ( result != -8 )
  {
    result->field_8 = *a3;
    result[1].Prev = a3[1];
  }
  return result;
}

//----- (01233340) --------------------------------------------------------
char __cdecl sub_1233340(int a1, int a2, int a3, int a4, int a5, int a6, WPARAM wParam)
{
  int v7; // ecx
  unsigned int v8; // edi
  CList *v9; // esi
  unsigned int v10; // ebx
  unsigned int v11; // ebx
  signed int v12; // edi
  unsigned int v13; // eax
  void *v14; // ebx
  ULONG v15; // edi
  ULONG v16; // eax
  unsigned int v17; // esi
  unsigned int v18; // edx
  unsigned int v19; // eax
  float v20; // xmm2_4
  float v21; // xmm0_4
  float v22; // ST4C_4
  float v23; // ST40_4
  float v24; // xmm0_4
  HWND v25; // ST14_4
  bool v26; // al
  char v27; // ST57_1
  HWND v28; // ST14_4
  unsigned __int8 v29; // al
  char v30; // ST57_1
  float v31; // xmm0_4
  HWND v32; // ST14_4
  unsigned __int8 v33; // al
  char v34; // ST57_1
  float v35; // xmm0_4
  HWND v36; // ST14_4
  unsigned __int8 v37; // al
  char v38; // ST57_1
  float v39; // xmm0_4
  int v41; // [esp+24h] [ebp-FD0h]
  unsigned int v42; // [esp+28h] [ebp-FCCh]
  unsigned int v43; // [esp+2Ch] [ebp-FC8h]
  ULONG v44; // [esp+38h] [ebp-FBCh]
  int v45; // [esp+3Ch] [ebp-FB8h]
  int v46; // [esp+40h] [ebp-FB4h]
  unsigned int v47; // [esp+44h] [ebp-FB0h]
  char v48; // [esp+4Fh] [ebp-FA5h]
  D3DKMT_QUERYSTATISTICS v49; // [esp+50h] [ebp-FA4h]
  D3DKMT_QUERYSTATISTICS v50; // [esp+370h] [ebp-C84h]
  unsigned int v51; // [esp+688h] [ebp-96Ch]
  D3DKMT_QUERYSTATISTICS v52; // [esp+690h] [ebp-964h]
  ULONG v53; // [esp+9A8h] [ebp-64Ch]
  D3DKMT_QUERYSTATISTICS v54; // [esp+9B0h] [ebp-644h]
  ULONG v55; // [esp+CC8h] [ebp-32Ch]
  D3DKMT_QUERYSTATISTICS v56; // [esp+CD0h] [ebp-324h]

  v7 = a6;
  v48 = 0;
  v8 = 0;
  v9 = gAdapterList->Prev;
  v10 = 0;
  v42 = 0;
  v46 = 0;
  v45 = 0;
  v41 = 0;
  if ( gAdapterList->Prev == gAdapterList )
  {
    v17 = 0;
  }
  else
  {
    v43 = 0;
    v47 = 0;
    do
    {
      memset(&v56, 0, 0x320u);
      v56.Type = 0;
      v56.AdapterLuid.LowPart = v9->field_8;
      v56.AdapterLuid.HighPart = v9[1].Prev;
      if ( !D3DKMTQueryStatistics(&v56) )
      {
        v11 = 0;
        v44 = v56.QueryResult.SegmentInformationV1.BytesCommitted;
        if ( v56.QueryResult.SegmentInformationV1.BytesCommitted )
        {
          v12 = 1;
          do
          {
            memset(&v50, 0, 0x320u);
            v50.Type = 6;
            v50.AdapterLuid.LowPart = v9->field_8;
            v50.AdapterLuid.HighPart = v9[1].Prev;
            v50.hProcess = a1;
            v51 = v11;
            if ( !D3DKMTQueryStatistics(&v50) && v12 & gdwGpuNodeUsageMask )
            {
              ++v42;
              v13 = (v50.QueryResult.SegmentInformation.CommitLimit + __PAIR__(v43, v47)) >> 32;
              v47 += v50.QueryResult.SegmentInformationV1.CommitLimit;
              v43 = v13;
            }
            ++v11;
            v12 = __ROL4__(v12, 1);
          }
          while ( v11 < v44 );
        }
        if ( v48 )
        {
          v14 = a1;
        }
        else
        {
          memset(&v49, 0, 0x320u);
          v14 = a1;
          v49.Type = 1;
          v49.hProcess = a1;
          v49.AdapterLuid.LowPart = v9->field_8;
          v49.AdapterLuid.HighPart = v9[1].Prev;
          if ( !D3DKMTQueryStatistics(&v49) )
          {
            v41 = v49.QueryResult.SegmentInformationV1.BytesResident >> 10;
            v48 = 1;
          }
        }
        v15 = 0;
        if ( v56.QueryResult.SegmentInformationV1.CommitLimit )
        {
          do
          {
            memset(&v52, 0, 0x320u);
            v52.Type = 4;
            v52.hProcess = v14;
            v52.AdapterLuid.LowPart = v9->field_8;
            v52.AdapterLuid.HighPart = v9[1].Prev;
            v53 = v15;
            if ( D3DKMTQueryStatistics(&v52) )
              goto LABEL_23;
            memset(&v54, 0, 0x320u);
            v54.Type = 3;
            v54.AdapterLuid.LowPart = v9->field_8;
            v54.AdapterLuid.HighPart = v9[1].Prev;
            v55 = v15;
            if ( D3DKMTQueryStatistics(&v54) )
              goto LABEL_23;
            v16 = v52.QueryResult.SegmentInformationV1.CommitLimit >> 10;
            if ( gdwOsType < 3 )
            {
              if ( v54.QueryResult.SegmentInformationV1.Aperture )
              {
LABEL_22:
                v45 += v16;
                goto LABEL_23;
              }
              v46 += v16;
            }
            else
            {
              if ( v54.QueryResult.SegmentInformation.Aperture )
                goto LABEL_22;
              v46 += v16;
            }
LABEL_23:
            ++v15;
          }
          while ( v15 < v56.QueryResult.SegmentInformationV1.CommitLimit );
        }
      }
      v9 = v9->Prev;
    }
    while ( v9 != gAdapterList );
    v8 = v42;
    v10 = v43;
    v17 = v47;
    v7 = a6;
  }
  v18 = *(v7 + 1400);
  v19 = *(v7 + 1404);
  if ( v17 != v18 || v10 != v19 )
  {
    v21 = (__PAIR__(v10, v17) - __PAIR__(v19, v18));
    v22 = v21;
    v23 = v8;
    v24 = __PAIR__(a3, a2);
    v20 = (v22 / (v23 * v24)) * 100.0;
    if ( v20 >= 0.0 )
    {
      if ( v20 > 100.0 )
        v20 = 100.0;
    }
    else
    {
      v20 = 0.0;
    }
  }
  else
  {
    v20 = 0.0;
  }
  *(a6 + 1400) = v17;
  *(a6 + 1404) = v10;
  v25 = ghWndTreeListView;
  v26 = sub_127F8F0(v20, (a6 + 1384));
  v27 = ColumnIDIsIllegal(v26, v25, 1650, wParam);
  UpdateText(*(a6 + 1392), __PAIR__(a5, a4), COERCE__INT64(*(a6 + 1384)), 0i64, 0);
  v28 = ghWndTreeListView;
  v29 = sub_127F920(v41, 0, (a6 + 1440));
  v30 = ColumnIDIsIllegal(v29, v28, 1653, wParam) | v27;
  v31 = *(a6 + 1440);
  UpdateText(*(a6 + 1448), __PAIR__(a5, a4), *&v31, 0i64, 0);
  v32 = ghWndTreeListView;
  v33 = sub_127F920(v45, 0, (a6 + 1408));
  v34 = ColumnIDIsIllegal(v33, v32, 1651, wParam) | v30;
  v35 = *(a6 + 1408);
  UpdateText(*(a6 + 1416), __PAIR__(a5, a4), *&v35, 0i64, 0);
  v36 = ghWndTreeListView;
  v37 = sub_127F920(v46, 0, (a6 + 1424));
  v38 = ColumnIDIsIllegal(v37, v36, 1652, wParam) | v34;
  v39 = *(a6 + 1424);
  UpdateText(*(a6 + 1432), __PAIR__(a5, a4), *&v39, 0i64, 0);
  return v38;
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E4E54: using guessed type int gdwOsType;
// 12E96DC: using guessed type int gdwGpuNodeUsageMask;

//----- (012338F0) --------------------------------------------------------
void __cdecl sub_12338F0(int a1, int a2, signed __int64 a3, int a4, int a5, int a6, int a7, int a8)
{
  unsigned int v8; // ecx
  unsigned int v9; // ebx
  CList *v10; // esi
  unsigned int v11; // edi
  unsigned int v12; // edi
  signed int v13; // ebx
  int v14; // eax
  bool v15; // zf
  ULONG v16; // ebx
  D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_V1 *v17; // edi
  float v18; // xmm0_4
  float v19; // ST64_4
  float v20; // xmm0_4
  float v21; // xmm1_4
  int v22; // edi
  ULONG v23; // edi
  unsigned int v24; // eax
  ULONG v25; // ecx
  ULONG v26; // eax
  float v27; // xmm0_4
  float v28; // ST7C_4
  float v29; // ST58_4
  float v30; // xmm0_4
  float v31; // xmm0_4
  wchar_t *v32; // eax
  float v33; // xmm1_4
  float v34; // xmm1_4
  __int64 ArgList_4; // [esp+10h] [ebp-11D4h]
  int a5_4; // [esp+18h] [ebp-11CCh]
  int v37; // [esp+1Ch] [ebp-11C8h]
  unsigned int v38; // [esp+38h] [ebp-11ACh]
  unsigned int v39; // [esp+40h] [ebp-11A4h]
  signed int v40; // [esp+48h] [ebp-119Ch]
  unsigned int v41; // [esp+50h] [ebp-1194h]
  ULONG v42; // [esp+58h] [ebp-118Ch]
  unsigned int v43; // [esp+5Ch] [ebp-1188h]
  unsigned int v44; // [esp+68h] [ebp-117Ch]
  unsigned int v45; // [esp+6Ch] [ebp-1178h]
  unsigned int v46; // [esp+70h] [ebp-1174h]
  int v47; // [esp+74h] [ebp-1170h]
  unsigned int v48; // [esp+78h] [ebp-116Ch]
  int v49; // [esp+7Ch] [ebp-1168h]
  float v50; // [esp+7Ch] [ebp-1168h]
  D3DKMT_QUERYSTATISTICS v51; // [esp+80h] [ebp-1164h]
  unsigned int v52; // [esp+398h] [ebp-E4Ch]
  D3DKMT_QUERYSTATISTICS v53; // [esp+3A0h] [ebp-E44h]
  D3DKMT_QUERYSTATISTICS v54; // [esp+6C0h] [ebp-B24h]
  ULONG v55; // [esp+9D8h] [ebp-80Ch]
  wchar_t Dst; // [esp+9E0h] [ebp-804h]
  char v57; // [esp+9E2h] [ebp-802h]

  v41 = 0;
  Dst = 0;
  v47 = 0;
  memset(&v57, 0, 0x7FEu);
  v8 = 0;
  v9 = 0;
  v10 = gAdapterList->Prev;
  v11 = 0;
  v43 = 0;
  if ( gAdapterList->Prev == gAdapterList )
  {
    v44 = 0;
    v45 = 0;
    v50 = 0.0;
  }
  else
  {
    v46 = 0;
    v44 = 0;
    v45 = 0;
    v39 = 0;
    v48 = 0;
    do
    {
      memset(&v53, 0, 0x320u);
      v53.Type = 0;
      v53.AdapterLuid.LowPart = v10->field_8;
      v53.AdapterLuid.HighPart = v10[1].Prev;
      if ( !D3DKMTQueryStatistics(&v53) )
      {
        v12 = 0;
        v42 = v53.QueryResult.SegmentInformationV1.BytesCommitted;
        v38 = 0;
        if ( v53.QueryResult.SegmentInformationV1.BytesCommitted )
        {
          v13 = 1;
          v40 = 1;
          v14 = a6 + 2184 + 2200 * v47;
          v47 += v53.QueryResult.NodeInformation.GlobalInformation.RunningTime.HighPart;
          v49 = v14;
          do
          {
            memset(&v51, 0, 0x320u);
            v51.Type = 5;
            v51.AdapterLuid.LowPart = v10->field_8;
            v51.AdapterLuid.HighPart = v10[1].Prev;
            v52 = v12;
            if ( D3DKMTQueryStatistics(&v51) )
            {
              v16 = 0;
              v17 = 0;
            }
            else
            {
              v15 = (v13 & gdwGpuNodeUsageMask) == 0;
              v16 = v51.QueryResult.SegmentInformationV1.BytesCommitted;
              v17 = v51.QueryResult.AdapterInformation;
              if ( !v15 )
              {
                ++v41;
                v43 = (v51.QueryResult.SegmentInformation.CommitLimit + __PAIR__(v43, v46)) >> 32;
                v46 += v51.QueryResult.SegmentInformationV1.CommitLimit;
              }
            }
            if ( a6 )
            {
              if ( v16 | v17 && *v49 )
              {
                v18 = (__PAIR__(v16, v17) - *v49);
                v19 = v18;
                v20 = a3;
                v21 = (v19 / v20) * 100.0;
              }
              else
              {
                v21 = 0.0;
              }
              if ( v21 > 100.0 )
                v21 = 100.0;
              *v49 = v17;
              v22 = v49;
              *(v49 + 4) = v16;
              UpdateText((v49 - 2184), __PAIR__(a2, a1), *&v21, 0i64, 0);
            }
            else
            {
              v22 = v49;
            }
            v49 = v22 + 2200;
            v12 = v38 + 1;
            v13 = __ROL4__(v40, 1);
            v38 = v12;
            v40 = __ROL4__(v40, 1);
          }
          while ( v12 < v42 );
          v9 = v39;
        }
        v23 = 0;
        if ( v53.QueryResult.SegmentInformationV1.CommitLimit )
        {
          do
          {
            memset(&v54, 0, 0x320u);
            v54.Type = 3;
            v54.AdapterLuid.LowPart = v10->field_8;
            v54.AdapterLuid.HighPart = v10[1].Prev;
            v55 = v23;
            if ( !D3DKMTQueryStatistics(&v54) )
            {
              if ( gdwOsType < 3 )
              {
                v26 = v54.QueryResult.SegmentInformationV1.BytesResident >> 10;
                if ( v54.QueryResult.SegmentInformationV1.Aperture )
                {
                  v44 = (v26 + __PAIR__(v44, v45)) >> 32;
                  v45 += v26;
                }
                else
                {
                  v9 = (v26 + __PAIR__(v9, v48)) >> 32;
                  v48 += v26;
                }
              }
              else
              {
                v24 = v54.QueryResult.SegmentInformationV1.Memory.TotalBytesEvicted >> 10;
                v25 = v54.QueryResult.NodeInformation.GlobalInformation.PreemptionStatistics.PreemptionCounter[2] >> 10;
                if ( v54.QueryResult.SegmentInformation.Aperture )
                {
                  v44 = (__PAIR__(v25, v24) + __PAIR__(v44, v45)) >> 32;
                  v45 += v24;
                }
                else
                {
                  v9 = (__PAIR__(v25, v24) + __PAIR__(v9, v48)) >> 32;
                  v48 += v24;
                }
              }
            }
            ++v23;
          }
          while ( v23 < v53.QueryResult.SegmentInformationV1.CommitLimit );
          v39 = v9;
        }
      }
      v10 = v10->Prev;
    }
    while ( v10 != gAdapterList );
    if ( v43 | v46 && *(a4 + 2184) )
    {
      v27 = (__PAIR__(v43, v46) - *(a4 + 2184));
      v28 = v27;
      v29 = v41;
      v30 = a3;
      v31 = (v28 / (v29 * v30)) * 100.0;
      v50 = v31;
      if ( v31 <= 100.0 )
      {
        if ( v31 < 0.0 )
          v50 = 0.0;
      }
      else
      {
        v50 = 100.0;
      }
      v11 = v48;
      v8 = v46;
    }
    else
    {
      v8 = v46;
      v11 = v48;
      v50 = 0.0;
    }
  }
  *(a4 + 2184) = v8;
  *(a4 + 2188) = v43;
  if ( a5 )
  {
    v37 = *(a5 + 68);
    a5_4 = *(a5 + 60);
    ArgList_4 = *(a5 + 1384);
    if ( gbShowCpuFractions )
      FormatTex(&Dst, L"%02.02f%% %s:%d", ArgList_4, a5_4, v37);
    else
      FormatTex(&Dst, L"%02.0f%% %s:%d", ArgList_4, a5_4, v37);
  }
  v32 = &Dst;
  if ( !a5 )
    v32 = 0;
  UpdateText(a4, __PAIR__(a2, a1), *&v50, 0i64, v32);
  v33 = __PAIR__(v44, v45);
  if ( v33 > *(a7 + 40) )
    *(a7 + 40) = (v33 * 1.2);
  UpdateText(a7, __PAIR__(a2, a1), *&v33, 0i64, 0);
  v34 = __PAIR__(v9, v11);
  if ( v34 > *(a7 + 40) )
    *(a8 + 40) = (v34 * 1.2);
  UpdateText(a8, __PAIR__(a2, a1), *&v34, 0i64, 0);
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E4E54: using guessed type int gdwOsType;
// 12E96C9: using guessed type char gbShowCpuFractions;
// 12E96DC: using guessed type int gdwGpuNodeUsageMask;

//----- (01233FB0) --------------------------------------------------------
BOOL __cdecl InitializeD3DStatistics(DWORD64 *a1, DWORD64 *dwSegCommitLimit)
{
  HMODULE hModuleGDI32; // eax
  HMODULE hhModuleGDI32; // eax
  HMODULE hhhModuleGDI32; // eax
  HDEVINFO hDeviceInfoSet; // edi
  DWORD guid; // ebx
  PSP_DEVICE_INTERFACE_DETAIL_DATA_W *pPSPDeviceInterfaceDetailData; // edi
  CList *v8; // ebx
  CList *pNode; // eax
  ULONG nIndexLast; // edi
  unsigned int *v11; // ebx
  signed int v12; // edi
  unsigned int v13; // edx
  ULONG64 v14; // rax
  int v15; // edx
  ULONG64 v16; // rcx
  char v17; // al
  _D3DKMT_OPENADAPTERFROMDEVICENAME DeviceName; // [esp+Ch] [ebp-68Ch]
  HDEVINFO DeviceInfoSet; // [esp+1Ch] [ebp-67Ch]
  ULONG64 v21; // [esp+20h] [ebp-678h]
  PSP_DEVICE_INTERFACE_DETAIL_DATA_W *v22; // [esp+28h] [ebp-670h]
  DWORD v23; // [esp+2Ch] [ebp-66Ch]
  DWORD RequiredSize; // [esp+30h] [ebp-668h]
  char v25; // [esp+37h] [ebp-661h]
  _D3DKMT_QUERYSTATISTICS statics1; // [esp+38h] [ebp-660h]
  _D3DKMT_QUERYSTATISTICS statics2; // [esp+358h] [ebp-340h]
  ULONG v28; // [esp+670h] [ebp-28h]
  SP_DEVICE_INTERFACE_DATA DeviceInterfaceData; // [esp+678h] [ebp-20h]

  *dwSegCommitLimit = 0i64;
  LODWORD(v21) = a1;
  *a1 = 0i64;
  hModuleGDI32 = LoadLibraryW(L"gdi32.dll");
  D3DKMTOpenAdapterFromDeviceName = GetProcAddress(hModuleGDI32, "D3DKMTOpenAdapterFromDeviceName");
  hhModuleGDI32 = LoadLibraryW(L"gdi32.dll");
  D3DKMTCloseAdapter = GetProcAddress(hhModuleGDI32, "D3DKMTCloseAdapter");
  hhhModuleGDI32 = LoadLibraryW(L"gdi32.dll");
  D3DKMTQueryStatistics = GetProcAddress(hhhModuleGDI32, "D3DKMTQueryStatistics");
  // NTSTATUS D3DKMTOpenAdapterFromDeviceName(_Inout_ D3DKMT_OPENADAPTERFROMDEVICENAME *pData)
  if ( D3DKMTOpenAdapterFromDeviceName )
  {
    DeviceInterfaceData.cbSize = 0;
    hDeviceInfoSet = SetupDiGetClassDevsW(&InterfaceClassGuid, 0, 0, 0x12u);// DIGCF_DEVICEINTERFACE|DIGCF_PRESENT
    *&DeviceInterfaceData.InterfaceClassGuid.Data4[4] = 0i64;
    guid = 0;
    DeviceInfoSet = hDeviceInfoSet;
    _mm_storeu_si128(&DeviceInterfaceData, 0i64);
    DeviceInterfaceData.cbSize = 28;
    v25 = 0;
    v23 = 0;
    // 遍历所有的设备对象
    do
    {
      if ( SetupDiEnumDeviceInterfaces(hDeviceInfoSet, NULL, &InterfaceClassGuid, guid, &DeviceInterfaceData) )
      {
        RequiredSize = 0;
        // 该函数返回设备接口的详细信息。
        if ( SetupDiGetDeviceInterfaceDetailW(hDeviceInfoSet, &DeviceInterfaceData, NULL, 0, &RequiredSize, NULL)
          || GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
          pPSPDeviceInterfaceDetailData = operator new[](RequiredSize);
          v22 = pPSPDeviceInterfaceDetailData;
          memset(pPSPDeviceInterfaceDetailData, 0, RequiredSize);
          *pPSPDeviceInterfaceDetailData = 6;
          SetupDiGetDeviceInterfaceDetailW(
            DeviceInfoSet,
            &DeviceInterfaceData,
            pPSPDeviceInterfaceDetailData,
            RequiredSize,
            0,
            0);
          _mm_storeu_si128(&DeviceName, 0i64);
          // 设备名称紧跟其后
          DeviceName.pDeviceName = (pPSPDeviceInterfaceDetailData + 1);
          // NTSTATUS D3DKMTOpenAdapterFromDeviceName(_Inout_ D3DKMT_OPENADAPTERFROMDEVICENAME *pData);
          // 根据指定的名称打开设备
          if ( !D3DKMTOpenAdapterFromDeviceName(&DeviceName) )
          {
            memset(&statics1, 0, 0x320u);
            statics1.AdapterLuid.LowPart = DeviceName.AdapterLuid.LowPart;
            statics1.AdapterLuid.HighPart = DeviceName.AdapterLuid.HighPart;
            // 查询显卡的统计信息
            statics1.Type = D3DKMT_QUERYSTATISTICS_ADAPTER;
            if ( !D3DKMTQueryStatistics(&statics1) )
              gdwAdapterRuntingTime += statics1.QueryResult.NodeInformation.GlobalInformation.RunningTime.HighPart;
            v8 = gAdapterList;
            // 增加到队列中
            pNode = CList::Append(gAdapterList, gAdapterList->Next, &DeviceName.AdapterLuid.LowPart);
            if ( -0xF0000002 - *(&gAdapterList + 1) < 1 )
              std::_Xlength_error("list<T> too long");
            *(&gAdapterList + 1) = (*(&gAdapterList + 1) + 1);
            v8->Next = pNode;
            *pNode->Next = pNode;
            nIndexLast = 0;
            HIDWORD(v21) = 0;
            if ( statics1.QueryResult.SegmentInformationV1.CommitLimit )
            {
              do
              {
                // 遍历该显卡所有的Segment对象
                memset(&statics2, 0, 0x320u);
                statics2.AdapterLuid.LowPart = DeviceName.AdapterLuid.LowPart;
                statics2.AdapterLuid.HighPart = DeviceName.AdapterLuid.HighPart;
                statics2.Type = D3DKMT_QUERYSTATISTICS_SEGMENT;
                v28 = nIndexLast;
                if ( !D3DKMTQueryStatistics(&statics2) )
                {
                  if ( gdwOsType < WINDOWS_8 )
                  {
                    // WIN7版本
                    LODWORD(v14) = statics2.QueryResult.SegmentInformationV1.CommitLimit >> 10;
                    if ( statics2.QueryResult.SegmentInformationV1.Aperture )
                    {
                      HIDWORD(v16) = v21;
                      v15 = *(v21 + 4);
                      LODWORD(v16) = *v21;
                      if ( v15 < 0 || v15 <= 0 && v16 <= v14 )
                      {
                        LODWORD(v16) = statics2.QueryResult.SegmentInformationV1.CommitLimit >> 10;
                        v15 = 0;
                      }
                      *v21 = v16;
                      *(HIDWORD(v16) + 4) = v15;
                    }
                    else
                    {
                      *dwSegCommitLimit += v14;
                    }
                  }
                  else if ( statics2.QueryResult.SegmentInformation.Aperture )
                  {
                    v11 = v21;
                    v12 = *(v21 + 4);
                    v13 = *v21;
                    if ( v12 < (statics2.QueryResult.SegmentInformationV1.BytesCommitted >> 10)
                      || v12 <= (statics2.QueryResult.SegmentInformationV1.BytesCommitted >> 10)
                      && v13 <= (statics2.QueryResult.SegmentInformation.CommitLimit >> 10) )
                    {
                      v13 = statics2.QueryResult.SegmentInformation.CommitLimit >> 10;
                      v12 = statics2.QueryResult.SegmentInformationV1.BytesCommitted >> 10;
                    }
                    *(v21 + 4) = v12;
                    nIndexLast = HIDWORD(v21);
                    *v11 = v13;
                  }
                  else
                  {
                    *dwSegCommitLimit += statics2.QueryResult.SegmentInformation.CommitLimit >> 10;
                  }
                }
                HIDWORD(v21) = ++nIndexLast;
              }
              while ( nIndexLast < statics1.QueryResult.SegmentInformationV1.CommitLimit );
            }
            pPSPDeviceInterfaceDetailData = v22;
            guid = v23;
          }
          j_j__free(pPSPDeviceInterfaceDetailData);
          hDeviceInfoSet = DeviceInfoSet;
        }
        v17 = v25;
      }
      else
      {
        v17 = 1;
        v25 = 1;
      }
      v23 = ++guid;
    }
    while ( !v17 );
    SetupDiDestroyDeviceInfoList(hDeviceInfoSet);
  }
  return gdwAdapterRuntingTime != 0;
}
// 12E4E38: using guessed type int D3DKMTCloseAdapter;
// 12E4E54: using guessed type int gdwOsType;

//----- (01234360) --------------------------------------------------------
CList *__stdcall sub_1234360(CList *a1, _DWORD *pNode)
{
  CList *result; // eax
  CList *v3; // ecx
  CList *v4; // edx

  result = operator new(0x10u);
  if ( !result )
    std::bad_alloc::bad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = pNode;
  }
  else
  {
    v3 = result;
    v4 = result;
  }
  result->Prev = v3;
  if ( result != -4 )
    result->Next = v4;
  return result;
}

//----- (012343A0) --------------------------------------------------------
ProcessorInfo *__thiscall CSimpleGraphData::Init(CSimpleGraphData *P)
{
  CSimpleGraphData *this; // esi
  ProcessorInfo *v2; // eax
  int v3; // ecx
  ProcessorInfo *result; // eax

  this = P;
  v2 = InitProcessorScreenData(1, 2, 1);
  v3 = HIDWORD(this->ID);
  this->GraphData = v2;
  v2->ID = v3;
  *&this->GraphData->m_dbMaxValue = gdbMaxValue;
  this->GraphData->field_24 = 1;
  this->GraphData->m_Buffer[0].m_Color = 0xC83C1E;
  this->GraphData->m_Buffer[0].m_ID = HIDWORD(this->ID);
  *&this->GraphData->m_Buffer[0].m_dbMaxValue = gdbMaxValue;
  result = this->GraphData;
  result->m_Buffer[1].m_Color = 0xC83CC8;
  return result;
}
// 12BCDC0: using guessed type double gdbMaxValue;

//----- (01234400) --------------------------------------------------------
signed __int64 __thiscall sub_1234400(_DWORD *this)
{
  int v1; // edx
  _DWORD *v2; // esi
  int i; // ecx
  int v4; // edi
  double v5; // xmm0_8
  signed int v6; // edx
  signed int v7; // ecx
  signed __int64 result; // rax

  v1 = 0;
  v2 = this;
  *(this[1] + 40) = doubleOnePointZero;
  for ( i = gScreenWidth; v1 < i; ++v1 )
  {
    v4 = v2[1];
    v5 = *(*(v4 + 52) + 8 * v1);
    if ( v5 > *(v4 + 40) )
    {
      *(v4 + 40) = v5 * 1.200000047683716;
      i = gScreenWidth;
    }
  }
  v6 = 1;
  if ( *(v2[1] + 28) > 1 )
  {
    v7 = 24;
    do
    {
      v7 += 24;
      ++v6;
      *(v7 + v2[1] + 16) = *(v2[1] + 40);
    }
    while ( v6 < *(v2[1] + 28) );
  }
  result = *(v2[1] + 40);
  *(v2 + 1) = result;
  return result;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12E4E28: using guessed type int gScreenWidth;

//----- (012344A0) --------------------------------------------------------
void __thiscall sub_12344A0(CSimpleGraphData *this, CDataInfo *pDataInfo)
{
  CSimpleGraphData *pGraphData; // edi
  int nOffset; // esi
  __int64 v4; // kr10_8
  signed __int64 v5; // kr20_8
  float v6; // xmm0_4
  int v7; // eax
  float v8; // xmm0_4
  float v9; // xmm0_4
  __int64 v10; // ST1C_8
  float v11; // xmm0_4
  float v12; // xmm0_4
  __int64 v13; // ST1C_8
  float v14; // xmm0_4
  __int64 a5; // ST14_8
  float v16; // xmm0_4
  float v17; // xmm0_4
  __int64 v18; // ST1C_8
  float v19; // xmm0_4
  __int64 v20; // ST14_8
  float v21; // xmm0_4
  wchar_t szText[1024]; // [esp+30h] [ebp-804h]

  szText[0] = 0;
  pGraphData = this;
  memset(&szText[1], 0, 2046u);
  if ( *&pDataInfo->field_58 + *&pDataInfo->field_50 + *&pDataInfo->field_48 )
  {
    nOffset = FormatTex(szText, L"%s:%d\n", *(pDataInfo->field_60 + 60), *(pDataInfo->field_60 + 68));
    sub_1232200(
      1,
      &szText[nOffset],
      1024 - nOffset,
      COERCE__INT64(*&pDataInfo->field_50),
      COERCE__INT64(*&pDataInfo->field_48),
      COERCE__INT64(*&pDataInfo->field_58));
    v4 = *&pDataInfo->field_58 + *&pDataInfo->field_50 + *&pDataInfo->field_48;
    if ( v4 > *&pGraphData->field_8 )
      *&pGraphData->field_8 = v4;
  }
  v5 = *&pDataInfo->field_20 + *&pDataInfo->field_18 + *&pDataInfo->field_28;
  if ( v5 >= *&pGraphData->GraphData->m_dbMaxValue )
  {
    v6 = v5;
    *&pGraphData->GraphData->m_dbMaxValue = (v6 * 1.2);
    *&pGraphData->GraphData->m_Buffer[0].m_dbMaxValue = *&pGraphData->GraphData->m_dbMaxValue;
  }
  v7 = LODWORD(pGraphData->ID) | pGraphData->field_8;
  if ( !*&pGraphData->field_8 )
  {
    pGraphData->field_8 = 1;
    LODWORD(pGraphData->ID) = v7;
  }
  v8 = *&pGraphData->field_8;
  *&pGraphData->GraphData->m_dbMaxValue = v8;
  *&pGraphData->GraphData->m_Buffer[0].m_dbMaxValue = *&pGraphData->GraphData->m_dbMaxValue;
  UpdateText(
    pGraphData->GraphData,
    gTimeLastRefresh1,
    COERCE__INT64((*&pDataInfo->field_20 + *&pDataInfo->field_18 + *&pDataInfo->field_28)),
    COERCE__INT64(*&pDataInfo->field_18),
    szText);
  if ( pGraphData == &gptrIOGraphData__3UCSimpleGraphData__A )
  {
    v9 = *&pDataInfo->field_28;
    *&v10 = v9;
    v11 = *&pDataInfo->field_20;
    sub_1280130(pGraphData->GraphData, pDataInfo->field_60, COERCE__INT64(*&pDataInfo->field_18), *&v11, v10);
  }
  else if ( pGraphData == &gptrDiskGraphData )
  {
    v12 = *&pDataInfo->field_28;
    *&v13 = v12;
    v14 = *&pDataInfo->field_20;
    *&a5 = v14;
    v16 = *&pDataInfo->field_18;
    sub_1280010(pGraphData->GraphData, pDataInfo->field_60, *&v16, a5, v13);
  }
  else if ( pGraphData == &gptrNetGraphData )
  {
    v17 = *&pDataInfo->field_28;
    *&v18 = v17;
    v19 = *&pDataInfo->field_20;
    *&v20 = v19;
    v21 = *&pDataInfo->field_18;
    sub_1280250(pGraphData->GraphData, pDataInfo->field_60, *&v21, v20, v18);
  }
}

//----- (012347C0) --------------------------------------------------------
int __stdcall CDataInfo::Init(int a1, CDataInfo *a2)
{
  CDataInfo *v2; // ecx
  CDataInfo *this; // edx
  int v4; // eax
  unsigned __int8 v5; // cf
  int v6; // eax
  int v7; // eax
  int result; // eax
  int v9; // [esp+Ch] [ebp-4h]

  this = v2;
  this->field_4 += a2->field_10;
  this->field_0 += a2->field_30;
  this->field_8 += a2->field_50;
  v4 = a2->field_38;
  v5 = __CFADD__(v4, v2->field_18);
  this->field_18 += v4;
  this->field_1C += a2->field_3C + v5;
  v6 = a2->field_18;
  v5 = __CFADD__(v6, v2->field_20);
  this->field_20 += v6;
  this->field_24 += a2->field_1C + v5;
  v7 = a2->field_58;
  v5 = __CFADD__(v7, v2->field_28);
  this->field_28 += v7;
  this->field_2C += a2->field_5C + v5;
  v9 = a2->field_3C;
  result = (*&this->field_48 + *&this->field_58 + *&this->field_50) >> 32;
  if ( *&a2->field_38 + *&a2->field_58 + *&a2->field_18 > *&this->field_48 + *&this->field_58 + *&this->field_50 )
  {
    v2->field_48 = a2->field_38;
    v2->field_4C = v9;
    v2->field_50 = a2->field_18;
    v2->field_54 = a2->field_1C;
    v2->field_58 = a2->field_58;
    v2->field_5C = a2->field_5C;
    result = a1;
    v2->field_60 = a1;
  }
  return result;
}

//----- (01234870) --------------------------------------------------------
int __cdecl CreateMainWindow(HINSTANCE hInstance, int nShowCmd)
{
  HANDLE hProcessExplorerElevatingEvent; // eax
  int cyy; // ST28_4
  int cxx; // eax
  HWND hWndMain; // esi
  HWND hMainWnd; // eax
  UINT bMinimized; // eax
  int nWidth; // edi
  int nHeight; // edx
  LONG left; // ecx
  LONG right; // eax
  LONG top; // ecx
  UINT v14; // eax
  int nShowCommand; // eax
  char v16; // cl
  WNDCLASSEXW wc; // [esp+8h] [ebp-30h]

  LoadStringW(hInstance, IDS_PROCEXPLORER, PROCESSEXPLORER_WINDOWNAME, 9);
  LoadStringW(hInstance, IDS_PROCESSEXPLORER, PROCESSEXPLORER_WINDOWNAME, 40);
  ghInstance = hInstance;
  InitDrawEngine();
  if ( gbAllOneInstance )
  {
    hProcessExplorerElevatingEvent = OpenEventW(0x100000u, 0, L"ProcessExplorerElevating");
    if ( hProcessExplorerElevatingEvent )
    {
      CloseHandle(hProcessExplorerElevatingEvent);
    }
    else
    {
      hMainWnd = FindWindowW(PROCESSEXPLORER_WINDOWNAME, 0);
      if ( hMainWnd )
      {
        PostMessageW(hMainWnd, 0x7F2u, 0, 0);
        return 0;
      }
    }
  }
  if ( !InitDriver() )
    return 0;
  ghArrowCursor = LoadCursorW(0, IDC_WAIT);
  wc.cbSize = 48;
  wc.style = 0;
  wc.lpfnWndProc = PEMainWndProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = hInstance;
  wc.hIcon = LoadIconW(hInstance, 101);
  wc.hCursor = 0;
  wc.hbrBackground = 0;
  wc.lpszMenuName = L"PROCEXPLORER";
  wc.lpszClassName = PROCESSEXPLORER_WINDOWNAME;
  cyy = GetSystemMetrics(SM_CYSMICON);
  cxx = GetSystemMetrics(SM_CXSMICON);
  wc.hIconSm = LoadImageW(hInstance, 101, IMAGE_ICON, cxx, cyy, 0);
  if ( !RegisterClassExW(&wc) && !RegisterClassW(&wc.style) )
    return 0;
  memset(&wc, 0, 0x30u);
  wc.cbSize = 48;
  wc.lpfnWndProc = CGraph::GraphWndProc;
  wc.hInstance = ghInstance;
  wc.hbrBackground = CreateSolidBrush(0xFFFFFFu);
  wc.lpszClassName = L"CpuGraphClassChart";
  wc.hCursor = LoadCursorW(0, IDC_ARROW);
  RegisterClassExW(&wc);
  memset(&wc, 0, 0x30u);
  wc.cbSize = 48;
  wc.lpfnWndProc = CGraph::GraphWndProc;
  wc.hInstance = ghInstance;
  wc.hbrBackground = CreateSolidBrush(gColorGraphBackground);
  wc.lpszClassName = L"CpuGraphClassGraph";
  wc.hCursor = LoadCursorW(0, IDC_ARROW);
  RegisterClassExW(&wc);
  hWndMain = CreateWindowExW(
               0,
               PROCESSEXPLORER_WINDOWNAME,
               L"Process Explorer - Sysinternals: www.sysinternals.com",
               // WS_CAPTION| WS_SYSMENU|WS_THICKFRAME|WS_GROUP|WS_TABSTOP
               0xCF0000u,
               0,
               0,
               780,
               550,
               0,
               0,
               hInstance,
               NULL);
  if ( !hWndMain )
    return 0;
  if ( gWindowPlacement[0].length )
  {
    bMinimized = gWindowPlacement[0].showCmd;
    if ( gWindowPlacement[0].showCmd == SW_MINIMIZE )
      bMinimized = 1;
    if ( gbHide1 )
      bMinimized = 0;
    gWindowPlacement[0].showCmd = bMinimized;
    nWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    if ( !nWidth )
      nWidth = GetSystemMetrics(SM_CXFULLSCREEN);
    nHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    if ( !nHeight )
      nHeight = GetSystemMetrics(SM_CYFULLSCREEN);
    left = gWindowPlacement[0].rcNormalPosition.left;
    right = gWindowPlacement[0].rcNormalPosition.right;
    if ( gWindowPlacement[0].rcNormalPosition.left >= nWidth - 10 )
      left = 100;
    gWindowPlacement[0].rcNormalPosition.left = left;
    top = gWindowPlacement[0].rcNormalPosition.top;
    if ( gWindowPlacement[0].rcNormalPosition.right > nWidth )
      right = nWidth;
    gWindowPlacement[0].rcNormalPosition.right = right;
    if ( gWindowPlacement[0].rcNormalPosition.top >= nHeight - 10 )
      top = 100;
    gWindowPlacement[0].rcNormalPosition.top = top;
    if ( nShowCmd == SW_SHOWMINNOACTIVE )
    {
      v14 = gWindowPlacement[0].showCmd;
      if ( gbHideWhenMinimized )
        v14 = 0;
      gWindowPlacement[0].showCmd = v14;
    }
    SetWindowPlacement(hWndMain, gWindowPlacement);
  }
  else
  {
    nShowCommand = SW_SHOW;
    if ( gbHide1 )
      nShowCommand = SW_HIDE;
    ShowWindow(hWndMain, nShowCommand);
  }
  v16 = gbProcessExplorerHide;
  if ( gbHide1 )
    v16 = 1;
  gbProcessExplorerHide = v16;
  UpdateWindow(hWndMain);
  return 1;
}
// 12BCB88: using guessed type wchar_t aCpugraphclassc[19];
// 12E96D1: using guessed type char gbHideWhenMinimized;
// 12E96D3: using guessed type char gbAllOneInstance;
// 12EA388: using guessed type char gbHide1;
// 12EA389: using guessed type char gbProcessExplorerHide;

//----- (01234B90) --------------------------------------------------------
int VLogEntry(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 256u, Format, ArgList);
}

//----- (01234BB0) --------------------------------------------------------
int sub_1234BB0(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x208u, Format, ArgList);
}

//----- (01234BD0) --------------------------------------------------------
int __stdcall CString::LoadString(LPCSTR lpMultiByteStr)
{
  CStringData *v1; // ecx
  CStringData *v2; // esi
  CAtlStringMgr *v3; // ecx
  HMODULE hModule; // eax

  v2 = v1;
  v3 = ATL::CAtlStringMgr::GetInstance();
  if ( !v3 )
    AtlThrow(E_FAIL);
  v2->pStringMgr = ((v3->vtptr->GetNilString)() + 0x10);
  if ( !lpMultiByteStr || lpMultiByteStr & 0xFFFF0000 )
  {
    AsciiToUNICODE(v2, lpMultiByteStr);
  }
  else
  {
    hModule = AtlGetStringResourceImage(lpMultiByteStr, 0);
    if ( hModule )
      sub_122BDC0(v2, hModule, lpMultiByteStr);
  }
  return v2;
}

//----- (01234C70) --------------------------------------------------------
CStringData **__thiscall AsciiToUNICODE(CString *str, LPCSTR lpMultiByteStr)
{
  CStringData **v2; // edi
  int nLength; // esi
  CStringData **result; // eax

  v2 = &str->m_pszData;
  if ( lpMultiByteStr && (nLength = MultiByteToWideChar(CP_THREAD_ACP, 0, lpMultiByteStr, -1, 0, 0) - 1, nLength > 0) )
  {
    if ( (((*v2)[-1].nAllocLength - nLength) | (1 - (*v2)[-1].nRefs)) < 0 )
      ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(v2, nLength);
    MultiByteToWideChar(CP_THREAD_ACP, 0, lpMultiByteStr, -1, *v2, nLength);
    if ( nLength > (*v2)[-1].nAllocLength )
      AtlThrow(E_INVALIDARG);
    (*v2)[-1].nDataLength = nLength;
    *(&(*v2)->pStringMgr + nLength) = 0;
    result = v2;
  }
  else
  {
    sub_122BA60(v2);
    result = v2;
  }
  return result;
}

//----- (01234D00) --------------------------------------------------------
int __stdcall AutoEllipsisText(HDC hDC, LPCTSTR lpszText, UINT nLength, int nWidth)
{
  HANDLE HeapHandle; // eax
  wchar_t *pBuffer; // eax
  unsigned __int16 *pszText; // edi
  int len; // esi
  HANDLE v8; // eax
  unsigned int nTextWidth; // ecx
  UINT SizeToCopy; // esi
  HANDLE v12; // eax
  struct tagSIZE sz3; // [esp+Ch] [ebp-20h]
  struct tagSIZE sz2; // [esp+14h] [ebp-18h]
  struct tagSIZE sz1; // [esp+1Ch] [ebp-10h]
  struct tagSIZE szText; // [esp+24h] [ebp-8h]
  unsigned int Width; // [esp+40h] [ebp+14h]

  Width = nWidth - 4;
  HeapHandle = GetProcessHeap();
  pBuffer = HeapAlloc(HeapHandle, 8u, 2 * nLength);
  pszText = pBuffer;
  if ( !pBuffer )
    return 0;
  tcscpy_s(pBuffer, nLength, lpszText);
  len = wcslen(pszText);
  if ( !GetTextExtentPoint32W(hDC, pszText, len, &szText) )
  {
LABEL_3:
    v8 = GetProcessHeap();
    HeapFree(v8, 0, pszText);
    return 0;
  }
  if ( szText.cx > Width )
  {
    if ( !GetTextExtentPoint32W(hDC, L"...", wcslen(L"..."), &sz1)
      || !GetTextExtentPoint32W(hDC, L"..", wcslen(L".."), &sz2)
      || !GetTextExtentPoint32W(hDC, L".", wcslen(L"."), &sz3) )
    {
      goto LABEL_3;
    }
    if ( len > 0 )
    {
      while ( 1 )
      {
        pszText[--len] = 0;
        if ( !GetTextExtentPoint32W(hDC, pszText, len, &szText) )
          goto LABEL_3;
        nTextWidth = Width;
        if ( szText.cx + sz1.cx <= Width || len <= 0 )
          goto LABEL_15;
      }
    }
    nTextWidth = Width;
LABEL_15:
    *pszText = *lpszText;
    if ( szText.cx + sz1.cx > nTextWidth )
    {
      if ( szText.cx + sz2.cx > nTextWidth )
      {
        if ( szText.cx + sz3.cx > nTextWidth )
        {
          SizeToCopy = nLength;
          *pszText = *lpszText;
        }
        else
        {
          SizeToCopy = nLength;
          wcscat_s(pszText, nLength, L".");
        }
      }
      else
      {
        SizeToCopy = nLength;
        wcscat_s(pszText, nLength, L"..");
      }
    }
    else
    {
      SizeToCopy = nLength;
      wcscat_s(pszText, nLength, L"...");
    }
    tcscpy_s(lpszText, SizeToCopy, pszText);
  }
  v12 = GetProcessHeap();
  HeapFree(v12, 0, pszText);
  return 1;
}

//----- (01234EF0) --------------------------------------------------------
signed int __cdecl sub_1234EF0(unsigned int *a1, _DWORD *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  signed int result; // eax
  __int64 v5; // rdi
  bool v6; // zf
  bool v7; // sf
  unsigned __int8 v8; // of

  v2 = *a1;
  v3 = a1[1];
  if ( *a1 )
  {
    HIDWORD(v5) = *a2;
    LODWORD(v5) = a2[1];
    if ( !v5 )
      return 1;
    if ( HIDWORD(v5) == v2 )
    {
      v8 = __OFSUB__(v3, v5);
      v6 = v3 == v5;
      v7 = (v3 - v5) < 0;
      if ( v3 == v5 )
        return 0;
    }
    else
    {
      v8 = __OFSUB__(v3, v5);
      v6 = v3 == v5;
      v7 = (v3 - v5) < 0;
    }
    if ( !(v7 ^ v8) && (!((v7 ^ v8) | v6) || v2 > HIDWORD(v5)) )
      return 1;
    result = -1;
  }
  else if ( *a2 )
  {
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (01234F50) --------------------------------------------------------
int __cdecl sub_1234F50(WINDOWPLACEMENT *pWindowPlacement, WDPLSETTINGS *lpszSetting, int nLength)
{
  WDPLSETTINGS *pSettings; // edx
  int result; // eax
  int *v5; // esi
  signed int v6; // ecx
  const wchar_t **v7; // eax
  const wchar_t **v8; // eax

  pSettings = lpszSetting;
  _mm_storeu_si128(pWindowPlacement, _mm_loadu_si128(&lpszSetting->Left));
  _mm_storeu_si128(&pWindowPlacement->ptMinPosition.y, _mm_loadu_si128(&lpszSetting->Y));
  _mm_storel_epi64(&pWindowPlacement->rcNormalPosition.top, _mm_loadl_epi64(&lpszSetting->Top));
  result = lpszSetting->Top.right;
  pWindowPlacement->rcNormalPosition.bottom = result;
  qmemcpy(&pWindowPlacement[6], &lpszSetting->Top.bottom, 0x5Cu);
  v5 = &lpszSetting[4].field_34;
  *&pWindowPlacement[8].showCmd = *&lpszSetting[1].field_3C;
  _mm_storeu_si128(&pWindowPlacement[20].rcNormalPosition.top, _mm_loadu_si128(&lpszSetting[1].field_44));
  _mm_storeu_si128(&pWindowPlacement[21].flags, _mm_loadu_si128(&lpszSetting[2]));
  _mm_storeu_si128(&pWindowPlacement[21].ptMaxPosition, _mm_loadu_si128(&lpszSetting[2].Left.bottom));
  _mm_storeu_si128(&pWindowPlacement[21].rcNormalPosition.right, _mm_loadu_si128(&lpszSetting[2].Y.bottom));
  _mm_storeu_si128(&pWindowPlacement[34].showCmd, _mm_loadu_si128(&lpszSetting[2].Top.bottom));
  _mm_storeu_si128(&pWindowPlacement[34].ptMaxPosition.y, _mm_loadu_si128(&lpszSetting[2].field_40));
  _mm_storeu_si128(&pWindowPlacement[34].rcNormalPosition.bottom, _mm_loadu_si128(&lpszSetting[2].field_50));
  _mm_storeu_si128(&pWindowPlacement[35].ptMinPosition, _mm_loadu_si128(&lpszSetting[3].Left.right));
  _mm_storeu_si128(&pWindowPlacement[38].rcNormalPosition.right, _mm_loadu_si128(&lpszSetting[3].Y.right));
  _mm_storeu_si128(&pWindowPlacement[39].showCmd, _mm_loadu_si128(&lpszSetting[3].Top.right));
  _mm_storeu_si128(&pWindowPlacement[39].ptMaxPosition.y, _mm_loadu_si128(&lpszSetting[3].field_3C));
  _mm_storeu_si128(&pWindowPlacement[39].rcNormalPosition.bottom, _mm_loadu_si128(&lpszSetting[3].field_4C));
  if ( lpszSetting[4].field_34 )
  {
    v6 = 32;
  }
  else
  {
    v5 = &lpszSetting[17].field_44;
    v6 = 64;
  }
  qmemcpy(&pWindowPlacement[25].flags, v5, 4 * v6);
  qmemcpy(&pWindowPlacement[35].rcNormalPosition, &lpszSetting[6].Left.bottom, 0x80u);
  qmemcpy(&pWindowPlacement[40].ptMinPosition, &lpszSetting[7].field_40, 0x80u);
  if ( nLength > 344 )
  {
    LOBYTE(result) = lpszSetting[4].Left.top;
    BYTE2(pWindowPlacement[390].showCmd) = result;
  }
  if ( nLength > 348 )
  {
    LOBYTE(result) = lpszSetting[4].Left.right;
    LOBYTE(pWindowPlacement[390].ptMinPosition.x) = result;
  }
  if ( nLength > 0x160 )
  {
    result = lpszSetting[4].Left.bottom;
    pWindowPlacement[43].showCmd = result;
  }
  if ( nLength > 0x164 )
  {
    LOBYTE(result) = lpszSetting[4].Y.left;
    LOBYTE(pWindowPlacement[43].ptMinPosition.x) = result;
  }
  if ( nLength > 0x168 )
  {
    result = lpszSetting[4].Y.top;
    pWindowPlacement[38].ptMaxPosition.y = result;
  }
  if ( nLength > 0x16C )
  {
    LOBYTE(result) = lpszSetting[4].Y.right;
    LOBYTE(pWindowPlacement[38].rcNormalPosition.left) = result;
  }
  if ( nLength > 0x170 )
  {
    result = lpszSetting[4].Y.bottom;
    pWindowPlacement[33].rcNormalPosition.right = result;
  }
  if ( nLength > 0x174 )
  {
    LOBYTE(result) = lpszSetting[4].Top.left;
    LOBYTE(pWindowPlacement[33].rcNormalPosition.bottom) = result;
  }
  if ( nLength > 0x175 )
  {
    LOBYTE(result) = BYTE1(lpszSetting[4].Top.left);
    BYTE1(pWindowPlacement[389].rcNormalPosition.right) = result;
  }
  if ( nLength > 0x176 )
  {
    LOBYTE(result) = BYTE2(lpszSetting[4].Top.left);
    BYTE2(pWindowPlacement[389].rcNormalPosition.right) = result;
  }
  if ( nLength > 0x178 )
  {
    LOBYTE(result) = lpszSetting[4].Top.top;
    BYTE2(pWindowPlacement[390].ptMinPosition.x) = result;
  }
  if ( nLength > 0x17C )
  {
    result = lpszSetting[4].Top.right;
    pWindowPlacement[8].ptMaxPosition.y = result;
  }
  if ( nLength > 0x180 )
  {
    result = lpszSetting[4].Top.bottom;
    pWindowPlacement[20].rcNormalPosition.left = result;
  }
  if ( nLength > 0x204 )
  {
    result = lpszSetting[6].Left.right;
    pWindowPlacement[38].rcNormalPosition.top = result;
  }
  if ( nLength > 0x288 )
  {
    result = lpszSetting[7].field_3C;
    pWindowPlacement[34].flags = result;
  }
  if ( nLength > 0x30C )
  {
    LOBYTE(result) = lpszSetting[9].Y.top;
    LOBYTE(pWindowPlacement[389].rcNormalPosition.right) = result;
  }
  if ( nLength > 0x30D )
  {
    LOBYTE(result) = BYTE1(lpszSetting[9].Y.top);
    BYTE1(pWindowPlacement[390].showCmd) = result;
  }
  if ( nLength > 0x310 )
    *&pWindowPlacement[8].ptMinPosition.y = *&lpszSetting[9].Y.right;
  if ( nLength > 0x318 )
  {
    LOBYTE(result) = lpszSetting[9].Top.left;
    BYTE1(pWindowPlacement[390].ptMinPosition.x) = result;
  }
  if ( nLength > 0x319 )
  {
    LOBYTE(result) = BYTE1(lpszSetting[9].Top.left);
    LOBYTE(pWindowPlacement[390].ptMinPosition.y) = result;
  }
  if ( nLength > 0x41E )
  {
    LOBYTE(result) = BYTE2(lpszSetting[12].Top.right);
    LOBYTE(pWindowPlacement[403].length) = result;
  }
  if ( nLength > 0x523 )
  {
    LOBYTE(result) = HIBYTE(lpszSetting[15].field_34);
    HIBYTE(pWindowPlacement[389].rcNormalPosition.right) = result;
  }
  if ( nLength > 0x524 )
  {
    LOBYTE(result) = lpszSetting[15].field_38;
    HIBYTE(pWindowPlacement[390].showCmd) = result;
  }
  if ( nLength > 0x525 )
  {
    LOBYTE(result) = BYTE1(lpszSetting[15].field_38);
    BYTE1(pWindowPlacement[390].ptMinPosition.y) = result;
  }
  if ( nLength > 0x554 )
  {
    result = lpszSetting[16].Y.left;
    pWindowPlacement[414].rcNormalPosition.bottom = result;
  }
  if ( nLength > 0x568 )
  {
    result = lpszSetting[16].Top.top;
    pWindowPlacement[415].rcNormalPosition.bottom = result;
  }
  if ( nLength > 0x558 )
  {
    result = lpszSetting[16].Y.top;
    pWindowPlacement[415].length = result;
  }
  if ( nLength > 0x55C )
  {
    result = lpszSetting[16].Y.right;
    pWindowPlacement[415].flags = result;
  }
  if ( nLength > 0x560 )
  {
    result = lpszSetting[16].Y.bottom;
    pWindowPlacement[415].showCmd = result;
  }
  if ( nLength > 0x564 )
  {
    result = lpszSetting[16].Top.left;
    pWindowPlacement[415].ptMinPosition.x = result;
  }
  if ( nLength > 0x56C )
  {
    result = lpszSetting[16].Top.right;
    pWindowPlacement[8].rcNormalPosition.left = result;
  }
  if ( nLength > 0x570 )
  {
    LOBYTE(result) = lpszSetting[16].Top.bottom;
    BYTE2(pWindowPlacement[390].ptMinPosition.y) = result;
  }
  if ( nLength > 0x571 )
  {
    LOBYTE(result) = BYTE1(lpszSetting[16].Top.bottom);
    BYTE2(pWindowPlacement[20].ptMaxPosition.y) = result;
  }
  if ( nLength > 0x574 )
  {
    result = lpszSetting[16].field_34;
    pWindowPlacement[34].length = result;
  }
  if ( nLength > 0x578 )
  {
    result = lpszSetting[16].field_38;
    pWindowPlacement[390].rcNormalPosition.right = result;
  }
  if ( nLength > 0x5D4 )
  {
    LOBYTE(result) = lpszSetting[17].field_40;
    LOBYTE(pWindowPlacement[390].ptMaxPosition.x) = result;
  }
  if ( nLength > 0x6D8 )
  {
    result = lpszSetting[20].field_48;
    pWindowPlacement[390].rcNormalPosition.bottom = result;
  }
  if ( nLength > 0x6F4 )
  {
    LOBYTE(result) = lpszSetting[21].Left.bottom;
    HIBYTE(pWindowPlacement[390].ptMaxPosition.x) = result;
  }
  if ( nLength > 0x6F5 )
  {
    LOBYTE(result) = BYTE1(lpszSetting[21].Left.bottom);
    LOBYTE(pWindowPlacement[390].ptMaxPosition.y) = result;
  }
  if ( nLength > 0x31A )
  {
    v7 = CString::LoadString(&lpszSetting[9].Top.left + 2);
    tcscpy_s(&pWindowPlacement[391].showCmd, 0x104u, *v7);
    result = &pWindowPlacement[-1].rcNormalPosition.bottom;
    if ( _InterlockedDecrement(result) <= 0 )
      result = (*(*pWindowPlacement[-1].rcNormalPosition.left + 4))(&pWindowPlacement[-1].rcNormalPosition);
    pSettings = lpszSetting;
  }
  if ( nLength > 0x41F )
  {
    v8 = CString::LoadString(&pSettings[12].Top.right + 3);
    tcscpy_s(&pWindowPlacement[403].length + 1, _MAX_PATH, *v8);
    result = &pWindowPlacement[-1].rcNormalPosition.bottom;
    if ( _InterlockedDecrement(result) <= 0 )
      result = (*(*pWindowPlacement[-1].rcNormalPosition.left + 4))(&pWindowPlacement[-1].rcNormalPosition);
  }
  if ( nLength > 0x528 )
  {
    _mm_storeu_si128(&pWindowPlacement[1], _mm_loadu_si128(&lpszSetting[15].field_3C));
    _mm_storeu_si128(&pWindowPlacement[1].ptMinPosition.y, _mm_loadu_si128(&lpszSetting[15].field_4C));
    _mm_storel_epi64(&pWindowPlacement[1].rcNormalPosition.top, _mm_loadl_epi64(&lpszSetting[16].Left.top));
    result = lpszSetting[16].Left.bottom;
    pWindowPlacement[1].rcNormalPosition.bottom = result;
  }
  if ( nLength > 0x57C )
  {
    _mm_storeu_si128(&pWindowPlacement[2], _mm_loadu_si128(&lpszSetting[16].field_3C));
    _mm_storeu_si128(&pWindowPlacement[2].ptMinPosition.y, _mm_loadu_si128(&lpszSetting[16].field_4C));
    _mm_storel_epi64(&pWindowPlacement[2].rcNormalPosition.top, _mm_loadl_epi64(&lpszSetting[17].Left.top));
    result = lpszSetting[17].Left.bottom;
    pWindowPlacement[2].rcNormalPosition.bottom = result;
  }
  if ( nLength > 0x5A8 )
  {
    _mm_storeu_si128(&pWindowPlacement[4], _mm_loadu_si128(&lpszSetting[17].Y));
    _mm_storeu_si128(&pWindowPlacement[4].ptMinPosition.y, _mm_loadu_si128(&lpszSetting[17].Top));
    _mm_storel_epi64(&pWindowPlacement[4].rcNormalPosition.top, _mm_loadl_epi64(&lpszSetting[17].field_34));
    result = lpszSetting[17].field_3C;
    pWindowPlacement[4].rcNormalPosition.bottom = result;
  }
  if ( nLength > 0x6DC )
  {
    _mm_storel_epi64(&pWindowPlacement[416], _mm_loadl_epi64(&lpszSetting[20].field_4C));
    result = lpszSetting[21].field_0;
    pWindowPlacement[416].showCmd = result;
  }
  if ( nLength > 0x6E8 )
  {
    _mm_storel_epi64(&pWindowPlacement[416].ptMinPosition, _mm_loadl_epi64(&lpszSetting[21].Left));
    result = lpszSetting[21].Left.right;
    pWindowPlacement[416].ptMaxPosition.x = result;
  }
  if ( nLength > 0x6F4 )
  {
    _mm_storel_epi64(&pWindowPlacement[416].ptMinPosition, _mm_loadl_epi64(&lpszSetting[21].Left.bottom));
    result = lpszSetting[21].Y.top;
    pWindowPlacement[416].ptMaxPosition.x = result;
  }
  if ( nLength > 0x700 )
  {
    _mm_storel_epi64(&pWindowPlacement[416].ptMinPosition, _mm_loadl_epi64(&lpszSetting[21].Y.right));
    result = lpszSetting[21].Top.left;
    pWindowPlacement[416].ptMaxPosition.x = result;
  }
  if ( nLength > 0x70C )
  {
    _mm_storel_epi64(&pWindowPlacement[416].ptMinPosition, _mm_loadl_epi64(&lpszSetting[21].Top.top));
    result = lpszSetting[21].Top.bottom;
    pWindowPlacement[416].ptMaxPosition.x = result;
  }
  return result;
}

//----- (012355D0) --------------------------------------------------------
BOOL __stdcall DrawItemText(HDC hDC, LPCTSTR lpszText, const RECT *lprc, int fRightAlign)
{
  signed int delta; // ecx
  int left; // esi
  int len; // eax
  TCHAR szText[16384]; // [esp+Ch] [ebp-4004h]

  if ( wcslen(lpszText) > 8191 )
  {
    wcsncpy_s(szText, 8192u, lpszText, -1u);
    __report_rangecheckfailure();
    __debugbreak();
    JUMPOUT(*sub_12356D0);
  }
  tcscpy_s(szText, 8192u, lpszText);
  delta = 2;
  if ( fRightAlign )
    delta = 8;
  AutoEllipsisText(hDC, szText, 8192u, lprc->right - delta - lprc->left);
  if ( fRightAlign )
  {
    SetTextAlign(hDC, TA_RIGHT);
    left = lprc->right - 10;
  }
  else
  {
    SetTextAlign(hDC, 0);
    left = lprc->left + 2;
  }
  len = lstrlenW(szText);
  return ExtTextOutW(hDC, left, lprc->top + 1, 6u, lprc, szText, len, 0);
}
// 12867E8: using guessed type int __report_rangecheckfailure(void);

//----- (012356D0) --------------------------------------------------------
char __cdecl sub_12356D0(char a1, int a2, WORD pwLuminance, HDC hDC, RECT *lprc)
{
  int v5; // esi
  HBRUSH v6; // eax
  RECT *v7; // esi
  HDC v8; // ebx
  HBRUSH v10; // eax
  RECT *v11; // esi
  HDC v12; // ebx
  HBRUSH v13; // eax
  RECT *v14; // ebx
  float v15; // xmm0_4
  HBRUSH v16; // eax
  RECT *v17; // esi
  HDC v18; // ebx
  float v19; // xmm0_4
  HDC v20; // edi
  double v21; // xmm0_8
  COLORREF v22; // eax
  WORD pwHue[4]; // [esp+1Ch] [ebp-Ch]
  WORD pwSaturation[2]; // [esp+24h] [ebp-4h]

  v5 = pwLuminance;
  switch ( pwLuminance )
  {
    case IDC_SYSTEMINFOMEM_STATIC_PRIORITY_7:
      v6 = GetSysColorBrush(COLOR_WINDOW);
      v7 = lprc;
      v8 = hDC;
      FrameRect(hDC, lprc, v6);
      ++v7->top;
      --v7->right;
      if ( !*(a2 + 1372) )
        InitTreeListItemColor(a2);
      PEDrawIcon(*(a2 + 1372), v8, &v7->left, gColorGraphBackground, 1, 0.0);
      return 1;
    case IDD_PROCPERFCOLUMNS_CHECKBOX_PROCESS_TIMELINE:
      v10 = GetSysColorBrush(5);
      v11 = lprc;
      v12 = hDC;
      FrameRect(hDC, lprc, v10);
      ++v11->top;
      --v11->right;
      if ( !*(a2 + 1372) )
        InitTreeListItemColor(a2);
      sub_1231FD0(COERCE_FLOAT(a2 + 624), v12, &v11->left, gColorGraphBackground);
      return 1;
    case IDC_SYSTEMINFOIO_STATIC_OTHER_BYTES_DELTA:
      v13 = GetSysColorBrush(5);
      v14 = lprc;
      FrameRect(hDC, lprc, v13);
      ++v14->top;
      --v14->right;
      if ( !*(a2 + 908) )
        InitTreeListItemColor(a2);
      v15 = qword_12FBA40;
      PEDrawIcon(*(a2 + 908), hDC, &v14->left, gColorGraphBackground, 1, ((v15 * 0.2 + qword_12FBA40) * 0.0009765625));
      return 1;
  }
  if ( pwLuminance != 1330 )
  {
    v20 = hDC;
    if ( pwLuminance == 1670 && sub_1281820(*(a2 + 844)) )
    {
      if ( sub_1282910(*(a2 + 844)) )
        SetTextColor(v20, 0xFFu);
      else
        SetTextColor(v20, 0xFF0000u);
      SelectObject(v20, ghDefaultFontUnderline);
    }
    if ( a1 || !gbShowColumnHeatmaps )
      return 0;
    *&pwLuminance = 0;
    switch ( v5 )
    {
      case 1055:
        ColorRGBToHLS(0x3C943Cu, &pwHue[2], &pwLuminance, pwSaturation);
        if ( *(a2 + 68) )
        {
          v21 = *(a2 + 1296) / 100.0;
          if ( v21 > 1.0 )
            v21 = doubleOnePointZero;
        }
        else
        {
          v21 = 0.0;
        }
        break;
      case 1060:
        ColorRGBToHLS(0x82A0u, &pwHue[2], &pwLuminance, pwSaturation);
        v21 = *(a2 + 888) * 0.0009765625 / *&gpGraphClassData[0]->dbTotalPageFile;
        break;
      case 1063:
        ColorRGBToHLS(0x4080FFu, &pwHue[2], &pwLuminance, pwSaturation);
        v21 = *(a2 + 900) * 0.0009765625 / *&gpGraphClassData[5]->dbTotalPageFile;
        break;
      case 1650:
        ColorRGBToHLS(0x8080FFu, &pwHue[2], &pwLuminance, pwSaturation);
        v21 = *(a2 + 1384) / 100.0;
        break;
      default:
        return 0;
    }
    if ( pwLuminance )
    {
      *&pwLuminance = sub_1236210(v21, 0x82u, 0xE6u);
      if ( pwLuminance >= 0x6Eu )
        SetTextColor(v20, 0);
      else
        SetTextColor(v20, 0xFFFFFFu);
      v22 = ColorHLSToRGB(pwHue[2], pwLuminance, pwSaturation[0]);
      SetBkColor(v20, v22);
    }
    return 0;
  }
  v16 = GetSysColorBrush(5);
  v17 = lprc;
  v18 = hDC;
  FrameRect(hDC, lprc, v16);
  ++v17->top;
  --v17->right;
  if ( !*(a2 + 1064) )
    InitTreeListItemColor(a2);
  v19 = *&gptrIOGraphData__3UCSimpleGraphData__A.field_8;
  PEDrawIcon(*(a2 + 1064), v18, &v17->left, gColorGraphBackground, 1, (v19 * 1.2));
  return 1;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E96CF: using guessed type char gbShowColumnHeatmaps;
// 12E9B24: using guessed type int ColorPacked;
// 12FBA40: using guessed type __int64 qword_12FBA40;

//----- (01235AD0) --------------------------------------------------------
errno_t __cdecl sub_1235AD0(int a1, int a2, int a3, int a4, int a5, wchar_t *Dst, rsize_t SizeInWords)
{
  double v7; // xmm1_8
  errno_t result; // eax
  char v9; // fl
  bool v10; // cf
  bool v11; // zf
  char v12; // sf
  char v13; // of
  char v14; // pf

  v7 = *a1;
  if ( *a1 == 0.0 && !__PAIR__(a3, a2) && !__PAIR__(a5, a4) )
    return tcscpy_s(Dst, SizeInWords, gpszTargetName);
  if ( gbShowCpuFractions )
  {
    if ( v7 >= 0.006 )
      return swprintf_s(Dst, SizeInWords, L"%02.2f", LODWORD(v7), HIDWORD(v7));
    result = swprintf_s(Dst, SizeInWords, L"< 0.01", LODWORD(v7), HIDWORD(v7));
  }
  else
  {
    if ( v7 >= 0.6 )
      return swprintf_s(Dst, SizeInWords, L"%0.0f", LODWORD(v7), HIDWORD(v7));
    result = swprintf_s(Dst, SizeInWords, L"< 1", LODWORD(v7), HIDWORD(v7));
  }
  v10 = *a1 < 0.0;
  v14 = 0;
  v11 = *a1 == 0.0;
  v12 = 0;
  v13 = 0;
  BYTE1(result) = v9;
  if ( *a1 == 0.0 )
    *a1 = dbl_12BE9C8;
  return result;
}
// 12BE04C: using guessed type wchar_t a001[7];
// 12BE9C8: using guessed type double dbl_12BE9C8;
// 12E96C9: using guessed type char gbShowCpuFractions;

//----- (01235BB0) --------------------------------------------------------
LPCWSTR __cdecl sub_1235BB0(wchar_t *Dst, __int64 a2)
{
  if ( *&a2 == 0.0 )
    return tcscpy_s(Dst, 0x104u, gpszTargetName);
  if ( gbFormatIoBytes )
    return sub_1232200(0, Dst, 0x104u, a2, 0i64, 0i64 >> 63);
  stprintf(Dst, L"%f", a2);
  return GetNumberTextFormat(Dst, 0x104u);
}
// 12E96D5: using guessed type char gbFormatIoBytes;

//----- (01235C30) --------------------------------------------------------
char __cdecl GetListColor(HWND hLstCtrl, int *nIDs, int bFocused_1, DWORD *clrTex, DWORD *clrBack)
{
  bool bFocused; // cl
  int nState; // ebx
  DWORD (__stdcall *GetSysColor)(int); // esi
  char result; // al
  DWORD (__stdcall *GetSysColor_1)(int); // ecx
  int color; // eax
  bool bTreeList; // [esp+Ah] [ebp-2h]
  char ret; // [esp+Bh] [ebp-1h]

  bFocused = GetFocus() == hLstCtrl;
  ret = 0;
  bTreeList = hLstCtrl == ghWndTreeListView;
  if ( nIDs <= 1000 )
  {
    nState = bFocused_1;
  }
  else
  {
    nState = nIDs[4];
    if ( nIDs[2] == gnCounter && nState == 1 )
      nState = nIDs[3];
  }
  if ( bFocused_1 )
  {
    GetSysColor = ::GetSysColor;
    if ( bFocused )
    {
      *clrTex = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
      *clrBack = ::GetSysColor(COLOR_HIGHLIGHT);
      return 0;
    }
    goto LABEL_9;
  }
  if ( nIDs >= 1000 )
  {
    GetSysColor_1 = ::GetSysColor;
    switch ( nState )
    {
      case 0:
        color = ::GetSysColor(COLOR_WINDOW);
        GetSysColor_1 = ::GetSysColor;
        goto LABEL_18;
      case 1:
        color = gColorDeleteObjects;
        goto LABEL_17;
      case 2:
      case 3:
        color = gColorNewProc;
LABEL_17:
        ret = 1;
LABEL_18:
        *clrBack = color;
        break;
      default:
        break;
    }
    *clrTex = GetSysColor_1(COLOR_WINDOWTEXT);
    if ( !nState )
    {
      if ( hLstCtrl == ghWndDllsListCtrl && gbHighlightRelocatedDlls && nIDs[11] & 1 )
        *clrBack = ColorRelocatedDlls;
      if ( bTreeList )
      {
        if ( gbHighlightOwnProcesses && gbShowAllUsers && nIDs[10] & 0x40 )
          *clrBack = ColorOwn;
        if ( gbHighlightServices && nIDs[10] & 0x20 )
          *clrBack = ColorServices;
        if ( nIDs[10] & 0x800 && gbHighlightJobs )
          *clrBack = gColorJobs_0;
        if ( (*(nIDs + 1288) || nIDs[321]) && gbHighlightNetProcess )
          *clrBack = gColorNet;
      }
      if ( gbHighlightPacked && (bTreeList && nIDs[10] & 0x100 || hLstCtrl == ghWndDllsListCtrl && nIDs[11] & 4) )
        *clrBack = ColorPacked;
      if ( bTreeList )
      {
        if ( gbHighlightProtected && nIDs[10] & 0x400 )
          *clrBack = gColorProtected;
        if ( gbHighlightImmersive && nIDs[10] & 0x1000 )
          *clrBack = ColorImmersive;
        if ( gbHighlightSuspend )
        {
          if ( *(nIDs + 40) < 0 )
            *clrBack = gColorSuspend;
        }
      }
    }
    result = ret;
  }
  else
  {
    GetSysColor = ::GetSysColor;
    if ( !nIDs )
    {
LABEL_9:
      *clrTex = GetSysColor(COLOR_WINDOWTEXT);
      *clrBack = GetSysColor(COLOR_ACTIVEBORDER);
      return 0;
    }
    *clrTex = ::GetSysColor(COLOR_WINDOWTEXT);
    *clrBack = ::GetSysColor(COLOR_WINDOW);
    result = 0;
  }
  return result;
}
// 128C704: using guessed type int (__stdcall *)(_DWORD);
// 12E96B8: using guessed type char gbHighlightJobs;
// 12E96B9: using guessed type char gbHighlightServices;
// 12E96BA: using guessed type char gbHighlightOwnProcesses;
// 12E96BB: using guessed type char gbHighlightNetProcess;
// 12E96BE: using guessed type char gbHighlightPacked;
// 12E96BF: using guessed type char gbHighlightImmersive;
// 12E96C0: using guessed type char gbHighlightSuspend;
// 12E96C1: using guessed type char gbHighlightProtected;
// 12E96CE: using guessed type char gbHighlightRelocatedDlls;
// 12E96D0: using guessed type char gbShowAllUsers;
// 12E9B08: using guessed type int ColorOwn;
// 12E9B0C: using guessed type int ColorServices;
// 12E9B10: using guessed type int ColorRelocatedDlls;
// 12E9B14: using guessed type int gColorJobs_0;
// 12E9B18: using guessed type int gColorNet;
// 12E9B1C: using guessed type int gColorNewProc;
// 12E9B20: using guessed type int gColorDeleteObjects;
// 12E9B24: using guessed type int ColorPacked;
// 12E9B2C: using guessed type int ColorImmersive;
// 12E9B30: using guessed type int gColorSuspend;
// 12E9B34: using guessed type int gColorProtected;
// 12EA11C: using guessed type int gnCounter;

//----- (01235E60) --------------------------------------------------------
BOOL __cdecl RedrawHeader(HWND hWnd, int iItem, int mode)
{
  BOOL result; // eax
  MACRO_HDF fmt; // ecx
  HDITEMW item; // [esp+Ch] [ebp-2Ch]

  if ( mode )
  {
    if ( gbTreeListSortable )
    {
      item.mask = HDI_FORMAT;
      SendMessageW(hWnd, HDM_GETITEMW, iItem, &item);
      fmt = HDF_SORTDOWN;
      if ( mode >= 0 )
        fmt = HDF_SORTUP;
      // HDF_BITMAP|HDF_SORTUP|HDF_SORTDOWN|HDF_RIGHT|HDF_LEFT
      item.fmt = item.fmt & -0x2601u | fmt;
    }
    else
    {
      item.mask = 0x24;                         // HDI_IMAGE|HDI_FORMAT
      SendMessageW(hWnd, HDM_GETITEMW, iItem, &item);
      // HDF_BITMAP_ON_RIGHT|HDF_IMAGE|HDF_LEFT
      item.fmt |= 0x1800u;
      item.iImage = mode < 0;
    }
    SendMessageW(hWnd, HDM_SETITEMW, iItem, &item);
    result = UpdateWindow(hWnd);
  }
  else
  {
    item.mask = HDI_FORMAT;
    SendMessageW(hWnd, HDM_GETITEMW, iItem, &item);
    if ( gbTreeListSortable )
      // HDF_BITMAP|HDF_SORTUP|HDF_SORTDOWN|HDF_RIGHT|HDF_LEFT
      item.fmt &= -0x2601u;
    else
      // HDF_BITMAP_ON_RIGHT|HDF_IMAGE|HDF_RIGHT|HDF_LEFT
      item.fmt &= -0x1801u;
    SendMessageW(hWnd, HDM_SETITEMW, iItem, &item);
    result = UpdateWindow(hWnd);
  }
  return result;
}
// 12EA8F8: using guessed type char gbTreeListSortable;

//----- (01235F60) --------------------------------------------------------
BOOL __stdcall EnumWindowsCallback2(HWND hWnd, LPARAM a2)
{
  _bstr_t *v2; // ecx
  _bstr_t *v3; // ecx
  DWORD dwProcessId; // [esp+Ch] [ebp-220h]
  BSTR *v6; // [esp+10h] [ebp-21Ch]
  WCHAR ClassName; // [esp+14h] [ebp-218h]
  int v8; // [esp+228h] [ebp-4h]

  GetWindowThreadProcessId(hWnd, &dwProcessId);
  if ( dwProcessId == *(*a2 + 68)
    && GetClassNameW(hWnd, &ClassName, 260)
    && !_wcsicmp(&ClassName, L"TabThumbnailWindow")
    && GetWindowTextW(hWnd, &ClassName, 260) )
  {
    bstr_t::EqualAssign(&v6, L"\n   ");
    v2 = *(a2 + 4);
    v8 = 0;
    bstr_t::Append(v2, &v6);
    v8 = -1;
    bstr_t::Data_t::Free(&v6);
    bstr_t::EqualAssign(&v6, &ClassName);
    v3 = *(a2 + 4);
    v8 = 1;
    bstr_t::Append(v3, &v6);
    bstr_t::Data_t::Free(&v6);
  }
  return 1;
}

//----- (01236090) --------------------------------------------------------
char __cdecl IsColumnSortable(signed int uID)
{
  bool v1; // zf

  if ( uID > IDS_PATH2 )
  {
    if ( uID <= IDS_AUTOSTARTLOCATION )
    {
      if ( uID < IDS_PACKAGENAME )
      {
        switch ( uID )
        {
          case IDS_DESKTOPINTEGRITYLEVEL:
          case IDS_COMMENT:
          case IDS_VERIFIEDSIGNER:
          case IDS_CPUHISTORY:
          case IDS_PRIVATEBYTESHISTORY:
          case IDS_WINDOWSTATUS:
          case IDS_DEP:
          case IDS_DECODEDACCESS:
          case IDS_IOHISTORY:
          case IDS_INTEGRITY:
          case IDS_VIRTUALIZED:
          case IDS_ASLR:
          case IDS_IOPRIORITY:
            return 0;
          default:
            return 1;
        }
        return 1;
      }
      return 0;
    }
    if ( uID > IDS_UIACCESS )
    {
      v1 = uID == IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD;
    }
    else
    {
      if ( uID >= IDS_PROTECTION || uID == IDS_DPIAWARENESS )
        return 0;
      v1 = uID == IDS_VIRUSTOTAL;
    }
  }
  else
  {
    if ( uID == IDS_PATH2 )
      return 0;
    if ( uID <= IDS_WINDOWTITLE )
    {
      if ( uID != IDS_WINDOWTITLE )
      {
        switch ( uID )
        {
          case IDS_PROCESS:
          case IDS_USERNAME:
          case IDS_TYPE:
          case IDS_NAME:
          case IDS_VERSION:
          case IDS_NAME2:
          case IDS_TIME:
            return 0;
          default:
            return 1;
        }
        return 1;
      }
      return 0;
    }
    if ( uID > IDS_COMPANYNAME )
    {
      v1 = uID == IDS_PATH1;
    }
    else
    {
      if ( uID >= IDS_COMMANDLINE || uID == IDS_DESCRIPTION1 )
        return 0;
      v1 = uID == IDS_DESCRIPTION2;
    }
  }
  if ( !v1 )
    return 1;
  return 0;
}

//----- (01236210) --------------------------------------------------------
unsigned __int16 __cdecl sub_1236210(double a1, unsigned __int16 a2, unsigned __int16 a3)
{
  unsigned __int16 result; // ax

  if ( a1 == 0.0 )
    result = a3;
  else
    result = a3 - 5 * (((a3 - a2) * a1) / 5);
  return result;
}

//----- (01236270) --------------------------------------------------------
BSTR **__cdecl sub_1236270(CTreeListItem *pTreeListItem, COLUMNTEXT *pData)
{
  COLUMNTEXT *pColumnText; // edi
  _WORD *v3; // eax
  int nColumn; // eax
  _WORD *v5; // eax
  int v6; // eax
  _WORD *pszCommandLine; // eax
  int v8; // eax
  CComBSTR *v9; // eax
  CComBSTR *strCommandLine; // ebx
  CComBSTR *v11; // edx
  int v12; // eax
  __int16 v13; // cx
  CComBSTR *v14; // edx
  OLECHAR *v15; // edx
  int *v16; // ebx
  CComBSTR *v17; // edi
  __int16 v18; // si
  CComBSTR *v19; // eax
  __int16 *v20; // ecx
  int v21; // esi
  __int16 v22; // ax
  _WORD *v23; // eax
  int v24; // eax
  _WORD *v25; // eax
  int v26; // eax
  _WORD *v27; // eax
  int v28; // eax
  TCHAR *i; // esi
  signed int v30; // esi
  signed int v31; // ebx
  CComBSTR *v32; // eax
  CComBSTR *v33; // edx
  CComBSTR *v34; // ecx
  CComBSTR **v35; // esi
  BSTR **v36; // eax
  _bstr_t *v37; // eax
  _bstr_t *v38; // eax
  int *v39; // eax
  const wchar_t *v40; // eax
  wchar_t *v41; // eax
  signed int v42; // esi
  CComBSTR *v43; // edi
  int v44; // eax
  OLECHAR *v45; // esi
  CComBSTR **v46; // eax
  _bstr_t *v47; // eax
  BSTR v48; // ecx
  int v49; // edx
  OLECHAR v50; // ax
  int v51; // ecx
  BSTR v52; // eax
  CComBSTR *v53; // esi
  LPARAM lParam; // [esp+14h] [ebp-40h]
  CComBSTR *v56; // [esp+18h] [ebp-3Ch]
  BSTR *v57; // [esp+1Ch] [ebp-38h]
  CComBSTR *v58; // [esp+20h] [ebp-34h]
  OLECHAR **v59; // [esp+24h] [ebp-30h]
  OLECHAR **v60; // [esp+28h] [ebp-2Ch]
  OLECHAR **v61; // [esp+2Ch] [ebp-28h]
  CComBSTR *v62; // [esp+30h] [ebp-24h]
  CComBSTR *v63; // [esp+34h] [ebp-20h]
  CComBSTR *ppv; // [esp+38h] [ebp-1Ch]
  CComBSTR *ppComBSTR2; // [esp+3Ch] [ebp-18h]
  CComBSTR *v66; // [esp+40h] [ebp-14h]
  CComBSTR *ppComBSTR; // [esp+44h] [ebp-10h]
  int v68; // [esp+50h] [ebp-4h]

  if ( !(dword_12E9E5C & 1) )
  {
    dword_12E9E5C |= 1u;
    v68 = 0;
    bstr_t::EqualAssign(&gppComBSTR2, L"\r\n");
    atexit(sub_12AA910);
  }
  ppComBSTR = 0;
  pColumnText = pData;
  v68 = 1;
  v3 = pData->szColumnText1;
  if ( v3 && *v3 )
  {
    nColumn = 0;
    if ( gdwProcessListColumnCount <= 0 )
    {
LABEL_8:
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      bstr_t::EqualAssign(&ppv, pColumnText->szColumnText1);
      LOBYTE(v68) = 2;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
    }
    else
    {
      while ( gdwIDMapProcesListForSelectColumn[nColumn] != IDS_DESCRIPTION1 )
      {
        if ( ++nColumn >= gdwProcessListColumnCount )
          goto LABEL_8;
      }
    }
  }
  v5 = pColumnText->szColumnText2;
  if ( v5 && *v5 )
  {
    v6 = 0;
    if ( gdwProcessListColumnCount <= 0 )
    {
LABEL_14:
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      bstr_t::EqualAssign(&ppv, pColumnText->szColumnText2);
      LOBYTE(v68) = 3;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
    }
    else
    {
      while ( gdwIDMapProcesListForSelectColumn[v6] != IDS_COMPANYNAME )
      {
        if ( ++v6 >= gdwProcessListColumnCount )
          goto LABEL_14;
      }
    }
  }
  pszCommandLine = pColumnText->m_CommandLine;
  if ( pszCommandLine && *pszCommandLine )
  {
    v8 = 0;
    if ( gdwProcessListColumnCount <= 0 )
    {
LABEL_20:
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      bstr_t::EqualAssign(&ppv, L"Command Line:\n   ");
      LOBYTE(v68) = 4;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
      v9 = _wcsdup(pColumnText->m_CommandLine);
      strCommandLine = v9;
      v11 = v9;
      v66 = v9;
      v12 = &v9->bstr + 2;
      do
      {
        v13 = v11->bstr;
        v11 = (v11 + 2);
      }
      while ( v13 );
      if ( ((v11 - v12) >> 1) <= 100 )
      {
        bstr_t::EqualAssign(&ppv, pColumnText->m_CommandLine);
        LOBYTE(v68) = 8;
      }
      else
      {
        v14 = 0;
        if ( wcslen(strCommandLine) > 0x64 )
        {
          v15 = strCommandLine;
          v16 = &strCommandLine[16].Length;
          v17 = 0;
          do
          {
            v18 = *v16;
            *v16 = 0;
            bstr_t::EqualAssign(&ppv, v15);
            LOBYTE(v68) = 5;
            bstr_t::Append(&ppComBSTR, &ppv);
            LOBYTE(v68) = 1;
            bstr_t::Data_t::Free(&ppv);
            bstr_t::EqualAssign(&ppComBSTR2, L"\n     ");
            LOBYTE(v68) = 6;
            bstr_t::Append(&ppComBSTR, &ppComBSTR2);
            LOBYTE(v68) = 1;
            bstr_t::Data_t::Free(&ppComBSTR2);
            v19 = v66;
            v16 += 50;
            v17 = (v17 + 100);
            *(v16 - 100) = v18;
            v15 = (v19 + 2 * v17);
            v20 = (v19 + 2 * v17);
            v21 = (v20 + 1);
            do
            {
              v22 = *v20;
              ++v20;
            }
            while ( v22 );
          }
          while ( ((v20 - v21) >> 1) > 0x64 );
          strCommandLine = v66;
          v62 = v17;
          pColumnText = pData;
          v14 = v62;
        }
        bstr_t::EqualAssign(&ppv, strCommandLine + v14);
        LOBYTE(v68) = 7;
      }
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
    }
    else
    {
      while ( gdwIDMapProcesListForSelectColumn[v8] != IDS_COMMANDLINE )
      {
        if ( ++v8 >= gdwProcessListColumnCount )
          goto LABEL_20;
      }
    }
  }
  v23 = pColumnText->m_PathName;
  if ( v23 && *v23 )
  {
    v24 = 0;
    if ( gdwProcessListColumnCount <= 0 )
    {
LABEL_37:
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      bstr_t::EqualAssign(&ppv, L"Path:\n   ");
      LOBYTE(v68) = 9;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
      bstr_t::EqualAssign(&ppv, pColumnText->m_PathName);
      LOBYTE(v68) = 10;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
    }
    else
    {
      while ( gdwIDMapProcesListForSelectColumn[v24] != 1061 )
      {
        if ( ++v24 >= gdwProcessListColumnCount )
          goto LABEL_37;
      }
    }
  }
  v25 = pColumnText->m_PackageName;
  if ( v25 && *v25 )
  {
    v26 = 0;
    if ( gdwProcessListColumnCount <= 0 )
    {
LABEL_43:
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      CComBSTR::AssignA(&ppv, "Package:\n   ");
      LOBYTE(v68) = 11;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
      bstr_t::EqualAssign(&ppv, pColumnText->m_PackageName);
      LOBYTE(v68) = 12;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
    }
    else
    {
      while ( gdwIDMapProcesListForSelectColumn[v26] != 1654 )
      {
        if ( ++v26 >= gdwProcessListColumnCount )
          goto LABEL_43;
      }
    }
  }
  v27 = pColumnText->m_Comment;
  if ( v27 && *v27 )
  {
    v28 = 0;
    if ( gdwProcessListColumnCount <= 0 )
    {
LABEL_49:
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      bstr_t::EqualAssign(&ppv, L"Comment:\n   ");
      LOBYTE(v68) = 13;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
      bstr_t::EqualAssign(&ppv, pColumnText->m_Comment);
      LOBYTE(v68) = 14;
      bstr_t::Append(&ppComBSTR, &ppv);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&ppv);
    }
    else
    {
      while ( gdwIDMapProcesListForSelectColumn[v28] != 1181 )
      {
        if ( ++v28 >= gdwProcessListColumnCount )
          goto LABEL_49;
      }
    }
  }
  if ( pColumnText->m_ClassName )
  {
    bstr_t::Append(&ppComBSTR, &gppComBSTR2);
    if ( _wcsicmp(pColumnText->m_TaskEngName, L"rundll32.exe") )
    {
      bstr_t::EqualAssign(&pData, L"COM Class:\n   ");
      LOBYTE(v68) = 16;
      bstr_t::Append(&ppComBSTR, &pData);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&pData);
      if ( !pColumnText->field_350 )
      {
LABEL_56:
        bstr_t::EqualAssign(&pData, pColumnText->m_ClassName);
        LOBYTE(v68) = 19;
        bstr_t::Append(&ppComBSTR, &pData);
        LOBYTE(v68) = 1;
        bstr_t::Data_t::Free(&pData);
        if ( pColumnText->field_358 )
        {
          bstr_t::EqualAssign(&pData, L"\n   ");
          LOBYTE(v68) = 20;
          bstr_t::Append(&ppComBSTR, &pData);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&pData);
          bstr_t::EqualAssign(&pData, pColumnText->field_358);
          LOBYTE(v68) = 21;
          bstr_t::Append(&ppComBSTR, &pData);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&pData);
        }
        if ( pColumnText->field_354 )
        {
          bstr_t::EqualAssign(&pData, L"\n   ");
          LOBYTE(v68) = 22;
          bstr_t::Append(&ppComBSTR, &pData);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&pData);
          bstr_t::EqualAssign(&pData, pColumnText->field_354);
          LOBYTE(v68) = 23;
          bstr_t::Append(&ppComBSTR, &pData);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&pData);
        }
        goto LABEL_93;
      }
      bstr_t::EqualAssign(&pData, pColumnText->field_350);
      LOBYTE(v68) = 17;
      bstr_t::Append(&ppComBSTR, &pData);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&pData);
      bstr_t::EqualAssign(&pData, L"\n   ");
      LOBYTE(v68) = 18;
    }
    else
    {
      bstr_t::EqualAssign(&pData, L"Rundll Target:\n   ");
      LOBYTE(v68) = 15;
    }
    bstr_t::Append(&ppComBSTR, &pData);
    LOBYTE(v68) = 1;
    bstr_t::Data_t::Free(&pData);
    goto LABEL_56;
  }
  if ( _wcsicmp(pColumnText->m_TaskEngName, L"taskeng.exe")
    && _wcsicmp(pColumnText->m_TaskEngName, L"taskhost.exe")
    && _wcsicmp(pColumnText->m_TaskEngName, L"taskhostex.exe")
    && _wcsicmp(pColumnText->m_TaskEngName, L"taskhostw.exe") )
  {
    if ( _wcsicmp(pColumnText->m_TaskEngName, L"iexplore.exe") && _wcsicmp(pColumnText->m_TaskEngName, L"iexplore.exe") )
    {
      if ( pColumnText->m_WMIProviders )
      {
        bstr_t::Append(&ppComBSTR, &gppComBSTR2);
        bstr_t::EqualAssign(&pData, L"WMI Providers:");
        LOBYTE(v68) = 27;
        bstr_t::Append(&ppComBSTR, &pData);
        LOBYTE(v68) = 1;
        bstr_t::Data_t::Free(&pData);
        for ( i = pColumnText->m_WMIProviders; i; i = *(i + 3) )
        {
          bstr_t::EqualAssign(&pData, L"\n   [");
          LOBYTE(v68) = 28;
          bstr_t::Append(&ppComBSTR, &pData);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&pData);
          bstr_t::EqualAssign(&ppv, *i);
          LOBYTE(v68) = 29;
          bstr_t::Append(&ppComBSTR, &ppv);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&ppv);
          bstr_t::EqualAssign(&ppComBSTR2, L"]\n       Namespace: ");
          LOBYTE(v68) = 30;
          bstr_t::Append(&ppComBSTR, &ppComBSTR2);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&ppComBSTR2);
          bstr_t::EqualAssign(&v66, *(i + 1));
          LOBYTE(v68) = 31;
          bstr_t::Append(&ppComBSTR, &v66);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&v66);
          bstr_t::EqualAssign(&v63, L"\n       DLL: ");
          LOBYTE(v68) = 32;
          bstr_t::Append(&ppComBSTR, &v63);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&v63);
          bstr_t::EqualAssign(&v62, *(i + 2));
          LOBYTE(v68) = 33;
          bstr_t::Append(&ppComBSTR, &v62);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&v62);
        }
      }
      else if ( pColumnText->field_28 & 0x20 )
      {
        if ( pColumnText->m_ServiceName )
        {
          bstr_t::EqualAssign(&v62, L" (");
          LOBYTE(v68) = 34;
          bstr_t::Append(&ppComBSTR, &v62);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&v62);
          bstr_t::EqualAssign(&v62, pColumnText->m_ServiceName);
          LOBYTE(v68) = 35;
          bstr_t::Append(&ppComBSTR, &v62);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&v62);
          bstr_t::EqualAssign(&v62, L")");
          LOBYTE(v68) = 36;
          bstr_t::Append(&ppComBSTR, &v62);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&v62);
        }
        bstr_t::Append(&ppComBSTR, &gppComBSTR2);
        bstr_t::EqualAssign(&v62, L"Services:");
        LOBYTE(v68) = 37;
        bstr_t::Append(&ppComBSTR, &v62);
        LOBYTE(v68) = 1;
        bstr_t::Data_t::Free(&v62);
        EnterCriticalSection(&gEnumServiceLock);
        v30 = gdwServiceNameBufferRealSize;
        v31 = 0;
        v32 = malloc(4 * gdwServiceNameBufferRealSize);
        v33 = 0;
        v66 = v32;
        v63 = 0;
        if ( v30 > 0 )
        {
          v34 = 0;
          ppv = 0;
          do
          {
            v61 = &gstrServiceNameBuffer[v34];
            if ( *&gstrServiceNameBuffer[v34 + 36] == pColumnText->field_44 )
            {
              ppComBSTR2 = 0;
              LOBYTE(v68) = 38;
              bstr_t::EqualAssign(&v62, *v61);
              LOBYTE(v68) = 39;
              v35 = CComBSTR::AssignA(&v56, "]");
              LOBYTE(v68) = 40;
              v36 = CComBSTR::AssignA(&v57, " [");
              LOBYTE(v68) = 41;
              v37 = sub_11F3B50(&v58, *&gstrServiceNameBuffer[ppv + 4], v36);
              LOBYTE(v68) = 42;
              v38 = CComBSTR::AppendTail(v37, &v59, &v62);
              LOBYTE(v68) = 43;
              v39 = CComBSTR::AppendTail(v38, &v60, v35);
              sub_11F3A50(&ppComBSTR2, v39);
              bstr_t::Data_t::Free(&v60);
              bstr_t::Data_t::Free(&v59);
              bstr_t::Data_t::Free(&v58);
              bstr_t::Data_t::Free(&v57);
              bstr_t::Data_t::Free(&v56);
              bstr_t::Data_t::Free(&v62);
              if ( ppComBSTR2 )
                v40 = ppComBSTR2->bstr;
              else
                v40 = 0;
              v41 = _wcsdup(v40);
              LOBYTE(v68) = 1;
              *(&v66->bstr + v31++) = v41;
              bstr_t::Data_t::Free(&ppComBSTR2);
              v30 = gdwServiceNameBufferRealSize;
              v34 = ppv;
              v33 = v63;
            }
            v33 = (v33 + 1);
            v34 = (v34 + 44);
            v63 = v33;
            ppv = v34;
          }
          while ( v33 < v30 );
          v32 = v66;
        }
        qsort(v32, v31, 4u, sub_1245A60);
        v42 = 0;
        if ( v31 > 0 )
        {
          v43 = v66;
          do
          {
            bstr_t::EqualAssign(&v62, L"\n   ");
            LOBYTE(v68) = 44;
            bstr_t::Append(&ppComBSTR, &v62);
            LOBYTE(v68) = 1;
            bstr_t::Data_t::Free(&v62);
            bstr_t::EqualAssign(&v63, *(&v43->bstr + v42));
            LOBYTE(v68) = 45;
            bstr_t::Append(&ppComBSTR, &v63);
            LOBYTE(v68) = 1;
            bstr_t::Data_t::Free(&v63);
            free(*(&v43->bstr + v42++));
          }
          while ( v42 < v31 );
          pColumnText = pData;
        }
        LeaveCriticalSection(&gEnumServiceLock);
        free(v66);
      }
    }
    else if ( HIWORD(pColumnText->field_280[3]) >= 0x37u )
    {
      v44 = pColumnText->field_54;
      if ( v44 )
      {
        if ( !_wcsicmp(*(v44 + 60), L"iexplore.exe") )
        {
          bstr_t::Append(&ppComBSTR, &gppComBSTR2);
          bstr_t::EqualAssign(&pData, L"Tabs:");
          LOBYTE(v68) = 26;
          bstr_t::Append(&ppComBSTR, &pData);
          LOBYTE(v68) = 1;
          bstr_t::Data_t::Free(&pData);
          lParam = pColumnText;
          v56 = &ppComBSTR;
          EnumWindows(EnumWindowsCallback2, &lParam);
        }
      }
    }
  }
  else
  {
    v45 = sub_1244990(pColumnText->field_44);
    if ( v45 )
    {
      bstr_t::Append(&ppComBSTR, &gppComBSTR2);
      v46 = bstr_t::EqualAssign(&v56, v45);
      LOBYTE(v68) = 24;
      v47 = sub_11F3B50(&pData, L"Tasks:\n", v46);
      LOBYTE(v68) = 25;
      bstr_t::Append(&ppComBSTR, v47);
      bstr_t::Data_t::Free(&pData);
      LOBYTE(v68) = 1;
      bstr_t::Data_t::Free(&v56);
      free(v45);
    }
  }
LABEL_93:
  if ( !ppComBSTR || !ppComBSTR->bstr || !SysStringLen(ppComBSTR->bstr) )
  {
    bstr_t::Append(&ppComBSTR, &gppComBSTR2);
    bstr_t::EqualAssign(&pData, pColumnText->m_TaskEngName);
    LOBYTE(v68) = 46;
    bstr_t::Append(&ppComBSTR, &pData);
    LOBYTE(v68) = 1;
    bstr_t::Data_t::Free(&pData);
  }
  if ( gppComBSTR2 )
    v48 = gppComBSTR2->bstr;
  else
    v48 = 0;
  v49 = (v48 + 1);
  do
  {
    v50 = *v48;
    ++v48;
  }
  while ( v50 );
  v51 = (v48 - v49) >> 1;
  if ( ppComBSTR )
    v52 = ppComBSTR->bstr;
  else
    v52 = 0;
  bstr_t::EqualAssign(pTreeListItem, &v52[v51]);
  v53 = ppComBSTR;
  if ( ppComBSTR && !InterlockedDecrement(&ppComBSTR->Length) && v53 )
  {
    if ( v53->bstr )
    {
      SysFreeString(v53->bstr);
      v53->bstr = 0;
    }
    if ( v53->hKey )
    {
      j_j__free(v53->hKey);
      v53->hKey = 0;
    }
    j__free(v53);
  }
  return pTreeListItem;
}
// 12E9E5C: using guessed type int dword_12E9E5C;

//----- (01236F30) --------------------------------------------------------
void __cdecl SerializeColumnset(int a1, int ArgList, TCHAR *pBuffer)
{
  GLOBALVAR var[10]; // [esp+0h] [ebp-3F4h]
  GLOBALVAR v4[10]; // [esp+F0h] [ebp-304h]
  GLOBALVAR v5; // [esp+1E0h] [ebp-214h]

  *&var[0].Name = dbl_12BEA00;
  *&var[4].Name = dbl_12BE9F0;
  var[1].dDefaultValue.HighPart = (pBuffer + 0x208);
  *&var[5].Name = 0i64;
  var[2].dDefaultValue.HighPart = (pBuffer + 0x210);
  var[3].dDefaultValue.HighPart = (pBuffer + 0x20C);
  *(&var[4].dDefaultValue.QuadPart + 4) = (pBuffer + 0x2D0);
  var[5].dDefaultValue.HighPart = (pBuffer + 0x528);
  var[6].dDefaultValue.HighPart = (pBuffer + 0x52C);
  var[7].dDefaultValue.HighPart = (pBuffer + 0x4A0);
  *&var[6].Name = doubleFourPointZero;
  var[8].dDefaultValue.HighPart = (pBuffer + 0x45C);
  *&var[8].Name = 0i64;
  var[9].dDefaultValue.HighPart = (pBuffer + 0x56C);
  *&var[9].Name = dbl_12BE9E8;
  v4[0].dDefaultValue.HighPart = (pBuffer + 0x460);
  var[0].Size = L"ColumnSetName";
  var[0].Value = 4;
  var[0].dDefaultValue.LowPart = 0x208;
  var[0].dDefaultValue.HighPart = pBuffer;
  *&var[1].Name = 0i64;
  var[1].Size = L"ProcessImageColumnWidth";
  var[1].Value = 3;
  var[1].dDefaultValue.LowPart = 2;
  var[2].Size = L"ProcessColumns";
  var[2].Value = 6;
  var[2].dDefaultValue.LowPart = 0xC0;
  *&var[3].Name = 0i64;
  var[3].Size = L"PrcessColumnCount";
  var[3].Value = 0;
  var[3].dDefaultValue.LowPart = 0;
  var[4].Size = L"ProcessColumnMap";
  var[4].Value = 5;
  var[4].dDefaultValue.LowPart = 0x180;
  var[5].Size = L"DllColumnCount";
  var[5].Value = 0;
  var[5].dDefaultValue.LowPart = 0;
  var[6].Size = L"DllColumns";
  var[6].Value = 6;
  var[6].dDefaultValue.LowPart = 0x40;
  *&var[7].Name = 0i64;
  var[7].Size = L"DllColumnMap";
  var[7].Value = 5;
  var[7].dDefaultValue.LowPart = 0x80;
  var[8].Size = L"HandleColumnCount";
  var[8].Value = 0;
  var[8].dDefaultValue.LowPart = 0;
  var[9].Size = L"HandleColumnMap";
  var[9].Value = 5;
  var[9].dDefaultValue.LowPart = 0x80;
  *&v4[0].Name = 0i64;
  v4[0].Size = L"HandleColumns";
  v4[0].Value = 6;
  v4[0].dDefaultValue.LowPart = 64;
  *&v4[1].Name = 0i64;
  v4[1].Size = L"HandleSortColumn";
  v4[1].Value = 0;
  v4[1].dDefaultValue.LowPart = 0;
  v4[1].dDefaultValue.HighPart = (pBuffer + 0x5EC);
  *&v4[2].Name = 0i64;
  v4[2].Size = L"HandleSortDirection";
  v4[2].dDefaultValue.HighPart = (pBuffer + 0x5F0);
  v4[3].dDefaultValue.HighPart = (pBuffer + 0x520);
  v4[4].dDefaultValue.HighPart = (pBuffer + 0x524);
  v4[5].dDefaultValue.HighPart = (pBuffer + 0x450);
  v4[6].dDefaultValue.HighPart = (pBuffer + 0x454);
  v4[7].dDefaultValue.HighPart = (pBuffer + 0x20A);
  v4[8].dDefaultValue.HighPart = (pBuffer + 0x458);
  *&v4[6].Name = dbl_12BEA40;
  v4[2].Value = 1;
  v4[2].dDefaultValue.LowPart = 0;
  *&v4[3].Name = doubleOnePointZero;
  v4[3].Size = L"DllSortColumn";
  v4[3].Value = 0;
  v4[3].dDefaultValue.LowPart = 0;
  *&v4[4].Name = 0i64;
  v4[4].Size = L"DllSortDirection";
  v4[4].Value = 1;
  v4[4].dDefaultValue.LowPart = 0;
  *&v4[5].Name = doubleOnePointZero;
  v4[5].Size = L"ProcessSortColumn";
  v4[5].Value = 0;
  v4[5].dDefaultValue.LowPart = 0;
  v4[6].Size = L"ProcessSortDirection";
  v4[6].Value = 1;
  v4[6].dDefaultValue.LowPart = 0;
  *&v4[7].Name = doubleOnePointZero;
  v4[7].Size = L"ShowProcessTree";
  v4[7].Value = 1;
  v4[7].dDefaultValue.LowPart = 0;
  *&v4[8].Name = doubleOnePointZero;
  v4[8].Size = L"StatusBarColumns";
  v4[8].Value = 0;
  v4[8].dDefaultValue.LowPart = 0;
  *&v4[9].Name = dbl_12BE9F8;
  v4[9].Size = 0;
  v4[9].Value = 0;
  v4[9].dDefaultValue.QuadPart = 0i64;
  *&v5.Name = 0i64;
  stprintf(&v5.Size, L"Software\\Sysinternals\\Process Explorer\\ColumnSet%d", ArgList);
  var[0].Name = _wcsdup(&v5.Size);
  if ( a1 )
    SaveGlobalVariable(var, (var + 8));
  else
    LoadGlobalVariablesFromRegistry(var, (var + 8));
  free(var[0].Name);
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCB38: using guessed type double doubleFourPointZero;
// 12BD414: using guessed type wchar_t aProcesscolumns[15];
// 12BD434: using guessed type wchar_t aProcessimageco[24];
// 12BD464: using guessed type wchar_t aHandlecolumns[14];
// 12BD480: using guessed type wchar_t aDllcolumns[11];
// 12BD4D8: using guessed type wchar_t aHandlesortcolu[17];
// 12BD4FC: using guessed type wchar_t aHandlesortdire[20];
// 12BD524: using guessed type wchar_t aDllsortcolumn[14];
// 12BD540: using guessed type wchar_t aDllsortdirecti[17];
// 12BD564: using guessed type wchar_t aProcesssortcol[18];
// 12BD588: using guessed type wchar_t aProcesssortdir[21];
// 12BD7D4: using guessed type wchar_t aShowprocesstre[16];
// 12BD8BC: using guessed type wchar_t aPrcesscolumnco[18];
// 12BD8E0: using guessed type wchar_t aProcesscolumnm[17];
// 12BD904: using guessed type wchar_t aDllcolumncount[15];
// 12BD924: using guessed type wchar_t aDllcolumnmap[13];
// 12BD940: using guessed type wchar_t aHandlecolumnco[18];
// 12BD964: using guessed type wchar_t aHandlecolumnma[16];
// 12BDB90: using guessed type wchar_t aStatusbarcolum[17];
// 12BDE18: using guessed type wchar_t aColumnsetname[14];
// 12BE9E8: using guessed type double dbl_12BE9E8;
// 12BE9F0: using guessed type double dbl_12BE9F0;
// 12BE9F8: using guessed type double dbl_12BE9F8;
// 12BEA00: using guessed type double dbl_12BEA00;
// 12BEA40: using guessed type double dbl_12BEA40;

//----- (012373D0) --------------------------------------------------------
HANDLESANDDLLSLISTUSERPARAM *__cdecl AddRowToListCtrl(HWND hWnd, LVITEMUSERDATA2 *pUserData)
{
  int Length; // eax
  HANDLESANDDLLSLISTUSERPARAM *result; // eax
  LVITEMW item; // [esp+Ch] [ebp-464h]
  LVITEMUSERDATA2 UserData; // [esp+40h] [ebp-430h]
  TCHAR String[256]; // [esp+26Ch] [ebp-204h]

  qmemcpy(&UserData, &pUserData, sizeof(UserData));
  memset(&item.iItem, 0, 0x30u);
  tcscpy_s(String, 0x100u, UserData.m_Text);
  item.mask = 0xD;                              // LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM
  item.iItem = -0x80000001;
  item.iSubItem = 0;
  item.state = 0;
  item.stateMask = 0;
  item.pszText = String;
  Length = lstrlenW(String);
  item.iImage = 0;
  item.cchTextMax = Length + 1;
  result = malloc(0x22Cu);
  if ( result )
  {
    qmemcpy(result, &UserData, 0x22Cu);
    item.lParam = result;
    result = (SendMessageW(hWnd, LVM_INSERTITEMW, 0, &item) != -1);
  }
  return result;
}

//----- (012374F0) --------------------------------------------------------
char __cdecl AutoLoadStringArrFromId(HWND hList, UINT uStringID, UINT *nStringIds, UINT nCount)
{
  LONG idx; // eax
  LONG i; // ecx
  bool format; // zf
  char v7; // cl
  HWND hListCtrl; // edi
  WPARAM count; // ecx
  LPARAM lParam; // [esp+Ch] [ebp-A8h]
  BOOL v12; // [esp+10h] [ebp-A4h]
  int v13; // [esp+14h] [ebp-A0h]
  WCHAR *v14; // [esp+18h] [ebp-9Ch]
  int v15; // [esp+1Ch] [ebp-98h]
  LONG v16; // [esp+20h] [ebp-94h]
  HWND hWnd; // [esp+2Ch] [ebp-88h]
  WCHAR Buffer[64]; // [esp+30h] [ebp-84h]

  hWnd = hList;
  idx = 0;
  for ( i = *nCount; idx < i; ++idx )
  {
    if ( nStringIds[idx] == uStringID )
      break;
  }
  if ( idx != i )
    return 0;
  v16 = *nCount;
  v13 = MulDiv(100, gLogPixelsX, 96);
  LoadStringW(ghInstance, uStringID, Buffer, 64);
  nStringIds[*nCount] = uStringID;
  lParam = 7;
  v15 = 64;
  v14 = Buffer;
  if ( uStringID > IDD_DLLCOLUMNS_CHECKBOX_PATH )
  {
    if ( uStringID <= IDS_AUTOSTARTLOCATION )
    {
      if ( uStringID < IDS_PACKAGENAME )
      {
        switch ( uStringID )
        {
          case IDS_DESKTOPINTEGRITYLEVEL:
          case IDS_COMMENT:
          case IDS_VERIFIEDSIGNER:
          case IDS_CPUHISTORY:
          case IDS_PRIVATEBYTESHISTORY:
          case IDS_WINDOWSTATUS:
          case IDS_DEP:
          case IDS_DECODEDACCESS:
          case IDS_IOHISTORY:
          case IDS_INTEGRITY:
          case IDS_VIRTUALIZED:
          case IDS_ASLR:
          case IDS_IOPRIORITY:
            goto LABEL_25;
          default:
            goto LABEL_24;
        }
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( uStringID > 1674 )
    {
      format = uStringID == IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD;
    }
    else
    {
      if ( uStringID >= IDD_PROCCOLUMNS_CHECKBOX_PROTECTION || uStringID == IDD_PROCCOLUMNS_CHECKBOX_DPI_AWARENESS )
        goto LABEL_25;
      format = uStringID == IDD_PROCCOLUMNS_CHECKBOX_VIRUSTOTAL;
    }
  }
  else
  {
    if ( uStringID == IDD_DLLCOLUMNS_CHECKBOX_PATH )
      goto LABEL_25;
    if ( uStringID <= IDS_WINDOWTITLE )
    {
      if ( uStringID != IDS_WINDOWTITLE )
      {
        switch ( uStringID )
        {
          case IDS_PROCESS:
          case IDS_USERNAME:
          case IDS_TYPE:
          case IDS_NAME:
          case IDS_VERSION:
          case IDS_NAME2:
          case IDS_TIME:
            goto LABEL_25;
          default:
            goto LABEL_24;
        }
        goto LABEL_24;
      }
LABEL_25:
      v7 = 0;
      goto LABEL_26;
    }
    if ( uStringID > IDD_PROCCOLUMNS_CHECKBOX_COMPANY_NAME )
    {
      format = uStringID == IDD_PROCCOLUMNS_CHECKBOX_IMAGE_PATH;
    }
    else
    {
      if ( uStringID >= IDD_PROCCOLUMNS_CHECKBOX_COMMAND_LINE || uStringID == 38 )
        goto LABEL_25;
      format = uStringID == IDS_DESCRIPTION2;
    }
  }
  if ( format )
    goto LABEL_25;
LABEL_24:
  v7 = 1;
LABEL_26:
  hListCtrl = hWnd;
  format = v7 == 0;
  count = *nCount;
  v12 = !format;
  *nCount = count + 1;
  SendMessageW(hListCtrl, LVM_INSERTCOLUMNW, count, &lParam);
  SetWindowLongW(hListCtrl, GWL_USERDATA, *nCount);
  if ( uStringID == IDD_PROCCOLUMNS_CHECKBOX_VIRUSTOTAL && !gbVirusTotalCheck )
    MessageBoxW(
      hListCtrl,
      L"You can enable lookup of VirusTotal results for all files displayed in the process and DLL views by selecting the "
       "Check VirusTotal entry in the Options menu or check individual  files on-demand using the process and DLL properties dialogs.",
      L"VirusTotal",
      0x40u);
  return 1;
}
// 12E96E0: using guessed type char gbVirusTotalCheck;

//----- (01237790) --------------------------------------------------------
int __cdecl VerifySignature(HWND hWnd, LVITEMUSERDATA *pUserData)
{
  LVITEMUSERDATA *pData; // eax
  LVITEMUSERDATA *pdata; // ebx
  int v5; // eax
  LVITEMW lParam; // [esp+4h] [ebp-34h]

  memset(&lParam.iItem, 0, 0x30u);
  lParam.mask = 0xD;
  lParam.iItem = -0x80000001;
  lParam.iSubItem = 0;
  lParam.state = 0;
  lParam.stateMask = 0;
  lParam.pszText = -1;
  lParam.iImage = 0;
  pData = malloc(0x188u);
  pdata = pData;
  if ( !pData )
    return 0;
  qmemcpy(pData, &pUserData, sizeof(LVITEMUSERDATA));
  pData->RefCount = 1;
  pData->field_164 = 0;
  pData->field_168 = 0;
  pData->field_160 = 0;
  pData->field_4 = 1;
  pData->field_8 = gnCounter + 1;
  lParam.lParam = pData;
  if ( SendMessageW(hWnd, LVM_INSERTITEMW, 0, &lParam) == -1 )
    return 0;
  // 形成双端队列，插入到队列前头
  pdata->Next = NULL;
  pdata->Prev = gpUserDataInVerifySignature;
  if ( gpUserDataInVerifySignature )
    gpUserDataInVerifySignature->Next = pdata;
  gpUserDataInVerifySignature = pdata;
  if ( gbVerifySignatures )
  {
    InterlockedIncrement(&pdata->RefCount);
    _beginthread(VerifySignatureThreadProc, 0, pdata);
  }
  v5 = 2;
  if ( gbVirusTotalCheck )
    v5 = 0;
  sub_1281C30(pdata, ~(pdata->field_2C >> 1) & 1, v5);
  return 1;
}
// 12E96D7: using guessed type char gbVerifySignatures;
// 12E96E0: using guessed type char gbVirusTotalCheck;
// 12EA11C: using guessed type int gnCounter;

//----- (012378D0) --------------------------------------------------------
DLLLISTITEMPARAM *__cdecl InsertRowToDllList(HWND hwnd, HANDLESANDDLLSLISTUSERPARAM *pUserParam)
{
  WCHAR *pszText; // eax
  int len; // eax
  DLLLISTITEMPARAM *result; // eax
  HWND hListCtrl; // esi
  HWND v6; // eax
  LVITEMW lvItem; // [esp+4h] [ebp-270h]
  LVITEMEXW item; // [esp+38h] [ebp-23Ch]
  HWND hWnd; // [esp+6Ch] [ebp-208h]
  TCHAR szText[256]; // [esp+70h] [ebp-204h]

  hWnd = hwnd;
  memset(&item.iItem, 0, 0x30u);
  pszText = pUserParam->ImgName;
  item.mask = 0xD;
  item.iItem = 0x7FFFFFFF;
  item.iSubItem = 0;
  item.state = 0;
  item.stateMask = 0;
  item.pszText = pszText;
  len = lstrlenW(pszText);
  item.iImage = 0;
  item.cchTextMax = len + 1;
  // 插入用户自定义的数据结构to handlres list or dlls list
  result = malloc(0xB8u);
  if ( result )
  {
    qmemcpy(result, pUserParam, 0xB8u);
    hListCtrl = hWnd;
    item.lParam = result;
    hWnd = SendMessageW(hWnd, LVM_INSERTITEMW, 0, &item);
    if ( hWnd == HWND_MESSAGE|0x2 )
    {
      result = 0;
    }
    else
    {
      VLogEntry(szText, L"%d", pUserParam->ProcessId);
      lvItem.iSubItem = 1;
      lvItem.pszText = szText;
      SendMessageW(hListCtrl, LVM_SETITEMTEXTW, hWnd, &lvItem);
      lvItem.iSubItem = 2;
      lvItem.pszText = pUserParam->szText;
      SendMessageW(hListCtrl, LVM_SETITEMTEXTW, hWnd, &lvItem);
      lvItem.pszText = pUserParam->szFileName;
      lvItem.iSubItem = 3;
      SendMessageW(hListCtrl, LVM_SETITEMTEXTW, hWnd, &lvItem);
      v6 = GetParent(hListCtrl);
      SendMessageW(v6, FDM_STARTSORT, 0, 0);
      result = 1;
    }
  }
  return result;
}

//----- (01237A90) --------------------------------------------------------
int FindDlg::AppendToListToFind(HWND hWnd, ...)
{
  FINDDLGLISTITEMPARAM *pItemPARAM; // esi
  int result; // eax
  tagLVITEMEXW item; // [esp+8h] [ebp-10F8h]
  FINDDLGLISTITEMPARAM Param; // [esp+3Ch] [ebp-10C4h]
  va_list va; // [esp+110Ch] [ebp+Ch]

  va_start(va, hWnd);
  memmove_0(&Param, va, 0x10C0u);
  memset(&item.iItem, 0, 0x30u);
  item.mask = 0xD;
  item.iItem = 0x7FFFFFFF;
  item.iSubItem = 0;
  item.state = 0;
  item.stateMask = 0;
  item.pszText = -1;
  item.iImage = 0;
  pItemPARAM = malloc(0x10C0u);
  if ( !pItemPARAM )
    return 0;
  memmove_0(pItemPARAM, &Param, 0x10C0u);
  pItemPARAM->value4 = 2;
  pItemPARAM->nCounter = gnCounter + 1;
  item.lParam = pItemPARAM;
  if ( SendMessageW(hWnd, LVM_INSERTITEMW, 0, &item) == -1 )
    return 0;
  pItemPARAM->Next = 0;
  pItemPARAM->Prev = gpUserDataInFindDlg;
  if ( gpUserDataInFindDlg )
    gpUserDataInFindDlg->Next = pItemPARAM;
  result = 1;
  gpUserDataInFindDlg = pItemPARAM;
  return result;
}
// 12EA11C: using guessed type int gnCounter;

//----- (01237BC0) --------------------------------------------------------
#1077 *__cdecl sub_1237BC0(HWND hWnd, int a2)
{
  #1077 *result; // eax
  #1077 *pInfo; // ebx
  wchar_t *v4; // eax
  #1077 *v5; // ecx
  CTreeList *v6; // eax
  HICON v7; // ST0C_4
  _IMAGELIST *v8; // eax
  int v9; // eax
  bool v10; // zf
  LRESULT (__stdcall *v11)(HWND, UINT, WPARAM, LPARAM); // esi
  int v12; // eax
  LRESULT v13; // eax
  WPARAM v14; // eax
  LPARAM lParam; // [esp+4h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-10h]

  SendMessageW(hWnd, 0xBu, 0, 0);
  result = malloc(0x5C0u);
  pInfo = result;
  if ( result )
  {
    qmemcpy(result, a2, 0x5C0u);
    *(result + 9) = 1;
    *(result + 1) = 0;
    *(result + 2) = gnCounter + 1;
    v4 = *(result + 0xC6);
    if ( !v4 )
      v4 = *(pInfo + 0xF);
    *(pInfo + 0xC7) = IsProcessComment(v4);
    *(pInfo + 11) = -1;
    *(pInfo + 365) = 0;
    *(pInfo + 364) = gpTreeListParamList;
    if ( gpTreeListParamList )
      *(gpTreeListParamList + 0x16D) = pInfo;
    gpTreeListParamList = pInfo;
    if ( *(pInfo + 17) )
    {
      v5 = pInfo;
      while ( *(pInfo + 19) != *(v5 + 17) || *(v5 + 78) > *(pInfo + 78) )
      {
        v5 = *(v5 + 364);
        if ( !v5 )
          goto LABEL_17;
      }
      *(pInfo + 21) = v5;
      while ( *(v5 + 40) & 4 )
      {
        v5 = *(v5 + 21);
        if ( !v5 )
          goto LABEL_17;
      }
      *(pInfo + 10) &= 0xFFFFFFFD;
    }
LABEL_17:
    v6 = GetTreeListCtrl(hWnd);
    if ( *(pInfo + 13) )
    {
      v7 = *(pInfo + 13);
      v8 = CTreeList::GetImageIcon(v6);
      v9 = ImageList_ReplaceIcon(v8, -1, v7);
    }
    else
    {
      v9 = 0;
    }
    v10 = (*(pInfo + 40) & 2) == 0;
    *(pInfo + 16) = v9;
    if ( v10
      || (!sub_12450E0(*(pInfo + 15)) ? (*(pInfo + 10) &= 0xFFFFFFFE) : (*(pInfo + 10) |= 1u),
          *(pInfo + 40) & 1 && byte_12E96D6) )
    {
      v11 = SendMessageW;
    }
    else
    {
      sub_1237F20(hWnd, pInfo);
      v11 = SendMessageW;
      SendMessageW(ghWndTreeListView, 0x2000u, *(pInfo + 366), *(pInfo + 12) != 0);
    }
    v12 = *(pInfo + 21);
    if ( v12 )
    {
      if ( ++*(v12 + 48) == 1 )
      {
        if ( *(*(pInfo + 21) + 40) & 2 )
        {
          lParam = 1;
          v16 = *(pInfo + 21);
          v13 = v11(ghWndTreeListView, 0x1053u, 0xFFFFFFFF, &lParam);
          v11(ghWndTreeListView, 0x1015u, v13, v13);
          v14 = *(*(pInfo + 21) + 1464);
          if ( v14 )
          {
            v11(ghWndTreeListView, 0x2000u, v14, 1);
            if ( *(pInfo + 40) & 2 )
              v11(ghWndTreeListView, 0x2001u, *(*(pInfo + 21) + 1464), 1);
          }
        }
      }
    }
    result = pInfo;
  }
  return result;
}
// 12E96D6: using guessed type char byte_12E96D6;
// 12EA11C: using guessed type int gnCounter;

//----- (01237DD0) --------------------------------------------------------
// 插入一行数据到列表中
HANDLESANDDLLSLISTUSERPARAM *__cdecl sub_1237DD0(HWND hWnd, char a2)
{
  HANDLESANDDLLSLISTUSERPARAM *result; // eax
  LVITEMUSERDATA2 *v3; // ebx
  LVITEMW lParam; // [esp+4h] [ebp-34h]

  memset(&lParam.iItem, 0, 0x30u);
  lParam.mask = 0xD;
  lParam.iItem = 0x7FFFFFFF;
  lParam.iSubItem = 0;
  lParam.state = 0;
  lParam.stateMask = 0;
  lParam.pszText = -1;
  lParam.iImage = 0;
  lParam.lParam = 0;
  result = malloc(0x890u);
  v3 = result;
  if ( result )
  {
    qmemcpy(result, &a2, 0x890u);
    lParam.lParam = result;
    if ( SendMessageW(hWnd, LVM_INSERTITEMW, 0, &lParam) == -1 )
      v3 = 0;
    result = v3;
  }
  return result;
}

//----- (01237E70) --------------------------------------------------------
int __cdecl sub_1237E70(HWND hWnd, char a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  int result; // eax
  _DWORD *v66; // ecx
  LVITEMW lParam; // [esp+0h] [ebp-34h]

  memset(&lParam.iItem, 0, 0x30u);
  lParam.mask = 13;
  lParam.iItem = 0x7FFFFFFF;
  lParam.iSubItem = 0;
  lParam.state = 0;
  lParam.stateMask = 0;
  lParam.pszText = -1;
  lParam.iImage = 0;
  lParam.lParam = 0;
  result = malloc(0x290u);
  if ( result )
  {
    qmemcpy(result, &a2, 0x290u);
    v66 = a65;
    lParam.lParam = result;
    *(result + 652) = *a65;
    *v66 = result;
    result = SendMessageW(hWnd, 0x104Du, 0, &lParam) != -1;
  }
  return result;
}
// 1237E70: too many input arguments, some ignored

//----- (01237F20) --------------------------------------------------------
int __cdecl sub_1237F20(HWND hWnd, #1077 *a2)
{
  int result; // eax
  int v3; // ecx
  #1077 *v4; // eax
  LRESULT v5; // eax
  LRESULT v6; // eax
  bool v7; // zf
  int v8; // eax
  LPARAM lParam; // [esp+4h] [ebp-10h]
  #1077 *v10; // [esp+8h] [ebp-Ch]
  int (__cdecl *v11)(_DWORD *, _DWORD *); // [esp+Ch] [ebp-8h]
  bool v12; // [esp+13h] [ebp-1h]

  v12 = gbShowProcessTree != 0;
  result = *(a2 + 366);
  if ( !result )
  {
    if ( gbShowProcessTree && (v3 = *(a2 + 21)) != 0 && *(v3 + 40) & 2 )
    {
      v4 = *(v3 + 1464);
      if ( !v4 )
      {
        if ( *(a2 + 40) & 2 )
          v4 = sub_1237F20(hWnd, *(a2 + 21));
        else
          v4 = a2;
      }
    }
    else
    {
      v4 = 0;
    }
    lParam = v4;
    v10 = a2;
    v11 = sub_1241AF0;
    v5 = SendMessageW(hWnd, 0x2004u, 0, &lParam);
    *(a2 + 366) = v5;
    v6 = SendMessageW(hWnd, 0x2005u, v5, 0);
    v7 = v12 == 0;
    *(a2 + 11) = v6;
    if ( v7 )
    {
      if ( *(a2 + 12) )
        SendMessageW(hWnd, 0x2000u, *(a2 + 366), 1);
      SendMessageW(hWnd, 0x2001u, *(a2 + 366), (*(a2 + 10) >> 2) & 1);
      v8 = *(a2 + 21);
      if ( v8 && !*(v8 + 48) )
      {
        if ( !*(v8 + 1464) )
          sub_1237F20(hWnd, *(a2 + 21));
        SendMessageW(hWnd, 0x2000u, *(*(a2 + 21) + 1464), 1);
        SendMessageW(hWnd, 0x2001u, *(*(a2 + 21) + 1464), (*(*(a2 + 21) + 40) >> 2) & 1);
      }
    }
    else
    {
      if ( *(a2 + 12) )
        SendMessageW(hWnd, 0x2000u, *(a2 + 366), 1);
      SendMessageW(hWnd, 0x2001u, *(a2 + 366), (*(a2 + 10) >> 2) & 1);
    }
    result = *(a2 + 366);
  }
  return result;
}
// 12E5742: using guessed type char gbShowProcessTree;

//----- (01238070) --------------------------------------------------------
// 初始化TreeList各子项的颜色
void __cdecl InitTreeListItemColor(TREELISTITEMPARAM *pTreeListItemData)
{
  ProcessorInfo *v1; // eax
  int v2; // eax
  int v3; // eax
  ProcessorInfo *v4; // eax
  ProcessorInfo *v5; // eax
  ProcessorInfo *v6; // eax
  ProcessorInfo *v7; // eax
  ProcessorInfo *v8; // eax
  ProcessorInfo *v9; // eax

  if ( !pTreeListItemData[2].field_140[7] )
  {
    v1 = InitProcessorScreenData(1, 2, 0);
    pTreeListItemData[2].field_140[7] = v1;
    v1->ID = 0;
    *(pTreeListItemData[2].field_140[7] + 48) = 0x3C943C;
    *(pTreeListItemData[2].field_140[7] + 40) = gdbMaxValue;
    v2 = pTreeListItemData[2].field_140[7];
    if ( *(v2 + 28) == 2 )
    {
      *(v2 + 72) = 255;
      *(pTreeListItemData[2].field_140[7] + 64) = gdbMaxValue;
    }
    v3 = pTreeListItemData->field_40[1];
    if ( v3 )
    {
      if ( v3 == -10 )
        *(pTreeListItemData[2].field_140[7] + 48) = 255;
    }
    else
    {
      *(pTreeListItemData[2].field_140[7] + 72) = 0x3C943C;
    }
  }
  if ( !pTreeListItemData[1].field_180[3] )
  {
    v4 = InitProcessorScreenData(1, 1, 0);
    pTreeListItemData[1].field_180[3] = v4;
    v4->ID = 1;
    *(pTreeListItemData[1].field_180[3] + 48) = 0xAAAA;
    *(pTreeListItemData[1].field_180[3] + 40) = gdbMaxValue;
  }
  if ( !pTreeListItemData[2].t00[10] )
  {
    v5 = InitProcessorScreenData(1, 2, 0);
    pTreeListItemData[2].t00[10] = v5;
    v5->ID = 2;
    *(pTreeListItemData[2].t00[10] + 48) = 0xC83C1E;
    *(pTreeListItemData[2].t00[10] + 40) = doubleOnePointZero;
    *(pTreeListItemData[2].t00[10] + 72) = 0xC83CC8;
    *(pTreeListItemData[2].t00[10] + 64) = doubleOnePointZero;
  }
  if ( gdwAdapterRuntingTime )
  {
    v6 = InitProcessorScreenData(1, 1, 0);
    pTreeListItemData[2].field_140[12] = v6;
    v6->ID = 4;
    *(pTreeListItemData[2].field_140[12] + 48) = 0x8080FF;
    *(pTreeListItemData[2].field_140[12] + 40) = gdbMaxValue;
    v7 = InitProcessorScreenData(1, 1, 0);
    pTreeListItemData[2].field_180[10] = v7;
    v7->ID = 7;
    *(pTreeListItemData[2].field_180[10] + 48) = 0xFFC080;
    *(pTreeListItemData[2].field_180[10] + 40) = doubleOnePointZero;
    v8 = InitProcessorScreenData(1, 1, 0);
    pTreeListItemData[2].field_180[2] = v8;
    v8->ID = 5;
    *(pTreeListItemData[2].field_180[2] + 48) = 0xAAAA;
    *(pTreeListItemData[2].field_180[2] + 40) = doubleOnePointZero;
    v9 = InitProcessorScreenData(1, 1, 0);
    pTreeListItemData[2].field_180[6] = v9;
    v9->ID = 6;
    *(pTreeListItemData[2].field_180[6] + 48) = 0x4080FF;
    *(pTreeListItemData[2].field_180[6] + 40) = doubleOnePointZero;
  }
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCDC0: using guessed type double gdbMaxValue;

//----- (012382A0) --------------------------------------------------------
struct _IMAGELIST *InitSortableImageList()
{
  _IMAGELIST *hImg; // ST20_4
  HICON hDesendIcon; // edi
  HICON hAscendIcon; // ebx

  hImg = ImageList_Create(16, 16, 1u, 256, 256);
  hDesendIcon = LoadIconW(ghInstance, 203);
  hAscendIcon = LoadIconW(ghInstance, 113);
  ImageList_ReplaceIcon(hImg, -1, hDesendIcon);
  ImageList_ReplaceIcon(hImg, -1, hAscendIcon);
  return hImg;
}

//----- (01238300) --------------------------------------------------------
HWND __cdecl CreateListCtrl(HWND hWnd, DWORD dwStyle, __int16 *nWidths, int *nIDs, LONG dwColumnCount, HMENU uCtrlID)
{
  HWND hListCtrl; // eax
  HWND hWndListCtrl; // esi
  WPARAM hFont; // ST28_4
  HWND hWndHeader; // eax
  HWND hToolTips; // eax
  struct _IMAGELIST *hImageList; // esi
  LONG dwStyle_1; // eax
  HWND hListWnd; // [esp+8h] [ebp-18h]
  struct tagRECT rcWnd; // [esp+Ch] [ebp-14h]

  _mm_storeu_si128(&rcWnd, 0i64);
  InitCommonControls();
  GetClientRect(hWnd, &rcWnd);
  hListCtrl = CreateWindowExW(
                0,
                L"SysListView32",
                gpszTargetName,
                dwStyle,
                rcWnd.left,
                rcWnd.top,
                rcWnd.right,
                rcWnd.bottom,
                hWnd,
                uCtrlID,
                ghInstance,
                NULL);
  hWndListCtrl = hListCtrl;
  hListWnd = hListCtrl;
  if ( !hListCtrl )
    return NULL;
  if ( !InitListCtrl(hListCtrl, nWidths, nIDs, dwColumnCount) )
  {
    DestroyWindow(hWndListCtrl);
    return NULL;
  }
  SetClassLongW(hWndListCtrl, GCL_HCURSOR, NULL);
  OldListCtrlWndProc = SetWindowLongW(hWndListCtrl, GWL_WNDPROC, PEListCtrlWndProc);
  SendMessageW(hWndListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4030u, 0x4030);
  hFont = ghDefaultFont;
  hWndHeader = SendMessageW(hWndListCtrl, LVM_GETHEADER, 0, 0);
  SendMessageW(hWndHeader, WM_SETFONT, hFont, 0);
  SendMessageW(hWndListCtrl, WM_SETFONT, ghDefaultFont, 0);
  hToolTips = SendMessageW(hWndListCtrl, LVM_GETTOOLTIPS, 0, 0);
  InitToolTips(hToolTips);
  hImageList = InitSortableImageList();
  dwStyle_1 = GetWindowLongW(hListWnd, GWL_STYLE);
  SetWindowLongW(hListWnd, GWL_STYLE, dwStyle_1 | LVS_SHAREIMAGELISTS);
  SendMessageW(hListWnd, LVM_SETIMAGELIST, TRUE, hImageList);
  return hListWnd;
}

//----- (01238460) --------------------------------------------------------
// 与sub_447BC0中的自定义结构更像
void __cdecl RemoveTreeListItemParam(#1077 *ListItemData)
{
  int v1; // eax
  bool v2; // zf
  LRESULT v3; // eax
  WPARAM v4; // eax
  #1077 *v5; // ecx
  #1077 *v6; // ecx
  #1077 *i; // eax
  LVFINDINFOW FindItem; // [esp+8h] [ebp-18h]

  SendMessageW(ghWndTreeListView, WM_SETREDRAW, 0, 0);
  BYTE1(dword_12E53B4) = 1;
  v1 = *(ListItemData + 21);
  if ( v1 )
  {
    v2 = (*(v1 + 48))-- == 1;
    if ( v2 )
    {
      if ( *(*(ListItemData + 21) + 40) & 2 )
      {
        FindItem.lParam = *(ListItemData + 21);
        FindItem.flags = 1;
        v3 = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &FindItem);
        SendMessageW(ghWndTreeListView, LVM_REDRAWITEMS, v3, v3);
        v4 = *(*(ListItemData + 21) + 0x5B8);
        if ( v4 )
          SendMessageW(ghWndTreeListView, 0x2000u, v4, 0);
      }
    }
  }
  v5 = *(ListItemData + 0x16D);
  if ( v5 )
    *(v5 + 0x16C) = *(ListItemData + 0x16C);
  else
    gpTreeListParamList = *(ListItemData + 0x16C);
  v6 = *(ListItemData + 0x16C);
  if ( v6 )
    *(v6 + 0x16D) = *(ListItemData + 365);
  for ( i = gpTreeListParamList; i; i = *(i + 364) )
  {
    if ( *(i + 19) == *(ListItemData + 17) )
    {
      *(i + 21) = 0;
      if ( gbShowAllUsers || *(i + 40) & 0x40 )
        *(i + 10) |= 2u;
      if ( !(*(ListItemData + 40) & 4) )
        *(i + 10) &= -5u;
    }
  }
  DestroyTreeListItemData(ListItemData);
}
// 12E53B4: using guessed type int dword_12E53B4;
// 12E96D0: using guessed type char gbShowAllUsers;

//----- (01238570) --------------------------------------------------------
#1077 *__cdecl DeleteItemFromTreeList(HWND hWnd, #1077 *a2)
{
  #1077 *result; // eax
  tagLVFINDINFOW lParam; // [esp+Ch] [ebp-18h]

  lParam.flags = 1;
  lParam.lParam = a2;
  result = SendMessageW(hWnd, LVM_FINDITEMW, 0xFFFFFFFF, &lParam);
  if ( result >= 0 )
  {
    SendMessageW(hWnd, LVM_DELETEITEM, result, 0);
    result = *(a2 + 0x15);
    if ( result )
    {
      if ( *(result + 0xC) )
      {
        result = *(result + 0x16E);
        if ( result )
        {
          result = SendMessageW(hWnd, 0x2002u, result, 0);
          if ( !result )
          {
            SendMessageW(hWnd, 0x2000u, *(*(a2 + 21) + 1464), 1);
            result = SendMessageW(hWnd, 0x2003u, *(*(a2 + 21) + 1464), 0);
          }
        }
      }
    }
  }
  return result;
}

//----- (01238600) --------------------------------------------------------
void __cdecl sub_1238600(LVITEMUSERDATA *lpAddend)
{
  if ( !InterlockedDecrement(&lpAddend->RefCount) )
  {
    if ( lpAddend->ImageDesc )
      free(lpAddend->ImageDesc);
    if ( lpAddend->VerInfo )
      free(lpAddend->VerInfo);
    if ( lpAddend->szPathName )
      free(lpAddend->szPathName);
    if ( lpAddend->field_164 )
      free(lpAddend->field_164);
    if ( lpAddend->field_168 )
      free(lpAddend->field_168);
    if ( lpAddend->field_15C )
      free(lpAddend->field_15C);
    free(lpAddend);
  }
}

//----- (01238690) --------------------------------------------------------
void __cdecl DestroyTreeListItemData(#1077 *a1)
{
  void *v1; // eax
  void *v2; // eax
  void *v3; // eax

  if ( !InterlockedDecrement(a1 + 9) )
  {
    if ( *(a1 + 13) )
      DestroyIcon(*(a1 + 13));
    if ( *(a1 + 14) )
      DestroyIcon(*(a1 + 14));
    if ( *(a1 + 209) )
      free(*(a1 + 209));
    if ( *(a1 + 197) )
      free(*(a1 + 197));
    if ( *(a1 + 196) )
      free(*(a1 + 196));
    if ( *(a1 + 321) )
      free(*(a1 + 321));
    if ( *(a1 + 198) )
      free(*(a1 + 198));
    if ( *(a1 + 15) )
      free(*(a1 + 15));
    if ( *(a1 + 22) )
      free(*(a1 + 22));
    if ( *(a1 + 18) )
      free(*(a1 + 18));
    if ( *(a1 + 199) )
      free(*(a1 + 199));
    if ( *(a1 + 200) )
      free(*(a1 + 200));
    if ( *(a1 + 202) )
      free(*(a1 + 202));
    if ( *(a1 + 201) )
      free(*(a1 + 201));
    if ( *(a1 + 212) )
      free(*(a1 + 212));
    if ( *(a1 + 213) )
      free(*(a1 + 213));
    if ( *(a1 + 214) )
      free(*(a1 + 214));
    if ( *(a1 + 215) )
      free(*(a1 + 215));
    if ( *(a1 + 204) )
      free(*(a1 + 204));
    if ( *(a1 + 205) )
      free(*(a1 + 205));
    if ( *(a1 + 206) )
      free(*(a1 + 206));
    if ( *(a1 + 207) )
      free(*(a1 + 207));
    if ( *(a1 + 217) )
      sub_12839A0(a1 + 217);
    if ( *(a1 + 232) )
      free(*(a1 + 232));
    v1 = *(a1 + 343);
    if ( v1 )
      sub_1231280(v1, 1);
    v2 = *(a1 + 227);
    if ( v2 )
      sub_1231280(v2, 1);
    v3 = *(a1 + 266);
    if ( v3 )
      sub_1231280(v3, 1);
    free(a1);
  }
}

//----- (012388B0) --------------------------------------------------------
char __cdecl FindDlg_DrawItem(DRAWITEMSTRUCT *lpdis)
{
  LONG count; // eax
  int itemID; // ecx
  WPARAM nCount; // edi
  char bFocused; // si
  unsigned int idx; // ecx
  __m128i v7; // xmm1
  __int128 *__Id128; // edx
  unsigned int idx1; // eax
  __m128i v10; // xmm0
  unsigned int index; // esi
  int _index; // edi
  LONG left; // ecx
  unsigned int nColumnCount; // edi
  __m128i v15; // xmm1
  __int128 *v16; // ecx
  unsigned int v17; // eax
  __m128i v18; // xmm0
  DWORD v19; // edi
  int iSubItem; // eax
  HWND hWndList; // edi
  COLORREF v22; // eax
  COLORREF v23; // eax
  tagLVITEMW item2; // [esp+Ch] [ebp-43B0h]
  LVITEMW item; // [esp+40h] [ebp-437Ch]
  tagLVCOLUMNW lvColumn; // [esp+74h] [ebp-4348h]
  unsigned int nColCount; // [esp+94h] [ebp-4328h]
  COLORREF clrText; // [esp+98h] [ebp-4324h]
  __int16 State; // [esp+9Ch] [ebp-4320h]
  COLORREF width; // [esp+A0h] [ebp-431Ch]
  HWND hWndItem; // [esp+A4h] [ebp-4318h]
  RECT rcItem; // [esp+A8h] [ebp-4314h]
  __int128 arrIDs[24]; // [esp+B8h] [ebp-4304h]
  __int128 arrIds[24]; // [esp+238h] [ebp-4184h]
  TCHAR szText[8192]; // [esp+3B8h] [ebp-4004h]

  hWndItem = lpdis->hwndItem;
  count = GetWindowLongW(hWndItem, GWL_USERDATA);
  itemID = lpdis->itemID;
  nCount = count;
  nColCount = count;
  item.mask = 0xE;
  item.iItem = itemID;
  item.iSubItem = 0;
  SendMessageW(hWndItem, LVM_GETITEMW, 0, &item);
  LOBYTE(State) = lpdis->itemState & LVIS_FOCUSED;
  bFocused = State;
  GetListColor(hWndItem, lpdis->itemData, *&State, &clrText, &width);
  SetTextColor(lpdis->hDC, clrText);
  SetBkMode(lpdis->hDC, OPAQUE);
  SetBkColor(lpdis->hDC, width);
  if ( hWndItem == ghWndTreeListView )
    return sub_12356D0(
             bFocused,
             lpdis->itemData,
             gdwIDMapProcesListForSelectColumn[lpdis->itemAction],
             lpdis->hDC,
             &lpdis->rcItem);
  if ( !SendMessageW(hWndItem, LVM_GETCOLUMNORDERARRAY, nCount, arrIds) )
  {
    idx = 0;
    if ( nCount )
    {
      if ( nCount >= 8 )
      {
        v7 = _mm_load_si128(&xmmword_12BEA50);
        __Id128 = &arrIds[1];
        do
        {
          idx1 = idx + 4;
          __Id128 += 2;
          v10 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(idx), 0), v7);
          idx += 8;
          _mm_storeu_si128(__Id128 - 3, v10);
          _mm_storeu_si128(__Id128 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(idx1), 0), v7));
        }
        while ( idx < nCount - (nCount & 7) );
      }
      for ( ; idx < nCount; ++idx )
        *(arrIds + idx) = idx;
    }
  }
  index = 0;
  width = 0;
  if ( nCount )
  {
    do
    {
      lvColumn.mask = 3;                        // LVIF_TEXT|LVIF_IMAGE
      _index = 4 * index;
      SendMessageW(hWndItem, LVM_GETCOLUMNW, *(arrIds + index), &lvColumn);
      left = lpdis->rcItem.left;
      *&State = lvColumn.cx;
      rcItem.left = left + width;
      rcItem.top = lpdis->rcItem.top;
      rcItem.bottom = lpdis->rcItem.bottom;
      rcItem.right = width + left + lvColumn.cx;
      if ( hWndItem == ghWndDllsListCtrl )
      {
        nColumnCount = GetWindowLongW(hWndItem, GWL_USERDATA);
        if ( !SendMessageW(hWndItem, LVM_GETCOLUMNORDERARRAY, nColumnCount, arrIDs) )
        {
          index = 0;
          if ( nColumnCount )
          {
            if ( nColumnCount >= 8 )
            {
              v15 = _mm_load_si128(&xmmword_12BEA50);
              v16 = &arrIDs[1];
              do
              {
                v17 = index + 4;
                v16 += 2;
                v18 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(index), 0), v15);
                index += 8;
                _mm_storeu_si128(v16 - 3, v18);
                _mm_storeu_si128(v16 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v17), 0), v15));
              }
              while ( index < nColumnCount - (nColumnCount & 7) );
            }
            for ( ; index < nColumnCount; ++index )
              *(arrIDs + index) = index;
          }
        }
        if ( gdwIdMapForDllsListColumn[*(arrIDs + index)] == IDD_DLLCOLUMNS_CHECKBOX_VIRUSTOTAL )
        {
          v19 = lpdis->itemData;
          if ( sub_1281820(*(v19 + 0x16C)) )
          {
            if ( sub_1282910(*(v19 + 0x16C)) )
              SetTextColor(lpdis->hDC, 0xFFu);
            else
              SetTextColor(lpdis->hDC, 0xFF0000u);
            SelectObject(lpdis->hDC, ghDefaultFontUnderline);
          }
        }
        else
        {
          SetTextColor(lpdis->hDC, clrText);
          SelectObject(lpdis->hDC, ghDefaultFont);
        }
        _index = 4 * index;
      }
      item2.cchTextMax = 8191;
      *szText = 0;
      iSubItem = *(arrIds + _index);
      hWndList = hWndItem;
      item2.iSubItem = iSubItem;
      item2.pszText = szText;
      SendMessageW(hWndItem, LVM_GETITEMTEXTW, lpdis->itemID, &item2);
      DrawItemText(lpdis->hDC, szText, &rcItem, lvColumn.fmt & LVCFMT_RIGHT);
      ++index;
      width += *&State;
    }
    while ( index < nColCount );
  }
  else
  {
    hWndList = hWndItem;
  }
  if ( lpdis->itemState & LVIS_FOCUSED )
  {
    v22 = GetSysColor(COLOR_WINDOWTEXT);
    SetTextColor(lpdis->hDC, v22);
    v23 = GetSysColor(COLOR_WINDOW);
    SetBkColor(lpdis->hDC, v23);
  }
  if ( hWndList == ghWndTreeListView )
  {
    rcItem.left = 0;
    SendMessageW(ghWndTreeListView, LVM_GETITEMRECT, 0, &rcItem);
    if ( rcItem.top != gdwTopLastTreeList )
    {
      gdwTopLastTreeList = rcItem.top;
      InvalidateRect(ghWndTreeListView, 0, 0);
    }
  }
  return 1;
}
// 12BEA50: using guessed type __int128 xmmword_12BEA50;
// 12EA338: using guessed type int gdwTopLastTreeList;

//----- (01238D00) --------------------------------------------------------
int __cdecl UpdateMenu(char bEnabled, int nPos)
{
  HMENU hMainMenu; // eax
  HMENU v3; // eax
  HMENU hSubMenu; // ebx
  int nMenuCount; // eax
  UINT iMenu; // edi
  WPARAM nMenuID; // esi
  int v8; // [esp+8h] [ebp-4h]

  hMainMenu = GetMenu(ghWndNewOwner);
  v3 = GetSubMenu(hMainMenu, nPos);
  hSubMenu = v3;
  nMenuCount = GetMenuItemCount(v3);
  iMenu = 0;
  v8 = nMenuCount;
  if ( nMenuCount > 0 )
  {
    while ( 1 )
    {
      nMenuCount = GetMenuItemID(hSubMenu, iMenu);
      nMenuID = nMenuCount;
      if ( nMenuCount == IDS_PROCEXPLORERMENU_SHOW_UNNAMED_HANDLES_AND_MAPPINGS
        || nMenuCount == IDS_PROCEXPLORERMENU_HILITE_RELOCATED_DLLS )
      {
        goto __next;
      }
      nMenuCount = EnableMenuItem(hSubMenu, iMenu, (bEnabled == 0) | 0x400);
      if ( nMenuID == IDS_PROCEXPLORERMENU_PROCESS_PROPERTIES )
        break;
      if ( nMenuID == IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS )
        goto LABEL_8;
__next:
      if ( ++iMenu >= v8 )
        return nMenuCount;
    }
    nMenuID = IDM_OTHER_VIEW_PROCESS_PROPERTIES;
LABEL_8:
    nMenuCount = SendMessageW(ghWndToolbar, TB_ENABLEBUTTON, nMenuID, bEnabled);
    goto __next;
  }
  return nMenuCount;
}

//----- (01238DA0) --------------------------------------------------------
BOOL __cdecl sub_1238DA0(int a1)
{
  #1077 *i; // edx
  int v2; // eax
  char v3; // bl

  SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
  for ( i = gpTreeListParamList; i; i = *(i + 364) )
  {
    v2 = *(i + 21);
    v3 = 1;
    if ( v2 )
    {
      while ( 1 )
      {
        v3 = (*(v2 + 40) & 4) != 0 ? v3 : 0;
        if ( v2 == a1 )
          break;
        v2 = *(v2 + 84);
        if ( !v2 )
          goto LABEL_11;
      }
      if ( v3 && (gbShowAllUsers || *(i + 40) & 0x40) )
        *(i + 10) |= 2u;
      else
        *(i + 10) &= 0xFFFFFFFD;
    }
LABEL_11:
    ;
  }
  BYTE1(dword_12E53B4) = 1;
  return SetEvent(ghRefreshEvent);
}
// 12E53B4: using guessed type int dword_12E53B4;
// 12E96D0: using guessed type char gbShowAllUsers;

//----- (01238E30) --------------------------------------------------------
char __cdecl sub_1238E30(int a1, HWND hWnd, int a3, int a4, int a5, wchar_t *Dst)
{
  int v6; // ebx
  char v7; // al
  LRESULT v8; // esi
  int v9; // eax
  LRESULT v11; // eax
  const wchar_t *v12; // ST0C_4
  HWND v13; // edi
  int v14; // esi
  unsigned int v15; // kr00_4
  const wchar_t *v16; // edi
  __int16 *v17; // edx
  int v18; // esi
  __int16 v19; // ax
  int v20; // esi
  wchar_t *v21; // eax
  int v22; // eax
  __int16 *v23; // edx
  __int16 v24; // ax
  wchar_t *v25; // ebx
  int v26; // esi
  const wchar_t *v27; // ecx
  int v28; // edx
  wchar_t v29; // ax
  int v30; // eax
  wchar_t v31; // ax
  unsigned int v32; // kr04_4
  __int16 *v33; // edx
  int v34; // esi
  __int16 v35; // ax
  signed int v36; // ecx
  HWND v37; // ebx
  HWND v38; // ST00_4
  LRESULT i; // eax
  WPARAM v40; // edi
  LPARAM lParam; // [esp+Ch] [ebp-427Ch]
  LPARAM v42; // [esp+2Ch] [ebp-425Ch]
  int v43; // [esp+34h] [ebp-4254h]
  int v44; // [esp+38h] [ebp-4250h]
  int v45; // [esp+3Ch] [ebp-424Ch]
  wchar_t *v46; // [esp+40h] [ebp-4248h]
  int v47; // [esp+44h] [ebp-4244h]
  LRESULT v48; // [esp+60h] [ebp-4228h]
  WPARAM v49; // [esp+64h] [ebp-4224h]
  int v50; // [esp+68h] [ebp-4220h]
  unsigned int v51; // [esp+6Ch] [ebp-421Ch]
  HWND v52; // [esp+70h] [ebp-4218h]
  _BYTE *v53; // [esp+74h] [ebp-4214h]
  HWND v54; // [esp+78h] [ebp-4210h]
  WPARAM wParam; // [esp+7Ch] [ebp-420Ch]
  char v56; // [esp+83h] [ebp-4205h]
  wchar_t v57[8192]; // [esp+84h] [ebp-4204h]
  WCHAR Text; // [esp+4084h] [ebp-204h]

  v6 = a3;
  v52 = a1;
  v53 = a5;
  v7 = *(a3 + 12) & 1;
  v54 = hWnd;
  v50 = a3;
  v56 = v7;
  wParam = SendMessageW(hWnd, 0x100Cu, 0xFFFFFFFF, 2);
  v8 = SendMessageW(hWnd, 0x1004u, 0, 0);
  if ( (wParam & 0x80000000) != 0 )
  {
    if ( v56 )
    {
      wParam = 0;
    }
    else
    {
      if ( *v53 )
      {
LABEL_12:
        VLogEntry(&Text, L"Cannot find string \"%s\"", *(v6 + 16));
        MessageBoxW(v52, &Text, L"Process Explorer", 0x30u);
        return 0;
      }
      wParam = v8;
    }
  }
  if ( *v53 )
  {
    v9 = wcscmp(a4, Dst);
    if ( v9 )
      v9 = -(v9 < 0) | 1;
    if ( !v9 )
    {
      if ( v56 )
      {
        if ( ++wParam >= v8 )
          goto LABEL_12;
      }
      else if ( (--wParam & 0x80000000) != 0 )
      {
        goto LABEL_12;
      }
    }
  }
  v11 = SendMessageW(v54, 0x1004u, 0, 0);
  v12 = *(a3 + 16);
  v48 = v11;
  tcscpy_s(Dst, 0x2000u, v12);
  v13 = v54;
  while ( 1 )
  {
    lParam = 2;
    v14 = 0;
    v49 = 0;
    if ( SendMessageW(v13, 0x105Fu, 0, &lParam) )
      break;
LABEL_46:
    v36 = 2 * (v56 != 0) - 1 + wParam;
    wParam = v36;
    if ( v36 <= 0 || v36 == v48 + 1 )
      goto LABEL_12;
  }
  while ( 1 )
  {
    v43 = v14;
    v57[0] = 0;
    v46 = v57;
    v47 = 0x2000;
    SendMessageW(v13, LVM_GETITEMTEXTW, wParam, &v42);
    v15 = wcslen(v57);
    v16 = *(v6 + 16);
    v17 = *(v6 + 16);
    v18 = (v17 + 1);
    do
    {
      v19 = *v17;
      ++v17;
    }
    while ( v19 );
    if ( v15 >= (v17 - v18) >> 1 )
    {
      if ( !(*(v6 + 12) & 2) )
      {
        v23 = *(v6 + 16);
        v51 = 0;
        do
        {
          v24 = *v23;
          ++v23;
        }
        while ( v24 );
        if ( v15 - ((v23 - (v16 + 1)) >> 1) != -1 )
        {
          v25 = v57;
          do
          {
            v26 = v50;
            v27 = v16;
            v28 = (v16 + 1);
            if ( *(v50 + 12) & 4 )
            {
              do
              {
                v29 = *v27;
                ++v27;
              }
              while ( v29 );
              v30 = wcsncmp(v25, v16, (v27 - v28) >> 1);
            }
            else
            {
              do
              {
                v31 = *v27;
                ++v27;
              }
              while ( v31 );
              v30 = _wcsnicmp(v25, v16, (v27 - v28) >> 1);
            }
            if ( v30 == 0 )
              goto LABEL_49;
            ++v51;
            ++v25;
            v32 = wcslen(v57);
            v16 = *(v26 + 16);
            v33 = *(v26 + 16);
            v34 = (v33 + 1);
            do
            {
              v35 = *v33;
              ++v33;
            }
            while ( v35 );
          }
          while ( v51 < v32 - ((v33 - v34) >> 1) + 1 );
          v6 = v50;
        }
        goto LABEL_45;
      }
      v20 = 0;
      if ( v57[0] )
        break;
    }
LABEL_45:
    v13 = v54;
    v14 = v49++ + 1;
    if ( !SendMessageW(v54, 0x105Fu, v49, &lParam) )
      goto LABEL_46;
  }
  v21 = v57;
  if ( !v57[0] )
    goto LABEL_24;
  while ( 1 )
  {
    do
    {
      if ( *v21 == 32 )
        break;
      v21 = &v57[++v20];
    }
    while ( v57[v20] );
LABEL_24:
    if ( *(v6 + 12) & 4 )
    {
      v22 = wcscmp(v57, *(v6 + 16));
      if ( v22 )
        v22 = -(v22 < 0) | 1;
    }
    else
    {
      v22 = _wcsicmp(v57, *(v6 + 16));
    }
    if ( v22 == 0 )
      break;
    v21 = &v57[++v20];
    if ( !v57[v20] )
      goto LABEL_45;
  }
LABEL_49:
  v37 = v54;
  v38 = v54;
  *v53 = 1;
  for ( i = SendMessageW(v38, 0x100Cu, 0xFFFFFFFF, 2); i != -1; i = SendMessageW(v37, 0x100Cu, 0xFFFFFFFF, 2) )
  {
    v45 = 3;
    v44 = 0;
    SendMessageW(v37, 0x102Bu, i, &v42);
  }
  v40 = wParam;
  v45 = 3;
  v44 = 3;
  SendMessageW(v37, 0x102Bu, wParam, &v42);
  SendMessageW(v37, 0x1013u, v40, 0);
  SetFocus(v37);
  return 1;
}

//----- (01239300) --------------------------------------------------------
void InitDrawEngine()
{
  UINT idx1; // esi
  int v1; // eax
  int v2; // ST10_4
  UINT idx2; // esi
  int v4; // ST10_4
  UINT idx3; // esi
  int v6; // ST10_4
  HGDIOBJ hFont; // eax
  int Height; // eax
  int v9; // eax
  UINT v10; // ecx
  int v11; // ecx
  int v12; // eax
  UINT v13; // ecx
  int v14; // ecx
  int v15; // eax
  UINT uID; // ecx
  UINT v17; // ecx
  int v18; // eax
  USHORT v19; // cx
  UINT v20; // ecx
  UINT dwOpacity; // eax
  UINT v22; // eax
  UINT idx; // edi
  TCHAR *v24; // ebx
  int *id; // esi
  UINT index; // esi
  UINT idxFound; // edi
  UINT v28; // eax
  int Index; // esi
  wchar_t (*pszBuffer)[762]; // edi
  CComBSTR bstrKeyName; // [esp+Ch] [ebp-768h]
  HKEY hKey; // [esp+18h] [ebp-75Ch]
  char szSettings[128]; // [esp+1Ch] [ebp-758h]
  __int16 v34[120]; // [esp+9Ch] [ebp-6D8h]
  int v35; // [esp+19Ch] [ebp-5D8h]
  int NumberOfProcessColumn[28]; // [esp+1A0h] [ebp-5D4h]
  int v37; // [esp+220h] [ebp-554h]
  int v38[32]; // [esp+224h] [ebp-550h]
  int v39; // [esp+2A4h] [ebp-4D0h]
  int v40[211]; // [esp+2A8h] [ebp-4CCh]
  int v41[72]; // [esp+5F4h] [ebp-180h]
  LOGFONTW lf; // [esp+714h] [ebp-60h]

  RegDeleteKey(HKEY_CURRENT_USER, L"Software\\Systems Internals\\Process Explorer");
  memset(gWindowPlacement, 0, 18400u);
  gWindowPlacement[Windowplacement].showCmd = SW_SHOWNORMAL;
  gWindowPlacement[Windowplacement].rcNormalPosition.top = MulDiv(50, gLogPixelsY, 96);
  gWindowPlacement[Windowplacement].rcNormalPosition.bottom = MulDiv(650, gLogPixelsY, 96);
  gWindowPlacement[Windowplacement].rcNormalPosition.left = MulDiv(100, gLogPixelsX, 96);
  gWindowPlacement[Windowplacement].rcNormalPosition.right = MulDiv(900, gLogPixelsX, 96);
  gWindowPlacement[0].length = 44;
  gWindowPlacement[FindWindowplacement].rcNormalPosition.top = MulDiv(150, gLogPixelsY, 96);
  gWindowPlacement[FindWindowplacement].rcNormalPosition.left = MulDiv(150, gLogPixelsX, 96);
  gWindowPlacement[FindWindowplacement].length = 44;
  gWindowPlacement[SysinfoWindowplacement].rcNormalPosition.top = MulDiv(40, gLogPixelsY, 96);
  gWindowPlacement[SysinfoWindowplacement].rcNormalPosition.left = MulDiv(40, gLogPixelsX, 96);
  gWindowPlacement[SysinfoWindowplacement].length = 44;
  gWindowPlacement[PropWindowplacement].rcNormalPosition.top = MulDiv(40, gLogPixelsY, 96);
  gWindowPlacement[PropWindowplacement].rcNormalPosition.left = MulDiv(40, gLogPixelsX, 96);
  gWindowPlacement[PropWindowplacement].length = 44;
  gWindowPlacement[DllPropWindowplacement].rcNormalPosition.top = MulDiv(40, gLogPixelsY, 96);
  gWindowPlacement[DllPropWindowplacement].rcNormalPosition.left = MulDiv(40, gLogPixelsX, 96);
  gWindowPlacement[DllPropWindowplacement].length = 44;
  gdwToolbarBands[0] = -1;
  gdwSortableColumnVector[1] = 0xFFFFFFFF;
  gdwSortableColumnVector[4] = 0xFFFFFFFF;
  gdwSortableColumnVector[7] = 0xFFFFFFFF;
  idx1 = 0;
  gdwSortableColumnVector[10] = 0xFFFFFFFF;
  gdwSortableColumnVector[13] = 0xFFFFFFFF;
  gdwSortableColumnVector[16] = 0xFFFFFFFF;
  gdwSortableColumnVector[19] = 0xFFFFFFFF;
  gdwProcessListColumnCount = 6;
  do
  {
    v1 = LOWORD(gdwNumberOfProcessColumn[idx1]);
    v2 = gLogPixelsX;
    NumberOfProcessColumn[idx1] = v1;
    gdwIDMapProcesListForSelectColumn[idx1] = v1;
    gwProcessListColumnWidths[idx1] = MulDiv(HIWORD(gdwNumberOfProcessColumn[idx1]), v2, 96);
    ++idx1;
  }
  while ( idx1 < gdwProcessListColumnCount );
  gdwHandlesListColumnCount = 2;
  idx2 = 0;
  do
  {
    v4 = gLogPixelsX;
    gdwHandlesListColumnMap[idx2] = LOWORD(gdwNumberOfHandleColumnMap[idx2]);
    gdwHandlesListColumnWidths[idx2] = MulDiv(HIWORD(gdwNumberOfHandleColumnMap[idx2]), v4, 96);
    ++idx2;
  }
  while ( idx2 < gdwHandlesListColumnCount );
  gdwDllsListColumnCount = 4;
  idx3 = 0;
  do
  {
    v6 = gLogPixelsX;
    gdwIdMapForDllsListColumn[idx3] = LOWORD(gdwNumberODllColumnMap[idx3]);
    DllColumns[idx3] = MulDiv(HIWORD(gdwNumberODllColumnMap[idx3]), v6, 96);
    ++idx3;
  }
  while ( idx3 < gdwDllsListColumnCount );
  hFont = GetStockObject(DEFAULT_GUI_FONT);
  GetObjectW(hFont, 92, &lf);
  lf.lfWeight = FW_NORMAL;
  Height = MulDiv(8, gLogPixelsY, 72);
  lf.lfWidth = 0;
  lf.lfHeight = -Height;
  qmemcpy(&gDefaultLogFont, &lf, sizeof(gDefaultLogFont));
  bstrKeyName.bstr = _wcsdup(L"Software\\Sysinternals\\Process Explorer");
  LoadGlobalVariablesFromRegistry(&bstrKeyName, &gGlobalVariables);
  if ( gDefaultLogFont.lfHeight > 0 )
    gDefaultLogFont.lfHeight = -MulDiv(gDefaultLogFont.lfHeight, gLogPixelsY, 72);
  if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &hKey) )
  {
    bstrKeyName.Length = 0x6F8;
    if ( !RegQueryValueExW(hKey, L"Settings", 0, 0, szSettings, &bstrKeyName.Length) && (*szSettings - 501) <= 0x140 )
    {
      v9 = 0;
      if ( v35 <= 0 )
      {
LABEL_25:
        v15 = 0;
        if ( v37 <= 0 )
        {
LABEL_31:
          v18 = 0;
          if ( v39 <= 0 )
          {
LABEL_37:
            sub_1234F50(gWindowPlacement, szSettings, bstrKeyName.Length);
            RegDeleteValueW(hKey, L"Settings");
            CloseHandle(hKey);
            dwOpacity = *gdwOpacity;
            if ( !*gdwOpacity )
              dwOpacity = 100;
            *gdwOpacity = dwOpacity;
            v22 = ColorOwn;
            if ( !ColorOwn )
              v22 = 0xFFD0D0;
            ColorOwn = v22;
            if ( !gdwIDMapProcesListForSelectColumn[0] )
              qmemcpy(gdwIDMapProcesListForSelectColumn, NumberOfProcessColumn, 0x80u);
          }
          else
          {
            while ( 1 )
            {
              v19 = v34[v18 + 0x2C];
              if ( !v19 )
                break;
              if ( v19 > 2000u )
                break;
              v20 = v40[v18];
              if ( v20 <= 0 || v20 > 41000 )
                break;
              if ( ++v18 >= v39 )
                goto LABEL_37;
            }
          }
        }
        else
        {
          while ( 1 )
          {
            LOWORD(uID) = v34[v15 + 76];
            if ( !uID )
              break;
            if ( uID > 2000u )
              break;
            v17 = v38[v15];
            if ( v17 <= 0 || v17 > 41000 )
              break;
            if ( ++v15 >= v37 )
              goto LABEL_31;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          LOWORD(v10) = v34[v9 + 12];
          if ( !v10 )
            break;
          if ( v10 > 2000u )
            break;
          v11 = v41[v9];
          if ( v11 <= 0 || v11 > 41000 )
            break;
          if ( ++v9 >= v35 )
            goto LABEL_25;
        }
        v12 = 0;
        while ( 1 )
        {
          LOWORD(v13) = v34[v12 + 12];
          if ( !v13 )
            break;
          if ( v13 > 2000u )
            break;
          v14 = NumberOfProcessColumn[v12];
          if ( v14 <= 0 || v14 > 41000 )
            break;
          if ( ++v12 >= v35 )
            goto LABEL_25;
        }
      }
    }
  }
  idx = 0;
  if ( gdwProcessListColumnCount > 0 )
  {
    v24 = gwProcessListColumnWidths;
    id = gdwIDMapProcesListForSelectColumn;
    do
    {
      if ( *id == 3 )
      {
        memmove_0(id, id + 1, 4 * (--gdwProcessListColumnCount - idx));
        memmove_0(v24, v24 + 2, 2 * (gdwProcessListColumnCount - idx));
      }
      ++idx;
      ++id;
      v24 += 2;
    }
    while ( idx < gdwProcessListColumnCount );
  }
  index = 0;
  idxFound = -1;
  if ( gdwProcessListColumnCount <= 0 )
    goto LABEL_68;
  do
  {
    if ( gdwIDMapProcesListForSelectColumn[index] == 4 )
    {
      idxFound = index;
      if ( gbETWstandardUserWarning )
        break;
    }
    else if ( !IsBuiltinAndAnministrative() && !gbETWstandardUserWarning )
    {
      v28 = gdwIDMapProcesListForSelectColumn[index];
      if ( v28 >= IDD_PROCNETWORKCOLUMNS_CHECKBOX_RECEIVES && v28 <= IDD_PROCDISKCOLUMNS_CHECKBOX_DELTA_TOTAL_BYTES )
      {
        gbETWstandardUserWarning = 1;
        MessageBoxW(
          0,
          L"Note that Disk and Networking information requires administrative rights",
          L"Process Explorer",
          0x30u);
        if ( idxFound != -1 )
          goto LABEL_60;
      }
    }
    ++index;
  }
  while ( index < gdwProcessListColumnCount );
  if ( idxFound == -1 )
  {
LABEL_68:
    gdwIDMapProcesListForSelectColumn[index] = 4;
    gwProcessListColumnWidths[index] = 200;
    ++gdwProcessListColumnCount;
  }
LABEL_60:
  Index = 0;
  if ( gdwNumColumnsets > 0 )
  {
    pszBuffer = gstrMenuCulumnSet;
    do
    {
      SerializeColumnset(0, Index++, pszBuffer);
      ++pszBuffer;
    }
    while ( Index < gdwNumColumnsets );
  }
  if ( !gszSymbolPath[0] )
    GetEnvironmentVariableW(L"_NT_SYMBOL_PATH", gszSymbolPath, _MAX_PATH);
  ghDefaultFont = CreateFontIndirectW(&gDefaultLogFont);
  qmemcpy(&lf, &gDefaultLogFont, sizeof(lf));
  lf.lfUnderline = 1;
  ghDefaultFontUnderline = CreateFontIndirectW(&lf);
  free(bstrKeyName.bstr);
}
// 12E5B2C: using guessed type int gdwNumColumnsets;
// 12E96E2: using guessed type char gbETWstandardUserWarning;
// 12E9B08: using guessed type int ColorOwn;
// 12E9B38: using guessed type int gdwToolbarBands[];
// 1239300: using guessed type int var_4CC[211];
// 1239300: using guessed type int var_550[32];
// 1239300: using guessed type int var_180[72];

//----- (01239980) --------------------------------------------------------
BOOL __cdecl sub_1239980(HWND hWnd)
{
  HDC v1; // ebx
  CHOOSEFONTW Font; // [esp+Ch] [ebp-DCh]
  HWND v4; // [esp+48h] [ebp-A0h]
  LOGFONTW lf; // [esp+4Ch] [ebp-9Ch]
  WINDOWPLACEMENT wndpl; // [esp+A8h] [ebp-40h]
  RECT Rect; // [esp+D4h] [ebp-14h]

  v4 = hWnd;
  v1 = GetDC(hWnd);
  qmemcpy(&lf, &gDefaultLogFont, sizeof(lf));
  Font.Font = CreateCompatibleDC(v1);
  ReleaseDC(hWnd, v1);
  Font.Font = 60;
  Font.lpLogFont = &lf;
  Font.hInstance = ghInstance;
  Font.nFontType = 0x2000;
  Font.hwndOwner = hWnd;
  Font.Flags = 8273;
  Font.rgbColors = 0;
  Font.lCustData = 0;
  Font.lpszStyle = 0;
  Font.nSizeMin = 0;
  Font.nSizeMax = 20;
  Font.lpfnHook = 0;
  Font.lpTemplateName = 1543;
  if ( ChooseFontW(&Font) )
  {
    qmemcpy(&gDefaultLogFont, &lf, sizeof(gDefaultLogFont));
    DeleteObject(ghDefaultFont);
    ghDefaultFont = CreateFontIndirectW(&gDefaultLogFont);
    lf.lfUnderline = 1;
    ghDefaultFontUnderline = CreateFontIndirectW(&lf);
    InitTreeList(ghWndTreeListView, ghDefaultFont);
    InitTreeList(ghWndDllsListCtrl, ghDefaultFont);
    InitTreeList(ghWndHandlesListCtrl, ghDefaultFont);
    GetWindowRect(ghWndNewOwner, &Rect);
    SetWindowPos(ghWndNewOwner, 0, Rect.left, Rect.top, Rect.right - Rect.left - 1, Rect.bottom - Rect.top, 4u);
    SetWindowPos(ghWndNewOwner, 0, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 4u);
    if ( ghDlgFindDialog )
    {
      EndDialog(ghDlgFindDialog, 0);
      ghDlgFindDialog = 0;
    }
    wndpl.flags = 0;
    wndpl.length = 44;
    GetWindowPlacement(hWnd, &wndpl);
    if ( wndpl.showCmd == 3 )
    {
      ShowWindow(hWnd, 9);
      ShowWindow(hWnd, 3);
    }
  }
  return DeleteDC(Font.hDC);
}

//----- (01239BB0) --------------------------------------------------------
LRESULT __cdecl CThreadStackPage::InitListCtrl(HWND hWnd, LONG pStackInfo, int a3, int a4, char a5)
{
  LONG v5; // eax
  HWND hWndTooltips; // eax
  LRESULT result; // eax
  struct _IMAGELIST *v8; // esi
  LONG v9; // eax

  v5 = GetWindowLongW(hWnd, GWL_STYLE);
  SetWindowLongW(hWnd, -16, v5 & 0xFFFFFFFD | 9);
  SetWindowLongW(hWnd, GWL_USERDATA, pStackInfo);
  SendMessageW(hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 0x4020);
  hWndTooltips = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
  InitToolTips(hWndTooltips);
  result = InitListCtrl(hWnd, a3, a4, pStackInfo);
  if ( a5 )
  {
    v8 = InitSortableImageList();
    v9 = GetWindowLongW(hWnd, GWL_STYLE);
    SetWindowLongW(hWnd, GWL_STYLE, v9 | 0x40);
    result = SendMessageW(hWnd, LVM_SETIMAGELIST, 1u, v8);
  }
  return result;
}

//----- (01239C50) --------------------------------------------------------
char __cdecl IsIllegalID(int a1, int uId)
{
  int idx; // eax

  idx = 0;
  if ( gdwProcessListColumnCount <= 0 )
    return 0;
  while ( gdwIDMapProcesListForSelectColumn[idx] != uId )
  {
    if ( ++idx >= gdwProcessListColumnCount )
      return 0;
  }
  return 1;
}

//----- (01239C80) --------------------------------------------------------
int __stdcall PEListCtrlWndProc(HWND hWnd, UINT msg, int wParam, LPARAM lParam)
{
  HWND hListCtrl; // ebx
  NMTTDISPINFOW *lParam1; // edi
  int result; // eax
  HCURSOR hCursor; // eax
  LRESULT nItemCount; // eax
  HBRUSH clrWindow; // eax
  HBRUSH hBrush; // eax
  LRESULT nTopIndex; // eax
  HBRUSH hBrBack; // eax
  int code; // eax
  UINT offset; // edi
  int t; // ST18_4
  int l; // ST14_4
  HWND hWnd1; // eax
  int top; // ST18_4
  int left; // ST14_4
  HWND hWnd2; // eax
  LRESULT res; // edi
  HDC hWindowDC; // esi
  int nTextWidth; // eax
  bool v24; // zf
  bool v25; // sf
  CHAR v26; // of
  NMTTDISPINFOW *v27; // eax
  void *dwColumn1; // ST24_4
  NMTTDISPINFOW *v29; // eax
  HWND hWndTooltip; // eax
  HANDLE nHitRow; // eax
  HWND hWndToolTip; // eax
  HCURSOR hCursor2; // eax
  UINT dwColumnCount; // esi
  UINT dwColumn; // ecx
  __m128i v36; // xmm1
  __int16 *v37; // edx
  UINT v38; // eax
  __m128i v39; // xmm0
  HGLOBAL hGlobal; // edi
  int nTotalLength; // ebx
  TCHAR *pBuffer; // esi
  LRESULT nCurIdx; // ecx
  UINT iSubItem; // eax
  HDC hdc; // ST20_4
  HWND hWnd5; // eax
  HWND hWndList; // edi
  int nCurIndex; // eax
  int uId; // esi
  LRESULT ItemCount; // eax
  LRESULT ItemCount_; // eax
  LVITEMEXW item; // [esp+Ch] [ebp-6254h]
  LVITEMEXW lvitem; // [esp+40h] [ebp-6220h]
  UINT nSubItem; // [esp+74h] [ebp-61ECh]
  HWND hWndNewOwner; // [esp+78h] [ebp-61E8h]
  UINT nColumnCount; // [esp+7Ch] [ebp-61E4h]
  NMTTDISPINFOW *lParam2; // [esp+80h] [ebp-61E0h]
  HDC hDC; // [esp+84h] [ebp-61DCh]
  LVHITTESTINFO HitTestInfo; // [esp+88h] [ebp-61D8h]
  RECT rcText; // [esp+9Ch] [ebp-61C4h]
  RECT rcItem; // [esp+ACh] [ebp-61B4h]
  RECT Rect; // [esp+BCh] [ebp-61A4h]
  RECT rc; // [esp+CCh] [ebp-6194h]
  __int16 arrIds[192]; // [esp+DCh] [ebp-6184h]
  __int16 szText[8192]; // [esp+25Ch] [ebp-6004h]
  __int16 szBuffer[4096]; // [esp+425Ch] [ebp-2004h]

  hListCtrl = hWnd;
  lParam1 = lParam;
  hDC = wParam;
  hWndNewOwner = hWnd;
  lParam2 = lParam;
  lvitem.mask = 0;
  memset(&lvitem.iItem, 0, 0x30u);
  if ( msg > WM_NOTIFY )
  {
    if ( msg == WM_KEYDOWN )
    {
      switch ( hDC )
      {
        case VK_TAB:
          hWndList = ghWndTreeListView;
          if ( hWnd == ghWndTreeListView )
          {
            hWndList = ghWndHandlesListCtrl;
            if ( gbShowDllView )
              hWndList = ghWndDllsListCtrl;
          }
          lvitem.iItem = 0;
          lvitem.iSubItem = 0;
          lvitem.stateMask = LVIS_SELECTED;
          lvitem.mask = 0xC;
          nCurIndex = SendMessageW(hWndList, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
          if ( nCurIndex == -1 )
            nCurIndex = 0;
          lvitem.iItem = nCurIndex;
          SetFocus(hWndList);
          item.stateMask = 3;
          item.state = 3;
          SendMessageW(hWndList, LVM_SETITEMSTATE, lvitem.iItem, &item);
          return 0;
        case VK_RETURN:
          if ( hWnd == ghWndTreeListView )
          {
            uId = IDC_TREELIST;
          }
          else
          {
            nColumnCount = 2 * (hWnd == ghWndDllsListCtrl) + IDW_HANDLES_LISTCTRL;
            uId = 2 * (hWnd == ghWndDllsListCtrl) + IDW_HANDLES_LISTCTRL;
          }
          lvitem.iItem = SendMessageW(hWnd, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
          if ( lvitem.iItem != -1 )
            OnTreeListDblclks(uId);
          return 0;
        case VK_END:
          item.stateMask = 3;
          item.state = 3;
          ItemCount = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
          SendMessageW(hWnd, LVM_SETITEMSTATE, ItemCount - 1, &item);
          ItemCount_ = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
          SendMessageW(hWnd, LVM_ENSUREVISIBLE, ItemCount_ - 1, 0);
          return 0;
        case VK_HOME:
          item.stateMask = 3;
          item.state = 3;
          SendMessageW(hWnd, LVM_SETITEMSTATE, 0, &item);
          SendMessageW(hWnd, LVM_ENSUREVISIBLE, 0, 0);
          return 0;
        case VK_CANCEL|0x40:                    // CTRL+C
          // 复制到剪贴板
          if ( hWnd != ghWndTreeListView && GetKeyState(VK_LCONTROL) )
          {
            dwColumnCount = GetWindowLongW(hWnd, GWL_USERDATA);
            nColumnCount = dwColumnCount;
            if ( !SendMessageW(hWnd, LVM_GETCOLUMNORDERARRAY, dwColumnCount, arrIds) )
            {
              dwColumn = 0;
              if ( dwColumnCount )
              {
                if ( dwColumnCount >= 8 )
                {
                  v36 = _mm_load_si128(&xmmword_12BEA50);
                  v37 = &arrIds[8];
                  do
                  {
                    v38 = dwColumn + 4;
                    v37 += 16;
                    v39 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(dwColumn), 0), v36);
                    dwColumn += 8;
                    _mm_storeu_si128(v37 - 3, v39);
                    _mm_storeu_si128(v37 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v38), 0), v36));
                  }
                  while ( dwColumn < dwColumnCount - (dwColumnCount & 7) );
                }
                for ( ; dwColumn < dwColumnCount; ++dwColumn )
                  *&arrIds[2 * dwColumn] = dwColumn;
              }
            }
            hGlobal = 0;
            lvitem.iItem = -1;
            nTotalLength = 0;
            pBuffer = 0;
            nCurIdx = SendMessageW(hWndNewOwner, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
            for ( lvitem.iItem = nCurIdx; nCurIdx != -1; lvitem.iItem = nCurIdx )
            {
              iSubItem = 0;
              nSubItem = 0;
              if ( nColumnCount )
              {
                while ( 1 )
                {
                  item.iSubItem = *&arrIds[2 * iSubItem];
                  item.pszText = szText;
                  item.cchTextMax = 8192;
                  SendMessageW(hWndNewOwner, LVM_GETITEMTEXTW, nCurIdx, &item);
                  nTotalLength += wcslen(szText) + 2;
                  if ( pBuffer )
                  {
                    GlobalUnlock(hGlobal);
                    hGlobal = GlobalReAlloc(hGlobal, 2 * nTotalLength + 2, 0);
                    pBuffer = GlobalLock(hGlobal);
                  }
                  else
                  {
                    hGlobal = GlobalAlloc(0x2002u, 2 * nTotalLength + 2);
                    pBuffer = GlobalLock(hGlobal);
                    *pBuffer = 0;
                  }
                  wcscat_s(pBuffer, nTotalLength + 1, szText);
                  if ( ++nSubItem >= nColumnCount )
                    break;
                  wcscat_s(pBuffer, nTotalLength + 1, L"\t");
                  iSubItem = nSubItem;
                  if ( nSubItem >= nColumnCount )
                    break;
                  nCurIdx = lvitem.iItem;
                }
              }
              wcscat_s(pBuffer, nTotalLength + 1, L"\r\n");
              GlobalUnlock(hGlobal);
              nCurIdx = SendMessageW(hWndNewOwner, LVM_GETNEXTITEM, lvitem.iItem, LVNI_SELECTED);
            }
            hListCtrl = hWndNewOwner;
            SetFocus(hWndNewOwner);
            if ( hGlobal && OpenClipboard(hListCtrl) )
            {
              EmptyClipboard();
              SetClipboardData(CF_UNICODETEXT, hGlobal);
              CloseClipboard();
            }
            lParam1 = lParam2;
          }
          goto LABEL_70;
        default:
LABEL_70:
          hdc = hDC;
          hWnd5 = GetParent(hListCtrl);
          SendMessageW(hWnd5, WM_KEYDOWN, hdc, lParam1);
          break;
      }
    }
    else if ( msg == WM_MOUSEMOVE )
    {
      if ( gdwOsType < WINDOWS_VISTA )
      {
        hWndTooltip = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
        if ( !IsWindowVisible(hWndTooltip)
          || (HitTestInfo.pt.x = lParam,
              HitTestInfo.pt.y = SHIWORD(lParam),
              SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &HitTestInfo) >= 0)
          && (nHitRow = GetPropW(hWnd, L"hitrow"), HitTestInfo.iSubItem != nHitRow) )
        {
          hWndToolTip = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
          SendMessageW(hWndToolTip, TTM_POP, 0, 0);
        }
      }
      if ( hWnd == ghWndDllsListCtrl )
      {
        GetCursorPos(&HitTestInfo.pt);
        ScreenToClient(hWnd, &HitTestInfo.pt);
        if ( SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &HitTestInfo) >= 0
          && gdwIdMapForDllsListColumn[HitTestInfo.iSubItem] == IDD_DLLCOLUMNS_CHECKBOX_VIRUSTOTAL )
        {
          // 访问某网站
          lvitem.iItem = HitTestInfo.iItem;
          lvitem.mask = 4;
          SendMessageW(hWnd, LVM_GETITEMW, 0, &lvitem);
          if ( sub_1281820(lvitem.lParam[6].field_4) )
          {
            hCursor2 = LoadCursorW(ghInstance, L"HAND");
            SetCursor(hCursor2);
          }
        }
      }
    }
    return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
  }
  if ( msg != WM_NOTIFY )
  {
    switch ( msg )
    {
      case WM_SETFOCUS:
      case WM_KILLFOCUS:
        if ( hWnd == ghWndTreeListView && hDC != ghWndTreeListView )
          RedrawTreeList();
        return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
      case WM_ERASEBKGND:
        if ( !SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0) )
          return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
        GetClientRect(hWnd, &Rect);
        rcItem.left = 0;
        nItemCount = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
        SendMessageW(hWnd, LVM_GETITEMRECT, nItemCount - 1, &rcItem);
        rc.left = rcItem.right;
        clrWindow = GetSysColorBrush(COLOR_WINDOW);
        FillRect(hDC, &rc, clrWindow);
        rc = Rect;
        rc.right = Rect.right;
        rc.top = rcItem.bottom;
        rc.bottom = Rect.bottom;
        hBrush = GetSysColorBrush(COLOR_WINDOW);
        FillRect(hDC, &rc, hBrush);
        rcItem.left = 0;
        nTopIndex = SendMessageW(hWnd, LVM_GETTOPINDEX, 0, 0);
        SendMessageW(hWnd, LVM_GETITEMRECT, nTopIndex, &rcItem);
        rc.right = Rect.right;
        rc.left = 0;
        rc.top = 0;
        rc.bottom = rcItem.top;
        hBrBack = GetSysColorBrush(COLOR_WINDOW);
        FillRect(hDC, &rc, hBrBack);
        return 1;
      case WM_SETCURSOR:
        if ( hWnd == ghWndHandlesListCtrl )
        {
          SetCursor(ghCursorArrow_1);
          result = 1;
        }
        else
        {
          if ( gnLock )
            hCursor = LoadCursorW(0, IDC_APPSTARTING);
          else
            hCursor = LoadCursorW(0, IDC_ARROW);
          SetCursor(hCursor);
          result = 1;
        }
        return result;
      default:
        return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
    }
    return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
  }
  // WM_NOTIFY
  if ( *lParam != SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0) )
    return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
  code = *(lParam + 8);
  if ( code != PE_TTN_GETDISPINFOW )
  {
    if ( code == PE_TTN_SHOW )
    {
      offset = -1;
      if ( gdwOsType >= 1 )
        offset = -4;
      GetCursorPos(&HitTestInfo.pt);
      ScreenToClient(hWnd, &HitTestInfo.pt);
      lvitem.iItem = SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &HitTestInfo);
      if ( lvitem.iItem != -1 && HitTestInfo.iSubItem != -1 )
      {
        GetListItemRect(hWnd, HitTestInfo.iItem, HitTestInfo.iSubItem, &rcText);
        HitTestInfo.pt.x = rcText.left;
        HitTestInfo.pt.y = rcText.top;
        ClientToScreen(hWnd, &HitTestInfo.pt);
        t = HitTestInfo.pt.y - 1;               // TreeListGetItemRect
        l = offset + HitTestInfo.pt.x;
        hWnd1 = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
        SetWindowPos(hWnd1, HWND_DESKTOP, l, t, 0, 0, SWP_NOACTIVATE|SWP_NOSIZE);
        return 1;
      }
      top = HitTestInfo.pt.y - 1;
      left = offset + HitTestInfo.pt.x;
      hWnd2 = SendMessageW(hWnd, LVM_GETTOOLTIPS, 0, 0);
      SetWindowPos(hWnd2, HWND_DESKTOP, left, top, 0, 0, SWP_NOACTIVATE);
      lParam1 = lParam2;
    }
    return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
  }
  // TTN_GETDISPINFO
  if ( gdwOsType >= 1 )
    return CallWindowProcW(OldListCtrlWndProc, hListCtrl, msg, hDC, lParam1);
  res = CallWindowProcW(OldListCtrlWndProc, hWnd, WM_NOTIFY, hDC, lParam);
  GetCursorPos(&HitTestInfo.pt);
  ScreenToClient(hWnd, &HitTestInfo.pt);
  if ( SendMessageW(hWnd, LVM_SUBITEMHITTEST, 0, &HitTestInfo) < 0
    || !(HitTestInfo.flags & HTTOPRIGHT)
    || HitTestInfo.iSubItem < 0 )
  {
    return res;
  }
  lvitem.iSubItem = HitTestInfo.iSubItem;
  lvitem.iItem = HitTestInfo.iItem;
  lvitem.mask = LVIF_TEXT;
  lvitem.pszText = szBuffer;
  lvitem.cchTextMax = 4096;
  SendMessageW(hWnd, LVM_GETITEMW, 0, &lvitem);
  if ( !szBuffer[0] )
  {
    v29 = lParam2;
    lParam2->lpszText = 0;
    v29->szText[0] = 0;
    return res;
  }
  item.pszText = 2;
  SendMessageW(hWnd, LVM_GETCOLUMNW, HitTestInfo.iSubItem, &item.pszText);
  _mm_storeu_si128(&rcText, 0i64);
  hWindowDC = GetDC(hWnd);
  SelectObject(hWindowDC, ghDefaultFont);
  DrawTextW(hWindowDC, szBuffer, -1, &rcText, 0xD00u);// DT_CENTER|DT_CALCRECT|DT_NOPREFIX
  nTextWidth = rcText.right - rcText.left + 6;
  v26 = __OFSUB__(nTextWidth, item.iImage);
  v24 = nTextWidth == item.iImage;
  v25 = nTextWidth - item.iImage < 0;
  v27 = lParam2;
  if ( (v25 ^ v26) | v24 )
  {
    lParam2->lpszText = 0;
    v27->szText[0] = 0;
  }
  else
  {
    dwColumn1 = HitTestInfo.iSubItem;
    lParam2->lpszText = szBuffer;
    SetPropW(hWnd, L"hitrow", dwColumn1);
  }
  ReleaseDC(hWnd, hWindowDC);
  return res;
}
// 12BEA50: using guessed type __int128 xmmword_12BEA50;
// 12E4E54: using guessed type int gdwOsType;
// 12E96CC: using guessed type char gbShowDllView;

//----- (0123A880) --------------------------------------------------------
void __cdecl GetListItemRect(HWND hWnd, WPARAM nItem, WPARAM nSubItem, LPRECT lprc)
{
  HWND hWnd2; // ebx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // edi
  LRESULT result; // eax
  UINT dwProcessListColumnCount; // edx
  UINT Index; // ecx
  __m128i __mValue; // xmm1
  UINT *pBuffer; // edi
  UINT dwColumnCount; // ebx
  UINT dwIndex; // eax
  __m128i __mValue2; // xmm0
  CTreeList *pTreeList; // eax
  LPRECT rcItem; // eax
  UINT offset; // eax
  LPRECT rcItem2; // eax
  LONG nWidth; // eax
  LPRECT rcItem3; // eax
  LONG width; // eax
  HWND hWnd1; // [esp+Ch] [ebp-188h]
  UINT arrIds[96]; // [esp+10h] [ebp-184h]

  hWnd2 = hWnd;
  SendMessageW = ::SendMessageW;
  hWnd1 = hWnd;
  result = ::SendMessageW(hWnd, LVM_GETCOLUMNORDERARRAY, gdwProcessListColumnCount, arrIds);
  dwProcessListColumnCount = gdwProcessListColumnCount;
  if ( !result )
  {
    Index = 0;
    if ( gdwProcessListColumnCount > 0 )
    {
      if ( gdwProcessListColumnCount >= 8 )
      {
        __mValue = _mm_load_si128(&xmmword_12BEA50);
        pBuffer = &arrIds[4];
        dwColumnCount = gdwProcessListColumnCount - gdwProcessListColumnCount % 8;
        do
        {
          dwIndex = Index + 4;
          pBuffer += 8;
          __mValue2 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(Index), 0), __mValue);
          Index += 8;
          _mm_storeu_si128(pBuffer - 3, __mValue2);
          _mm_storeu_si128(pBuffer - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(dwIndex), 0), __mValue));
        }
        while ( Index < dwColumnCount );
        hWnd2 = hWnd1;
        SendMessageW = ::SendMessageW;
      }
      for ( ; Index < dwProcessListColumnCount; ++Index )
        arrIds[Index] = Index;
    }
  }
  if ( nItem == -2 )
  {
    pTreeList = GetTreeListCtrl(hWnd2);
    CTreeList::GetItemWidth(pTreeList, nSubItem, lprc);
    lprc->bottom -= lprc->top;
    lprc->right -= lprc->left;
  }
  else if ( nSubItem )
  {
    if ( lprc )
    {
      lprc->top = nSubItem;
      rcItem = lprc;
      lprc->left = 0;
    }
    else
    {
      rcItem = 0;
    }
    SendMessageW(hWnd2, LVM_GETSUBITEMRECT, nItem, rcItem);
    lprc->bottom -= lprc->top;
    lprc->right -= lprc->left;
  }
  else
  {
    offset = 0;
    while ( arrIds[offset] )
    {
      if ( !arrIds[offset + 1] )
      {
        ++offset;
        break;
      }
      if ( !arrIds[offset + 2] )
      {
        offset += 2;
        break;
      }
      if ( !arrIds[offset + 3] )
      {
        offset += 3;
        break;
      }
      if ( !arrIds[offset + 4] )
      {
        offset += 4;
        break;
      }
      if ( !arrIds[offset + 5] )
      {
        offset += 5;
        break;
      }
      offset += 6;
      if ( offset >= 96 )
        break;
    }
    if ( dwProcessListColumnCount == 1 )
    {
      if ( lprc )
      {
        lprc->left = 0;
        SendMessageW(hWnd2, LVM_GETITEMRECT, nItem, lprc);
      }
      else
      {
        SendMessageW(hWnd2, LVM_GETITEMRECT, nItem, 0);
      }
    }
    else if ( offset )
    {
      if ( lprc )
      {
        lprc->top = *(&hWnd1 + offset);
        rcItem2 = lprc;
        lprc->left = 0;
      }
      else
      {
        rcItem2 = NULL;
      }
      SendMessageW(hWnd2, LVM_GETSUBITEMRECT, nItem, rcItem2);
      lprc->left = lprc->right;
      SendMessageW(hWnd2, LVM_GETCOLUMNWIDTH, 0, 0);
      lprc->right = nWidth;
    }
    else
    {
      if ( lprc )
      {
        lprc->top = 1;
        rcItem3 = lprc;
        lprc->left = 0;
      }
      else
      {
        rcItem3 = NULL;
      }
      SendMessageW(hWnd2, LVM_GETSUBITEMRECT, nItem, rcItem3);
      lprc->bottom -= lprc->top;
      width = (SendMessageW)(hWnd2, LVM_GETCOLUMNWIDTH, 0, 0);
      lprc->left = 0;
      lprc->right = width;
    }
  }
}
// 12BEA50: using guessed type __int128 xmmword_12BEA50;

//----- (0123AB00) --------------------------------------------------------
BOOL __cdecl InitTreeList(HWND hTreeList, WPARAM hFont)
{
  HWND hWndHeader; // eax
  RECT Rect; // [esp+Ch] [ebp-14h]

  hWndHeader = SendMessageW(hTreeList, LVM_GETHEADER, 0, 0);
  SendMessageW(hWndHeader, WM_SETFONT, hFont, 0);
  SendMessageW(hTreeList, WM_SETFONT, hFont, 0);
  GetClientRect(ghWndNewOwner, &Rect);
  HandleSize(
    ghWndNewOwner,
    0,
    0,
    (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
  return InvalidateRgn(hTreeList, 0, 1);
}

//----- (0123ABA0) --------------------------------------------------------
signed int __stdcall TreeListSort(int a1, int a2, int *a3)
{
  _DWORD *v3; // esi
  signed int v4; // ebx
  int v5; // ecx
  _DWORD *v6; // edi
  _DWORD *v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  _DWORD *v10; // ebx
  bool v11; // cf
  signed int result; // eax
  signed int v13; // eax
  double v14; // xmm0_8
  double v15; // xmm1_8
  bool v16; // zf
  int v17; // ebx
  int v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // eax
  int v21; // ebx
  int v22; // edx
  unsigned int v23; // ecx
  unsigned int v24; // eax
  int v25; // eax
  _DWORD *v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  __int16 v42; // cx
  __int16 v43; // dx
  int v44; // ebx
  int v45; // eax
  const WCHAR *v46; // ecx
  int (__stdcall *v47)(LPCWSTR, LPCWSTR); // eax
  signed int v48; // eax
  int v49; // ebx
  int v50; // eax
  LPCWSTR v51; // eax
  LPCWSTR v52; // ebx
  int v53; // ecx
  int v54; // eax
  int v55; // ebx
  wchar_t **v56; // eax
  wchar_t *v57; // eax
  wchar_t **v58; // eax
  wchar_t *v59; // eax
  int v60; // eax
  int v61; // eax
  int v62; // eax
  int v63; // eax
  int v64; // eax
  unsigned int v65; // eax
  unsigned int v66; // ecx
  int v67; // eax
  int v68; // eax
  int v69; // eax
  unsigned int v70; // eax
  unsigned int v71; // ecx
  bool v72; // cf
  int v73; // eax
  const wchar_t *v74; // eax
  const wchar_t *v75; // eax
  int v76; // eax
  unsigned int v77; // ecx
  unsigned int v78; // eax
  unsigned int v79; // esi
  unsigned int v80; // edx
  unsigned __int64 v81; // kr18_8
  int v82; // eax
  int v83; // eax
  int v84; // eax
  int v85; // eax
  int v86; // eax
  int v87; // ebx
  unsigned int v88; // eax
  unsigned int v89; // ecx
  int v90; // eax
  int v91; // eax
  signed int v92; // eax
  int v93; // eax
  int v94; // eax
  int v95; // eax
  int v96; // eax
  int v97; // eax
  int v98; // ecx
  int v99; // eax
  int v100; // ebx
  wchar_t **v101; // eax
  wchar_t *v102; // eax
  wchar_t **v103; // eax
  wchar_t *v104; // eax
  int v105; // eax
  int v106; // eax
  int v107; // eax
  double v108; // xmm0_8
  int v109; // ebx
  int v110; // edx
  unsigned int v111; // ecx
  unsigned int v112; // eax
  unsigned int v113; // ecx
  signed int v114; // esi
  signed __int64 v115; // rax
  double v116; // xmm1_8
  int v117; // eax
  int v118; // eax
  int v119; // eax
  const wchar_t *v120; // ecx
  u_long v121; // esi
  u_long v122; // eax
  int v123; // esi
  u_short v124; // ax
  u_long v125; // esi
  u_long v126; // eax
  int v127; // esi
  u_short v128; // ax
  int v129; // eax
  int v130; // ebx
  int v131; // edi
  u_long v132; // edi
  int v133; // eax
  int v134; // ebx
  int v135; // edi
  u_long v136; // eax
  int v137; // [esp+10h] [ebp-424h]
  int v138; // [esp+14h] [ebp-420h]
  LPCWSTR lpString1; // [esp+18h] [ebp-41Ch]
  LPCWSTR v140; // [esp+1Ch] [ebp-418h]
  WCHAR String2; // [esp+20h] [ebp-414h]
  WCHAR String1; // [esp+228h] [ebp-20Ch]

  v3 = a1;
  v4 = 0;
  v5 = *a3;
  v140 = a1;
  v6 = a2;
  if ( v5 != 101 )
  {
    if ( v5 == 102 )
    {
      v61 = gdwHandlesListColumnMap[a3[1]];
      if ( v61 > 39 )
      {
        v67 = v61 - 1185;
        if ( !v67 )
        {
          v4 = *(a1 + 40) - *(a2 + 40);
LABEL_274:
          v16 = HandleSortDirection == 0;
          goto LABEL_419;
        }
        v68 = v67 - 9;
        if ( !v68 )
        {
          v4 = *(a1 + 52) - *(a2 + 52);
          v16 = HandleSortDirection == 0;
          goto LABEL_419;
        }
        if ( v68 != 114 )
        {
LABEL_270:
          v4 = -1;
          v16 = HandleSortDirection == 0;
          goto LABEL_419;
        }
      }
      else if ( v61 != 39 )
      {
        v62 = v61 - 20;
        if ( v62 )
        {
          v63 = v62 - 1;
          if ( v63 )
          {
            if ( v63 == 1 )
            {
              v64 = lstrcmpiW((a1 + 2232), (a2 + 2232));
              v16 = HandleSortDirection == 0;
              v4 = v64;
              goto LABEL_419;
            }
            goto LABEL_270;
          }
          v4 = lstrcmpiW((a1 + 56), (a2 + 56));
          if ( !v4 )
          {
            v4 = *(a2 + 44) < *(a1 + 44) ? 1 : -1;
            v16 = HandleSortDirection == 0;
            goto LABEL_419;
          }
          goto LABEL_274;
        }
        v65 = *(a1 + 44);
        v66 = *(a2 + 44);
        if ( v65 <= v66 )
        {
          v4 = -(v65 < v66);
          v16 = HandleSortDirection == 0;
        }
        else
        {
          v16 = HandleSortDirection == 0;
          v4 = 1;
        }
        goto LABEL_419;
      }
      v4 = *(a1 + 48) - *(a2 + 48);
      v16 = HandleSortDirection == 0;
      goto LABEL_419;
    }
    if ( v5 == 104 )
    {
      v69 = gdwIdMapForDllsListColumn[a3[1]];
      if ( v69 <= 30 )
      {
        if ( v69 != 30 )
        {
          switch ( v69 )
          {
            case 23:
              v70 = *(a1 + 36);
              v71 = *(a2 + 36);
              v72 = v70 < v71;
              if ( v70 <= v71 )
                goto LABEL_281;
              v16 = DllSortDirection == 0;
              v4 = 1;
              break;
            case 24:
              v4 = *(a1 + 56) - *(a2 + 56);
              v16 = DllSortDirection == 0;
              break;
            case 25:
              v73 = lstrcmpiW((a1 + 206), (a2 + 206));
              v16 = DllSortDirection == 0;
              v4 = v73;
              break;
            case 26:
              if ( wcsrchr(*(a1 + 344), 0x5Cu) )
                v74 = wcsrchr(*(a1 + 344), 0x5Cu) + 1;
              else
                v74 = *(a1 + 344);
              tcscpy_s(&String1, 0x104u, v74);
              if ( wcsrchr(*(a2 + 344), 0x5Cu) )
                v75 = wcsrchr(*(a2 + 344), 0x5Cu) + 1;
              else
                v75 = *(a2 + 344);
              tcscpy_s(&String2, 0x104u, v75);
              v76 = lstrcmpiW(&String1, &String2);
              v16 = DllSortDirection == 0;
              v4 = v76;
              break;
            default:
              goto LABEL_330;
          }
          goto LABEL_419;
        }
        v77 = *(a1 + 64);
        v78 = *(a1 + 68);
        v79 = *(a2 + 64);
        v80 = *(a2 + 68);
        if ( v77 == v79 && v78 == v80 )
        {
          v4 = 0;
          v16 = DllSortDirection == 0;
          goto LABEL_419;
        }
        v81 = __PAIR__(v78, v77) - __PAIR__(v80, v79);
        v137 = (__PAIR__(v78, v77) - __PAIR__(v80, v79)) >> 32;
        if ( v137 >= 0 && (__PAIR__(v78, v77) >= __PAIR__(v80, v79) && HIDWORD(v81) != 0 || v81) )
        {
          v16 = DllSortDirection == 0;
          v4 = 1;
          goto LABEL_419;
        }
        goto LABEL_330;
      }
      if ( v69 > 1118 )
      {
        if ( v69 > 1656 )
        {
          if ( v69 == 1670 )
          {
            v98 = *(a1 + 364);
            if ( v98 )
            {
              v99 = *(a2 + 364);
              if ( v99 )
              {
                v100 = *(v98 + 4);
                if ( v100 != 1 || *(v99 + 4) != 1 )
                {
                  v4 = v100 - *(v99 + 4);
                  v16 = DllSortDirection == 0;
                  goto LABEL_419;
                }
                v137 = *(v98 + 4);
                v138 = 1;
                lpString1 = -1;
                v140 = -1;
                v101 = *(v98 + 40);
                if ( v101 )
                  v102 = *v101;
                else
                  v102 = 0;
                vscan_fn(v102, L"%d/%d", &v137);
                v103 = *(*(a2 + 364) + 40);
                if ( v103 )
                  v104 = *v103;
                else
                  v104 = 0;
                vscan_fn(v104, L"%d/%d", &v138);
                v87 = v137;
                v86 = v138;
                if ( v137 == v138 )
                {
                  v4 = lpString1 - v140;
                  v16 = DllSortDirection == 0;
                  goto LABEL_419;
                }
                goto LABEL_308;
              }
            }
            v92 = sub_12437B0(v98, *(a2 + 364));
            goto LABEL_350;
          }
          if ( v69 == IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD )
          {
            v4 = (*(a1 + 54) & 0x4000) - (*(a2 + 54) & 0x4000);
            if ( (*(a1 + 54) & 0x4000) == (*(a2 + 54) & 0x4000) )
            {
              if ( *(a1 + 54) )
                v4 = *(a2 + 54) == 0;
              else
                v4 = -1;
              v16 = DllSortDirection == 0;
              goto LABEL_419;
            }
            goto LABEL_351;
          }
        }
        else
        {
          if ( v69 == 1656 )
          {
            v97 = lstrcmpiW(*(a1 + 348), *(a2 + 348));
            v16 = DllSortDirection == 0;
            v4 = v97;
            goto LABEL_419;
          }
          v94 = v69 - 1187;
          if ( !v94 )
          {
            v96 = lstrcmpiW(*(a1 + 356), *(a2 + 356));
            v16 = DllSortDirection == 0;
            v4 = v96;
            goto LABEL_419;
          }
          v95 = v94 - 130;
          if ( !v95 )
          {
            v92 = sub_12437B0(*(a1 + 376), *(a2 + 376));
            goto LABEL_350;
          }
          if ( v95 == 21 )
          {
            v4 = (*(a1 + 54) & 0x40) - (*(a2 + 54) & 0x40);
            if ( (*(a1 + 54) & 0x40) == (*(a2 + 54) & 0x40) )
            {
              v4 = ((*(a2 + 44) >> 1) & 1) - ((*(a1 + 44) >> 1) & 1);
              v16 = DllSortDirection == 0;
              goto LABEL_419;
            }
            goto LABEL_351;
          }
        }
      }
      else
      {
        if ( v69 == 1118 )
        {
          v92 = sub_12437B0(*(a1 + 380), *(a2 + 380));
          goto LABEL_350;
        }
        if ( v69 <= 1074 )
        {
          if ( v69 == 1074 )
          {
            v88 = *(a1 + 48);
            v89 = *(a2 + 48);
            v72 = v88 < v89;
            if ( v88 <= v89 )
            {
LABEL_281:
              v4 = -v72;
              v16 = DllSortDirection == 0;
            }
            else
            {
              v16 = DllSortDirection == 0;
              v4 = 1;
            }
            goto LABEL_419;
          }
          v82 = v69 - 40;
          if ( v82 )
          {
            v83 = v82 - 2;
            if ( !v83 )
            {
              v85 = lstrcmpiW(*(a1 + 336), *(a2 + 336));
              v16 = DllSortDirection == 0;
              v4 = v85;
              goto LABEL_419;
            }
            if ( v83 == 991 )
            {
              v84 = lstrcmpiW(*(a1 + 340), *(a2 + 340));
              v16 = DllSortDirection == 0;
              v4 = v84;
              goto LABEL_419;
            }
            goto LABEL_330;
          }
          v86 = (*(a2 + 44) >> 1) & 1;
          v87 = (*(a1 + 44) >> 1) & 1;
LABEL_308:
          v4 = v87 - v86;
          v16 = DllSortDirection == 0;
          goto LABEL_419;
        }
        v90 = v69 - 1111;
        if ( !v90 )
        {
          v93 = lstrcmpiW(*(a1 + 344), *(a2 + 344));
          v16 = DllSortDirection == 0;
          v4 = v93;
          goto LABEL_419;
        }
        v91 = v90 - 4;
        if ( !v91 )
        {
          v92 = sub_12437B0(*(a1 + 368), *(a2 + 368));
          goto LABEL_350;
        }
        if ( v91 == 1 )
        {
          v92 = sub_12437B0(*(a1 + 372), *(a2 + 372));
LABEL_350:
          v4 = v92;
LABEL_351:
          v16 = DllSortDirection == 0;
          goto LABEL_419;
        }
      }
LABEL_330:
      v4 = -1;
      v16 = DllSortDirection == 0;
      goto LABEL_419;
    }
    if ( v5 != 1040 )
    {
      if ( v5 == 1044 )
      {
        v107 = a3[1];
        switch ( v107 )
        {
          case 0:
            v4 = *(a1 + 44) - *(a2 + 44);
            v16 = dword_12E53B4 == 0;
            goto LABEL_419;
          case 1:
            v108 = *(a1 + 576);
            if ( v108 != 0.0 || v108 != *(a2 + 576) )
            {
              v116 = *(a2 + 576);
              if ( v108 <= v116 )
              {
                v4 = (v116 <= v108) - 1;
                v16 = dword_12E53B4 == 0;
              }
              else
              {
                v16 = dword_12E53B4 == 0;
                v4 = 1;
              }
              goto LABEL_419;
            }
            v109 = *(a1 + 604);
            v110 = *(a2 + 604);
            v111 = *(a1 + 600);
            v112 = *(a2 + 600);
            if ( v109 < v110 )
              goto LABEL_377;
            if ( v109 > v110 )
              goto LABEL_375;
            if ( v111 > v112 )
            {
              v16 = dword_12E53B4 == 0;
              v4 = 1;
              goto LABEL_419;
            }
            if ( v109 > v110 )
              goto LABEL_372;
            if ( v109 >= v110 )
            {
              if ( v111 < v112 )
              {
                v4 = -1;
                v16 = dword_12E53B4 == 0;
                goto LABEL_419;
              }
LABEL_372:
              v113 = *(a1 + 584);
              v114 = *(a1 + 588);
              v115 = *(a2 + 584);
              if ( v114 >= SHIDWORD(v115) )
              {
                if ( v114 > SHIDWORD(v115) || v113 > v115 )
                {
LABEL_375:
                  v16 = dword_12E53B4 == 0;
                  v4 = 1;
                  goto LABEL_419;
                }
                if ( __PAIR__(v114, v113) >= v115 )
                {
                  v4 = 0;
                  v16 = dword_12E53B4 == 0;
                  goto LABEL_419;
                }
              }
            }
LABEL_377:
            v4 = -1;
            v16 = dword_12E53B4 == 0;
            goto LABEL_419;
          case 2:
            if ( QueryThreadCycleTime && *(a1 + 40) )
            {
              v4 = sub_12437B0(*(a1 + 600), *(a2 + 600));
              v16 = dword_12E53B4 == 0;
            }
            else
            {
              v4 = *(a1 + 584) - *(a2 + 584);
              v16 = dword_12E53B4 == 0;
            }
            goto LABEL_419;
          case 3:
          case 4:
            if ( *(a1 + 644) == -1 )
              goto LABEL_389;
            v117 = v107 - 3;
            if ( v117 )
            {
              if ( v117 != 1 )
                goto LABEL_391;
LABEL_389:
              v118 = _wcsicmp((a1 + 52), (a2 + 52));
            }
            else
            {
              v119 = *(a2 + 648);
              if ( !v119 || (v120 = *(a1 + 648)) == 0 )
              {
                v4 = (*(a1 + 648) - v119) >> 1;
                v16 = dword_12E53B4 == 0;
                goto LABEL_419;
              }
              v118 = _wcsicmp(v120, *(a2 + 648));
            }
            v4 = v118;
            goto LABEL_391;
          default:
LABEL_391:
            v16 = dword_12E53B4 == 0;
            goto LABEL_419;
        }
      }
      if ( v5 != 1192 )
        return v4;
      switch ( a3[1] )
      {
        case 0:
          v4 = *(a1 + 40) - *(a2 + 40);
          if ( *(a1 + 40) == *(a2 + 40) )
          {
            v121 = ntohl(*(a2 + 44));
            v122 = ntohl(*(v140 + 11));
            v4 = v122 - v121;
            if ( v122 == v121 )
            {
              v123 = ntohs(*(a2 + 584));
              v124 = ntohs(v140[292]);
              v4 = v124 - v123;
              if ( v124 == v123 )
              {
                v125 = ntohl(*(a2 + 1108));
                v126 = ntohl(v140[554]);
                v4 = v126 - v125;
                if ( v126 == v125 )
                {
                  v127 = ntohs(*(a2 + 1648));
                  v128 = ntohs(v140[824]);
                  v4 = v128 - v127;
                  if ( v128 == v127 )
                    v4 = *(v140 + 543) - *(a2 + 2172);
                }
              }
            }
          }
          break;
        case 1:
          v129 = *(a1 + 40);
          v130 = *(a2 + 40);
          if ( v129 == v130 )
          {
            if ( *(a2 + 44) == *(a1 + 44) )
            {
              v131 = ntohs(*(a2 + 584));
              v4 = ntohs(v140[292]) - v131;
            }
            else
            {
              v132 = ntohl(*(a2 + 44));
              v4 = ntohl(*(v140 + 11)) - v132;
            }
          }
          else
          {
            v4 = v130 - v129;
          }
          break;
        case 2:
          v133 = *(a1 + 40);
          v134 = *(a2 + 40);
          if ( v133 == v134 )
          {
            if ( *(a2 + 1108) != *(a1 + 1108) )
            {
              v136 = ntohl(*(a2 + 1108));
              goto LABEL_414;
            }
            v135 = ntohs(*(a2 + 1648));
            v4 = ntohs(v140[824]) - v135;
          }
          else
          {
            v4 = v134 - v133;
          }
          break;
        case 3:
          v4 = *(a1 + 2172) - *(a2 + 2172);
          if ( *(a1 + 2172) == *(a2 + 2172) )
          {
            v136 = ntohl(*(a2 + 1108));
LABEL_414:
            v4 = ntohl(*(v140 + 277)) - v136;
          }
          break;
        case 4:
          v4 = _wcsicmp(*(a1 + 2184), *(a2 + 2184));
          break;
        default:
          break;
      }
      v16 = gbProcessTcpDumpListAscending == 0;
LABEL_419:
      if ( v16 )
        v4 = -v4;
      return v4;
    }
    v105 = a3[1];
    if ( v105 )
    {
      if ( v105 != 1 )
      {
LABEL_358:
        v16 = gbProcessSecurityUserListSortAscending == 0;
        goto LABEL_419;
      }
      v106 = _wcsicmp(*(a1 + 48), *(a2 + 48));
    }
    else
    {
      v106 = _wcsicmp(*(a1 + 40), *(a2 + 40));
    }
    v4 = v106;
    goto LABEL_358;
  }
  if ( !gbShowProcessTree )
  {
    v13 = gdwIDMapProcesListForSelectColumn[a3[1]];
    if ( v13 <= 1032 )
    {
      if ( v13 != 1032 )
      {
        switch ( v13 )
        {
          case 3:
            v4 = lstrcmpiW(*(a1 + 60), *(a2 + 60));
            goto LABEL_253;
          case 4:
            goto LABEL_189;
          case 5:
            v4 = *(a1 + 1368) - *(a2 + 1368);
            goto LABEL_253;
          case 7:
            v14 = *(a1 + 1304);
            v15 = *(a2 + 1304);
            if ( v14 <= v15 )
              goto LABEL_25;
            v16 = gbProcessSortDirection == 0;
            v4 = 1;
            goto LABEL_419;
          case 9:
            v4 = sub_12437B0(*(a1 + 920), *(a2 + 920));
            goto LABEL_253;
          case 10:
            v4 = sub_12437B0(*(a1 + 924), *(a2 + 924));
            goto LABEL_253;
          case 18:
            v4 = *(a1 + 92) - *(a2 + 92);
            goto LABEL_253;
          case 19:
            v4 = lstrcmpiW(*(a1 + 88), *(a2 + 88));
            goto LABEL_253;
          case 25:
            v4 = lstrcmpiW((a1 + 654), (a2 + 654));
            goto LABEL_253;
          case 35:
            v4 = lstrcmpiW((a1 + 104), (a2 + 104));
            goto LABEL_253;
          case 38:
            v4 = lstrcmpiW(*(a1 + 784), *(a2 + 784));
            goto LABEL_253;
          default:
            goto LABEL_26;
        }
        goto LABEL_26;
      }
      v4 = lstrcmpiW(*(a1 + 800), *(a2 + 800));
      goto LABEL_253;
    }
    if ( v13 > 1317 )
    {
      if ( v13 > 1609 )
      {
        if ( v13 > IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD )
          goto LABEL_26;
        if ( v13 != IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD )
        {
          switch ( v13 )
          {
            case 1610:
              v4 = *(a1 + 1088) - *(a2 + 1088);
              goto LABEL_253;
            case 1611:
              v4 = *(a1 + 1104) - *(a2 + 1104);
              goto LABEL_253;
            case 1612:
              v4 = *(a1 + 1120) - *(a2 + 1120);
              goto LABEL_253;
            case 1613:
              v4 = *(a1 + 1136) - *(a2 + 1136);
              goto LABEL_253;
            case 1614:
              v4 = *(a1 + 1152) - *(a2 + 1152);
              goto LABEL_253;
            case 1615:
              v4 = sub_12437B0(*(a1 + 1096) + *(a1 + 1128), *(a2 + 1096) + *(a2 + 1128));
              goto LABEL_253;
            case 1616:
              v4 = sub_12437B0(*(a1 + 1096), *(a2 + 1096));
              goto LABEL_253;
            case 1617:
              v4 = sub_12437B0(*(a1 + 1080), *(a2 + 1080));
              goto LABEL_253;
            case 1618:
              v4 = sub_12437B0(*(a1 + 1112), *(a2 + 1112));
              goto LABEL_253;
            case 1619:
              v4 = sub_12437B0(*(a1 + 1128), *(a2 + 1128));
              goto LABEL_253;
            case 1620:
              v4 = sub_12437B0(*(a1 + 1144), *(a2 + 1144));
              goto LABEL_253;
            case 1621:
              v4 = sub_12437B0(*(a1 + 1160), *(a2 + 1160));
              goto LABEL_253;
            case 1622:
              v4 = sub_12437B0(*(a1 + 1168), *(a2 + 1168));
              goto LABEL_253;
            case 1623:
              v4 = *(a1 + 1176) - *(a2 + 1176);
              goto LABEL_253;
            case 1624:
              v4 = *(a1 + 1192) - *(a2 + 1192);
              goto LABEL_253;
            case 1625:
              v4 = *(a1 + 1208) - *(a2 + 1208);
              goto LABEL_253;
            case 1626:
              v4 = *(a1 + 1224) - *(a2 + 1224);
              goto LABEL_253;
            case 1627:
              v4 = *(a1 + 1240) - *(a2 + 1240);
              goto LABEL_253;
            case 1628:
              v4 = *(a1 + 1256) - *(a2 + 1256);
              goto LABEL_253;
            case 1629:
              v4 = sub_12437B0(*(a1 + 1200) + *(a1 + 1232), *(a2 + 1200) + *(a2 + 1232));
              goto LABEL_253;
            case 1630:
              v4 = sub_12437B0(*(a1 + 1184), *(a2 + 1184));
              goto LABEL_253;
            case 1631:
              v4 = sub_12437B0(*(a1 + 1200), *(a2 + 1200));
              goto LABEL_253;
            case 1632:
              v4 = sub_12437B0(*(a1 + 1216), *(a2 + 1216));
              goto LABEL_253;
            case 1633:
              v4 = sub_12437B0(*(a1 + 1232), *(a2 + 1232));
              goto LABEL_253;
            case 1634:
              v4 = sub_12437B0(*(a1 + 1248), *(a2 + 1248));
              goto LABEL_253;
            case 1635:
              v4 = sub_12437B0(*(a1 + 1264), *(a2 + 1264));
              goto LABEL_253;
            case 1636:
              v4 = sub_12437B0(*(a1 + 1272), *(a2 + 1272));
              goto LABEL_253;
            case 1637:
              v14 = *(a1 + 1312);
              v15 = *(a2 + 1312);
              if ( v14 <= v15 )
                goto LABEL_25;
              v16 = gbProcessSortDirection == 0;
              v4 = 1;
              goto LABEL_419;
            case 1638:
LABEL_189:
              v49 = *(a1 + 68);
              v50 = *(a2 + 68);
              if ( v49 < 0 )
                v49 = 0;
              if ( v50 < 0 )
                v50 = 0;
              v51 = (v50 & 0xFFFFFFF);
              v52 = (v49 & 0xFFFFFFF);
              goto LABEL_194;
            case 1650:
              v14 = *(a1 + 1384);
              v15 = *(a2 + 1384);
              if ( v14 <= v15 )
                goto LABEL_25;
              v16 = gbProcessSortDirection == 0;
              v4 = 1;
              goto LABEL_419;
            case 1651:
              v4 = sub_12437B0(*(a1 + 1408), *(a2 + 1408));
              goto LABEL_253;
            case 1652:
              v4 = sub_12437B0(*(a1 + 1424), *(a2 + 1424));
              goto LABEL_253;
            case 1653:
              v4 = sub_12437B0(*(a1 + 1440), *(a2 + 1440));
              goto LABEL_253;
            case 1654:
              v4 = lstrcmpiW(*(a1 + 824), *(a2 + 824));
              goto LABEL_253;
            case 1655:
LABEL_218:
              v4 = sub_1234EF0((a1 + 624), (a2 + 624));
              goto LABEL_253;
            case 1656:
              v4 = lstrcmpiW(*(a1 + 828), *(a2 + 828));
              goto LABEL_253;
            case 1667:
              v4 = *(a2 + 644) - *(a1 + 644);
              goto LABEL_253;
            case 1670:
              v53 = *(a1 + 844);
              if ( v53 && (v54 = *(a2 + 844)) != 0 )
              {
                v55 = *(v53 + 4);
                if ( v55 != 1 || *(v54 + 4) != 1 )
                {
                  v4 = v55 - *(v54 + 4);
                }
                else
                {
                  lpString1 = *(v53 + 4);
                  v140 = 1;
                  v138 = -1;
                  v137 = -1;
                  v56 = *(v53 + 40);
                  if ( v56 )
                    v57 = *v56;
                  else
                    v57 = 0;
                  vscan_fn(v57, L"%d/%d", &lpString1);
                  v58 = *(*(a2 + 844) + 40);
                  if ( v58 )
                    v59 = *v58;
                  else
                    v59 = 0;
                  vscan_fn(v59, L"%d/%d", &v140);
                  v52 = lpString1;
                  v51 = v140;
                  if ( lpString1 == v140 )
                    v4 = v138 - v137;
                  else
LABEL_194:
                    v4 = v52 - v51;
                }
              }
              else
              {
                v4 = sub_12437B0(v53, *(a2 + 844));
              }
              goto LABEL_253;
            case 1673:
              v4 = *(a1 + 649) - *(a2 + 649);
              goto LABEL_253;
            case 1674:
              v4 = ((*(a1 + 40) >> 13) & 1) - ((*(a2 + 40) >> 13) & 1);
              goto LABEL_253;
            default:
              goto LABEL_26;
          }
          goto LABEL_26;
        }
        v42 = *(a1 + 650);
        v43 = *(a2 + 650);
        v44 = *(a1 + 650) & 0x4000;
        v45 = *(a2 + 650) & 0x4000;
LABEL_250:
        v4 = v44 - v45;
        if ( v4 )
          goto LABEL_27;
        if ( !v42 )
          goto LABEL_26;
        LOBYTE(v4) = v43 == 0;
      }
      else
      {
        if ( v13 != 1609 )
        {
          switch ( v13 )
          {
            case 1326:
              v4 = *(a1 + 976) - *(a2 + 976);
              goto LABEL_253;
            case 1327:
              v4 = sub_12437B0(*(a1 + 984), *(a2 + 984));
              goto LABEL_253;
            case 1328:
              v4 = *(a1 + 1008) - *(a2 + 1008);
              goto LABEL_253;
            case 1329:
              v4 = sub_12437B0(*(a1 + 1016), *(a2 + 1016));
              goto LABEL_253;
            case 1330:
              v4 = sub_12437B0(*(a1 + 984) + *(a1 + 1016), *(a2 + 984) + *(a2 + 1016));
              goto LABEL_253;
            case 1332:
              v4 = sub_12437B0(*(a1 + 1048), *(a2 + 1048));
              goto LABEL_253;
            case 1333:
              v4 = sub_12437B0(*(a1 + 1056), *(a2 + 1056));
              goto LABEL_253;
            case 1335:
              v4 = *(a1 + 1040) - *(a2 + 1040);
              goto LABEL_253;
            case 1336:
LABEL_151:
              v4 = -1;
              if ( gdwIDMapProcesListForSelectColumn[a3[1]] == 1336 )
              {
                v46 = *(a1 + 816);
                v140 = *(a2 + 816);
              }
              else
              {
                v46 = *(a1 + 820);
                v140 = *(a2 + 820);
              }
              v47 = lstrcmpW;
              lpString1 = v46;
              if ( v46 )
              {
                if ( lstrcmpW(v46, L"Low") )
                {
                  if ( lstrcmpW(lpString1, L"Medium") )
                  {
                    if ( lstrcmpW(lpString1, L"High") )
                    {
                      if ( !lstrcmpW(lpString1, L"System") )
                        v4 = 3;
                    }
                    else
                    {
                      v4 = 2;
                    }
                  }
                  else
                  {
                    v4 = 1;
                  }
                }
                else
                {
                  v4 = 0;
                }
                v47 = lstrcmpW;
              }
              else
              {
                v4 = -2;
              }
              if ( v140 )
              {
                if ( v47(v140, L"Low") )
                {
                  if ( lstrcmpW(v140, L"Medium") )
                  {
                    if ( lstrcmpW(v140, L"High") )
                    {
                      v16 = lstrcmpW(v140, L"System") == 0;
                      v48 = -1;
                      if ( v16 )
                        v48 = 3;
                      v4 -= v48;
                    }
                    else
                    {
                      v4 -= 2;
                    }
                  }
                  else
                  {
                    --v4;
                  }
                }
              }
              else
              {
                v4 += 2;
              }
              goto LABEL_253;
            case 1337:
              v4 = ((*(a1 + 40) >> 9) & 1) - ((*(a2 + 40) >> 9) & 1);
              goto LABEL_253;
            case 1338:
              v42 = *(a1 + 650);
              v43 = *(a2 + 650);
              v44 = *(a1 + 650) & 0x40;
              v45 = *(a2 + 650) & 0x40;
              goto LABEL_250;
            case 1339:
              v4 = *(a1 + 872) - *(a2 + 872);
              goto LABEL_253;
            case 1340:
              v4 = *(a1 + 952) - *(a2 + 952);
              goto LABEL_253;
            case 1341:
              v4 = sub_12437B0(*(a1 + 912), *(a2 + 912));
              goto LABEL_253;
            case 1342:
              v4 = sub_12437B0(*(a1 + 916), *(a2 + 916));
              goto LABEL_253;
            default:
              goto LABEL_26;
          }
          goto LABEL_26;
        }
        v4 = *(a1 + 1072) - *(a2 + 1072);
      }
    }
    else
    {
      if ( v13 != 1317 )
      {
        switch ( v13 )
        {
          case 1033:
            v4 = lstrcmpiW(*(a1 + 788), *(a2 + 788));
            goto LABEL_253;
          case 1055:
          case 1191:
            v14 = *(a1 + 1296);
            if ( v14 != 0.0 || v14 != *(a2 + 1296) )
            {
              v15 = *(a2 + 1296);
              if ( v14 > v15 )
              {
                v16 = gbProcessSortDirection == 0;
                v4 = 1;
                goto LABEL_419;
              }
LABEL_25:
              if ( v15 <= v14 )
                goto LABEL_254;
            }
            else
            {
              v17 = *(a1 + 1356);
              v18 = *(a2 + 1356);
              v19 = *(a1 + 1352);
              v20 = *(a2 + 1352);
              if ( v17 < v18 )
                break;
              if ( v17 > v18 || v19 > v20 )
                goto LABEL_45;
              if ( v17 > v18 || v17 >= v18 && v19 >= v20 )
              {
                v21 = *(a1 + 1340);
                v22 = *(a2 + 1340);
                v23 = *(a1 + 1336);
                v24 = *(a2 + 1336);
                if ( v21 >= v22 )
                {
                  if ( v21 > v22 )
                  {
LABEL_45:
                    v16 = gbProcessSortDirection == 0;
                    v4 = 1;
                    goto LABEL_419;
                  }
                  if ( v23 > v24 )
                  {
                    v16 = gbProcessSortDirection == 0;
                    v4 = 1;
                    goto LABEL_419;
                  }
                  if ( v21 > v22 )
                    goto LABEL_254;
                  if ( v21 >= v22 )
                  {
                    if ( v23 < v24 )
                    {
                      v4 = -1;
                      v16 = gbProcessSortDirection == 0;
                      goto LABEL_419;
                    }
                    goto LABEL_254;
                  }
                }
              }
            }
            break;
          case 1056:
            v4 = *(a1 + 100) - *(a2 + 100);
            goto LABEL_253;
          case 1059:
            v4 = sub_12437B0(*(a1 + 880), *(a2 + 880));
            goto LABEL_253;
          case 1060:
          case 1193:
            v4 = sub_12437B0(*(a1 + 888), *(a2 + 888));
            goto LABEL_253;
          case 1061:
            v4 = lstrcmpiW(*(a1 + 792), *(a2 + 792));
            goto LABEL_253;
          case 1062:
            v4 = sub_12437B0(*(a1 + 896), *(a2 + 896));
            goto LABEL_253;
          case 1063:
            v4 = sub_12437B0(*(a1 + 900), *(a2 + 900));
            goto LABEL_253;
          case 1064:
            v4 = sub_12437B0(*(a1 + 904), *(a2 + 904));
            goto LABEL_253;
          case 1065:
            v4 = *(a1 + 96) - *(a2 + 96);
            goto LABEL_253;
          case 1066:
            v4 = *(a1 + 1380) - *(a2 + 1380);
            goto LABEL_253;
          case 1067:
            v4 = *(a1 + 1376) - *(a2 + 1376);
            goto LABEL_253;
          case 1068:
            v4 = *(a1 + 960) - *(a2 + 960);
            goto LABEL_253;
          case 1069:
            v4 = sub_12437B0(*(a1 + 968), *(a2 + 968));
            goto LABEL_253;
          case 1070:
            v4 = *(a1 + 992) - *(a2 + 992);
            goto LABEL_253;
          case 1071:
            v4 = sub_12437B0(*(a1 + 1000), *(a2 + 1000));
            goto LABEL_253;
          case 1072:
            v4 = *(a1 + 1024) - *(a2 + 1024);
            goto LABEL_253;
          case 1073:
            v4 = sub_12437B0(*(a1 + 1032), *(a2 + 1032));
            goto LABEL_253;
          case 1086:
            goto LABEL_218;
          case 1087:
            v4 = sub_1234EF0((a1 + 1320), (a2 + 1320));
            goto LABEL_253;
          case 1091:
            v4 = sub_12437B0(*(a1 + 1344), *(a2 + 1344));
            goto LABEL_253;
          case 1092:
            v4 = sub_12437B0(*(a1 + 1336), *(a2 + 1336));
            goto LABEL_253;
          case 1094:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v26 = *(a2 + 1284);
            if ( !v26 )
              goto LABEL_95;
            v4 = *v25 - *v26;
            goto LABEL_253;
          case 1095:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v27 = *(a2 + 1284);
            if ( !v27 )
              goto LABEL_95;
            v4 = (*(v25 + 8) - *(v27 + 8));
            goto LABEL_253;
          case 1096:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v28 = *(a2 + 1284);
            if ( !v28 )
              goto LABEL_95;
            v4 = *(v25 + 16) - *(v28 + 16);
            goto LABEL_253;
          case 1097:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v29 = *(a2 + 1284);
            if ( !v29 )
              goto LABEL_95;
            v4 = *(v25 + 48) - *(v29 + 48);
            goto LABEL_253;
          case 1098:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v30 = *(a2 + 1284);
            if ( !v30 )
              goto LABEL_95;
            v4 = *(v25 + 32) - *(v30 + 32);
            goto LABEL_253;
          case 1099:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v31 = *(a2 + 1284);
            if ( !v31 )
              goto LABEL_95;
            v4 = *(v25 + 24) - *(v31 + 24);
            goto LABEL_253;
          case 1100:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v32 = *(a2 + 1284);
            if ( !v32 )
              goto LABEL_95;
            v4 = *(v25 + 56) - *(v32 + 56);
            goto LABEL_253;
          case 1101:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v33 = *(a2 + 1284);
            if ( !v33 )
              goto LABEL_95;
            v4 = *(v25 + 40) - *(v33 + 40);
            goto LABEL_253;
          case 1103:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v35 = *(a2 + 1284);
            if ( !v35 )
              goto LABEL_95;
            v4 = *(v25 + 112) - *(v35 + 112);
            goto LABEL_253;
          case 1104:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v36 = *(a2 + 1284);
            if ( !v36 )
              goto LABEL_95;
            v4 = *(v25 + 64) - *(v36 + 64);
            goto LABEL_253;
          case 1105:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v37 = *(a2 + 1284);
            if ( !v37 )
              goto LABEL_95;
            v4 = *(v25 + 72) - *(v37 + 72);
            goto LABEL_253;
          case 1106:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v38 = *(a2 + 1284);
            if ( !v38 )
              goto LABEL_95;
            v4 = *(v25 + 80) - *(v38 + 80);
            goto LABEL_253;
          case 1107:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v39 = *(a2 + 1284);
            if ( !v39 )
              goto LABEL_95;
            v4 = (*(v25 + 88) - *(v39 + 88));
            goto LABEL_253;
          case 1108:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v40 = *(a2 + 1284);
            if ( !v40 )
              goto LABEL_95;
            v4 = *(v25 + 104) - *(v40 + 104);
            goto LABEL_253;
          case 1109:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v41 = *(a2 + 1284);
            if ( !v41 )
              goto LABEL_95;
            v4 = *(v25 + 120) - *(v41 + 120);
            goto LABEL_253;
          case 1110:
            v25 = *(a1 + 1284);
            if ( !v25 )
              goto LABEL_97;
            v34 = *(a2 + 1284);
            if ( v34 )
            {
              v4 = *(v25 + 128) - *(v34 + 128);
            }
            else
            {
LABEL_95:
              if ( v25 )
              {
                v16 = gbProcessSortDirection == 0;
                v4 = 1;
                goto LABEL_419;
              }
LABEL_97:
              v4 = -(*(a2 + 1284) != 0);
            }
            goto LABEL_253;
          case 1114:
            v4 = sub_12437B0(*(a1 + 876), *(a2 + 876));
            goto LABEL_253;
          case 1115:
            v4 = sub_12437B0(*(a1 + 936), *(a2 + 936));
            goto LABEL_253;
          case 1116:
            v4 = sub_12437B0(*(a1 + 940), *(a2 + 940));
            goto LABEL_253;
          case 1118:
            v4 = sub_12437B0(*(a1 + 948), *(a2 + 948));
            goto LABEL_253;
          case 1179:
            v4 = sub_12437B0(*(a1 + 884), *(a2 + 884));
            goto LABEL_253;
          case 1180:
            goto LABEL_151;
          case 1181:
            v4 = lstrcmpiW(*(a1 + 796), *(a2 + 796));
            goto LABEL_253;
          case 1187:
            v4 = lstrcmpiW(*(a1 + 836), *(a2 + 836));
            goto LABEL_253;
          case 1192:
            v4 = *(a1 + 892) - *(a2 + 892);
            goto LABEL_253;
          case 1195:
            v4 = sub_12437B0(*(a1 + 1360), *(a2 + 1360));
            goto LABEL_253;
          case 1196:
            v4 = *(a1 + 620) - *(a2 + 620);
            if ( *(a1 + 620) != *(a2 + 620) )
              goto LABEL_27;
            v4 = (*(a1 + 616) - *(a2 + 616)) >> 2;
            goto LABEL_253;
          case 1199:
            v4 = *(a1 + 636) - *(a2 + 636);
            goto LABEL_253;
          case 1200:
            v4 = sub_12437B0(*(a1 + 1352), *(a2 + 1352));
            goto LABEL_253;
          default:
            break;
        }
LABEL_26:
        v4 = -1;
LABEL_27:
        v16 = gbProcessSortDirection == 0;
        goto LABEL_419;
      }
      v4 = sub_12437B0(*(a1 + 944), *(a2 + 944));
    }
LABEL_253:
    if ( v4 )
      goto LABEL_27;
LABEL_254:
    v60 = lstrcmpiW(*(a1 + 60), *(a2 + 60));
    v16 = gbProcessSortDirection == 0;
    v4 = v60;
    goto LABEL_419;
  }
  v7 = *(a2 + 84);
  v8 = *(a1 + 80);
  v9 = *(a2 + 80);
  v10 = *(a1 + 84);
  if ( v7 == a1 )
    return -1;
  while ( 1 )
  {
    if ( v10 == v6 )
      return 1;
    v11 = v8 < v9;
    if ( v8 == v9 )
      break;
LABEL_9:
    if ( v11 )
      goto LABEL_13;
    v3 = v10;
    if ( v8 <= v9 )
    {
      --v8;
LABEL_13:
      v6 = v7;
      --v9;
      goto LABEL_14;
    }
    --v8;
LABEL_14:
    v7 = v6[21];
    v10 = v3[21];
    if ( v7 == v3 )
      return -1;
  }
  if ( v8 && v10 != v7 )
  {
    v11 = v8 < v9;
    goto LABEL_9;
  }
  result = sub_1234EF0(v3 + 156, v6 + 156);
  if ( !result )
    result = v3[17] - v6[17];
  return result;
}
// 12B2BB0: using guessed type wchar_t aDD[6];
// 12DD224: using guessed type char gbProcessSecurityUserListSortAscending;
// 12DD225: using guessed type char gbProcessTcpDumpListAscending;
// 12E53B4: using guessed type int dword_12E53B4;
// 12E5742: using guessed type char gbShowProcessTree;
// 12E598C: using guessed type char gbProcessSortDirection;
// 12E5A5C: using guessed type char DllSortDirection;
// 12E5B28: using guessed type char HandleSortDirection;

//----- (0123CB80) --------------------------------------------------------
int __stdcall InitListCtrl(HWND hWnd, int *uIDs, __int16 *nWidths, LONG dwCount)
{
  HWND (__stdcall *GetParent)(HWND); // ecx
  int item; // esi
  char bSortable; // al
  __m128i __v1; // xmm1
  __m128i *__Id; // edx
  unsigned int idx; // ecx
  unsigned int idx1; // eax
  __m128i __v2; // xmm0
  tagLVCOLUMNW lvcolumn; // [esp+0h] [ebp-22Ch]
  __int16 *pnWidths; // [esp+20h] [ebp-20Ch]
  int *pnIDs; // [esp+24h] [ebp-208h]
  __m128i arrIds[24]; // [esp+28h] [ebp-204h]
  WCHAR szName[64]; // [esp+1A8h] [ebp-84h]

  pnIDs = uIDs;
  pnWidths = nWidths;
  lvcolumn.mask = 0;
  _mm_storeu_si128(&lvcolumn.fmt, 0i64);
  lvcolumn.iOrder = 0;
  *&lvcolumn.iSubItem = 0i64;
  while ( SendMessageW(hWnd, LVM_DELETECOLUMN, 0, 0) )
    ;
  GetParent = ::GetParent;
  item = 0;
  // LVCF_FMT|LVCF_TEXT|LVCF_WIDTH|LVCF_SUBITEM|LVCF_IMAGE
  lvcolumn.mask = 0xF;
  lvcolumn.pszText = szName;
  if ( dwCount )
  {
    while ( 1 )
    {
      lvcolumn.iSubItem = item;
      lvcolumn.cx = abs(pnWidths[item]);
      if ( GetParent(hWnd) != ghWndNewOwner )
        break;
      if ( pnWidths[item] < 0 )
        goto __rightalign;
      bSortable = IsColumnSortable(pnIDs[item]);
      lvcolumn.fmt = LVCFMT_LEFT;
      if ( bSortable )
        goto __rightalign;
__INERSTCOLUMN:
      LoadStringW(ghInstance, pnIDs[item], szName, 64);
      if ( SendMessageW(hWnd, LVM_INSERTCOLUMNW, item, &lvcolumn) == -1 )
        return FALSE;
      GetParent = ::GetParent;
      if ( ++item >= dwCount )
        goto BREAK;
    }
    if ( pnWidths[item] >= 0 )
    {
      lvcolumn.fmt = LVCFMT_LEFT;
      goto __INERSTCOLUMN;
    }
__rightalign:
    lvcolumn.fmt = LVCFMT_RIGHT;
    goto __INERSTCOLUMN;
  }
BREAK:
  if ( GetParent(hWnd) == ghWndNewOwner && IsColumnSortable(*pnIDs) )
  {
    lvcolumn.mask = LVIF_TEXT;
    SendMessageW(hWnd, LVM_GETCOLUMNW, 0, &lvcolumn);
    lvcolumn.fmt |= LVCFMT_RIGHT;
    lvcolumn.mask = LVIF_TEXT;
    SendMessageW(hWnd, LVM_SETCOLUMNW, 0, &lvcolumn);
  }
  // 用户自定义数据记录的当前列总数
  SetWindowLongW(hWnd, GWL_USERDATA, dwCount);
  // 对一个128位双精度浮点数进行某种操作
  __v1 = _mm_load_si128(&xmmword_12BEA50);
  __Id = &arrIds[1];
  idx = 0;
  do
  {
    idx1 = idx + 4;
    __Id += 2;
    __v2 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(idx), 0), __v1);
    idx += 8;
    _mm_storeu_si128(__Id - 3, __v2);
    _mm_storeu_si128(__Id - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(idx1), 0), __v1));
  }
  while ( idx < 96 );
  SendMessageW(hWnd, LVM_SETCOLUMNORDERARRAY, dwCount, arrIds);
  InvalidateRect(hWnd, NULL, TRUE);
  return TRUE;
}
// 12BEA50: using guessed type __int128 xmmword_12BEA50;

//----- (0123CDD0) --------------------------------------------------------
// NM_CLICK
int __cdecl OnTreeListClick(int a1, int a2)
{
  HWND v2; // edi
  void *v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  wchar_t **v9; // eax
  wchar_t *v10; // eax
  wchar_t **v11; // eax
  wchar_t *v12; // eax
  void *v13; // [esp-8h] [ebp-88h]
  LPARAM v14; // [esp+8h] [ebp-78h]
  WPARAM wParam; // [esp+Ch] [ebp-74h]
  int v16; // [esp+10h] [ebp-70h]
  void *a1a; // [esp+28h] [ebp-58h]
  POINT Point; // [esp+3Ch] [ebp-44h]
  LPARAM v19; // [esp+44h] [ebp-3Ch]
  int v20; // [esp+48h] [ebp-38h]
  int v21; // [esp+54h] [ebp-2Ch]
  LPARAM lParam; // [esp+58h] [ebp-28h]
  WPARAM nItem[4]; // [esp+5Ch] [ebp-24h]
  RECT rcItem1; // [esp+6Ch] [ebp-14h]

  lParam = 0;
  _mm_storeu_si128(nItem, 0i64);
  v14 = 0;
  memset(&wParam, 0, 0x30u);
  Point.x = 0;
  Point.y = 0;
  if ( a1 == 101 )
  {
    v2 = ghWndTreeListView;
  }
  else
  {
    if ( a1 != 104 )
      return 0;
    v2 = ghWndDllsListCtrl;
  }
  GetCursorPos(&Point);
  ScreenToClient(v2, &Point);
  lParam = Point.x;
  nItem[0] = Point.y;
  wParam = SendMessageW(v2, LVM_HITTEST, 0, &lParam);
  v16 = 0;
  v14 = 4;
  if ( SendMessageW(v2, LVM_GETITEMW, 0, &v14) != 1 )
    return 0;
  GetListItemRect(v2, wParam, nItem[3], &rcItem1);
  v3 = a1a;
  if ( v2 != ghWndTreeListView )
  {
    v19 = *(a2 + 32);
    v20 = *(a2 + 36);
    SendMessageW(v2, 0x1039u, 0, &v19);
    if ( gdwIdMapForDllsListColumn[v21] == 1670 && sub_1281820(*(v3 + 91)) )
    {
      v11 = *(*(v3 + 91) + 36);
      if ( v11 )
        v12 = *v11;
      else
        v12 = 0;
      sub_1245750(v2, 0, v12);
    }
    return 0;
  }
  v4 = gdwIDMapProcesListForSelectColumn[nItem[3]];
  if ( v4 != 3 )
  {
    if ( v4 == 1670 && sub_1281820(*(a1a + 211)) )
    {
      v9 = *(*(v3 + 211) + 36);
      if ( v9 )
        v10 = *v9;
      else
        v10 = 0;
      sub_1245750(v2, 0, v10);
    }
    goto LABEL_24;
  }
  if ( !*(a1a + 12)
    || (!gbShowProcessTree ? (v5 = 0) : (v5 = *(a1a + 20)),
        (v6 = rcItem1.left + 16 * v5, lParam <= v6 + 1) || lParam >= v6 + 17) )
  {
LABEL_24:
    CheckProcessWindowMenuItems(v3);
    sub_12469D0(v3);
    return 0;
  }
  v7 = *(a1a + 10);
  if ( v7 & 4 )
  {
    v13 = a1a;
    *(a1a + 10) = v7 & 0xFFFFFFFB;
  }
  else
  {
    v13 = a1a;
    *(a1a + 10) = v7 | 4;
  }
  sub_1238DA0(v13);
  CheckProcessWindowMenuItems(v3);
  sub_12469D0(v3);
  return 0;
}
// 12E5742: using guessed type char gbShowProcessTree;

//----- (0123D040) --------------------------------------------------------
int __cdecl OnTreeListColumnClick(HWND hWnd, tagNMLISTVIEW *pInfo, DWORD bMenu, LPARAM lParam)
{
  tagNMLISTVIEW *pNMListView; // ebx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  HWND column; // eax
  LPARAM v7; // edi
  char v8; // al
  HMENU v9; // eax
  void *v10; // eax
  signed int v11; // edi
  signed int v12; // ebx
  int v13; // ST04_4
  HMENU v14; // eax
  BOOL v15; // ST0C_4
  HMENU v16; // eax
  int row; // edi
  HWND v18; // ST00_4
  LRESULT v19; // edi
  int v20; // esi
  int v21; // eax
  HWND v22; // edx
  char bAscending; // al
  int nColumnToSort; // ecx
  LRESULT v25; // eax
  HWND v26; // ST00_4
  HWND v27; // ST00_4
  tagLVFINDINFOW find; // [esp+Ch] [ebp-94h]
  LPARAM lParama; // [esp+24h] [ebp-7Ch]
  WPARAM v31; // [esp+28h] [ebp-78h]
  int v32; // [esp+2Ch] [ebp-74h]
  LPARAM v33; // [esp+44h] [ebp-5Ch]
  LVITEMW item1; // [esp+58h] [ebp-48h]
  WPARAM wParam; // [esp+8Ch] [ebp-14h]
  HWND v36; // [esp+90h] [ebp-10h]
  LPARAM v37; // [esp+94h] [ebp-Ch]
  void *i; // [esp+98h] [ebp-8h]
  LRESULT count; // [esp+9Ch] [ebp-4h]

  pNMListView = pInfo;
  SendMessageW = ::SendMessageW;
  column = pInfo->iSubItem;
  v7 = 0;
  count = pInfo;
  v37 = 0;
  wParam = hWnd;
  v36 = column;
  if ( hWnd == 101 )
  {
    v31 = ::SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
    if ( v31 != -1 )
    {
      v32 = 0;
      lParama = LVCF_TEXT;
      ::SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &lParama);
      v37 = v33;
    }
    v8 = gbProcessSortDirection;
    if ( gbShowProcessTree || gdwIDMapProcesListForSelectColumn[pInfo->iSubItem] != 3 || gbProcessSortDirection )
    {
      gbShowProcessTree = 0;
      if ( gdwProcessListSortColumnCount == pInfo->iSubItem )
      {
        v8 = gbProcessSortDirection == 0;
        gbProcessSortDirection = gbProcessSortDirection == 0;
      }
      v13 = gdwProcessListSortColumnCount;
      gdwProcessListSortColumnCount = pInfo->iSubItem;
      InitTreeListSortableHeader(pInfo->hdr.hwndFrom, v13, gdwProcessListSortColumnCount, v8);
      v14 = GetMenu(ghWndNewOwner);
      EnableMenuItem(v14, IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS_TREE, 1u);
      ::SendMessageW(ghWndToolbar, TB_ENABLEBUTTON, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, gbShowProcessTree == 0);
      v15 = gbShowProcessTree != 0;
      v16 = GetMenu(ghWndNewOwner);
      EnableMenuItem(v16, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, v15);
      SendMessageW = ::SendMessageW;
    }
    else
    {
      gdwProcessListSortColumnCount = pInfo->iSubItem;
      ::SendMessageW(ghWndToolbar, TB_ENABLEBUTTON, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, 0);
      v9 = GetMenu(ghWndNewOwner);
      EnableMenuItem(v9, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, 1u);
      v10 = GetWindowLongW(ghWndTreeListView, GWL_USERDATA);
      v11 = 0;
      i = v10;
      if ( v10 > 0 )
      {
        v12 = v10;
        do
        {
          item1.pszText = LVIF_TEXT;
          ::SendMessageW(ghWndTreeListView, LVM_GETCOLUMNW, v11, &item1.pszText);
          item1.cchTextMax &= 0xFFFFE7FF;
          item1.pszText = LVIF_TEXT;
          ::SendMessageW(ghWndTreeListView, LVM_SETCOLUMNW, v11++, &item1.pszText);
        }
        while ( v11 < v12 );
        pNMListView = count;
      }
      gbShowProcessTree = 1;
      sub_1276020(gpTreeListParamList);
    }
    SendMessageW(pNMListView->hdr.hwndFrom, 0xBu, 0, 0);
    count = (SendMessageW)(pNMListView->hdr.hwndFrom, LVM_GETITEMCOUNT, 0, 0);
    row = 0;
    for ( i = operator new[](4 * count); row < count; ++row )
    {
      item1.iItem = row;
      v18 = pNMListView->hdr.hwndFrom;
      item1.iSubItem = 0;
      item1.mask = LVCF_TEXT;
      SendMessageW(v18, LVM_GETITEMW, 0, &item1);
      *(i + row) = item1.lParam;
    }
    SendMessageW(pNMListView->hdr.hwndFrom, LVM_DELETEALLITEMS, 0, 0);
    v19 = 0;
    if ( count > 0 )
    {
      do
      {
        v20 = *(i + v19);
        v21 = sub_1237F20(pNMListView->hdr.hwndFrom, *(i + v19++));
        *(v20 + 1464) = v21;
      }
      while ( v19 < count );
      SendMessageW = ::SendMessageW;
    }
    j_j__free(i);
    v7 = v37;
  }
  else
  {
    if ( hWnd == IDW_HANDLES_LISTCTRL )
    {
      v22 = gdwHandlesListSortColumnCount;
      if ( gdwHandlesListSortColumnCount == column )
      {
        bAscending = HandleSortDirection == 0;
        HandleSortDirection = HandleSortDirection == 0;
        nColumnToSort = pInfo->iSubItem;
      }
      else
      {
        nColumnToSort = pInfo->iSubItem;
        bAscending = HandleSortDirection;
      }
      gdwHandlesListSortColumnCount = pInfo->iSubItem;
    }
    else if ( hWnd == IDW_DLL_LISTCTRL )
    {
      v22 = gdwDllsListlSortColumnCount;
      if ( gdwDllsListlSortColumnCount == column )
      {
        bAscending = DllSortDirection == 0;
        DllSortDirection = DllSortDirection == 0;
        nColumnToSort = pInfo->iSubItem;
      }
      else
      {
        nColumnToSort = pInfo->iSubItem;
        bAscending = DllSortDirection;
      }
      gdwDllsListlSortColumnCount = pInfo->iSubItem;
    }
    else if ( hWnd == IDD_PROCTHREADS_CTRL_LISTVIEW )
    {
      v22 = gdwProcessThreadSortColumnLast;
      if ( gdwProcessThreadSortColumnLast == column )
      {
        bAscending = dword_12E53B4 == 0;
        LOBYTE(dword_12E53B4) = dword_12E53B4 == 0;
        nColumnToSort = pInfo->iSubItem;
      }
      else
      {
        nColumnToSort = pInfo->iSubItem;
        bAscending = dword_12E53B4;
      }
      gdwProcessThreadSortColumnLast = pInfo->iSubItem;
    }
    else if ( hWnd == IDD_PROCSECURITY_CTRL_LISTVIEW1 )
    {
      v22 = gdwSortableColumnVector[23];
      if ( gdwSortableColumnVector[23] == column )
      {
        bAscending = gbProcessSecurityUserListSortAscending == 0;
        gbProcessSecurityUserListSortAscending = gbProcessSecurityUserListSortAscending == 0;
        nColumnToSort = pInfo->iSubItem;
      }
      else
      {
        nColumnToSort = pInfo->iSubItem;
        bAscending = gbProcessSecurityUserListSortAscending;
      }
      gdwSortableColumnVector[23] = pInfo->iSubItem;
    }
    else
    {
      if ( hWnd != IDD_PROCTCPUDP_CTRL_LISTVIEW )
        goto LABEL_47;
      v22 = gdwSortableColumnVector[22];
      if ( gdwSortableColumnVector[22] == column )
      {
        bAscending = gbProcessTcpDumpListAscending == 0;
        gbProcessTcpDumpListAscending = gbProcessTcpDumpListAscending == 0;
      }
      else
      {
        bAscending = gbProcessTcpDumpListAscending;
      }
      nColumnToSort = pInfo->iSubItem;
      gdwSortableColumnVector[22] = pInfo->iSubItem;
    }
    InitTreeListSortableHeader(pInfo->hdr.hwndFrom, v22, nColumnToSort, bAscending);
  }
LABEL_47:
  SendMessageW(pNMListView->hdr.hwndFrom, LVM_SORTITEMS, &wParam, TreeListSort);
  v25 = (SendMessageW)(pNMListView->hdr.hwndFrom, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  SendMessageW(pNMListView->hdr.hwndFrom, LVM_ENSUREVISIBLE, v25, 0);
  if ( hWnd == IDC_TREELIST )
  {
    if ( v7 )
    {
      find.flags = 1;
      v26 = pNMListView->hdr.hwndFrom;
      find.lParam = v7;
      v31 = (SendMessageW)(v26, LVM_FINDITEMW, 0xFFFFFFFF, &find);
      v27 = pNMListView->hdr.hwndFrom;
      item1.stateMask = 3;
      item1.state = 3;
      SendMessageW(v27, LVM_SETITEMSTATE, v31, &item1);
      SendMessageW(pNMListView->hdr.hwndFrom, LVM_ENSUREVISIBLE, v31, 0);
    }
    SendMessageW(pNMListView->hdr.hwndFrom, WM_SETREDRAW, 1u, 0);
  }
  return 0;
}
// 128C710: using guessed type int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD);
// 12DD224: using guessed type char gbProcessSecurityUserListSortAscending;
// 12DD225: using guessed type char gbProcessTcpDumpListAscending;
// 12E53B4: using guessed type int dword_12E53B4;
// 12E5742: using guessed type char gbShowProcessTree;
// 12E598C: using guessed type char gbProcessSortDirection;
// 12E5A5C: using guessed type char DllSortDirection;
// 12E5B28: using guessed type char HandleSortDirection;

//----- (0123D4B0) --------------------------------------------------------
int __cdecl CTreeList::DeleteItem(signed int uId, CTreeList *pTreeList)
{
  HANDLESANDDLLSLISTUSERPARAM *v2; // ecx
  int v3; // edi
  __int16 *v4; // esi
  __int16 *v5; // edx
  int v6; // edx
  LVITEMUSERDATA *v8; // ecx
  int v9; // edx
  int v10; // edx
  HANDLESANDDLLSLISTUSERPARAM *v11; // eax
  void *v12; // ecx
  HANDLESANDDLLSLISTUSERPARAM *v13; // esi
  LVITEMW lvitem; // [esp+4h] [ebp-34h]

  lvitem.mask = LVIF_PARAM;
  lvitem.iItem = pTreeList->m_hWndHeaderLeft;
  if ( uId > 104 )
  {
    if ( uId == 1040 )
    {
      SendMessageW(pTreeList->vtptr, LVM_GETITEMW, 0, &lvitem);
      v11 = lvitem.lParam;
      v13 = lvitem.lParam;
      if ( *&lvitem.lParam->szText[4] )
      {
        free(*&lvitem.lParam->szText[4]);
        v11 = lvitem.lParam;
      }
      v12 = *v13->szText;
    }
    else
    {
      if ( uId != 1192 )
        return 0;
      SendMessageW(pTreeList->vtptr, LVM_GETITEMW, 0, &lvitem);
      v11 = lvitem.lParam;
      if ( *&lvitem.lParam[11].szText[56] )
      {
        free(*&lvitem.lParam[11].szText[56]);
        v11 = lvitem.lParam;
      }
      v12 = *&v11[11].szText[60];
    }
    if ( v12 )
    {
      free(v12);
      v11 = lvitem.lParam;
    }
    free(v11);
    return 0;
  }
  if ( uId != 104 )
  {
    if ( uId == 101 )
    {
      dword_12DE0D8 = -1;
      *(pTreeList->m_hWndStatic + 1464) = 0;
      return 0;
    }
    if ( uId == 102 )
    {
      SendMessageW(ghWndHandlesListCtrl, LVM_GETITEMW, 0, &lvitem);
      v2 = lvitem.lParam;
      v3 = *&lvitem.lParam[23].szText[6];
      v4 = &lvitem.lParam[23].szText[6];
      v5 = &lvitem.lParam[23].szText[4];
      if ( v3 )
      {
        *(v3 + 4280) = *&lvitem.lParam[23].szText[4];
        v2 = lvitem.lParam;
      }
      else
      {
        gpUserDataInFindDlg = *&lvitem.lParam[23].szText[4];
      }
      v6 = *v5;
      if ( v6 )
      {
        *(v6 + 4284) = *v4;
        v2 = lvitem.lParam;
      }
      free(v2);
      return 0;
    }
    return 0;
  }
  SendMessageW(ghWndDllsListCtrl, LVM_GETITEMW, 0, &lvitem);
  v8 = lvitem.lParam;
  v9 = lvitem.lParam[2].field_14;
  if ( v9 )
    *(v9 + 384) = lvitem.lParam[2].field_10;
  else
    gpUserDataInVerifySignature = lvitem.lParam[2].field_10;
  v10 = v8->Prev;
  if ( v10 )
    *(v10 + 388) = v8->Next;
  sub_1238600(v8);
  return 0;
}
// 12DE0D8: using guessed type int dword_12DE0D8;

//----- (0123D660) --------------------------------------------------------
int __cdecl OnTreeListDblclks(int uId)
{
  HWND hListCtrl; // edi
  int iItem; // eax
  DLLLISTITEMPARAM *v4; // esi
  LVITEMEXW item; // [esp+8h] [ebp-34h]

  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  switch ( uId )
  {
    case IDC_TREELIST:
      hListCtrl = ghWndTreeListView;
      break;
    case IDW_HANDLES_LISTCTRL:
      hListCtrl = ghWndHandlesListCtrl;
      break;
    case IDW_DLL_LISTCTRL:
      hListCtrl = ghWndDllsListCtrl;
      break;
    default:
      return 0;
  }
  iItem = SendMessageW(hListCtrl, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
  if ( iItem != -1 )
  {
    item.iItem = iItem;
    item.iSubItem = 0;
    item.mask = LVCF_TEXT;
    if ( SendMessageW(hListCtrl, LVM_GETITEMW, 0, &item) == 1 )
    {
      switch ( uId )
      {
        case IDC_TREELIST:
          StartProcessPropSheet(item.lParam);
          return 0;
        case IDW_HANDLES_LISTCTRL:
          ShowHandleProperties(hListCtrl, item.lParam);
          return 0;
        case IDW_DLL_LISTCTRL:
          v4 = item.lParam;
          if ( item.lParam->field_2C & 8 )
          {
            MessageBoxW(
              ghWndTreeListView,
              L"Properties not supported on pagefile-backed sections",
              L"Process Explorer Error",
              0x10u);
            return 0;
          }
          if ( !item.lParam->field_38 )
          {
            MessageBoxW(ghWndNewOwner, L"Not a valid DLL", L"Process Explorer", 0x10u);
            return 0;
          }
          InterlockedIncrement(&item.lParam->field_0);
          v4->field_28 = g_dwProcessId;
          _beginthread(LaunchDllPropDlg, 0, v4);
          break;
      }
    }
  }
  return 0;
}

//----- (0123D7A0) --------------------------------------------------------
int __cdecl OnFindItem(int a1)
{
  return -(a1 != 101);
}

//----- (0123D7B0) --------------------------------------------------------
int __usercall CTreeList::OnGetDispInfo@<eax>(int esi0@<esi>, signed int a1, NMLVDISPINFOW *pnmhdr)
{
  UINT v3; // eax
  int result; // eax
  HANDLESANDDLLSLISTUSERPARAM *v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  wchar_t *v9; // eax
  int v10; // eax
  int v11; // eax
  bool v12; // zf
  int v13; // edx
  signed int v14; // ecx
  signed int v15; // eax
  signed int v16; // eax
  int v17; // eax
  HANDLESANDDLLSLISTUSERPARAM *v18; // ebx
  signed int v19; // eax
  double v20; // xmm0_8
  NMLVDISPINFOW *v21; // ebx
  unsigned int v22; // eax
  __int64 v23; // ST18_8
  WCHAR *v24; // eax
  int v25; // eax
  int v26; // ecx
  int v27; // ecx
  int v28; // eax
  int v29; // eax
  const FILETIME *v30; // ebx
  unsigned int v31; // kr00_4
  int v32; // edx
  int v33; // ecx
  int *v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  double v38; // xmm0_8
  int v39; // eax
  int v40; // edx
  int v41; // ecx
  int v42; // eax
  int v43; // edx
  int v44; // ecx
  int v45; // eax
  int v46; // edx
  int v47; // ecx
  int v48; // eax
  int v49; // edx
  int v50; // ecx
  int v51; // eax
  int v52; // edx
  int v53; // ecx
  int v54; // eax
  int v55; // edx
  int v56; // ecx
  int v57; // eax
  int v58; // edx
  int v59; // ecx
  int v60; // eax
  int v61; // edx
  int v62; // ecx
  int v63; // eax
  int v64; // edx
  int v65; // ecx
  int v66; // eax
  int v67; // edx
  int v68; // ecx
  int v69; // eax
  int v70; // edx
  int v71; // ecx
  int v72; // eax
  int v73; // eax
  int v74; // edx
  int v75; // ecx
  int v76; // eax
  int v77; // edx
  int v78; // ecx
  __int16 v79; // ax
  float v80; // xmm0_4
  double v81; // xmm0_8
  unsigned __int8 v82; // cl
  wchar_t *v83; // edx
  wchar_t *v84; // esi
  wchar_t v85; // ax
  unsigned int v86; // edx
  __int16 *v87; // edi
  __int16 v88; // ax
  __int16 *v89; // ecx
  __int16 v90; // ax
  wchar_t *v91; // eax
  HANDLESANDDLLSLISTUSERPARAM *v92; // esi
  int v93; // eax
  int v94; // eax
  int v95; // eax
  WCHAR *v96; // eax
  int v97; // eax
  int v98; // eax
  int v99; // eax
  int v100; // eax
  WCHAR *v101; // eax
  int v102; // eax
  int v103; // eax
  WCHAR *v104; // eax
  HANDLESANDDLLSLISTUSERPARAM *v105; // esi
  char v106; // al
  int v107; // ecx
  unsigned int v108; // kr04_4
  int v109; // ecx
  unsigned int v110; // kr08_4
  int v111; // eax
  int v112; // eax
  #1077 *pInfo; // esi
  int v114; // eax
  unsigned int v115; // eax
  void *v116; // ebx
  const wchar_t *v117; // eax
  wchar_t *v118; // [esp+Ch] [ebp-268h]
  wchar_t *v119; // [esp+Ch] [ebp-268h]
  wchar_t *ArgList; // [esp+10h] [ebp-264h]
  unsigned int ArgLista; // [esp+10h] [ebp-264h]
  int ArgListb; // [esp+10h] [ebp-264h]
  signed int ArgList_4; // [esp+14h] [ebp-260h]
  int ArgList_4a; // [esp+14h] [ebp-260h]
  int ArgList_4b; // [esp+14h] [ebp-260h]
  int ArgList_4c; // [esp+14h] [ebp-260h]
  int ArgList_8; // [esp+18h] [ebp-25Ch]
  SIZE_T NumberOfBytesRead; // [esp+24h] [ebp-250h]
  _FILETIME LocalFileTime; // [esp+28h] [ebp-24Ch]
  unsigned int Buffer; // [esp+30h] [ebp-244h]
  NMLVDISPINFOW *pNMLVDispInfo; // [esp+34h] [ebp-240h]
  _SYSTEMTIME SystemTime; // [esp+38h] [ebp-23Ch]
  wchar_t Dst; // [esp+48h] [ebp-22Ch]
  __int16 v134; // [esp+4Ah] [ebp-22Ah]
  __int16 v135; // [esp+66h] [ebp-20Eh]
  TCHAR TimeStr[260]; // [esp+68h] [ebp-20Ch]

  pNMLVDispInfo = pnmhdr;
  v3 = pnmhdr->item.mask;
  if ( v3 & 2 )
  {
    pnmhdr->item.iImage = *&pnmhdr->item.lParam->szText[12];
    return 0;
  }
  if ( !pnmhdr->item.pszText || !(v3 & 1) )
    return 0;
  ArgList_8 = esi0;
  tcscpy_s(TimeStr, _MAX_PATH, gpszTargetName);
  if ( a1 > 104 )
  {
    if ( a1 == 0x414 )
    {
      v112 = pnmhdr->item.iSubItem;
      pInfo = pnmhdr->item.lParam;
      switch ( v112 )
      {
        case 0:
          ArgList_4a = *(pInfo + 11);
LABEL_49:
          stprintf(TimeStr, L"%d", ArgList_4a);
          goto LABEL_50;
        case 1:
          sub_1235AD0(pInfo + 576, *(pInfo + 73), *(pInfo + 73) >> 32, *(pInfo + 150), *(pInfo + 151), &Dst, 0x10u);
          goto LABEL_41;
        case 2:
          if ( QueryThreadCycleTime && *(pInfo + 10) )
          {
            v9 = TimeStr;
            if ( !*(pInfo + 75) )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64u", *(pInfo + 150), *(pInfo + 151));
LABEL_90:
            GetNumberTextFormat(TimeStr, 0x104u);
          }
          else
          {
            v9 = TimeStr;
            if ( !*(pInfo + 73) )
              goto LABEL_51;
            stprintf(TimeStr, L"%d", *(pInfo + 146), *(pInfo + 147));
          }
          goto LABEL_50;
        case 3:
        case 4:
          if ( *(pInfo + 161) == -1 )
            goto LABEL_363;
          v114 = v112 - 3;
          if ( v114 )
          {
            if ( v114 != 1 )
              goto LABEL_50;
LABEL_363:
            v9 = (pInfo + 52);
          }
          else
          {
            Buffer = *(pInfo + 161);
            ReadProcessMemory(*(pInfo + 159), (gdwSomeFunctionVA + *(pInfo + 160)), &Buffer, 4u, &NumberOfBytesRead);
            v115 = Buffer;
            if ( Buffer != *(pInfo + 161) )
            {
              v116 = *(pInfo + 162);
              if ( Buffer )
              {
                v117 = sub_127EFB0(Buffer);
                *(pInfo + 162) = _wcsdup(v117);
                v115 = Buffer;
              }
              else
              {
                *(pInfo + 162) = 0;
              }
              if ( v116 )
              {
                free(v116);
                v115 = Buffer;
              }
              *(pInfo + 161) = v115;
            }
            v9 = *(pInfo + 162);
          }
          break;
        default:
          goto LABEL_50;
      }
      goto LABEL_364;
    }
    if ( a1 == 1192 )
    {
      v105 = pnmhdr->item.lParam;
      v106 = GetPropW(pnmhdr->hdr.hwndFrom, L"resolve");
      v107 = pnmhdr->item.iSubItem;
      LOBYTE(Buffer) = v106;
      switch ( v107 )
      {
        case 0:
          stprintf(gszProtocalName, L"%S", proto[*v105->szText], ArgList_8);
          pnmhdr->item.pszText = gszProtocalName;
          return 0;
        case 1:
          if ( v106 )
          {
            if ( v105->szText[12] )
            {
              tcscpy_s(TimeStr, 0x104u, &v105->szText[12]);
            }
            else if ( sub_12444B0(*v105->szText, Buffer, 1, *&v105->szText[2], &v105->szText[4], TimeStr, 0x104u) )
            {
              tcscpy_s(&v105->szText[12], 0x104u, TimeStr);
            }
          }
          else
          {
            sub_12444B0(*v105->szText, 0, 1, *&v105->szText[2], &v105->szText[4], TimeStr, 0x104u);
          }
          v108 = wcslen(TimeStr);
          sub_1244670(Buffer, v105[3].field_20, proto[*v105->szText], &TimeStr[2 * v108], 260 - v108);
          v21 = pNMLVDispInfo;
          v9 = TimeStr;
          goto LABEL_52;
        case 2:
          v109 = *v105->szText;
          if ( v109 && v109 != 2 )
          {
            pnmhdr->item.pszText = L"*:*";
            return 0;
          }
          if ( v106 )
          {
            if ( *&v105[6].field_18 )
            {
              tcscpy_s(TimeStr, 0x104u, &v105[6].field_18);
            }
            else if ( sub_12444B0(v109, Buffer, 0, v105[6].field_4, &v105[6].field_8, TimeStr, 0x104u) )
            {
              tcscpy_s(&v105[6].field_18, 0x104u, TimeStr);
            }
          }
          else
          {
            sub_12444B0(v109, 0, 0, v105[6].field_4, &v105[6].field_8, TimeStr, 0x104u);
          }
          v110 = wcslen(TimeStr);
          sub_1244670(Buffer, v105[8].field_B0, proto[*v105->szText], &TimeStr[2 * v110], 260 - v110);
          v21 = pNMLVDispInfo;
          v9 = TimeStr;
          break;
        case 3:
          v111 = *v105->szText;
          if ( v111 && v111 != 2 )
            goto LABEL_50;
          v9 = off_12DD238[*&v105[11].szText[54]];
          goto LABEL_364;
        case 4:
          v9 = *&v105[11].szText[60];
          goto LABEL_364;
        default:
          goto LABEL_50;
      }
      goto LABEL_52;
    }
    goto LABEL_50;
  }
  if ( a1 != 104 )
  {
    if ( a1 != 101 )
    {
      if ( a1 == 102 )
      {
        v5 = pnmhdr->item.lParam;
        v6 = gdwHandlesListColumnMap[pnmhdr->item.iSubItem];
        if ( v6 > 39 )
        {
          v10 = v6 - 1185;
          if ( v10 )
          {
            v11 = v10 - 9;
            if ( v11 )
            {
              v12 = v11 == 114;
              v9 = TimeStr;
              if ( !v12 )
              {
LABEL_51:
                v21 = pnmhdr;
LABEL_52:
                wcsncpy_s(*&v21->item.pszText, *&v21->item.pszText >> 32, v9, 0xFFFFFFFF);
                return 0;
              }
              sub_1228CE0(*&v5->szText[4], &v5->szText[8], TimeStr);
            }
            else
            {
              v13 = *&v5->szText[6];
              if ( v13 )
              {
                v14 = 45;
                v15 = 45;
                if ( v13 & 4 )
                  v15 = 68;
                ArgList_4 = v15;
                v16 = 45;
                if ( v13 & 2 )
                  v16 = 87;
                if ( v13 & 1 )
                  v14 = 82;
                stprintf(TimeStr, L"%C%C%C", v14, v16, ArgList_4);
              }
            }
          }
          else
          {
            stprintf(TimeStr, L"0x%08X", *v5->szText);
          }
        }
        else if ( v6 == 39 )
        {
          stprintf(TimeStr, L"0x%08X", *&v5->szText[4]);
        }
        else
        {
          v7 = v6 - 20;
          if ( v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                v9 = &v5[12].field_18;
                goto LABEL_364;
              }
              goto LABEL_50;
            }
            v9 = &v5->szText[8];
LABEL_364:
            if ( !v9 )
            {
LABEL_228:
              pnmhdr->item.pszText = gpszTargetName;
              return 0;
            }
            if ( v9 != TimeStr )
            {
              pnmhdr->item.pszText = v9;
              return 0;
            }
            goto LABEL_51;
          }
          stprintf(TimeStr, L"0x%X", *&v5->szText[2]);
        }
      }
      goto LABEL_50;
    }
    v17 = pnmhdr->item.iSubItem;
    v18 = pnmhdr->item.lParam;
    if ( v17 > gdwProcessListColumnCount )
      return 0;
    v19 = gdwIDMapProcesListForSelectColumn[v17];
    if ( v19 <= 1032 )
    {
      if ( v19 == 1032 )
      {
        v9 = *&v18[4].szText[12];
        goto LABEL_364;
      }
      switch ( v19 )
      {
        case 3:
          v9 = *&v18->szText[10];
          goto LABEL_364;
        case 4:
          goto LABEL_204;
        case 5:
          ArgList_4a = *&v18[7].szText[20];
          goto LABEL_49;
        case 6:
          goto LABEL_54;
        case 7:
          v20 = *&v18[7].field_10;
          if ( v20 <= 0.005 )
          {
            tcscpy_s(&Dst, 0x10u, gpszTargetName);
          }
          else if ( gbShowCpuFractions )
          {
            wsprintf(&Dst, L"%02.2f", LODWORD(v20), HIDWORD(v20));
          }
          else
          {
            wsprintf(&Dst, L"%0.0f", LODWORD(v20), HIDWORD(v20));
          }
          goto LABEL_41;
        case 9:
          v22 = v18[5].field_0;
          goto LABEL_62;
        case 10:
          stprintf(TimeStr, L"%I64u", v18[5].field_4 >> 10, 0);
          GetNumberTextFormat(TimeStr, 0x104u);
          wcscat_s(TimeStr, 0x104u, L" K");
          goto LABEL_50;
        case 18:
          ArgList_4b = *&v18->szText[26];
          goto LABEL_55;
        case 19:
          v9 = *&v18->szText[24];
          goto LABEL_364;
        case 25:
          v9 = &v18[3].szText[31];
          goto LABEL_364;
        case 35:
          v9 = &v18->szText[32];
          goto LABEL_364;
        case 38:
          v9 = *&v18[4].szText[4];
          goto LABEL_364;
        default:
          goto LABEL_50;
      }
      goto LABEL_50;
    }
    if ( v19 <= 1317 )
    {
      if ( v19 != 1317 )
      {
        switch ( v19 )
        {
          case 1033:
            v9 = *&v18[4].szText[6];
            goto LABEL_364;
          case 1055:
            if ( SLOBYTE(v18->szText[0]) < 0 )
            {
              pnmhdr->item.pszText = L"Suspended";
              return 0;
            }
            sub_1235AD0(
              &v18[7].field_8,
              *&v18[7].szText[4],
              *&v18[7].szText[4] >> 32,
              *&v18[7].szText[12],
              *&v18[7].szText[14],
              &Dst,
              0x10u);
            break;
          case 1056:
            v28 = *&v18->szText[30];
            goto LABEL_113;
          case 1059:
            ArgList_4c = 0;
            ArgListb = *&v18[4].szText[52];
            goto LABEL_88;
          case 1060:
            stprintf(TimeStr, L"%I64u", *&v18[4].szText[56] >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1061:
            v9 = *&v18[4].szText[8];
            goto LABEL_364;
          case 1062:
            stprintf(TimeStr, L"%I64u", *&v18[4].szText[60] >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1063:
            stprintf(TimeStr, L"%I64u", *&v18[4].szText[62] >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1064:
            stprintf(TimeStr, L"%I64u", v18[4].ProcessId >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1065:
LABEL_54:
            ArgList_4b = *&v18->szText[28];
            goto LABEL_55;
          case 1066:
            ArgList_4b = *&v18[7].szText[26];
            goto LABEL_55;
          case 1067:
            ArgList_4b = *&v18[7].szText[24];
            goto LABEL_55;
          case 1068:
            ArgList_4b = *v18[5].szText;
            ArgList = L"%u";
            goto LABEL_56;
          case 1069:
            v32 = *&v18[5].szText[6];
            v33 = *&v18[5].szText[4];
            goto LABEL_188;
          case 1070:
            ArgList_4b = *&v18[5].szText[16];
            ArgList = L"%u";
            goto LABEL_56;
          case 1071:
            v32 = *&v18[5].szText[22];
            v33 = *&v18[5].szText[20];
            goto LABEL_188;
          case 1072:
            ArgList_4b = *&v18[5].szText[32];
            ArgList = L"%u";
            goto LABEL_56;
          case 1073:
            v32 = *&v18[5].szText[38];
            v33 = *&v18[5].szText[36];
            goto LABEL_188;
          case 1086:
            v29 = *&v18[3].szText[16];
            v30 = &v18[3].szText[16];
            if ( !(v30->dwHighDateTime | v29) )
              goto LABEL_184;
            FileTimeToLocalFileTime(v30, &LocalFileTime);
            FileTimeToSystemTime(&LocalFileTime, &SystemTime);
            GetTimeFormatW(0x400u, 0, &SystemTime, 0, TimeStr, 260);
            wcscat_s(TimeStr, 0x104u, L" ");
            v31 = wcslen(TimeStr);
            GetDateFormatW(0x400u, 0, &SystemTime, 0, &TimeStr[2 * v31], 260 - v31);
            goto LABEL_50;
          case 1087:
            v23 = *&v18[7].field_20;
            v21 = pNMLVDispInfo;
            stprintf(
              TimeStr,
              L"%I64d:%02I64d:%02I64d.%03I64d",
              *&pNMLVDispInfo->item.lParam[7].field_20 / 0x861C46800ui64,
              *&pNMLVDispInfo->item.lParam[7].field_20 / 0x23C34600ui64 % 0x3C,
              v23 / 10000000 % 60,
              v23 % 10000000 / 10000);
            v9 = TimeStr;
            goto LABEL_52;
          case 1091:
            ArgList_4c = *&v18[7].szText[10];
            ArgListb = *&v18[7].szText[8];
            goto LABEL_88;
          case 1092:
            v27 = *&v18[7].szText[6];
            if ( v27 < 0 || v27 <= 0 && !*&v18[7].szText[4] )
              goto LABEL_50;
            ArgList_4c = *&v18[7].szText[6];
            ArgListb = *&v18[7].szText[4];
LABEL_88:
            v119 = L"%I64d";
            goto LABEL_89;
          case 1094:
            v34 = v18[6].szFileName;
            if ( !v34 )
              goto LABEL_50;
            v35 = *v34;
            v36 = v34[1];
            v12 = *v34 == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v35, v36);
            goto LABEL_90;
          case 1095:
            v37 = v18[6].szFileName;
            if ( !v37 )
              goto LABEL_50;
            v38 = *(v37 + 8);
            goto LABEL_129;
          case 1096:
            v39 = v18[6].szFileName;
            if ( !v39 )
              goto LABEL_50;
            v40 = *(v39 + 16);
            v41 = *(v39 + 20);
            v12 = *(v39 + 16) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v40, v41);
            goto LABEL_90;
          case 1097:
            v42 = v18[6].szFileName;
            if ( !v42 )
              goto LABEL_50;
            v43 = *(v42 + 48);
            v44 = *(v42 + 52);
            v12 = *(v42 + 48) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v43, v44);
            goto LABEL_90;
          case 1098:
            v45 = v18[6].szFileName;
            if ( !v45 )
              goto LABEL_50;
            v46 = *(v45 + 32);
            v47 = *(v45 + 36);
            v12 = *(v45 + 32) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v46, v47);
            goto LABEL_90;
          case 1099:
            v48 = v18[6].szFileName;
            if ( !v48 )
              goto LABEL_50;
            v49 = *(v48 + 24);
            v50 = *(v48 + 28);
            v12 = *(v48 + 24) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v49, v50);
            goto LABEL_90;
          case 1100:
            v51 = v18[6].szFileName;
            if ( !v51 )
              goto LABEL_50;
            v52 = *(v51 + 56);
            v53 = *(v51 + 60);
            v12 = *(v51 + 56) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v52, v53);
            goto LABEL_90;
          case 1101:
            v54 = v18[6].szFileName;
            if ( !v54 )
              goto LABEL_50;
            v55 = *(v54 + 40);
            v56 = *(v54 + 44);
            v12 = *(v54 + 40) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v55, v56);
            goto LABEL_90;
          case 1103:
            v60 = v18[6].szFileName;
            if ( !v60 )
              goto LABEL_50;
            v61 = *(v60 + 112);
            v62 = *(v60 + 116);
            v12 = *(v60 + 112) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v61, v62);
            goto LABEL_90;
          case 1104:
            v63 = v18[6].szFileName;
            if ( !v63 )
              goto LABEL_50;
            v64 = *(v63 + 64);
            v65 = *(v63 + 68);
            v12 = *(v63 + 64) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v64, v65);
            goto LABEL_90;
          case 1105:
            v66 = v18[6].szFileName;
            if ( !v66 )
              goto LABEL_50;
            v67 = *(v66 + 72);
            v68 = *(v66 + 76);
            v12 = *(v66 + 72) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v67, v68);
            goto LABEL_90;
          case 1106:
            v69 = v18[6].szFileName;
            if ( !v69 )
              goto LABEL_50;
            v70 = *(v69 + 80);
            v71 = *(v69 + 84);
            v12 = *(v69 + 80) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v70, v71);
            goto LABEL_90;
          case 1107:
            v72 = v18[6].szFileName;
            if ( !v72 )
              goto LABEL_50;
            v38 = *(v72 + 88);
LABEL_129:
            v9 = TimeStr;
            if ( v38 == 0.0 )
              goto LABEL_51;
            stprintf(TimeStr, L"%02.02f", LODWORD(v38), HIDWORD(v38));
            goto LABEL_50;
          case 1108:
            v73 = v18[6].szFileName;
            if ( !v73 )
              goto LABEL_50;
            v74 = *(v73 + 104);
            v75 = *(v73 + 108);
            v12 = *(v73 + 104) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v74, v75);
            goto LABEL_90;
          case 1109:
            v76 = v18[6].szFileName;
            if ( !v76 )
              goto LABEL_50;
            v77 = *(v76 + 120);
            v78 = *(v76 + 124);
            v12 = *(v76 + 120) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v77, v78);
            goto LABEL_90;
          case 1110:
            v57 = v18[6].szFileName;
            if ( !v57 )
              goto LABEL_50;
            v58 = *(v57 + 128);
            v59 = *(v57 + 132);
            v12 = *(v57 + 128) == 0i64;
            v9 = TimeStr;
            if ( v12 )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64d", v58, v59);
            goto LABEL_90;
          case 1114:
            stprintf(TimeStr, L"%I64u", *&v18[4].szText[50] >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1115:
            ArgLista = v18[5].field_10 >> 10;
            v118 = L"%I64d";
            goto LABEL_63;
          case 1116:
            stprintf(TimeStr, L"%I64u", v18[5].field_14 >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1118:
            stprintf(TimeStr, L"%I64u", v18[5].field_1C >> 10, 0);
            GetNumberTextFormat(TimeStr, 0x104u);
            wcscat_s(TimeStr, 0x104u, L" K");
            goto LABEL_50;
          case 1179:
            if ( !*&v18[4].szText[54] )
              goto LABEL_50;
            ArgList_4b = *&v18[4].szText[54];
            goto LABEL_55;
          case 1180:
            v9 = *&v18[4].szText[22];
            goto LABEL_364;
          case 1181:
            v9 = *&v18[4].szText[10];
            goto LABEL_364;
          case 1187:
            v9 = *&v18[4].szText[30];
            goto LABEL_364;
          case 1190:
            goto LABEL_79;
          case 1192:
            v25 = *&v18[4].szText[58];
            if ( v25 )
            {
              stprintf(TimeStr, L"%d", v25 / 1024);
              GetNumberTextFormat(TimeStr, 0x104u);
              wcscat_s(TimeStr, 0x104u, L" K");
            }
            goto LABEL_50;
          case 1195:
            ArgList_4c = *&v18[7].szText[18];
            ArgListb = *&v18[7].szText[16];
            v119 = L"%I64u";
            goto LABEL_89;
          case 1196:
            if ( !*&v18[3].szText[12] )
              goto LABEL_50;
            v24 = L"Not responding";
            if ( !LOBYTE(v18[3].szText[14]) )
              v24 = L"Running";
            pnmhdr->item.pszText = v24;
            return 0;
          case 1199:
            sub_1277720(v18, TimeStr, 0x104u);
            goto LABEL_50;
          case 1200:
            v26 = *&v18[7].szText[14];
            if ( v26 < 0 || v26 <= 0 && !*&v18[7].szText[12] )
              goto LABEL_50;
            ArgList_4c = *&v18[7].szText[14];
            ArgListb = *&v18[7].szText[12];
            v119 = L"%I64u";
LABEL_89:
            stprintf(TimeStr, v119, ArgListb, ArgList_4c);
            goto LABEL_90;
          default:
            goto LABEL_50;
        }
LABEL_41:
        if ( Dst == 48 && (v134 == 48 || !v134) )
        {
          pnmhdr->item.pszText = L"    ";
          return 0;
        }
        tcscpy_s(TimeStr, 0x104u, &Dst);
        goto LABEL_50;
      }
      v22 = *&v18[5].field_18;
      goto LABEL_62;
    }
    if ( v19 <= 1609 )
    {
      if ( v19 == 1609 )
      {
        if ( *&v18[5].szText[56] )
        {
          ArgList_4b = *&v18[5].szText[56];
          ArgList = L"%u";
LABEL_56:
          stprintf(TimeStr, ArgList, ArgList_4b);
LABEL_57:
          GetNumberTextFormat(TimeStr, 0x104u);
        }
      }
      else
      {
        switch ( v19 )
        {
          case 1326:
            if ( !*&v18[5].szText[8] )
              goto LABEL_50;
            ArgList_4b = *&v18[5].szText[8];
            goto LABEL_55;
          case 1327:
            v32 = *&v18[5].szText[14];
            v33 = *&v18[5].szText[12];
            goto LABEL_188;
          case 1328:
            if ( !*&v18[5].szText[24] )
              goto LABEL_50;
            ArgList_4b = *&v18[5].szText[24];
            goto LABEL_55;
          case 1329:
            v32 = *&v18[5].szText[30];
            v33 = *&v18[5].szText[28];
            goto LABEL_188;
          case 1332:
            v32 = *&v18[5].szText[46];
            v33 = *&v18[5].szText[44];
            goto LABEL_188;
          case 1333:
            v32 = *&v18[5].szText[50];
            v33 = *&v18[5].szText[48];
            goto LABEL_188;
          case 1335:
            if ( !*&v18[5].szText[40] )
              goto LABEL_50;
            ArgList_4b = *&v18[5].szText[40];
            goto LABEL_55;
          case 1336:
            v9 = *&v18[4].szText[20];
            goto LABEL_364;
          case 1337:
            if ( !(*v18->szText & 0x200) )
              goto LABEL_50;
            pnmhdr->item.pszText = L"Virtualized";
            return 0;
          case 1338:
            v79 = v18[3].szText[29];
            if ( v79 & 0x40 )
              goto LABEL_182;
            goto LABEL_183;
          case 1339:
            v28 = *&v18[4].szText[48];
LABEL_113:
            if ( v28 == -1 )
              goto LABEL_50;
            ArgList_4a = v28;
            goto LABEL_49;
          case 1340:
            sub_1277790(v18[5].field_20, TimeStr, 0x104u);
            goto LABEL_50;
          case 1341:
            v22 = v18[4].field_B0;
            goto LABEL_62;
          case 1342:
            v22 = v18[4].szFileName;
            goto LABEL_62;
          default:
            goto LABEL_50;
        }
      }
      goto LABEL_50;
    }
    if ( v19 <= IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD )
    {
      if ( v19 != IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD )
      {
        switch ( v19 )
        {
          case 1610:
            if ( !v18[5].ProcessId )
              goto LABEL_50;
            ArgList_4b = v18[5].ProcessId;
            goto LABEL_55;
          case 1611:
            if ( !v18[6].field_0 )
              goto LABEL_50;
            ArgList_4b = v18[6].field_0;
            ArgList = L"%u";
            goto LABEL_56;
          case 1612:
            if ( !v18[6].field_10 )
              goto LABEL_50;
            ArgList_4b = v18[6].field_10;
            goto LABEL_55;
          case 1613:
            if ( !v18[6].field_20 )
              goto LABEL_50;
            ArgList_4b = v18[6].field_20;
            ArgList = L"%u";
            goto LABEL_56;
          case 1614:
            if ( !*&v18[6].szText[4] )
              goto LABEL_50;
            ArgList_4b = *&v18[6].szText[4];
            goto LABEL_55;
          case 1616:
            v81 = *&v18[5].field_B0;
            goto LABEL_189;
          case 1617:
            v32 = *&v18[5].szText[62];
            v33 = *&v18[5].szText[60];
            goto LABEL_188;
          case 1618:
            v32 = v18[6].field_C;
            v33 = v18[6].field_8;
            goto LABEL_188;
          case 1619:
            v32 = v18[6].field_1C;
            v33 = *&v18[6].field_18;
            goto LABEL_188;
          case 1620:
            v81 = *v18[6].szText;
            goto LABEL_189;
          case 1621:
            if ( *&v18[6].szText[8] )
              sub_1232200(0, TimeStr, 0x104u, COERCE__INT64(*&v18[6].szText[8]), 0i64, 0i64 >> 63);
            goto LABEL_50;
          case 1622:
            v81 = *&v18[6].szText[12];
            goto LABEL_189;
          case 1623:
            v9 = TimeStr;
            if ( !*&v18[6].szText[20] )
              goto LABEL_51;
            stprintf(TimeStr, L"%u", *&v18[6].szText[16]);
            goto LABEL_57;
          case 1624:
            if ( !*&v18[6].szText[24] )
              goto LABEL_50;
            ArgList_4b = *&v18[6].szText[24];
            goto LABEL_55;
          case 1625:
            if ( !*&v18[6].szText[32] )
              goto LABEL_50;
            ArgList_4b = *&v18[6].szText[32];
            ArgList = L"%u";
            goto LABEL_56;
          case 1626:
            if ( !*&v18[6].szText[40] )
              goto LABEL_50;
            ArgList_4b = *&v18[6].szText[40];
            goto LABEL_55;
          case 1627:
            if ( !*&v18[6].szText[48] )
              goto LABEL_50;
            ArgList_4b = *&v18[6].szText[48];
            ArgList = L"%u";
            goto LABEL_56;
          case 1628:
            if ( !*&v18[6].szText[56] )
              goto LABEL_50;
            ArgList_4b = *&v18[6].szText[56];
LABEL_55:
            ArgList = L"%d";
            goto LABEL_56;
          case 1630:
            v32 = *&v18[6].szText[22];
            v33 = *&v18[6].szText[20];
            goto LABEL_188;
          case 1631:
            v32 = *&v18[6].szText[30];
            v33 = *&v18[6].szText[28];
            goto LABEL_188;
          case 1632:
            v32 = *&v18[6].szText[38];
            v33 = *&v18[6].szText[36];
            goto LABEL_188;
          case 1633:
            v32 = *&v18[6].szText[46];
            v33 = *&v18[6].szText[44];
            goto LABEL_188;
          case 1634:
            v32 = *&v18[6].szText[54];
            v33 = *&v18[6].szText[52];
            goto LABEL_188;
          case 1635:
            v32 = *&v18[6].szText[62];
            v33 = *&v18[6].szText[60];
            goto LABEL_188;
          case 1636:
            v32 = v18[6].field_AC;
            v33 = v18[6].ProcessId;
LABEL_188:
            v80 = __PAIR__(v32, v33);
            v81 = v80;
LABEL_189:
            sub_1235BB0(TimeStr, *&v81);
            goto LABEL_50;
          case 1637:
            sub_1235AD0(&v18[7].field_18, 0, 0, 0, 0, &Dst, 0x10u);
            goto LABEL_41;
          case 1638:
LABEL_204:
            if ( *&v18->szText[14] < 0 )
              goto LABEL_184;
            ArgList_4a = *&v18->szText[14];
            goto LABEL_49;
          case 1650:
            sub_1235AD0(&v18[7].szText[28], 0, 0, 0, 0, &Dst, 0x10u);
            goto LABEL_41;
          case 1651:
            v9 = TimeStr;
            if ( !*&v18[7].szText[40] )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64u", *&v18[7].szText[40], *&v18[7].szText[42]);
            goto LABEL_64;
          case 1652:
            v9 = TimeStr;
            if ( !*&v18[7].szText[48] )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64u", *&v18[7].szText[48], *&v18[7].szText[50]);
            goto LABEL_64;
          case 1653:
            v9 = TimeStr;
            if ( !*&v18[7].szText[56] )
              goto LABEL_51;
            stprintf(TimeStr, L"%I64u", *&v18[7].szText[56], *&v18[7].szText[58]);
            goto LABEL_64;
          case 1654:
            v9 = *&v18[4].szText[24];
            goto LABEL_364;
          case 1656:
            v9 = *&v18[4].szText[26];
            goto LABEL_364;
          case 1667:
            switch ( *&v18[3].szText[26] )
            {
              case 0xFFFFFFFF:
                goto LABEL_228;
              case 0:
                pnmhdr->item.pszText = L"Unaware";
                return 0;
              case 1:
                pnmhdr->item.pszText = L"System Aware";
                return 0;
              case 2:
                pnmhdr->item.pszText = L"Per-Monitor Aware";
                return 0;
              default:
                ArgList_4a = *&v18[3].szText[26];
                break;
            }
            goto LABEL_49;
          case 1670:
            sub_1281A50(*&v18[4].szText[34], TimeStr);
            goto LABEL_50;
          case 1673:
            v82 = HIBYTE(v18[3].szText[28]);
            if ( !v82 )
              goto LABEL_50;
            if ( (v82 & 0xF0u) < 0x70 )
            {
              v83 = &aPsprotectedsig[64 * (v82 >> 4)];
              v84 = &aPsprotectedsig[64 * (v82 >> 4)];
              do
              {
                v85 = *v83;
                ++v83;
              }
              while ( v85 );
              v86 = v83 - v84;
              v87 = &v135;
              do
              {
                v88 = v87[1];
                ++v87;
              }
              while ( v88 );
              qmemcpy(v87, v84, v86);
            }
            if ( (HIBYTE(v18[3].szText[28]) & 7) == 1 )
            {
              v89 = &v135;
              do
              {
                v90 = v89[1];
                ++v89;
              }
              while ( v90 );
              *v89 = *L"-Light";
              *(v89 + 1) = *L"ight";
              *(v89 + 2) = *L"ht";
              v89[6] = aLight[6];
            }
            v21 = pNMLVDispInfo;
            v9 = TimeStr;
            goto LABEL_52;
          case 1674:
            v91 = L"UI Access";
            if ( !(*v18->szText & 0x2000) )
              v91 = gpszTargetName;
            pnmhdr->item.pszText = v91;
            return 0;
          default:
            goto LABEL_50;
        }
        goto LABEL_50;
      }
      v79 = v18[3].szText[29];
      if ( !(v18[3].szText[29] & 0x4000) )
      {
LABEL_183:
        if ( !v79 )
        {
LABEL_184:
          pnmhdr->item.pszText = L"n/a";
          return 0;
        }
        goto LABEL_50;
      }
LABEL_276:
      pnmhdr->item.pszText = L"CFG";
      return 0;
    }
LABEL_50:
    v9 = TimeStr;
    goto LABEL_51;
  }
  v92 = pnmhdr->item.lParam;
  v93 = gdwIdMapForDllsListColumn[pnmhdr->item.iSubItem];
  if ( v93 <= 30 )
  {
    if ( v93 == 30 )
    {
      v9 = &v92->szText[18];
      goto LABEL_364;
    }
    switch ( v93 )
    {
      case 23:
        stprintf(TimeStr, L"0x%X", v92->ImgName);
        goto LABEL_50;
      case 24:
        stprintf(TimeStr, L"0x%X", *&v92->szText[8]);
        goto LABEL_50;
      case 25:
        v9 = (&v92[1].field_14 + 2);
        goto LABEL_364;
      case 26:
        if ( !wcsrchr(*&v92[1].szText[60], 0x5Cu) )
          goto LABEL_304;
        v9 = wcsrchr(*&v92[1].szText[60], 0x5Cu) + 1;
        goto LABEL_364;
      default:
        goto LABEL_50;
    }
    goto LABEL_50;
  }
  if ( v93 <= 1118 )
  {
    if ( v93 == 1118 )
    {
      v22 = v92[2].field_C;
    }
    else
    {
      if ( v93 <= 1074 )
      {
        if ( v93 == 1074 )
        {
          stprintf(TimeStr, L"0x%X", *&v92->szText[4]);
          goto LABEL_50;
        }
        v94 = v93 - 40;
        if ( v94 )
        {
          v95 = v94 - 2;
          if ( !v95 )
          {
            v9 = *&v92[1].szText[56];
            goto LABEL_364;
          }
          if ( v95 == 991 )
          {
            v9 = *&v92[1].szText[58];
            goto LABEL_364;
          }
          goto LABEL_50;
        }
        v96 = L"Data";
        if ( !(v92->szText[2] & 2) )
          v96 = L"Image";
        pnmhdr->item.pszText = v96;
        return 0;
      }
      v97 = v93 - 1111;
      if ( !v97 )
      {
LABEL_304:
        v9 = *&v92[1].szText[60];
        goto LABEL_364;
      }
      v98 = v97 - 4;
      if ( v98 )
      {
        if ( v98 != 1 )
          goto LABEL_50;
        v22 = v92[2].field_4;
      }
      else
      {
        v22 = v92[2].field_0;
      }
    }
LABEL_62:
    ArgLista = v22 >> 10;
    v118 = L"%I64u";
LABEL_63:
    stprintf(TimeStr, v118, ArgLista, 0);
LABEL_64:
    GetNumberTextFormat(TimeStr, 0x104u);
    wcscat_s(TimeStr, 0x104u, L" K");
    goto LABEL_50;
  }
  if ( v93 <= 1338 )
  {
    if ( v93 == 1338 )
    {
      if ( v92->szText[7] & 0x40 )
      {
LABEL_182:
        pnmhdr->item.pszText = L"ASLR";
        result = 0;
      }
      else
      {
        v101 = L"n/a";
        if ( !(v92->szText[2] & 2) )
          v101 = gpszTargetName;
        pnmhdr->item.pszText = v101;
        result = 0;
      }
      return result;
    }
    v99 = v93 - 1187;
    if ( !v99 )
    {
      v9 = v92[1].field_AC;
      goto LABEL_364;
    }
    v100 = v99 - 3;
    if ( !v100 )
    {
LABEL_79:
      pnmhdr->item.pszText = L"32-bit";
      return 0;
    }
    if ( v100 != 127 )
      goto LABEL_50;
    v22 = v92[2].field_8;
    goto LABEL_62;
  }
  v102 = v93 - 1656;
  if ( !v102 )
  {
    v9 = *&v92[1].szText[62];
    goto LABEL_364;
  }
  v103 = v102 - 14;
  if ( !v103 )
  {
    sub_1281A50(v92[1].szFileName, TimeStr);
    goto LABEL_50;
  }
  if ( v103 != 39087 )
    goto LABEL_50;
  if ( v92->szText[7] & 0x4000 )
    goto LABEL_276;
  v104 = L"n/a";
  if ( v92->szText[7] )
    v104 = gpszTargetName;
  pnmhdr->item.pszText = v104;
  return 0;
}
// 123D7B0: could not find valid save-restore pair for esi
// 12BE080: using guessed type wchar_t aSuspended[10];
// 12BE094: using guessed type wchar_t asc_12BE094[5];
// 12BE0A0: using guessed type wchar_t aVirtualized[12];
// 12BE0C8: using guessed type wchar_t aUiAccess[10];
// 12BE0DC: using guessed type wchar_t aUnaware[8];
// 12BE0EC: using guessed type wchar_t aSystemAware[13];
// 12BE108: using guessed type wchar_t aPerMonitorAwar[18];
// 12BE12C: using guessed type wchar_t aAslr[5];
// 12BE138: using guessed type wchar_t aCfg[4];
// 12BE140: using guessed type wchar_t a32Bit[7];
// 12BE18C: using guessed type wchar_t aNotResponding[15];
// 12BE200: using guessed type wchar_t a0x08x[7];
// 12BE220: using guessed type wchar_t aData_0[5];
// 12BE250: using guessed type wchar_t asc_12BE250[4];
// 12BE9C8: using guessed type double dbl_12BE9C8;
// 12DD238: using guessed type wchar_t *off_12DD238[13];
// 12E96C9: using guessed type char gbShowCpuFractions;
// 12EB1CC: using guessed type int gdwSomeFunctionVA;

//----- (0123F490) --------------------------------------------------------
int __cdecl OnTreeListKeydown(int uID, NMLVKEYDOWN *pNMKeyDown)
{
  int vKey; // eax
  int result; // eax

  if ( uID != IDC_TREELIST || (vKey = pNMKeyDown->wVKey, vKey != '\t') && vKey != '$' && vKey != '#' && vKey != '\r' )
    result = 0;
  else
    result = PEListCtrlWndProc(pNMKeyDown->hdr.hwndFrom, WM_KEYDOWN, vKey, 0);
  return result;
}

//----- (0123F4D0) --------------------------------------------------------
int __cdecl CTreeList::OnItemChanged(UINT nID)
{
  HWND hListCtrl; // edi
  LRESULT v2; // eax
  HANDLESANDDLLSLISTUSERPARAM *v3; // edi
  int v4; // eax
  HMENU hMenuOwner; // eax
  int v6; // ecx
  HMENU hMenu_1; // esi
  const WCHAR *v8; // eax
  const WCHAR *v9; // eax
  BOOL v10; // ST10_4
  HMENU v11; // eax
  HMENU v12; // eax
  LPARAM lParam; // [esp+8h] [ebp-68h]
  int v15; // [esp+14h] [ebp-5Ch]
  int v16; // [esp+18h] [ebp-58h]
  LVITEMW item; // [esp+3Ch] [ebp-34h]
  HMENU hMnua; // [esp+78h] [ebp+8h]

  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  switch ( nID )
  {
    case IDC_TREELIST:
      hListCtrl = ghWndTreeListView;
      break;
    case IDW_HANDLES_LISTCTRL:
      hListCtrl = ghWndHandlesListCtrl;
      break;
    case IDW_DLL_LISTCTRL:
      hListCtrl = ghWndDllsListCtrl;
      break;
    default:
      return 0;
  }
  item.iItem = SendMessageW(hListCtrl, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  item.iSubItem = 0;
  item.stateMask = 2;
  item.mask = 12;
  v2 = SendMessageW(hListCtrl, LVM_GETITEMW, 0, &item);
  if ( nID == IDC_TREELIST )
  {
    if ( v2 == 1 && item.state & 2 )
    {
      v3 = item.lParam;
      v4 = *&item.lParam->szText[14];
      if ( g_dwProcessId != v4 )
      {
        g_dwProcessId = *&item.lParam->szText[14];
        UpdateMenu(1, 3);
        hMenuOwner = GetMenu(ghWndNewOwner);
        v6 = *&v3[7].szText[20];
        hMenu_1 = hMenuOwner;
        hMnua = hMenuOwner;
        if ( v6 == 4 && !v3[5].field_20 )
          v6 = 0;
        sub_127EF00(hMenuOwner, v6);
        v16 = 2;
        v15 = 2;
        SendMessageW(ghWndDllsListCtrl, LVM_SETITEMSTATE, 0, &lParam);
        v16 = 2;
        v15 = 2;
        SendMessageW(ghWndHandlesListCtrl, LVM_SETITEMSTATE, 0, &lParam);
        v8 = L"R&esume";
        if ( SLOBYTE(v3->szText[0]) >= 0 )
          v8 = L"S&uspend";
        ModifyMenuW(hMenu_1, IDS_PROCEXPLORERMENU_PROCESS_SUSPEND, 0, IDS_PROCEXPLORERMENU_PROCESS_SUSPEND, v8);
        v9 = L"Un&hide";
        if ( !(v3->szText[0] & 1) )
          v9 = L"&Hide";
        ModifyMenuW(hMnua, 40090u, 0, 40090u, v9);
        CheckProcessWindowMenuItems(v3);
        sub_12469D0(v3);
        if ( gbShowLowerpane )
          UpdateMenu(0, 5);
        v10 = gbShowProcessTree == 0;
        v11 = GetMenu(ghWndNewOwner);
        EnableMenuItem(v11, IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS_TREE, v10);
LABEL_23:
        if ( gbShowLowerpane && !IsWindowVisible(ghDlgFindDialog) && ghStartToResumeProcessEvent )
        {
          SetEvent(ghStartToResumeProcessEvent);
          return 0;
        }
        return 0;
      }
    }
    else
    {
      g_dwProcessId = -1;
      UpdateMenu(0, 3);
      v12 = GetMenu(ghWndNewOwner);
      EnableMenuItem(v12, IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS_TREE, 1u);
      if ( gbShowLowerpane )
      {
        UpdateMenu(0, 5);
        goto LABEL_23;
      }
    }
  }
  else if ( gbShowLowerpane )
  {
    if ( v2 == 1 && item.state & 2 )
    {
      UpdateMenu(1, 5);
      return 0;
    }
    UpdateMenu(0, 5);
  }
  return 0;
}
// 12BE398: using guessed type wchar_t aREsume[8];
// 12BE3BC: using guessed type wchar_t aUnHide[8];
// 12E5742: using guessed type char gbShowProcessTree;
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (0123F750) --------------------------------------------------------
int __cdecl OnTreeListRClick(int a1, HWND *a2, POINT *a3)
{
  HWND v3; // edi
  LRESULT v4; // eax
  HMENU v5; // eax
  HMENU v6; // eax
  TREELISTITEMPARAM *v7; // esi
  HMENU v8; // eax
  void *v9; // esi
  char v10; // bl
  HMENU v11; // eax
  HMENU v12; // edx
  int v13; // ecx
  const WCHAR *v14; // eax
  _WORD *v15; // eax
  int result; // eax
  HWND v17; // eax
  UINT_PTR v18; // esi
  LPARAM lParam; // [esp+8h] [ebp-34h]
  LRESULT v20; // [esp+Ch] [ebp-30h]
  int v21; // [esp+10h] [ebp-2Ch]
  void *a1a; // [esp+28h] [ebp-14h]

  lParam = 0;
  memset(&v20, 0, 0x30u);
  switch ( a1 )
  {
    case 101:
      v3 = ghWndTreeListView;
      goto LABEL_7;
    case 102:
      v3 = ghWndHandlesListCtrl;
      goto LABEL_7;
    case 104:
      v3 = ghWndDllsListCtrl;
LABEL_7:
      v4 = SendMessageW(v3, 0x100Cu, 0xFFFFFFFF, 2);
      if ( v4 != -1 )
      {
        v20 = v4;
        v21 = 0;
        lParam = 4;
        if ( SendMessageW(v3, 0x104Bu, 0, &lParam) == 1 )
        {
          hMenu = CreatePopupMenu();
          if ( a1 == 101 )
          {
            v5 = GetMenu(ghWndNewOwner);
            v6 = GetSubMenu(v5, 3);
            v7 = a1a;
            hMenu = v6;
            CheckProcessWindowMenuItems(a1a);
            sub_12469D0(v7);
          }
          else if ( a1 == 102 )
          {
            v8 = GetMenu(ghWndNewOwner);
            hMenu = GetSubMenu(v8, 5);
          }
          else
          {
            v9 = a1a;
            v10 = 0;
            v11 = GetMenu(ghWndNewOwner);
            v12 = GetSubMenu(v11, 5);
            hMenu = v12;
            v13 = *(v9 + 91);
            if ( !v13 || (v14 = L"&Submit to VirusTotal", *(v13 + 4) != 6) )
              v14 = L"&Check VirusTotal";
            ModifyMenuW(v12, IDS_DLLMENU_CHECK_VIRUSTOTALCOM, 0, 0x9F3Au, v14);
            v15 = *(v9 + 86);
            if ( v15 && *v15 != 91 )
            {
              v10 = 0;
              if ( sub_1281C10(*(v9 + 91)) )
                v10 = 1;
            }
            EnableMenuItem(hMenu, IDS_DLLMENU_CHECK_VIRUSTOTALCOM, v10 == 0);
          }
          TrackPopupMenuEx(hMenu, 0, a3->x, a3->y, ghWndNewOwner, 0);
          hMenu = 0;
        }
      }
      return 0;
    case 106:
      hMenu = CreatePopupMenu();
      AppendMenuW(hMenu, 0, IDS_OPACITY_SIXTY_PERCENT|0x8, L"&Select Status Bar Columns...");
      TrackPopupMenuEx(hMenu, 0, a3->x, a3->y, ghWndNewOwner, 0);
      hMenu = 0;
      result = 0;
      break;
    default:
      v17 = GetParent(*a2);
      if ( v17 == ghWndTreeListView )
      {
        v18 = 40105;
      }
      else if ( v17 == ghWndDllsListCtrl )
      {
        v18 = 40104;
      }
      else
      {
        v18 = 40041;
        if ( v17 == ghWndHandlesListCtrl )
          v18 = 40106;
      }
      hMenu = CreatePopupMenu();
      AppendMenuW(hMenu, 0, v18, L"&Select Columns...");
      TrackPopupMenuEx(hMenu, 0, a3->x, a3->y, ghWndNewOwner, 0);
      hMenu = 0;
      result = 0;
      break;
  }
  return result;
}
// 12BE374: using guessed type wchar_t aCheckVirustota[18];

//----- (0123F9E0) --------------------------------------------------------
bool __cdecl InitTreeListSortableHeader(HWND hWnd, int item1, int item2, char Ascending)
{
  CTreeList *TreeList; // eax
  HWND hWndHeader; // ebx
  HWND hWndHeader1; // eax
  HDITEMW item; // [esp+4h] [ebp-2Ch]

  TreeList = GetTreeListCtrl(hWnd);
  if ( TreeList )
    return CTreeList::SetSortableColumn(TreeList, item2, Ascending != 0);
  hWndHeader = SendMessageW(hWnd, LVM_GETHEADER, 0, 0);
  item.mask = HDI_FORMAT;
  SendMessageW(hWndHeader, HDM_GETITEMW, item1, &item);
  if ( gbTreeListSortable )
    // HDF_BITMAP|HDF_SORTUP|HDF_SORTDOWN|HDF_RIGHT|HDF_LEFT
    item.fmt &= -0x2601u;
  else
    // HDF_BITMAP_ON_RIGHT|HDF_IMAGE|HDF_RIGHT|HDF_LEFT
    item.fmt &= -0x1801u;
  SendMessageW(hWndHeader, HDM_SETITEMW, item1, &item);
  UpdateWindow(hWndHeader);
  hWndHeader1 = SendMessageW(hWnd, LVM_GETHEADER, 0, 0);
  return RedrawHeader(hWndHeader1, item2, 2 * (Ascending != 0) - 1);
}
// 12EA8F8: using guessed type char gbTreeListSortable;

//----- (0123FAA0) --------------------------------------------------------
LRESULT __cdecl sub_123FAA0(HWND hWnd)
{
  HWND v1; // ecx
  HWND v2; // ebx
  LRESULT v3; // eax
  BOOL v4; // eax
  UINT v5; // ST0C_4
  HMENU v6; // eax
  LPARAM lParam; // [esp+Ch] [ebp-3Ch]
  WPARAM v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  WPARAM wParam; // [esp+40h] [ebp-8h]
  HWND v13; // [esp+44h] [ebp-4h]

  v1 = HWND_MESSAGE|0x2;
  wParam = hWnd;
  if ( hWnd == 101 )
  {
    v1 = gdwProcessListSortColumnCount;
    v2 = ghWndTreeListView;
  }
  else if ( hWnd == 102 )
  {
    v1 = gdwHandlesListSortColumnCount;
    v2 = ghWndHandlesListCtrl;
  }
  else
  {
    if ( (hWnd - 102) != 2 )
    {
      v2 = hWnd;
      goto LABEL_9;
    }
    v1 = gdwDllsListlSortColumnCount;
    v2 = ghWndDllsListCtrl;
  }
  if ( v1 != HWND_MESSAGE|0x2 )
  {
    if ( hWnd != 101 )
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_9:
  if ( hWnd != 101 || !gbShowProcessTree )
    return SendMessageW(v2, WM_SETREDRAW, 1u, 0);
LABEL_13:
  BYTE1(dword_12E53B4) = 1;
LABEL_14:
  v13 = v1;
  SendMessageW(v2, LVM_SORTITEMS, &wParam, TreeListSort);
  if ( hWnd == 101 )
  {
    if ( gbShowNewProcesses )
    {
      lParam = 4;
      v10 = 0;
      v9 = 0;
      if ( SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0) > 0 )
      {
        while ( 1 )
        {
          SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &lParam);
          if ( *(v11 + 16) == 2 && !*(v11 + 20) )
            break;
          ++v9;
          v3 = SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
          if ( v9 >= v3 )
            goto LABEL_22;
        }
        SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, v9, 0);
      }
    }
LABEL_22:
    BYTE1(dword_12E53B4) = 0;
    v4 = !gbShowProcessTree || SendMessageW(v2, LVM_GETNEXTITEM, 0xFFFFFFFF, 2) == -1;
    v5 = v4;
    v6 = GetMenu(ghWndNewOwner);
    EnableMenuItem(v6, IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS_TREE, v5);
  }
  return SendMessageW(v2, WM_SETREDRAW, 1u, 0);
}
// 12E53B4: using guessed type int dword_12E53B4;
// 12E5742: using guessed type char gbShowProcessTree;
// 12E96DB: using guessed type char gbShowNewProcesses;

//----- (0123FC20) --------------------------------------------------------
BOOL __stdcall ColumnSetDlgProc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // edi
  LRESULT v5; // ebx
  int v6; // ecx
  BOOL result; // eax
  LRESULT v8; // esi
  int i; // esi
  int v10; // ST0C_4
  HMENU v11; // eax
  HMENU v12; // eax
  HMENU v13; // eax
  void (__stdcall *v14)(HWND, UINT, WPARAM, LPARAM); // esi
  signed int v15; // ebx
  int v16; // eax
  int v17; // ST08_4
  HMENU v18; // eax
  HMENU v19; // eax
  HMENU v20; // eax
  LRESULT v21; // ST10_4
  void (__stdcall *v22)(HWND, UINT, WPARAM, LPARAM); // ebx
  HANDLESANDDLLSLISTUSERPARAM *dwColumn; // esi
  wchar_t (*v24)[762]; // ebx
  int v25; // eax
  int v26; // eax
  LRESULT v27; // esi
  HWND v28; // eax
  HWND v29; // eax
  BOOL v30; // eax
  BOOL v31; // ST14_4
  HWND v32; // eax
  BOOL v33; // eax
  BOOL v34; // ST14_4
  HWND v35; // eax
  int v36; // eax
  WPARAM v37; // ST10_4
  LVCOLUMNW lvColumn; // [esp+Ch] [ebp-44A4h]
  LPARAM v39; // [esp+2Ch] [ebp-4484h]
  LRESULT v40; // [esp+30h] [ebp-4480h]
  int v41; // [esp+34h] [ebp-447Ch]
  wchar_t *v42; // [esp+40h] [ebp-4470h]
  int v43; // [esp+44h] [ebp-446Ch]
  int v44; // [esp+4Ch] [ebp-4464h]
  LPARAM v45; // [esp+60h] [ebp-4450h]
  int v46; // [esp+68h] [ebp-4448h]
  int v47; // [esp+6Ch] [ebp-4444h]
  int v48; // [esp+70h] [ebp-4440h]
  int v49; // [esp+74h] [ebp-443Ch]
  LVITEMW lvItem; // [esp+94h] [ebp-441Ch]
  LPARAM lParam; // [esp+C8h] [ebp-43E8h]
  WPARAM wParam; // [esp+CCh] [ebp-43E4h]
  int v53; // [esp+D0h] [ebp-43E0h]
  wchar_t *v54; // [esp+DCh] [ebp-43D4h]
  int v55; // [esp+E0h] [ebp-43D0h]
  int v56; // [esp+E8h] [ebp-43C8h]
  HWND v57; // [esp+FCh] [ebp-43B4h]
  HWND v58; // [esp+100h] [ebp-43B0h]
  char v59[15240]; // [esp+104h] [ebp-43ACh]
  WCHAR NewItem; // [esp+3C8Ch] [ebp-824h]
  char v61; // [esp+409Ch] [ebp-414h]
  wchar_t Src; // [esp+42A4h] [ebp-20Ch]

  v58 = hDlg;
  lvColumn.mask = 0;
  _mm_storeu_si128(&lvColumn.fmt, 0i64);
  lvColumn.iOrder = 0;
  *&lvColumn.iSubItem = 0i64;
  lvItem.mask = 0;
  memset(&lvItem.iItem, 0, 0x30u);
  v4 = GetDlgItem(hDlg, 1310);
  v57 = v4;
  if ( a2 == 78 )
  {
    v26 = *(a4 + 8);
    if ( v26 != -176 )
    {
      if ( v26 == -175 )
      {
        byte_12E9E70 = 1;
      }
      else if ( v26 == -101 && !byte_12E9E70 )
      {
        v27 = SendMessageW(v4, 0x100Cu, 0xFFFFFFFF, 2);
        v28 = GetDlgItem(v58, 1214);
        EnableWindow(v28, v27 != -1);
        v29 = GetDlgItem(v58, 1212);
        EnableWindow(v29, v27 != -1);
        v30 = v27 != -1 && v27;
        v31 = v30;
        v32 = GetDlgItem(v58, 1210);
        EnableWindow(v32, v31);
        v33 = v27 != -1 && v27 != SendMessageW(v4, 0x1004u, 0, 0) - 1;
        v34 = v33;
        v35 = GetDlgItem(v58, 1211);
        EnableWindow(v35, v34);
      }
      return 0;
    }
    v36 = *(a4 + 32);
    byte_12E9E70 = 0;
    if ( !v36 )
      return 0;
    v49 = v36;
    v37 = *(a4 + 16);
    v46 = 0;
    SendMessageW(v4, 0x1074u, v37, &v45);
    result = 1;
  }
  else
  {
    if ( a2 != 272 )
    {
      if ( a2 == 273 )
      {
        if ( a3 <= 1212 )
        {
          if ( a3 == 1212 )
          {
            v8 = SendMessageW(v4, 0x100Cu, 0xFFFFFFFF, 2);
            SendMessageW(v4, 0x1008u, v8, 0);
            if ( v8 )
              --v8;
            v48 = 3;
            v47 = 3;
            SendMessageW(v4, 0x102Bu, v8, &v45);
            return 0;
          }
          if ( a3 != 2 )
          {
            if ( a3 - 1210 <= 1 )
            {
              v5 = SendMessageW(v4, 0x100Cu, 0xFFFFFFFF, 2);
              lParam = 5;
              if ( a3 == 1210 )
                wParam = v5 - 1;
              else
                wParam = v5 + 1;
              v55 = 259;
              v54 = &Src;
              v53 = 0;
              SendMessageW(v4, 0x104Bu, 0, &lParam);
              v39 = 5;
              v42 = &v61;
              v40 = v5;
              v43 = 259;
              v41 = 0;
              SendMessageW(v4, 0x104Bu, 0, &v39);
              v6 = v56;
              v54 = &v61;
              v42 = &Src;
              v56 = v44;
              v44 = v6;
              SendMessageW(v4, 0x104Cu, 0, &lParam);
              SendMessageW(v4, 0x104Cu, 0, &v39);
              v48 = 3;
              v47 = 3;
              SendMessageW(v4, 0x102Bu, wParam, &v45);
            }
            return 0;
          }
          goto LABEL_28;
        }
        if ( a3 == 1214 )
        {
          SetFocus(v4);
          v21 = SendMessageW(v4, 0x100Cu, 0xFFFFFFFF, 2);
          SendMessageW(v4, 0x1076u, v21, 0);
          return 0;
        }
        if ( a3 == 1313 )
        {
          for ( i = 0; i < gdwNumColumnsets; ++i )
          {
            v10 = gnMenuLastColumnsetPosLast;
            v11 = GetMenu(ghWndNewOwner);
            v12 = GetSubMenu(v11, 2);
            v13 = GetSubMenu(v12, v10);
            DeleteMenu(v13, 0, 0x400u);
          }
          memmove_0(v59, gstrMenuCulumnSet, 0x3B88u);
          v14 = SendMessageW;
          v15 = 0;
          gdwNumColumnsets = SendMessageW(v4, 0x1004u, 0, 0);
          if ( gdwNumColumnsets > 0 )
          {
            do
            {
              lParam = 5;
              v54 = &Src;
              wParam = v15;
              v55 = 259;
              v53 = 0;
              v14(v4, 0x104Bu, 0, &lParam);
              qmemcpy(gstrMenuCulumnSet[v15], &v59[1524 * v56], sizeof(wchar_t[762]));
              tcscpy_s(gstrMenuCulumnSet[v15], 0x104u, &Src);
              if ( v15 >= 10 )
              {
                tcscpy_s(&NewItem, 0x208u, &Src);
              }
              else
              {
                if ( v15 == 9 )
                  v16 = 0;
                else
                  v16 = v15 + 1;
                sub_1234BB0(&NewItem, L"%s\tCtrl+%d", &Src, v16);
              }
              v17 = gnMenuLastColumnsetPosLast;
              v18 = GetMenu(ghWndNewOwner);
              v19 = GetSubMenu(v18, 2);
              v20 = GetSubMenu(v19, v17);
              AppendMenuW(v20, 0, v15 + 40665, &NewItem);
              v4 = v57;
              ++v15;
              v14 = SendMessageW;
            }
            while ( v15 < gdwNumColumnsets );
          }
LABEL_28:
          EndDialog(v58, 0);
          return 0;
        }
      }
      return 0;
    }
    v22 = SendMessageW;
    byte_12E9E70 = 0;
    SendMessageW(v4, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x20u, 32);
    SendMessageW(v4, LVM_INSERTCOLUMNW, 0, &lvColumn);
    dwColumn = 0;
    lvItem.mask = 13;
    lvItem.iItem = 0x7FFFFFFF;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    if ( gdwNumColumnsets > 0 )
    {
      v24 = gstrMenuCulumnSet;
      do
      {
        lvItem.pszText = v24;
        v25 = lstrlenW(v24);
        lvItem.iImage = 0;
        lvItem.cchTextMax = v25 + 1;
        lvItem.lParam = dwColumn;
        SendMessageW(v4, LVM_INSERTITEMW, 0, &lvItem);
        dwColumn = (dwColumn + 1);
        ++v24;
      }
      while ( dwColumn < gdwNumColumnsets );
      v22 = SendMessageW;
    }
    v22(v4, 0x101Eu, 0, 65534);
    v48 = 3;
    v47 = 3;
    v22(v4, 0x102Bu, 0, &v45);
    SetFocus(v4);
    result = 1;
  }
  return result;
}
// 12E5B2C: using guessed type int gdwNumColumnsets;
// 12E9E70: using guessed type char byte_12E9E70;
// 123FC20: using guessed type char var_43AC[15240];

//----- (012402A0) --------------------------------------------------------
BOOL __cdecl AutoComputerSomeGraphColor(int nId, HDC hdc, int bkColor)
{
  WORD v3; // cx
  signed int uId; // eax
  int v5; // eax
  double Value; // xmm0_8
  WORD v7; // cx
  COLORREF clrBack; // eax
  bool fWhiteText; // cf
  COLORREF clrRGB; // [esp-10h] [ebp-2Ch]
  double dbValue; // [esp+0h] [ebp-1Ch]
  int Red[2]; // [esp+8h] [ebp-14h]
  WORD pwHue[2]; // [esp+10h] [ebp-Ch]
  WORD pwSaturation[2]; // [esp+14h] [ebp-8h]
  WORD pwLuminance[2]; // [esp+18h] [ebp-4h]

  v3 = 0;
  *pwLuminance = 0;
  if ( !gbShowColumnHeatmaps )
    return v3 != 0;
  uId = gdwIDMapProcesListForSelectColumn[nId];
  if ( uId > IDD_PROCMEMCOLUMNS_CHECKBOX_WORKING_SET_SIZE )
  {
    if ( uId != IDD_PROCGPUCOLUMNS_CHECKBOX_GPU_USAGE )
      return v3 != 0;
    GetPalletteInfo(gpGraphClassData[2], Red, 0);
    Value = *Red / *&gpGraphClassData[GraphIndex_GPUUsage]->dbTotalPageFile;
    clrRGB = 0x8080FF;
  }
  else if ( uId == IDD_PROCMEMCOLUMNS_CHECKBOX_WORKING_SET_SIZE )
  {
    GetPalletteInfo(gpGraphClassData[5], Red, 0);
    Value = *Red / *&gpGraphClassData[GraphIndex_PhysicalMemory]->dbTotalPageFile;
    clrRGB = 0x4080FF;
  }
  else
  {
    v5 = uId - IDD_PROCCOLUMNS95_CHECKBOX_CPU_USAGE;
    if ( !v5 )
    {
      GetPalletteInfo(gpGraphClassData[1], Red, 0);
      dbValue = *Red / *&gpGraphClassData[GraphIndex_CPU]->dbTotalPageFile;
      if ( *Red / *&gpGraphClassData[GraphIndex_CPU]->dbTotalPageFile > 100.0 )
        dbValue = gdbMaxValue;
      ColorRGBToHLS(0x3C943Cu, pwHue, pwLuminance, pwSaturation);
      goto LABEL_14;
    }
    if ( v5 != 5 )
      return v3 != 0;
    GetPalletteInfo(gpGraphClassData[0], Red, 0);
    Value = *Red / *&gpGraphClassData[0]->dbTotalPageFile;
    clrRGB = 0x82A0;
  }
  dbValue = Value;
  ColorRGBToHLS(clrRGB, pwHue, pwLuminance, pwSaturation);
LABEL_14:
  v3 = pwLuminance[0];
  if ( pwLuminance[0] )
  {
    v7 = 5 * (46 - (dbValue * 100.0) / 5);
    if ( dbValue == 0.0 )
      v7 = 230;
    *pwLuminance = v7;
    clrBack = ColorHLSToRGB(pwHue[0], v7, pwSaturation[0]);
    fWhiteText = pwLuminance[0] < 0x6Eu;
    *bkColor = clrBack;
    if ( fWhiteText )
      SetTextColor(hdc, 0xFFFFFFu);
    else
      SetTextColor(hdc, 0);
    SetBkColor(hdc, *bkColor);
    v3 = pwLuminance[0];
  }
  return v3 != 0;
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E96CF: using guessed type char gbShowColumnHeatmaps;

//----- (01240490) --------------------------------------------------------
HCURSOR __cdecl LoadHandCursor(int a1, int nId)
{
  ResizeInfo *pInfo; // eax
  HCURSOR hCursorHand; // eax

  if ( gdwIDMapProcesListForSelectColumn[nId] == IDD_DLLCOLUMNS_CHECKBOX_VIRUSTOTAL
    && (GetTreeListCtrl(ghWndTreeListView), pInfo = sub_121E5D0(a1), sub_1281820(pInfo[0xF].d1.top)) )
  {
    hCursorHand = LoadCursorW(ghInstance, L"HAND");
  }
  else
  {
    hCursorHand = 0;
  }
  return hCursorHand;
}

//----- (012404F0) --------------------------------------------------------
char __cdecl ColumnIDIsIllegal(int a1, HWND hWnd, int uID, WPARAM wParam)
{
  char v4; // bl
  LPARAM col; // eax

  v4 = 0;
  if ( !a1 )
    return 0;
  if ( hWnd == ghWndTreeListView )
  {
    if ( gdwProcessListSortColumnCount == -1
      || gbShowProcessTree
      || gdwIDMapProcesListForSelectColumn[gdwProcessListSortColumnCount] != uID )
    {
      if ( !gbProcessExplorerHide )
      {
        col = 0;
        if ( gdwProcessListColumnCount > 0 )
        {
          while ( gdwIDMapProcesListForSelectColumn[col] != uID )
          {
            if ( ++col >= gdwProcessListColumnCount )
              return 0;
          }
          PostMessageW(ghWndNewOwner, PMT_MSG_7EB, wParam, col);
        }
      }
    }
    else
    {
      v4 = 1;
      if ( gdwProcessListColumnCount < 16 && !gbShowLowerpane )
      {
        SendMessageW(hWnd, WM_SETREDRAW, 0, 0);
        return 1;
      }
    }
  }
  return v4;
}
// 12E5742: using guessed type char gbShowProcessTree;
// 12E96CD: using guessed type char gbShowLowerpane;
// 12EA389: using guessed type char gbProcessExplorerHide;

//----- (012405A0) --------------------------------------------------------
BOOL __userpurge ColumnSetSaveDlgProc@<eax>(double a1@<st0>, double a2@<st1>, double a3@<st3>, double a4@<st2>, double a5@<st4>, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  HWND v9; // ecx
  HWND v11; // eax
  LPARAM wMenuIndex; // ebx
  wchar_t **v13; // esi
  wchar_t *v14; // edi
  DWORD v15; // edi
  int v16; // eax
  int v17; // ST08_4
  HMENU v18; // eax
  HMENU v19; // eax
  HMENU v20; // eax
  int nIndex; // ebx
  int dwCountOfColumnSetToSave; // eax
  int dwIndex; // esi
  wchar_t (*v24)[762]; // edi
  bool bFound; // zf
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  HWND v27; // ebx
  int v28; // edi
  wchar_t (*v29)[762]; // esi
  int v30; // [esp+0h] [ebp-62Ch]
  WCHAR strMenuItem[520]; // [esp+10h] [ebp-61Ch]
  WCHAR String[260]; // [esp+420h] [ebp-20Ch]

  v9 = hDlg;
  if ( uMsg == WM_INITDIALOG )
  {
    nIndex = 0;
    do
    {
      stprintf(String, L"Column Set %d", nIndex, v30);
      dwCountOfColumnSetToSave = gdwNumColumnsets;
      dwIndex = 0;
      if ( gdwNumColumnsets > 0 )
      {
        v24 = gstrMenuCulumnSet;
        while ( 1 )
        {
          bFound = _wcsicmp(String, v24) == 0;
          dwCountOfColumnSetToSave = gdwNumColumnsets;
          if ( bFound )
            break;
          ++dwIndex;
          ++v24;
          if ( dwIndex >= gdwNumColumnsets )
            goto LABEL_31;
        }
        ++nIndex;
      }
LABEL_31:
      ;
    }
    while ( dwIndex != dwCountOfColumnSetToSave );
    SendMessageW = ::SendMessageW;
    v27 = GetDlgItem(hDlg, IDD_COLUMNSETSAVE_COMBOBOX_COLUMNSET_NAME);
    ::SendMessageW(v27, CB_ADDSTRING, 0, String);
    v28 = 0;
    if ( gdwNumColumnsets > 0 )
    {
      v29 = gstrMenuCulumnSet;
      do
      {
        ::SendMessageW(v27, CB_ADDSTRING, 0, v29);
        ++v28;
        ++v29;
      }
      while ( v28 < gdwNumColumnsets );
      SendMessageW = ::SendMessageW;
    }
    SendMessageW(v27, CB_SETCURSEL, 0, 0);
    SendMessageW(v27, CB_SETEDITSEL, 0, 0xFFFF0000);
  }
  else
  {
    if ( uMsg != WM_COMMAND )
      return 0;
    if ( wParam != 1 )
    {
      if ( wParam != 2 )
        return 0;
      goto LABEL_22;
    }
    v11 = GetDlgItem(hDlg, IDD_COLUMNSETSAVE_COMBOBOX_COLUMNSET_NAME);
    GetWindowTextW(v11, String, _MAX_PATH);
    wMenuIndex = 0;
    if ( gdwNumColumnsets <= 0 )
      goto LABEL_13;
    v13 = gstrMenuCulumnSet;
    do
    {
      if ( !_wcsicmp(String, v13) )
        break;
      ++wMenuIndex;
      v13 += 381;
    }
    while ( wMenuIndex < gdwNumColumnsets );
    if ( wMenuIndex != 10 )
    {
LABEL_13:
      CMainWnd::Reset(ghWndNewOwner, 0);
      v14 = gstrMenuCulumnSet[wMenuIndex];
      qmemcpy(v14, gszColumnsetName, 1524u);
      v15 = (v14 + 762);
      tcscpy_s(gstrMenuCulumnSet[wMenuIndex], 0x104u, String);
      if ( wMenuIndex == gdwNumColumnsets )
      {
        if ( wMenuIndex >= 10 )
        {
          tcscpy_s(strMenuItem, 0x208u, String);
        }
        else
        {
          if ( wMenuIndex == 9 )
            v16 = 0;
          else
            v16 = wMenuIndex + 1;
          sub_1234BB0(strMenuItem, L"%s\tCtrl+%d", String, v16, v30);
        }
        v17 = gnMenuLastColumnsetPosLast;
        v18 = GetMenu(ghWndNewOwner);
        v19 = GetSubMenu(v18, 2);
        v20 = GetSubMenu(v19, v17);
        AppendMenuW(v20, 0, wMenuIndex + 40665, strMenuItem);
        ++gdwNumColumnsets;
      }
      OnSelectColumnMRU(a1, wMenuIndex, v15, a2, a3, a4, a5, 0, wMenuIndex - 24871);
      v9 = hDlg;
LABEL_22:
      EndDialog(v9, 0);
      return 0;
    }
    while ( MessageBoxW(
              ghWndNewOwner,
              L"You must delete at least one column set before you can save a new column set.\n"
               "Do you want to open the Column Set Organizer dialog?",
              L"Process Explorer Warning",
              0x34u) != 7 )
    {
      DialogBoxParamW(ghInstance, L"COLUMNSETS", ghWndNewOwner, ColumnSetDlgProc, 0);
      wMenuIndex = gdwNumColumnsets;
      if ( gdwNumColumnsets != 10 )
        goto LABEL_13;
    }
  }
  return 1;
}
// 12E5538: using guessed type __int16 gszColumnsetName[260];
// 12E5B2C: using guessed type int gdwNumColumnsets;

//----- (012408A0) --------------------------------------------------------
int __cdecl CMainWnd::Reset(HWND hWnd, char fSave)
{
  WPARAM bandidx; // ebx
  unsigned int idx; // esi
  HKEY uID; // ebx
  LRESULT res; // eax
  signed int dwPrcoessColumnCount; // edx
  signed int v7; // ecx
  __m128i v8; // xmm1
  __int16 *v9; // esi
  signed int v10; // ebx
  unsigned int v11; // eax
  __m128i v12; // xmm0
  signed int i; // ecx
  signed int dwIdx; // esi
  int nId; // eax
  WPARAM dwCount; // ecx
  signed int nIndex; // esi
  HKEY Handle; // ebx
  LRESULT ret; // eax
  signed int dwHandleColumnCount; // edx
  signed int v21; // ecx
  __m128i v22; // xmm1
  __int16 *v23; // esi
  signed int v24; // ebx
  unsigned int v25; // eax
  __m128i v26; // xmm0
  signed int j; // ecx
  signed int nColIdx; // esi
  int v29; // eax
  WPARAM v30; // ecx
  signed int nColumn; // esi
  HKEY v32; // ebx
  int result; // eax
  signed int v34; // edx
  signed int v35; // ecx
  __m128i v36; // xmm1
  __int16 *v37; // esi
  signed int v38; // ebx
  __m128i v39; // xmm0
  signed int k; // ecx
  signed int v41; // esi
  HWND v42; // ecx
  signed int v43; // esi
  int dwIndex; // esi
  wchar_t (*strName)[762]; // edi
  char OldSetup[18400]; // [esp+8h] [ebp-4B3Ch]
  REBARBANDINFOW rbbi; // [esp+47E8h] [ebp-35Ch]
  CComBSTR v48; // [esp+4838h] [ebp-30Ch]
  int nColumnIndex[4]; // [esp+49C0h] [ebp-184h]
  __int16 v50[184]; // [esp+49D0h] [ebp-174h]

  memmove_0(OldSetup, gWindowPlacement, 18400u);
  gWindowPlacement[0].length = 44;
  GetWindowPlacement(hWnd, gWindowPlacement);
  if ( gbShowLowerpane )
    gdSavedDivider = *&gdSavedDividerCopy;
  if ( ghDlgFindDialog )
  {
    gWindowPlacement[FindWindowplacement].length = 44;
    GetWindowPlacement(ghDlgFindDialog, &gWindowPlacement[1]);
  }
  if ( !gdwRefreshRateOfSearch )
  {
    switch ( gdwRefreshMenuId )
    {
      case IDS_PROCEXPLORERMENU_TWO_SECONDS:
        gdwRefreshRateOfSearch = 2000;
        break;
      case IDS_PROCEXPLORERMENU_FIVE_SECONDS:
        gdwRefreshRateOfSearch = 5000;
        break;
      case IDS_PROCEXPLORERMENU_TEN_SECONDS:
        gdwRefreshRateOfSearch = 10000;
        break;
      case IDS_PROCEXPLORERMENU_HALF_SECONDS:
        gdwRefreshRateOfSearch = 500;
        break;
      default:
        gdwRefreshRateOfSearch = 1000;
        break;
    }
  }
  bandidx = 0;
  rbbi.cbSize = 80;
  // RBBIM_ID|||RBBIM_SIZE|RBBIM_STYLE|
  rbbi.fMask = 0x141;
  idx = 0;
  do
  {
    SendMessageW(ghWndRebar, RB_GETBANDINFOW, bandidx, &rbbi);
    gdwToolbarBands[idx] = MulDiv(rbbi.cx, 96, gLogPixelsX);
    ++bandidx;
    gGraphReBarCtrlIds[idx] = rbbi.wID;
    LOBYTE(gdwSortableColumnVector[idx]) = rbbi.fStyle & RBBS_BREAK;
    idx += 3;
  }
  while ( idx < 24 );
  gwProcessImageColumnWidth = SendMessageW(ghWndTreeListView, LVM_GETCOLUMNWIDTH, 0, 0);
  uID = gdwIDMapProcesListForSelectColumn[gdwProcessListSortColumnCount];
  v48.hKey = gdwIDMapProcesListForSelectColumn[gdwProcessListSortColumnCount];
  res = SendMessageW(ghWndTreeListView, LVM_GETCOLUMNORDERARRAY, gdwProcessListColumnCount, nColumnIndex);
  dwPrcoessColumnCount = gdwProcessListColumnCount;
  if ( !res )
  {
    // 重置宽度设置
    v7 = 0;
    if ( gdwProcessListColumnCount > 0 )
    {
      if ( gdwProcessListColumnCount >= 8 )
      {
        v8 = _mm_load_si128(&xmmword_12BEA50);
        v9 = v50;
        v10 = gdwProcessListColumnCount - gdwProcessListColumnCount % 8;
        do
        {
          v11 = v7 + 4;
          v9 += 16;
          v12 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v7), 0), v8);
          v7 += 8;
          _mm_storeu_si128(v9 - 3, v12);
          _mm_storeu_si128(v9 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0), v8));
        }
        while ( v7 < v10 );
        uID = v48.hKey;
      }
      for ( ; v7 < dwPrcoessColumnCount; ++v7 )
        nColumnIndex[v7] = v7;
    }
  }
  for ( i = 0; i < dwPrcoessColumnCount; ++i )
    *(&v48.Length + i) = gdwIDMapProcesListForSelectColumn[nColumnIndex[i]];
  dwIdx = 0;
  if ( dwPrcoessColumnCount > 0 )
  {
    do
    {
      nId = *(&v48.Length + dwIdx);
      gdwIDMapProcesListForSelectColumn[dwIdx] = nId;
      dwCount = gdwProcessListSortColumnCount;
      dwPrcoessColumnCount = gdwProcessListColumnCount;
      if ( nId == uID )
        dwCount = dwIdx;
      ++dwIdx;
      gdwProcessListSortColumnCount = dwCount;
    }
    while ( dwIdx < gdwProcessListColumnCount );
  }
  nIndex = 0;
  if ( dwPrcoessColumnCount > 0 )
  {
    do
    {
      gwProcessListColumnWidths[nIndex] = SendMessageW(ghWndTreeListView, LVM_GETCOLUMNWIDTH, nColumnIndex[nIndex], 0);
      ++nIndex;
    }
    while ( nIndex < gdwProcessListColumnCount );
  }
  Handle = gdwHandlesListColumnMap[gdwHandlesListSortColumnCount];
  v48.hKey = gdwHandlesListColumnMap[gdwHandlesListSortColumnCount];
  ret = SendMessageW(ghWndHandlesListCtrl, LVM_GETCOLUMNORDERARRAY, gdwHandlesListColumnCount, nColumnIndex);
  dwHandleColumnCount = gdwHandlesListColumnCount;
  if ( !ret )
  {
    v21 = 0;
    if ( gdwHandlesListColumnCount > 0 )
    {
      if ( gdwHandlesListColumnCount >= 8 )
      {
        v22 = _mm_load_si128(&xmmword_12BEA50);
        v23 = v50;
        v24 = gdwHandlesListColumnCount - gdwHandlesListColumnCount % 8;
        do
        {
          v25 = v21 + 4;
          v23 += 16;
          v26 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v21), 0), v22);
          v21 += 8;
          _mm_storeu_si128(v23 - 3, v26);
          _mm_storeu_si128(v23 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v25), 0), v22));
        }
        while ( v21 < v24 );
        Handle = v48.hKey;
      }
      for ( ; v21 < dwHandleColumnCount; ++v21 )
        nColumnIndex[v21] = v21;
    }
  }
  for ( j = 0; j < dwHandleColumnCount; ++j )
    *(&v48.Length + j) = gdwHandlesListColumnMap[nColumnIndex[j]];
  nColIdx = 0;
  if ( dwHandleColumnCount > 0 )
  {
    do
    {
      v29 = *(&v48.Length + nColIdx);
      gdwHandlesListColumnMap[nColIdx] = v29;
      v30 = gdwHandlesListSortColumnCount;
      dwHandleColumnCount = gdwHandlesListColumnCount;
      if ( v29 == Handle )
        v30 = nColIdx;
      ++nColIdx;
      gdwHandlesListSortColumnCount = v30;
    }
    while ( nColIdx < gdwHandlesListColumnCount );
  }
  nColumn = 0;
  if ( dwHandleColumnCount > 0 )
  {
    do
    {
      gdwHandlesListColumnWidths[nColumn] = SendMessageW(
                                              ghWndHandlesListCtrl,
                                              LVM_GETCOLUMNWIDTH,
                                              nColumnIndex[nColumn],
                                              0);
      ++nColumn;
    }
    while ( nColumn < gdwHandlesListColumnCount );
  }
  v32 = gdwIdMapForDllsListColumn[gdwDllsListlSortColumnCount];
  v48.hKey = gdwIdMapForDllsListColumn[gdwDllsListlSortColumnCount];
  result = SendMessageW(ghWndDllsListCtrl, LVM_GETCOLUMNORDERARRAY, gdwDllsListColumnCount, nColumnIndex);
  v34 = gdwDllsListColumnCount;
  if ( !result )
  {
    v35 = 0;
    if ( gdwDllsListColumnCount > 0 )
    {
      if ( gdwDllsListColumnCount >= 8 )
      {
        v36 = _mm_load_si128(&xmmword_12BEA50);
        v37 = v50;
        v38 = gdwDllsListColumnCount - gdwDllsListColumnCount % 8;
        do
        {
          result = v35 + 4;
          v37 += 16;
          v39 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v35), 0), v36);
          v35 += 8;
          _mm_storeu_si128(v37 - 3, v39);
          _mm_storeu_si128(v37 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(result), 0), v36));
        }
        while ( v35 < v38 );
        v32 = v48.hKey;
      }
      for ( ; v35 < v34; ++v35 )
        nColumnIndex[v35] = v35;
    }
  }
  for ( k = 0; k < v34; ++k )
  {
    result = gdwIdMapForDllsListColumn[nColumnIndex[k]];
    *(&v48.Length + k) = result;
  }
  v41 = 0;
  if ( v34 > 0 )
  {
    do
    {
      result = *(&v48.Length + v41);
      gdwIdMapForDllsListColumn[v41] = result;
      v42 = gdwDllsListlSortColumnCount;
      v34 = gdwDllsListColumnCount;
      if ( result == v32 )
        v42 = v41;
      ++v41;
      gdwDllsListlSortColumnCount = v42;
    }
    while ( v41 < gdwDllsListColumnCount );
  }
  v43 = 0;
  if ( v34 > 0 )
  {
    do
    {
      result = SendMessageW(ghWndDllsListCtrl, LVM_GETCOLUMNWIDTH, nColumnIndex[v43], 0);
      DllColumns[v43++] = result;
    }
    while ( v43 < gdwDllsListColumnCount );
  }
  if ( fSave )
  {
    v48.bstr = _wcsdup(L"Software\\Sysinternals\\Process Explorer");
    gDefaultLogFont.lfHeight = -MulDiv(gDefaultLogFont.lfHeight, 72, gLogPixelsY);
    SaveGlobalVariable(&v48, &gGlobalVariables);
    // 恢复原始neicun
    memmove_0(gWindowPlacement, OldSetup, 18400u);
    dwIndex = 0;
    if ( gdwNumColumnsets > 0 )
    {
      strName = gstrMenuCulumnSet;
      do
      {
        SerializeColumnset(1, dwIndex++, strName);
        ++strName;
      }
      while ( dwIndex < gdwNumColumnsets );
    }
    free(v48.bstr);
  }
  return result;
}
// 12BEA50: using guessed type __int128 xmmword_12BEA50;
// 12DE10C: using guessed type int gdwRefreshMenuId;
// 12E5528: using guessed type __int64 gdSavedDivider;
// 12E5740: using guessed type __int16 gwProcessImageColumnWidth;
// 12E5B2C: using guessed type int gdwNumColumnsets;
// 12E96CD: using guessed type char gbShowLowerpane;
// 12E9B38: using guessed type int gdwToolbarBands[];
// 12E9B3C: using guessed type int gGraphReBarCtrlIds[];

//----- (01240E90) --------------------------------------------------------
int __stdcall SelectColumnForProcDLLPageWndProc(HWND hDlg, int a2, int a3, int a4)
{
  HWND v4; // edi
  HWND v5; // eax
  BOOL v6; // ST0C_4
  HWND v7; // eax
  BOOL v8; // ST0C_4
  HWND v9; // eax
  BOOL v10; // ST0C_4
  HWND v11; // eax
  signed int v12; // esi
  UINT (__stdcall *v14)(HWND, int); // eax
  signed int i; // esi
  WPARAM v16; // ecx
  unsigned int v17; // esi
  LPARAM lParam; // [esp+Ch] [ebp-ACh]
  char *v19; // [esp+18h] [ebp-A0h]
  int v20; // [esp+1Ch] [ebp-9Ch]
  int v21; // [esp+2Ch] [ebp-8Ch]
  HWND v22; // [esp+30h] [ebp-88h]
  char v23; // [esp+34h] [ebp-84h]

  v21 = a4;
  v4 = hDlg;
  v22 = hDlg;
  if ( a2 == 78 )
  {
    if ( *(a4 + 8) == -202 )
    {
      lParam = 7;
      v20 = 64;
      v19 = &v23;
      SendMessageW(ghWndDllsListCtrl, 0xBu, 0, 0);
      v14 = IsDlgButtonChecked;
      for ( i = 0; i < gdwDllsListColumnCount; ++i )
      {
        if ( v14(v4, gdwIdMapForDllsListColumn[i]) != 1 )
        {
          v16 = gdwDllsListColumnCount;
          if ( i < (gdwDllsListColumnCount - 1) )
          {
            do
            {
              SendMessageW(ghWndDllsListCtrl, 0x105Fu, i + 1, &lParam);
              SendMessageW(ghWndDllsListCtrl, 0x1060u, i, &lParam);
              gdwIdMapForDllsListColumn[i] = gdwIdMapForDllsListColumn[i + 1];
              ++i;
              v16 = gdwDllsListColumnCount;
            }
            while ( i < (gdwDllsListColumnCount - 1) );
            v4 = v22;
          }
          gdwDllsListColumnCount = v16 - 1;
          SendMessageW(ghWndDllsListCtrl, 0x101Cu, v16 - 1, 0);
          SetWindowLongW(ghWndDllsListCtrl, -21, gdwDllsListColumnCount);
          i = -1;
          *dword_12E9E60 = 1;
        }
        v14 = IsDlgButtonChecked;
      }
      v17 = 0;
      do
      {
        if ( v14(v4, dword_12DD7F8[v17]) )
          AutoLoadStringArrFromId(
            ghWndDllsListCtrl,
            dword_12DD7F8[v17],
            gdwIdMapForDllsListColumn,
            &gdwDllsListColumnCount);
        v14 = IsDlgButtonChecked;
        ++v17;
      }
      while ( v17 < 21 );
      SendMessageW(ghWndDllsListCtrl, 0xBu, 1u, 0);
      InvalidateRect(ghWndDllsListCtrl, 0, 1);
      return 1;
    }
    return 0;
  }
  if ( a2 != 272 )
    return 0;
  v5 = GetDlgItem(hDlg, 1190);
  EnableWindow(v5, 0);
  v6 = gdwOsType >= 1;
  v7 = GetDlgItem(v22, 1338);
  EnableWindow(v7, v6);
  v8 = gdwOsType >= 4;
  v9 = GetDlgItem(v22, IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD);
  EnableWindow(v9, v8);
  v10 = IsImmersiveProcess != 0;
  v11 = GetDlgItem(v22, 1654);
  EnableWindow(v11, v10);
  v12 = 0;
  for ( dword_12E9E60 = *(v21 + 28); v12 < gdwDllsListColumnCount; ++v12 )
    CheckDlgButton(v22, gdwIdMapForDllsListColumn[v12], 1u);
  return 1;
}
// 12E4E54: using guessed type int gdwOsType;
// 12E9E60: using guessed type int dword_12E9E60;
// 12FBA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);

//----- (01241110) --------------------------------------------------------
int __stdcall SelectColumnForProcHandlePageWndProc(HWND hDlg, int a2, int a3, int a4)
{
  HWND v4; // edi
  signed int v5; // esi
  UINT (__stdcall *v7)(HWND, int); // eax
  signed int i; // esi
  WPARAM v9; // ecx
  unsigned int v10; // esi
  signed int j; // eax
  signed int v12; // ST0C_4
  WPARAM v13; // ecx
  LVITEMW item; // [esp+Ch] [ebp-A8h]

  v4 = hDlg;
  item.lParam = hDlg;
  if ( a2 == 78 )
  {
    if ( *(a4 + 8) == -202 )
    {
      item.mask = 7;
      item.iItem = 0;
      item.stateMask = 64;
      item.state = &item.iIndent;
      SendMessageW(ghWndHandlesListCtrl, 0xBu, 0, 0);
      v7 = IsDlgButtonChecked;
      for ( i = 0; i < gdwHandlesListColumnCount; ++i )
      {
        if ( v7(v4, gdwHandlesListColumnMap[i]) != 1 )
        {
          v9 = gdwHandlesListColumnCount;
          if ( i < (gdwHandlesListColumnCount - 1) )
          {
            do
            {
              SendMessageW(ghWndHandlesListCtrl, 0x105Fu, i + 1, &item);
              SendMessageW(ghWndHandlesListCtrl, 0x1060u, i, &item);
              gdwHandlesListColumnMap[i] = gdwHandlesListColumnMap[i + 1];
              ++i;
              v9 = gdwHandlesListColumnCount;
            }
            while ( i < (gdwHandlesListColumnCount - 1) );
            v4 = item.lParam;
          }
          gdwHandlesListColumnCount = v9 - 1;
          SendMessageW(ghWndHandlesListCtrl, 0x101Cu, v9 - 1, 0);
          SetWindowLongW(ghWndHandlesListCtrl, -21, gdwHandlesListColumnCount);
          i = -1;
          *dword_12E9E64 = 1;
        }
        v7 = IsDlgButtonChecked;
      }
      v10 = 0;
      do
      {
        if ( v7(v4, dword_12DD7DC[v10]) )
        {
          for ( j = 0; j < gdwHandlesListColumnCount; ++j )
          {
            if ( gdwHandlesListColumnMap[j] == dword_12DD7DC[v10] )
              break;
          }
          if ( j == gdwHandlesListColumnCount )
          {
            item.pszText = gdwHandlesListColumnCount;
            item.iSubItem = MulDiv(100, gLogPixelsX, 96);
            LoadStringW(ghInstance, dword_12DD7DC[v10], &item.iIndent, 64);
            v12 = dword_12DD7DC[v10];
            gdwHandlesListColumnMap[gdwHandlesListColumnCount] = v12;
            item.iItem = IsColumnSortable(v12) != 0;
            v13 = gdwHandlesListColumnCount++;
            SendMessageW(ghWndHandlesListCtrl, LVM_INSERTCOLUMNW, v13, &item);
            SetWindowLongW(ghWndHandlesListCtrl, GWL_USERDATA, gdwHandlesListColumnCount);
            *dword_12E9E64 = 1;
          }
        }
        v7 = IsDlgButtonChecked;
        ++v10;
      }
      while ( v10 < 7 );
      SendMessageW(ghWndHandlesListCtrl, 0xBu, 1u, 0);
      InvalidateRect(ghWndHandlesListCtrl, 0, 1);
      return 1;
    }
    return 0;
  }
  if ( a2 != 272 )
    return 0;
  v5 = 0;
  for ( dword_12E9E64 = *(a4 + 28); v5 < gdwHandlesListColumnCount; ++v5 )
    CheckDlgButton(hDlg, gdwHandlesListColumnMap[v5], 1u);
  return 1;
}
// 12E9E64: using guessed type int dword_12E9E64;

//----- (012413D0) --------------------------------------------------------
int __stdcall SelectColumnForDotNetProcPageWndProc(HWND hDlg, int a2, int a3, int a4)
{
  HWND v4; // edi
  signed int v5; // esi
  signed int v7; // esi
  WPARAM v8; // ecx
  unsigned int idx; // esi
  signed int i; // eax
  signed int v11; // ST0C_4
  WPARAM v12; // ecx
  LVITEMW lParam; // [esp+Ch] [ebp-A8h]

  v4 = hDlg;
  lParam.lParam = hDlg;
  if ( a2 == 78 )
  {
    if ( *(a4 + 8) == -202 )
    {
      v7 = 0;
      lParam.mask = 7;
      lParam.iItem = 0;
      lParam.stateMask = 64;
      for ( lParam.state = &lParam.iIndent; v7 < gdwProcessListColumnCount; ++v7 )
      {
        if ( GetDlgItem(v4, gdwIDMapProcesListForSelectColumn[v7])
          && IsDlgButtonChecked(v4, gdwIDMapProcesListForSelectColumn[v7]) != 1 )
        {
          v8 = gdwProcessListColumnCount;
          if ( v7 < (gdwProcessListColumnCount - 1) )
          {
            do
            {
              SendMessageW(ghWndTreeListView, LVM_GETCOLUMNW, v7 + 1, &lParam);
              SendMessageW(ghWndTreeListView, 0x1060u, v7, &lParam);
              gdwIDMapProcesListForSelectColumn[v7] = gdwIDMapProcesListForSelectColumn[v7 + 1];
              ++v7;
              v8 = gdwProcessListColumnCount;
            }
            while ( v7 < (gdwProcessListColumnCount - 1) );
            v4 = lParam.lParam;
          }
          gdwProcessListColumnCount = v8 - 1;
          SendMessageW(ghWndTreeListView, LVM_DELETECOLUMN, v8 - 1, 0);
          SetWindowLongW(ghWndTreeListView, -21, gdwProcessListColumnCount);
          v7 = -1;
          *dword_12E9E6C = 1;
        }
      }
      idx = 0;
      do
      {
        if ( IsDlgButtonChecked(v4, dword_12DD798[idx]) )
        {
          for ( i = 0; i < gdwProcessListColumnCount; ++i )
          {
            if ( gdwIDMapProcesListForSelectColumn[i] == dword_12DD798[idx] )
              break;
          }
          if ( i == gdwProcessListColumnCount )
          {
            lParam.pszText = gdwProcessListColumnCount;
            lParam.iSubItem = MulDiv(100, gLogPixelsX, 96);
            LoadStringW(ghInstance, dword_12DD798[idx], &lParam.iIndent, 64);
            v11 = dword_12DD798[idx];
            gdwIDMapProcesListForSelectColumn[gdwProcessListColumnCount] = v11;
            lParam.iItem = IsColumnSortable(v11) != 0;
            v12 = gdwProcessListColumnCount++;
            SendMessageW(ghWndTreeListView, LVM_INSERTCOLUMNW, v12, &lParam);
            SetWindowLongW(ghWndTreeListView, GWL_USERDATA, gdwProcessListColumnCount);
            *dword_12E9E6C = 1;
          }
        }
        ++idx;
      }
      while ( idx < 17 );
      return 1;
    }
    return 0;
  }
  if ( a2 != 272 )
    return 0;
  v5 = 0;
  for ( dword_12E9E6C = *(a4 + 28); v5 < gdwProcessListColumnCount; ++v5 )
    CheckDlgButton(hDlg, gdwIDMapProcesListForSelectColumn[v5], 1u);
  return 1;
}
// 12E9E6C: using guessed type int dword_12E9E6C;

//----- (01241680) --------------------------------------------------------
int __stdcall SelectColumnForProcessImagePageWndProc(HWND hWnd, UINT message, WPARAM wParam, _PSHNOTIFY *lParam)
{
  HWND v4; // eax
  int v5; // ST0C_4
  HWND v6; // eax
  int v7; // ST0C_4
  HWND v8; // eax
  BOOL v9; // ST0C_4
  HWND v10; // eax
  BOOL v11; // ST0C_4
  HWND v12; // eax
  BOOL v13; // ST0C_4
  HWND v14; // eax
  BOOL v15; // ST0C_4
  HWND v16; // eax
  BOOL v17; // ST0C_4
  HWND v18; // eax
  BOOL v19; // ST0C_4
  HWND v20; // eax
  BOOL v21; // ST0C_4
  HWND v22; // eax
  BOOL v23; // ST0C_4
  HWND v24; // eax
  BOOL v25; // ST0C_4
  HWND v26; // eax
  BOOL v27; // ST0C_4
  HWND v28; // eax
  BOOL v29; // ST0C_4
  HWND v30; // eax
  BOOL v31; // ST0C_4
  HWND v32; // eax
  void (__stdcall *CheckDlgButton)(HWND, int, UINT); // eax
  signed int j; // esi
  HWND v35; // eax
  void (__stdcall *EnableWindow)(HWND, BOOL); // esi
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  HWND v43; // eax
  HWND v44; // eax
  HWND v45; // eax
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND (__stdcall *GetDlgItem)(HWND, int); // eax
  signed int i; // esi
  WPARAM v50; // ecx
  unsigned int idx; // esi
  LVCOLUMNW lParama; // [esp+Ch] [ebp-A4h]
  char szText[128]; // [esp+2Ch] [ebp-84h]

  if ( message == WM_NOTIFY )
  {
    if ( lParam->hdr.code == -202 )
    {
      SendMessageW = ::SendMessageW;
      // LVCF_FMT|LVCF_TEXT|LVCF_WIDTH
      lParama.mask = 7;
      lParama.fmt = 0;
      lParama.cchTextMax = 64;
      lParama.pszText = szText;
      ::SendMessageW(ghWndTreeListView, WM_SETREDRAW, 0, 0);
      GetDlgItem = ::GetDlgItem;
      for ( i = 0; i < gdwProcessListColumnCount; ++i )
      {
        if ( GetDlgItem(hWnd, gdwIDMapProcesListForSelectColumn[i])
          && IsDlgButtonChecked(hWnd, gdwIDMapProcesListForSelectColumn[i]) != BST_CHECKED )
        {
          v50 = gdwProcessListColumnCount;
          if ( i < (gdwProcessListColumnCount - 1) )
          {
            do
            {
              ::SendMessageW(ghWndTreeListView, LVM_GETCOLUMNW, i + 1, &lParama);
              ::SendMessageW(ghWndTreeListView, LVM_SETCOLUMNW, i, &lParama);
              gdwIDMapProcesListForSelectColumn[i] = gdwIDMapProcesListForSelectColumn[i + 1];
              ++i;
              v50 = gdwProcessListColumnCount;
            }
            while ( i < (gdwProcessListColumnCount - 1) );
            SendMessageW = ::SendMessageW;
          }
          gdwProcessListColumnCount = v50 - 1;
          SendMessageW(ghWndTreeListView, LVM_DELETECOLUMN, v50 - 1, 0);
          SetWindowLongW(ghWndTreeListView, GWL_USERDATA, gdwProcessListColumnCount);
          i = -1;
          *dword_12E9E68 = 1;
        }
        GetDlgItem = ::GetDlgItem;
      }
      idx = 0;
      do
      {
        if ( GetDlgItem(hWnd, gdwStringIDVectorForProcessIageOfSelectCoumn[idx])
          && IsDlgButtonChecked(hWnd, gdwStringIDVectorForProcessIageOfSelectCoumn[idx]) )
        {
          AutoLoadStringArrFromId(
            ghWndTreeListView,
            gdwStringIDVectorForProcessIageOfSelectCoumn[idx],
            gdwIDMapProcesListForSelectColumn,
            &gdwProcessListColumnCount);
        }
        GetDlgItem = ::GetDlgItem;
        ++idx;
      }
      while ( idx < 105 );
      SendMessageW(ghWndTreeListView, WM_SETREDRAW, 1u, 0);
      InvalidateRect(ghWndTreeListView, 0, 1);
      return 1;
    }
    return 0;
  }
  if ( message != WM_INITDIALOG )
    return 0;
  // WM_INITDIALOG
  dword_12E9E68 = lParam[1].lParam;
  v4 = ::GetDlgItem(hWnd, IDD_DLLCOLUMNS_CHECKBOX_IMAGE_TYPE);
  ::EnableWindow(v4, 0);
  v5 = gbWintrustInited;
  v6 = ::GetDlgItem(hWnd, IDD_DLLCOLUMNS_CHECKBOX_VERIFIED_SIGNER);
  ::EnableWindow(v6, v5);
  v7 = gbProcessDEPStatus;
  v8 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_DEP_STATUS);
  ::EnableWindow(v8, v7);
  v9 = gdwOsType >= 1;
  v10 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_VIRTUALIZED);
  ::EnableWindow(v10, v9);
  v11 = gdwOsType >= 1;
  v12 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_INTEGRITY_LEVEL);
  ::EnableWindow(v12, v11);
  v13 = gdwOsType >= 1;
  v14 = ::GetDlgItem(hWnd, IDS_DESKTOPINTEGRITYLEVEL);
  ::EnableWindow(v14, v13);
  v15 = gdwOsType >= 1;
  v16 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_ASLR_ENABLED);
  ::EnableWindow(v16, v15);
  v17 = gdwOsType >= 4;
  // -24779
  v18 = ::GetDlgItem(hWnd, IDD_SELECT_COLUMN_PAGE_PROCESS_IMAGE_CONTROL_FLOW_GUARD);
  ::EnableWindow(v18, v17);
  v19 = gdwOsType >= 1;
  v20 = ::GetDlgItem(hWnd, IDS_IOPRIORITY);
  ::EnableWindow(v20, v19);
  v21 = gdwOsType >= 1;
  v22 = ::GetDlgItem(hWnd, IDD_PROCMEMCOLUMNS_CHECKBOX_MEMORY_PRIORITY);
  ::EnableWindow(v22, v21);
  v23 = GetProcessDpiAwareness != 0;
  v24 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_DPI_AWARENESS);
  ::EnableWindow(v24, v23);
  v25 = gdwOsType >= 1;
  v26 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_UI_ACCESS);
  ::EnableWindow(v26, v25);
  v27 = gdwOsType >= 3;
  v28 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_PROTECTION);
  ::EnableWindow(v28, v27);
  v29 = GetProcessorSystemCycleTime != 0;
  v30 = ::GetDlgItem(hWnd, IDNO);
  ::EnableWindow(v30, v29);
  v31 = IsImmersiveProcess != 0;
  v32 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_PACKAGE_NAME);
  ::EnableWindow(v32, v31);
  CheckDlgButton = ::CheckDlgButton;
  for ( j = 0; j < gdwProcessListColumnCount; ++j )
  {
    CheckDlgButton(hWnd, gdwIDMapProcesListForSelectColumn[j], 1u);
    CheckDlgButton = ::CheckDlgButton;
  }
  CheckDlgButton(hWnd, IDABORT, 1u);
  if ( gbSessionValid )
  {
    EnableWindow = ::EnableWindow;
  }
  else
  {
    v35 = ::GetDlgItem(hWnd, IDD_PROCCOLUMNS_CHECKBOX_SESSION);
    EnableWindow = ::EnableWindow;
    ::EnableWindow(v35, 0);
  }
  if ( !QueryProcessCycleTime )
  {
    v37 = ::GetDlgItem(hWnd, IDD_PROCPERFCOLUMNS_CHECKBOX_CPU_CYCLES);
    EnableWindow(v37, 0);
    v38 = ::GetDlgItem(hWnd, IDD_PROCPERFCOLUMNS_CHECKBOX_CPU_CYCLES_DELTA);
    EnableWindow(v38, 0);
  }
  if ( !*GetGuiResources )
  {
    v39 = ::GetDlgItem(hWnd, IDD_PROCMEMCOLUMNS_CHECKBOX_USER_OBJECTS);
    EnableWindow(v39, 0);
    v40 = ::GetDlgItem(hWnd, IDD_PROCMEMCOLUMNS_CHECKBOX_GDI_OBJECTS);
    EnableWindow(v40, 0);
  }
  if ( !gdwAdapterRuntingTime )
  {
    v41 = ::GetDlgItem(hWnd, IDD_PROCGPUCOLUMNS_CHECKBOX_GPU_USAGE);
    EnableWindow(v41, 0);
  }
  if ( !*QueryWorkingSet )
  {
    v42 = ::GetDlgItem(hWnd, IDD_DLLCOLUMNS_CHECKBOX_WS_TOTAL_BYTES);
    EnableWindow(v42, 0);
    v43 = ::GetDlgItem(hWnd, IDD_DLLCOLUMNS_CHECKBOX_WS_PRIVATE_BYTES);
    EnableWindow(v43, 0);
    v44 = ::GetDlgItem(hWnd, IDD_DLLCOLUMNS_CHECKBOX_WS_SHAREABLE_BYTES);
    EnableWindow(v44, 0);
    v45 = ::GetDlgItem(hWnd, IDD_DLLCOLUMNS_CHECKBOX_WS_SHARED_BYTES);
    EnableWindow(v45, 0);
  }
  return 1;
}
// 128C644: using guessed type int (__stdcall *)(_DWORD, _DWORD);
// 12E4E54: using guessed type int gdwOsType;
// 12E9E68: using guessed type int dword_12E9E68;
// 12EA38A: using guessed type char gbSessionValid;
// 12EA390: using guessed type char gbProcessDEPStatus;
// 12EA391: using guessed type char gbWintrustInited;
// 12EF2E0: using guessed type int (__stdcall *QueryProcessCycleTime)(_DWORD, _DWORD);
// 12EF36C: using guessed type int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD);
// 12FBA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);

//----- (01241AF0) --------------------------------------------------------
int __cdecl sub_1241AF0(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx
  unsigned int v3; // edi
  unsigned int v5; // edx
  int v6; // esi
  bool v7; // zf
  bool v8; // sf
  unsigned __int8 v9; // of

  v2 = a1[157];
  v3 = a1[156];
  if ( !*(a1 + 78) )
  {
    if ( *(a2 + 78) )
      return -1;
    return a1[17] - a2[17];
  }
  v5 = a2[156];
  v6 = a2[157];
  if ( !*(a2 + 78) )
    return 1;
  if ( v5 == v3 )
  {
    v9 = __OFSUB__(v2, v6);
    v7 = v2 == v6;
    v8 = v2 - v6 < 0;
    if ( v2 == v6 )
      return a1[17] - a2[17];
  }
  else
  {
    v9 = __OFSUB__(v2, v6);
    v7 = v2 == v6;
    v8 = v2 - v6 < 0;
  }
  if ( !(v8 ^ v9) && (!((v8 ^ v9) | v7) || v3 > v5) )
    return 1;
  return -1;
}

//----- (01241B70) --------------------------------------------------------
signed int __cdecl OnTreeListNotify7D4(int a1, CTreeListItem *pTreeItem)
{
  CTreeListItem *pTreeListItem; // esi
  COLUMNTEXT *v3; // eax
  CComBSTR **v4; // edi
  CComBSTR *v5; // eax

  pTreeListItem = pTreeItem;
  if ( !IsFocusWindow(pTreeItem->m_hWnd) )
    return 1;
  if ( pTreeListItem->m_hWnd == ghWndTreeListView && !pTreeListItem->m_bInited )
  {
    if ( !(sbInited2 & 1) )
    {
      gppComBSTR = 0;
      sbInited2 |= 1u;
      atexit(sub_12AA970);
    }
    GetTreeListCtrl(pTreeListItem->m_hWnd);
    v3 = sub_121E5D0(pTreeListItem->field_10);
    v4 = sub_1236270(&pTreeItem, v3);
    if ( v4 != &gppComBSTR )
    {
      bstr_t::Data_t::Free(&gppComBSTR);
      v5 = *v4;
      gppComBSTR = v5;
      if ( v5 )
        InterlockedIncrement(&v5->Length);
    }
    bstr_t::Data_t::Free(&pTreeItem);
    if ( gppComBSTR )
    {
      *pTreeListItem->m_Text = gppComBSTR->bstr;
      return 1;
    }
    *pTreeListItem->m_Text = 0;
    return 1;
  }
  return 0;
}
// 12E9E54: using guessed type int sbInited2;

//----- (01241C50) --------------------------------------------------------
signed int __cdecl OnTreeListNotify7D5(int a1, int a2)
{
  HMONITOR v2; // eax
  struct tagPOINT Point; // [esp+8h] [ebp-54h]
  struct tagMONITORINFO mi; // [esp+10h] [ebp-4Ch]
  RECT pvParam; // [esp+38h] [ebp-24h]
  struct tagRECT Rect; // [esp+48h] [ebp-14h]

  GetCursorPos(&Point);
  if ( *MonitorFromPoint )
  {
    v2 = MonitorFromPoint(Point, 2u);
    if ( v2 )
    {
      mi.cbSize = 40;
      if ( GetMonitorInfoA(v2, &mi) )
        _mm_storeu_si128(&pvParam, _mm_loadu_si128(&mi.rcWork));
    }
  }
  else
  {
    SystemParametersInfoW(SPI_GETWORKAREA, 0, &pvParam, 0);
  }
  pvParam.right -= 10;
  pvParam.bottom -= 10;
  GetWindowRect(*a2, &Rect);
  if ( !*(a2 + 20) )
    OffsetRect(&Rect, Point.x - Rect.left + 17, 34);
  if ( Rect.right > pvParam.right )
    OffsetRect(&Rect, pvParam.right - Rect.right, 0);
  if ( Rect.bottom > pvParam.bottom )
    OffsetRect(&Rect, 0, pvParam.bottom - Rect.bottom);
  SetWindowPos(*a2, 0, Rect.left, Rect.top, 0, 0, 0x15u);
  return 1;
}

//----- (01241D40) --------------------------------------------------------
BOOL RedrawTreeList()
{
  return InvalidateRect(ghWndTreeListView, 0, 0);
}

//----- (01241D60) --------------------------------------------------------
int sub_1241D60(char *DstBuf, char *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vsprintf_s(DstBuf, 0x104u, Format, ArgList);
}

//----- (01241D80) --------------------------------------------------------
int sub_1241D80(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 3u, Format, ArgList);
}

//----- (01241DA0) --------------------------------------------------------
int *__thiscall sub_1241DA0(int *this, void *a2)
{
  int *v2; // esi

  v2 = this;
  this[5] = 7;
  this[4] = 0;
  *this = 0;
  if ( *a2 )
    sub_1229760(this, a2, wcslen(a2));
  else
    sub_1229760(this, a2, 0);
  return v2;
}

//----- (01241E00) --------------------------------------------------------
_DWORD *__thiscall sub_1241E00(void *this, void *a2)
{
  _DWORD *result; // eax

  if ( *a2 )
    result = sub_12431B0(this, a2, wcslen(a2));
  else
    result = sub_12431B0(this, a2, 0);
  return result;
}

//----- (01241E50) --------------------------------------------------------
HRESULT __cdecl sub_1241E50(char a1, OLECHAR *a2)
{
  HRESULT v2; // esi
  __m128i v3; // xmm0
  LPVOID v4; // ecx
  int v5; // edx
  CComBSTR *v6; // eax
  int *v7; // edx
  int v8; // eax
  OLECHAR *v9; // eax
  CComBSTR *v10; // edx
  int *v11; // edx
  int v12; // ecx
  int v13; // ecx
  int (__stdcall **v14)(int, int *, int *); // ecx
  CComBSTR *v15; // eax
  int *v16; // edx
  HANDLE v17; // eax
  OLECHAR *v18; // eax
  CComBSTR *v19; // edx
  int *v20; // edx
  int v21; // eax
  int v22; // ecx
  int (__stdcall **v23)(int, int *, int *); // ecx
  CComBSTR *v24; // eax
  int *v25; // edx
  int v26; // eax
  CComBSTR *v27; // edx
  int *v28; // edx
  int *v29; // edx
  BSTR v30; // ecx
  VARIANTARG *v31; // esi
  signed int v32; // ebx
  __m128i v33; // xmm0
  __m128i v34; // xmm0
  int *v35; // eax
  CComBSTR *v36; // edi
  BSTR v37; // edi
  __m128i v38; // xmm0
  int v39; // esi
  char v40; // al
  __m128i v41; // xmm0
  __m128i v42; // xmm0
  int v44; // [esp-40h] [ebp-548h]
  signed int v45; // [esp-3Ch] [ebp-544h]
  int v46; // [esp-38h] [ebp-540h]
  int v47; // [esp-34h] [ebp-53Ch]
  int v48; // [esp-30h] [ebp-538h]
  int v49; // [esp-2Ch] [ebp-534h]
  int v50; // [esp-28h] [ebp-530h]
  int v51; // [esp-24h] [ebp-52Ch]
  wchar_t *v52; // [esp-20h] [ebp-528h]
  rsize_t v53; // [esp-1Ch] [ebp-524h]
  WCHAR *v54; // [esp-18h] [ebp-520h]
  rsize_t v55; // [esp-14h] [ebp-51Ch]
  WCHAR *v56; // [esp-10h] [ebp-518h]
  LPVOID v57; // [esp-Ch] [ebp-514h]
  int *v58; // [esp-8h] [ebp-510h]
  int *v59; // [esp-4h] [ebp-50Ch]
  __int128 v60; // [esp+10h] [ebp-4F8h]
  __int128 v61; // [esp+20h] [ebp-4E8h]
  __int128 v62; // [esp+30h] [ebp-4D8h]
  VARIANTARG v63; // [esp+40h] [ebp-4C8h]
  VARIANTARG v64; // [esp+50h] [ebp-4B8h]
  VARIANTARG v65; // [esp+60h] [ebp-4A8h]
  VARIANTARG pvarg; // [esp+70h] [ebp-498h]
  int *v67; // [esp+80h] [ebp-488h]
  int (__stdcall ***v68)(int, int *, int *); // [esp+84h] [ebp-484h]
  int *v69; // [esp+88h] [ebp-480h]
  int (__stdcall ***v70)(int, int *, int *); // [esp+8Ch] [ebp-47Ch]
  int *v71; // [esp+90h] [ebp-478h]
  int *v72; // [esp+94h] [ebp-474h]
  int *v73; // [esp+98h] [ebp-470h]
  int *v74; // [esp+9Ch] [ebp-46Ch]
  CComBSTR *ppComBSTR; // [esp+A0h] [ebp-468h]
  CComBSTR *v76; // [esp+A4h] [ebp-464h]
  LPVOID ppv; // [esp+A8h] [ebp-460h]
  CComBSTR *v78; // [esp+ACh] [ebp-45Ch]
  int *v79; // [esp+B0h] [ebp-458h]
  int *v80; // [esp+B4h] [ebp-454h]
  OLECHAR *psz; // [esp+B8h] [ebp-450h]
  unsigned int v82; // [esp+CCh] [ebp-43Ch]
  OLECHAR *v83; // [esp+D0h] [ebp-438h]
  unsigned int v84; // [esp+E4h] [ebp-424h]
  WCHAR Buffer2[2]; // [esp+E8h] [ebp-420h]
  wchar_t Dst; // [esp+2F0h] [ebp-218h]
  int v87; // [esp+504h] [ebp-4h]

  v76 = a2;
  v78 = 0;
  sub_12426B0(&psz);
  v87 = 0;
  ppv = 0;
  v2 = CoCreateInstance(&CLSID_TaskScheduler, 0, 1u, &IID_ITaskService, &ppv);
  if ( v2 >= 0 )
  {
    VariantInit(&pvarg);
    _mm_storeu_si128(&v60, _mm_loadu_si128(&pvarg));
    VariantInit(&v65);
    _mm_storeu_si128(&v61, _mm_loadu_si128(&v65));
    VariantInit(&v64);
    _mm_storeu_si128(&v62, _mm_loadu_si128(&v64));
    VariantInit(&v63);
    v3 = _mm_loadu_si128(&v60);
    v4 = ppv;
    LOBYTE(v87) = 4;
    v5 = *ppv;
    _mm_storeu_si128(&v56, v3);
    _mm_storeu_si128(&v52, _mm_loadu_si128(&v61));
    _mm_storeu_si128(&v48, _mm_loadu_si128(&v62));
    _mm_storeu_si128(&v44, _mm_loadu_si128(&v63));
    v2 = (*(v5 + 40))(v4, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
    VariantClear(&v63);
    VariantClear(&v64);
    VariantClear(&v65);
    LOBYTE(v87) = 0;
    VariantClear(&pvarg);
    if ( v2 < 0 )
    {
      v59 = ppv;
      (*(*ppv + 8))(ppv);
      goto LABEL_64;
    }
    v79 = 0;
    v6 = *bstr_t::EqualAssign(&ppComBSTR, L"\\");
    LOBYTE(v87) = 5;
    if ( v6 )
      v7 = v6->bstr;
    else
      v7 = 0;
    v59 = &v79;
    v58 = v7;
    v57 = ppv;
    v8 = (*(*ppv + 28))(ppv, v7, &v79);
    LOBYTE(v87) = 0;
    v2 = v8;
    bstr_t::Data_t::Free(&ppComBSTR);
    if ( v2 < 0 )
    {
      v59 = ppv;
      (*(*ppv + 8))(ppv);
      goto LABEL_64;
    }
    v9 = &psz;
    if ( v82 >= 8 )
      v9 = psz;
    v10 = *bstr_t::EqualAssign(&ppComBSTR, v9);
    LOBYTE(v87) = 6;
    if ( v10 )
      v11 = v10->bstr;
    else
      v11 = 0;
    v59 = 0;
    v58 = v11;
    v57 = v79;
    (*(*v79 + 60))(v79, v11, 0);
    LOBYTE(v87) = 0;
    bstr_t::Data_t::Free(&ppComBSTR);
    if ( a1 )
    {
      v59 = &v80;
      v80 = 0;
      v58 = 0;
      v12 = *ppv;
      v57 = ppv;
      v2 = (*(v12 + 36))(ppv, 0, &v80);
      v59 = ppv;
      (*(*ppv + 8))(ppv);
      if ( v2 < 0 )
      {
        v59 = v79;
        (*(*v79 + 8))(v79);
        goto LABEL_64;
      }
      v69 = 0;
      v59 = &v69;
      v58 = v80;
      v2 = (*(*v80 + 28))(v80, &v69);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = L"Process Explorer";
      v58 = v69;
      v2 = (*(*v69 + 40))(v69, L"Process Explorer");
      v59 = v69;
      (*(*v69 + 8))(v69);
      if ( v2 < 0 )
        goto LABEL_69;
      v73 = 0;
      v59 = &v73;
      v58 = v80;
      v2 = (*(*v80 + 44))(v80, &v73);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = -1;
      v58 = v73;
      v2 = (*(*v73 + 88))(v73, -1);
      v59 = v73;
      (*(*v73 + 8))(v73);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = 0;
      v58 = v73;
      (*(*v73 + 72))(v73, 0);
      v67 = 0;
      v59 = &v67;
      v58 = v80;
      v2 = (*(*v80 + 36))(v80, &v67);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = &v70;
      v70 = 0;
      v58 = 9;
      v13 = *v67;
      v57 = v67;
      v2 = (*(v13 + 40))(v67, 9, &v70);
      v59 = v67;
      (*(*v67 + 8))(v67);
      if ( v2 < 0 )
        goto LABEL_69;
      v59 = &v72;
      v72 = 0;
      v58 = dword_12C776C;
      v14 = *v70;
      v57 = v70;
      v2 = (*v14)(v70, dword_12C776C, &v72);
      v59 = v70;
      ((*v70)[2])(v70);
      if ( v2 < 0 )
      {
LABEL_69:
        v59 = v79;
        (*(*v79 + 8))(v79);
        v59 = v80;
        (*(*v80 + 8))(v80);
        goto LABEL_64;
      }
      v15 = *bstr_t::EqualAssign(&v78, L"Logon Trigger");
      LOBYTE(v87) = 7;
      if ( v15 )
        v16 = v15->bstr;
      else
        v16 = 0;
      v59 = v16;
      v58 = v72;
      (*(*v72 + 36))(v72, v16);
      LOBYTE(v87) = 0;
      bstr_t::Data_t::Free(&v78);
      v59 = 0;
      v58 = 0;
      v57 = 0;
      v56 = 0;
      v55 = 260;
      v54 = Buffer2;
      v53 = 260;
      v52 = &Dst;
      v51 = 0;
      v50 = GetCurrentProcessId();
      v17 = GetCurrentProcess();
      QueryProcessUserInfo(v17, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      sub_1241DA0(&v83, Buffer2);
      LOBYTE(v87) = 8;
      sub_1241E00(&v83, L"\\");
      sub_1241E00(&v83, &Dst);
      v18 = &v83;
      if ( v84 >= 8 )
        v18 = v83;
      v19 = *bstr_t::EqualAssign(&v78, v18);
      LOBYTE(v87) = 9;
      if ( v19 )
        v20 = v19->bstr;
      else
        v20 = 0;
      v59 = v20;
      v58 = v72;
      v21 = (*(*v72 + 92))(v72, v20);
      LOBYTE(v87) = 8;
      v2 = v21;
      bstr_t::Data_t::Free(&v78);
      v59 = v72;
      (*(*v72 + 8))(v72);
      if ( v2 < 0 )
        goto LABEL_70;
      v71 = 0;
      v59 = &v71;
      v58 = v80;
      v2 = (*(*v80 + 68))(v80, &v71);
      if ( v2 < 0 )
        goto LABEL_70;
      v59 = &v68;
      v68 = 0;
      v58 = 0;
      v22 = *v71;
      v57 = v71;
      v2 = (*(v22 + 48))(v71, 0, &v68);
      v59 = v71;
      (*(*v71 + 8))(v71);
      if ( v2 < 0 )
        goto LABEL_70;
      v59 = &v74;
      v74 = 0;
      v58 = dword_12C781C;
      v23 = *v68;
      v57 = v68;
      v2 = (*v23)(v68, dword_12C781C, &v74);
      v59 = v68;
      ((*v68)[2])(v68);
      if ( v2 < 0 )
        goto LABEL_70;
      v24 = *bstr_t::EqualAssign(&v76, v76);
      LOBYTE(v87) = 10;
      v25 = (v24 ? v24->bstr : 0);
      v59 = v25;
      v58 = v74;
      v26 = (*(*v74 + 44))(v74, v25);
      LOBYTE(v87) = 8;
      v2 = v26;
      bstr_t::Data_t::Free(&v76);
      v27 = *bstr_t::EqualAssign(&v76, L"/t");
      LOBYTE(v87) = 11;
      v28 = (v27 ? v27->bstr : 0);
      v59 = v28;
      v58 = v74;
      (*(*v74 + 52))(v74, v28);
      LOBYTE(v87) = 8;
      bstr_t::Data_t::Free(&v76);
      v59 = v74;
      (*(*v74 + 8))(v74);
      if ( v2 < 0 )
        goto LABEL_70;
      if ( IsBuiltinAndAnministrative() )
      {
        v78 = 0;
        v59 = &v78;
        v58 = v80;
        (*(*v80 + 60))(v80, &v78);
        v29 = &v83;
        if ( v84 >= 8 )
          v29 = v83;
        v30 = v78->bstr;
        v59 = v29;
        v58 = v78;
        (*(v30 + 12))(v78, v29);
        v59 = 1;
        v58 = v78;
        (*(v78->bstr + 18))(v78, 1);
        v59 = v78;
        (*(v78->bstr + 2))(v78);
      }
      ppComBSTR = 0;
      if ( IsBuiltinAndAnministrative() )
      {
        v31 = sub_12193D0(&v63, L"Builtin\\Administrators");
        LOBYTE(v87) = 12;
        v32 = 1;
      }
      else
      {
        VariantInit(&v65);
        v31 = &v65;
        v87 = 13;
        v32 = 2;
      }
      v78 = v32;
      v33 = _mm_loadu_si128(sub_12193D0(&v64, gpszTargetName));
      v87 = 14;
      v59 = &pvarg;
      _mm_storeu_si128(&v62, v33);
      VariantInit(v59);
      v34 = _mm_loadu_si128(&pvarg);
      v35 = &psz;
      LOBYTE(v87) = 15;
      if ( v82 >= 8 )
        v35 = psz;
      _mm_storeu_si128(&v61, v34);
      v59 = v35;
      _mm_storeu_si128(&v60, _mm_loadu_si128(v31));
      v36 = *bstr_t::EqualAssign(&v76, v59);
      LOBYTE(v87) = 16;
      if ( v36 )
        v37 = v36->bstr;
      else
        v37 = 0;
      v38 = _mm_loadu_si128(&v62);
      v39 = *v79;
      v59 = &ppComBSTR;
      _mm_storeu_si128(&v55, v38);
      v40 = IsBuiltinAndAnministrative();
      v41 = _mm_loadu_si128(&v61);
      v54 = ((v40 != 0) + 3);
      _mm_storeu_si128(&v50, v41);
      v42 = _mm_loadu_si128(&v60);
      v45 = 6;
      v44 = v80;
      _mm_storeu_si128(&v46, v42);
      v2 = (*(v39 + 68))(v79, v37, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      bstr_t::Data_t::Free(&v76);
      VariantClear(&pvarg);
      VariantClear(&v64);
      if ( v32 & 2 )
      {
        LOBYTE(v32) = v32 & 0xFD;
        VariantClear(&v65);
      }
      v87 = 8;
      if ( v32 & 1 )
        VariantClear(&v63);
      if ( v2 < 0 )
      {
LABEL_70:
        v59 = v79;
        (*(*v79 + 8))(v79);
        v59 = v80;
        (*(*v80 + 8))(v80);
        sub_11F3820(&v83);
        goto LABEL_64;
      }
      v59 = v80;
      (*(*v80 + 8))(v80);
      v59 = ppComBSTR;
      (*(ppComBSTR->bstr + 2))(ppComBSTR);
      LOBYTE(v87) = 0;
      sub_11F3820(&v83);
    }
    v59 = v79;
    (*(*v79 + 8))(v79);
    v2 = 0;
  }
LABEL_64:
  if ( v82 >= 8 )
    j__free(psz);
  return v2;
}
// 12C776C: using guessed type int dword_12C776C[44];
// 12C781C: using guessed type int dword_12C781C[8];

//----- (012426B0) --------------------------------------------------------
void *__cdecl sub_12426B0(void *a1)
{
  int dwPid; // ST04_4
  HANDLE ProcessHandle; // eax
  int v3; // ecx
  int v4; // ecx
  void *List; // [esp+10h] [ebp-438h]
  int v7; // [esp+20h] [ebp-428h]
  unsigned int v8; // [esp+24h] [ebp-424h]
  WCHAR Buffer2[260]; // [esp+28h] [ebp-420h]
  wchar_t Buffer1[260]; // [esp+230h] [ebp-218h]
  int v11; // [esp+444h] [ebp-4h]

  v11 = 0;
  dwPid = GetCurrentProcessId();
  ProcessHandle = GetCurrentProcess();
  QueryProcessUserInfo(ProcessHandle, dwPid, 0, Buffer1, _MAX_PATH, Buffer2, _MAX_PATH, 0, 0, 0, 0);
  v8 = 7;
  v7 = 0;
  LOWORD(List) = 0;
  if ( Buffer2[0] )
    v3 = wcslen(Buffer2);
  else
    v3 = 0;
  sub_1229760(&List, Buffer2, v3);
  v11 = 1;
  sub_12431B0(&List, L"-", 1);
  if ( Buffer1[0] )
    v4 = wcslen(Buffer1);
  else
    v4 = 0;
  sub_12431B0(&List, Buffer1, v4);
  *(a1 + 5) = 7;
  *(a1 + 4) = 0;
  *a1 = 0;
  sub_1229760(a1, L"Process Explorer-", 17);
  sub_12430E0(a1, &List, 0, -1);
  if ( v8 >= 8 )
    j__free(List);
  return a1;
}
// 12BF134: using guessed type wchar_t asc_12BF134[2];
// 12BF138: using guessed type wchar_t aProcessExplore_3[18];

//----- (01242850) --------------------------------------------------------
errno_t __cdecl FillDebuggerInfo(wchar_t *Dst, rsize_t SizeInWords)
{
  DWORD nLength; // [esp+Ch] [ebp-420h]
  WCHAR RemoteName; // [esp+10h] [ebp-41Ch]
  WCHAR LocalName; // [esp+420h] [ebp-Ch]

  GetModuleFileNameW(0, Dst + 1, SizeInWords - 2);
  sub_1241D80(&LocalName, L"%c:", Dst[1]);
  nLength = 520;
  if ( !WNetGetConnectionW(&LocalName, &RemoteName, &nLength) )
  {
    wcscat_s(&RemoteName, 0x208u, Dst + 2);
    tcscpy_s(Dst + 1, SizeInWords - 1, &RemoteName);
  }
  *Dst = 34;
  wcscat_s(Dst, SizeInWords, L"\"");
  return _wcsupr_s(Dst, SizeInWords);
}

//----- (01242910) --------------------------------------------------------
char __cdecl sub_1242910(int a1, int a2, int a3, wchar_t *Dst, rsize_t SizeInWords)
{
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  unsigned int v8; // esi
  bool v9; // cf
  const wchar_t **v10; // eax
  int v12; // [esp+Ch] [ebp-4h]

  v5 = dword_12E9E78;
  if ( !dword_12E9E78 )
    return 0;
  while ( 1 )
  {
    if ( a1 && a1 != 1 || *v5 && *v5 != 1 )
    {
      if ( (a1 == 2 || a1 == 3) && (*v5 == 2 || *v5 == 3) )
      {
        v6 = a3;
        v7 = (v5 + 272);
        v8 = 12;
        while ( *v7 == *v6 )
        {
          ++v7;
          ++v6;
          v9 = v8 < 4;
          v8 -= 4;
          if ( v9 )
            goto LABEL_13;
        }
      }
      goto LABEL_17;
    }
    if ( *(v5 + 268) == a2 )
      break;
LABEL_17:
    v5 = *(v5 + 288);
    if ( !v5 )
      return 0;
  }
LABEL_13:
  v10 = CString::LoadString((v5 + 4));
  tcscpy_s(Dst, SizeInWords, *v10);
  if ( _InterlockedDecrement((v12 - 16 + 12)) <= 0 )
    (*(**(v12 - 16) + 4))(v12 - 16);
  return 1;
}
// 12E9E78: using guessed type int dword_12E9E78;

//----- (012429E0) --------------------------------------------------------
WCHAR *__cdecl CReg::ReadEnvString(HKEY hKey, LPCWSTR lpValueName)
{
  WCHAR *v2; // esi
  WCHAR *pszEnvString; // ebx
  DWORD v4; // edi
  DWORD cbData; // [esp+8h] [ebp-4h]

  v2 = 0;
  cbData = 0;
  if ( !RegQueryValueExW(hKey, lpValueName, 0, 0, 0, &cbData) )
  {
    pszEnvString = malloc(cbData);
    if ( !RegQueryValueExW(hKey, lpValueName, 0, 0, pszEnvString, &cbData) )
    {
      v4 = ExpandEnvironmentStringsW(pszEnvString, 0, 0);
      cbData = v4;
      if ( v4 )
      {
        v2 = malloc(2 * v4);
        ExpandEnvironmentStringsW(pszEnvString, v2, v4);
      }
    }
    free(pszEnvString);
  }
  return v2;
}

//----- (01242A70) --------------------------------------------------------
void __cdecl sub_1242A70(const __m128i *a1)
{
  struct hostent *v1; // eax
  void (__stdcall *v2)(LPCRITICAL_SECTION); // edi
  const __m128i *v3; // ebx
  int v4; // ST24_4
  int v5; // ST20_4
  int v6; // ST1C_4
  int v7; // ST18_4
  int v8; // ST14_4
  int v9; // ST10_4
  int v10; // ST0C_4
  u_short v11; // ax
  struct hostent *v12; // eax
  __m128i *v13; // esi
  _DWORD *v14; // eax
  char Dst; // [esp+10h] [ebp-108h]

  EnterCriticalSection(&gLock3);
  if ( a1->m128i_i32[0] && a1->m128i_i32[0] != 1 )
  {
    v1 = gethostbyaddr(a1[17].m128i_i8, 16, 23);
    if ( v1 )
    {
      strcpy_s(&Dst, 0x104u, v1->h_name);
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
    }
    else
    {
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
      v4 = htons(a1[17].m128i_u16[7]);
      v5 = htons(a1[17].m128i_u16[6]);
      v6 = htons(a1[17].m128i_u16[5]);
      v7 = htons(a1[17].m128i_u16[4]);
      v8 = htons(a1[17].m128i_u16[3]);
      v9 = htons(a1[17].m128i_u16[2]);
      v10 = htons(a1[17].m128i_u16[1]);
      v11 = htons(a1[17].m128i_u16[0]);
      sub_1241D60(&Dst, "[%x:%x:%x:%x:%x:%x:%x:%x]", v11, v10, v9, v8, v7, v6, v5, v4);
    }
    v3 = a1;
  }
  else
  {
    v3 = htonl(a1[16].m128i_u32[2]);
    v12 = gethostbyaddr(&a1[16].m128i_i8[8], 4, 2);
    if ( v12 )
    {
      strcpy_s(&Dst, 0x104u, v12->h_name);
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
    }
    else
    {
      v2 = LeaveCriticalSection;
      LeaveCriticalSection(&gLock3);
      sub_1241D60(&Dst, "%d.%d.%d.%d", v3 >> 24, (v3 >> 16) & 0xFF, v3 >> 8, v3);
    }
  }
  _strlwr_s(&Dst, 0x104u);
  EnterCriticalSection(&gLock2);
  v13 = malloc(0x124u);
  strcpy_s(&v13->m128i_i32[1], 0x104u, &Dst);
  v13[16].m128i_i32[3] = v3;
  _mm_storeu_si128(v13 + 17, _mm_loadu_si128(a1 + 17));
  v13->m128i_i32[0] = a1->m128i_i32[0];
  v13[18].m128i_i32[0] = dword_12E9E78;
  v14 = dword_12E9E7C;
  dword_12E9E78 = v13;
  if ( dword_12E9E7C )
  {
    while ( v14[67] != v3 )
    {
      v14 = v14[72];
      if ( !v14 )
        goto LABEL_15;
    }
    dword_12E9E7C = v14[72];
    free(v14);
  }
LABEL_15:
  SetEvent(ghEvent6);
  v2(&gLock2);
}
// 12E9E78: using guessed type int dword_12E9E78;

//----- (01242CD0) --------------------------------------------------------
char __cdecl GetStringFromMemory(HWND hList, unsigned int dwSize, PUCHAR pBuffer, unsigned int dwLength)
{
  PUCHAR pbuffer; // ebx
  volatile signed __int32 *bPrintable; // eax
  unsigned int dwLen; // ecx
  unsigned int nSize; // edx
  unsigned int iCharStart; // esi
  unsigned int iChar; // edi
  unsigned int chBuffer; // ebx
  signed int v11; // edx
  int v12; // ecx
  int nString; // ebx
  CString *v14; // eax
  int bAlphaChar; // eax
  __int16 chString; // ax
  UINT nTextLen; // ebx
  UINT v18; // esi
  UINT v19; // edi
  int v20; // ecx
  UINT v21; // ebx
  unsigned int v22; // edx
  UINT v23; // eax
  CStringData *strData; // edx
  LVITEMW item; // [esp+4h] [ebp-30050h]
  UINT v27; // [esp+38h] [ebp-3001Ch]
  char *v28; // [esp+3Ch] [ebp-30018h]
  HWND hWnd; // [esp+40h] [ebp-30014h]
  CString *str; // [esp+44h] [ebp-30010h]
  int v31; // [esp+48h] [ebp-3000Ch]
  PUCHAR pBuf; // [esp+4Ch] [ebp-30008h]
  char szTextA[65536]; // [esp+50h] [ebp-30004h]
  TCHAR szText[65536]; // [esp+10050h] [ebp-20004h]

  pbuffer = pBuffer;
  hWnd = hList;
  pBuf = pBuffer;
  item.mask = 0;
  LOBYTE(bPrintable) = memset(&item.iItem, 0, 0x30u);
  dwLen = dwLength;
  nSize = dwSize;
  if ( dwLength >= dwSize )
  {
    iCharStart = -1;
    iChar = 0;
    if ( dwLength )
    {
      while ( 1 )
      {
        chBuffer = *&pbuffer[iChar];
        bPrintable = _ismbcprint(chBuffer);
        if ( !bPrintable && chBuffer != '~' )
        {
          if ( iCharStart != -1 )
          {
            v11 = dwSize;
            LOBYTE(bPrintable) = 2 * dwSize;
            if ( iChar - iCharStart >= 2 * dwSize )
            {
              v12 = 0;
              nString = 0;
              v31 = 0;
              if ( iCharStart < iChar )
              {
                v14 = (dwLength - dwSize + 1);
                str = (dwLength - dwSize + 1);
                do
                {
                  if ( iCharStart >= v14 )
                    break;
                  bAlphaChar = iswalpha(pBuf[iCharStart]);
                  v12 = v31;
                  if ( bAlphaChar )
                    v12 = v31++ + 1;
                  chString = pBuf[iCharStart];
                  iCharStart += 2;
                  *&szText[2 * nString++] = chString;
                  v14 = str;
                }
                while ( iCharStart < iChar );
                v11 = dwSize;
              }
              nTextLen = 2 * nString;
              if ( nTextLen >= 0x20000 )
              {
LABEL_51:
                __report_rangecheckfailure();
                JUMPOUT(*algn_1242FF0);
              }
              LOBYTE(bPrintable) = 0;
              *&szText[nTextLen] = 0;
              if ( v12 >= v11 )
              {
                szTextA[1024] = 0;
                item.pszText = szText;
                item.mask = 5;
                item.iItem = 0x7FFFFFFF;
                item.lParam = 1;
                LOBYTE(bPrintable) = SendMessageW(hWnd, LVM_INSERTITEMW, 0, &item);
              }
            }
            iCharStart = -1;
          }
          goto __nextchar;
        }
        if ( chBuffer == ' ' )
        {
          if ( iCharStart == -1 )
            goto __nextchar;
        }
        else if ( iCharStart == -1 )
        {
          iCharStart = iChar;
        }
        ++iChar;
__nextchar:
        dwLen = dwLength;
        ++iChar;
        pbuffer = pBuf;
        if ( iChar >= dwLength )
        {
          nSize = dwSize;
          break;
        }
      }
    }
    v18 = -1;
    v19 = 0;
    if ( dwLen )
    {
      do
      {
        LOBYTE(bPrintable) = pbuffer[v19];
        if ( (bPrintable < ' ' || bPrintable >= '~') && bPrintable != '~' )
        {
          if ( v18 != -1 )
          {
            LOBYTE(bPrintable) = v19 - v18;
            if ( v19 - v18 >= nSize )
            {
              v20 = 0;
              v21 = 0;
              v31 = 0;
              if ( v18 < v19 )
              {
                v22 = dwLength - nSize + 1;
                v27 = v22;
                bPrintable = &szTextA[-v18];
                v28 = &szTextA[-v18];
                do
                {
                  if ( v18 >= v22 )
                    break;
                  v23 = isalpha(pBuf[v18]);
                  v20 = v31;
                  if ( v23 )
                    v20 = v31++ + 1;
                  ++v21;
                  LOBYTE(bPrintable) = pBuf[v18];
                  v28[v18++] = bPrintable;
                  v22 = v27;
                }
                while ( v18 < v19 );
                if ( v21 >= 0x10000 )
                  goto LABEL_51;
                nSize = dwSize;
              }
              szTextA[v21] = 0;
              if ( v20 >= nSize )
              {
                CString::LoadString(szTextA);
                item.pszText = str;
                item.mask = 5;
                item.iItem = 0x7FFFFFFF;
                szTextA[1024] = 0;
                item.lParam = 1;
                SendMessageW(hWnd, LVM_INSERTITEMW, 0, &item);
                strData = &str[-4];
                bPrintable = &str[-1];
                if ( _InterlockedDecrement(bPrintable) <= 0 )
                  LOBYTE(bPrintable) = (strData->pStringMgr->vtptr->Free)(strData);
                nSize = dwSize;
              }
              pbuffer = pBuf;
              dwLen = dwLength;
            }
            v18 = -1;
          }
        }
        else if ( bPrintable != ' ' && v18 == -1 )
        {
          v18 = v19;
        }
        ++v19;
      }
      while ( v19 < dwLen );
    }
  }
  return bPrintable;
}
// 12867E8: using guessed type int __report_rangecheckfailure(void);

//----- (01243000) --------------------------------------------------------
// 通过注册表检测是否为Terminal Server版本
int __cdecl IsTerminalServer(LPCWSTR szProduction)
{
  signed int ret; // ebx
  BYTE *pBuffer; // eax
  BYTE *pBuff; // edi
  const WCHAR *pBuf; // esi
  DWORD dwType; // [esp+4h] [ebp-Ch]
  DWORD cbData; // [esp+8h] [ebp-8h]
  HKEY hKey; // [esp+Ch] [ebp-4h]

  ret = NULL;
  hKey = NULL;
  dwType = NULL;
  cbData = NULL;
  // 本机值为 Terminal Server
  if ( !RegOpenKeyW(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\ProductOptions", &hKey)
    && !RegQueryValueExW(hKey, L"ProductSuite", NULL, &dwType, NULL, &cbData) )
  {
    if ( cbData )
    {
      pBuffer = LocalAlloc(0x40u, cbData);
      pBuff = pBuffer;
      if ( pBuffer )
      {
        if ( !RegQueryValueExW(hKey, L"ProductSuite", NULL, &dwType, pBuffer, &cbData) && dwType == REG_MULTI_SZ )
        {
          pBuf = pBuff;
          if ( *pBuff )
          {
            while ( lstrcmpW(pBuf, szProduction) )
            {
              pBuf += lstrlenW(pBuf) + 1;
              if ( !*pBuf )
                goto __exit;
            }
            ret = 1;
          }
        }
__exit:
        LocalFree(pBuff);
      }
    }
  }
  if ( hKey )
    RegCloseKey(hKey);
  return ret;
}

//----- (012430E0) --------------------------------------------------------
_DWORD *__thiscall sub_12430E0(void *this, int a2, int a3, int a4)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  int v9; // ecx
  _DWORD *v10; // ecx
  int v11; // ecx
  bool v12; // cf
  int v14; // [esp+14h] [ebp+8h]

  v4 = a2;
  v5 = this;
  v6 = *(a2 + 16);
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = a4;
  v8 = v6 - a3;
  v9 = *(this + 4);
  v14 = v5[4];
  if ( v8 < a4 )
    v7 = v8;
  if ( -1 - v9 <= v7 )
    std::_Xlength_error("string too long");
  if ( v7 && sub_11FFC40(v5, v9 + v7, 0) )
  {
    if ( v4[5] >= 8u )
      v4 = *v4;
    if ( v5[5] < 8u )
      v10 = v5;
    else
      v10 = *v5;
    if ( v7 )
      memmove_0(v10 + 2 * v5[4], v4 + 2 * a3, 2 * v7);
    v11 = v7 + v14;
    v12 = v5[5] < 8u;
    v5[4] = v7 + v14;
    if ( !v12 )
    {
      *(*v5 + 2 * v11) = 0;
      return v5;
    }
    *(v5 + v11) = 0;
  }
  return v5;
}

//----- (012431B0) --------------------------------------------------------
_DWORD *__thiscall sub_12431B0(void *this, void *a2, int a3)
{
  void *v3; // edi
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  _DWORD *result; // eax
  char *v10; // ecx
  _DWORD *v11; // ecx
  int v12; // ecx
  bool v13; // cf
  char *v14; // [esp+10h] [ebp+8h]

  v3 = a2;
  v4 = this;
  if ( a2
    && ((v5 = *(this + 5), v5 < 8) ? (v6 = v4) : (v6 = *v4),
        a2 >= v6 && (v5 < 8 ? (v7 = v4) : (v7 = *v4), v7 + 2 * v4[4] > a2)) )
  {
    if ( v5 < 8 )
      v8 = v4;
    else
      v8 = *v4;
    result = sub_12430E0(v4, v4, (a2 - v8) >> 1, a3);
  }
  else
  {
    v10 = v4[4];
    v14 = v10;
    if ( -1 - v10 <= a3 )
      std::_Xlength_error("string too long");
    if ( a3 && sub_11FFC40(v4, &v10[a3], 0) )
    {
      if ( v4[5] < 8u )
        v11 = v4;
      else
        v11 = *v4;
      if ( a3 )
        memmove_0(v11 + 2 * v4[4], v3, 2 * a3);
      v12 = &v14[a3];
      v13 = v4[5] < 8u;
      v4[4] = &v14[a3];
      if ( !v13 )
      {
        *(*v4 + 2 * v12) = 0;
        return v4;
      }
      *(v4 + v12) = 0;
    }
    result = v4;
  }
  return result;
}

//----- (01243290) --------------------------------------------------------
LPCWSTR __cdecl GetNumberTextFormat(LPCWSTR lpszText, rsize_t SizeInWords)
{
  wchar_t *psz; // eax
  __int16 szFormat[1024]; // [esp+4h] [ebp-804h]

  GetNumberFormatW(LANG_USER_DEFAULT, 0, lpszText, 0, szFormat, 1024);
  tcscpy_s(lpszText, SizeInWords, szFormat);
  psz = wcsstr(lpszText, &gszLocaleInfo);
  if ( psz )
    *psz = 0;
  return lpszText;
}

//----- (01243300) --------------------------------------------------------
void __cdecl sub_1243300(wchar_t *a1)
{
  int v1; // edi
  int v2; // esi
  int v3; // edx
  WCHAR v4; // ax
  WCHAR v5; // cx
  wchar_t *v6; // esi
  wchar_t v7; // ax
  size_t v8; // esi
  wchar_t *v9; // edi
  wchar_t *v10; // ecx
  wchar_t v11; // ax
  DWORD cbData; // [esp+8h] [ebp-618h]
  WCHAR ValueName[2]; // [esp+Ch] [ebp-614h]
  HKEY phkResult; // [esp+10h] [ebp-610h]
  wchar_t v15[260]; // [esp+14h] [ebp-60Ch]
  BYTE v16[2]; // [esp+21Ch] [ebp-404h]
  wchar_t Dst; // [esp+21Eh] [ebp-402h]
  __int16 v18; // [esp+250h] [ebp-3D0h]
  BYTE Data[2]; // [esp+41Ch] [ebp-204h]
  char v20; // [esp+41Eh] [ebp-202h]
  WCHAR v21; // [esp+44Eh] [ebp-1D2h]

  *Data = 0;
  memset(&v20, 0, 0x1FEu);
  *v16 = 0;
  memset(&Dst, 0, 0x1FEu);
  *ValueName = 65;
  v1 = 0;
  if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU", &phkResult) )
  {
    cbData = 512;
    RegQueryValueExW(phkResult, L"MRUList", 0, 0, Data, &cbData);
    _wcslwr_s(Data, 0x100u);
    v2 = 0;
    if ( wcslen(Data) <= 0 )
    {
LABEL_8:
      tcscpy_s(&Dst, 0xFFu, Data);
      v18 = 0;
      v3 = 0;
      while ( (1 << v3) & v1 )
      {
        if ( ++v3 >= 26 )
        {
          v4 = *v16;
          goto LABEL_14;
        }
      }
      v4 = v3 + 97;
LABEL_14:
      v5 = v4;
      v6 = a1;
      if ( v3 == 26 )
        v5 = v21;
      *v16 = v5;
      ValueName[0] = v5;
      do
      {
        v7 = *v6;
        ++v6;
      }
      while ( v7 );
      v8 = v6 - (a1 + 1) + 3;
      v9 = malloc(2 * v8);
      swprintf_s(v9, v8, L"%s\\1", a1);
      v10 = v9;
      do
      {
        v11 = *v10;
        ++v10;
      }
      while ( v11 );
      RegSetValueEx(phkResult, ValueName, 0, 1u, v9, 2 * (v10 - (v9 + 1)) + 2);
      RegSetValueEx(phkResult, L"MRUList", 0, 1u, v16, 2 * wcslen(v16) + 2);
      RegCloseKey(phkResult);
      free(v9);
    }
    else
    {
      while ( 1 )
      {
        ValueName[0] = *&Data[2 * v2];
        cbData = 520;
        v1 |= 122 - ValueName[0] > 1;
        if ( !RegQueryValueExW(phkResult, ValueName, 0, 0, v15, &cbData) )
        {
          if ( wcsrchr(v15, 0x5Cu) )
            *wcsrchr(v15, 0x5Cu) = 0;
          if ( !_wcsicmp(a1, v15) )
            break;
        }
        if ( ++v2 >= wcslen(Data) )
          goto LABEL_8;
      }
      RegCloseKey(phkResult);
    }
  }
}

//----- (012435F0) --------------------------------------------------------
BOOL __cdecl UpdateSysIconInMenu(HMENU hMenu, UINT item)
{
  HICON hIcon; // esi
  MENUITEMINFOW mii; // [esp+8h] [ebp-24Ch]
  _SHSTOCKICONINFO StockIconInfo; // [esp+38h] [ebp-21Ch]

  hIcon = ghShieldIcon;
  if ( !ghShieldIcon )
  {
    memset(&StockIconInfo.hIcon, ghShieldIcon, 0x214u);
    StockIconInfo.cbSize = 536;
    SHGetStockIconInfo(SIID_SHIELD, 0x101, &StockIconInfo);// SIID_SHIELD
    hIcon = StockIconInfo.hIcon;
    ghShieldIcon = StockIconInfo.hIcon;
  }
  memset(&mii.fMask, 0, 0x2Cu);
  mii.cbSize = 48;
  mii.fMask = 0xA0;
  mii.hbmpItem = -1;
  mii.dwItemData = hIcon;
  return SetMenuItemInfoW(hMenu, item, 0, &mii);
}
// 12FBA50: using guessed type int (__stdcall *SHGetStockIconInfo)(_DWORD, _DWORD, _DWORD);

//----- (012436B0) --------------------------------------------------------
bool __cdecl sub_12436B0(int a1, unsigned int a2, char a3, char a4)
{
  unsigned int v4; // esi
  _DWORD *v5; // edx

  v4 = 0;
  if ( !a2 )
    return 0;
  v5 = (a1 + 4);
  while ( *v5 != 1 && *v5 || !((1 << a3) & *(v5 - 1)) )
  {
    ++v4;
    v5 += 6;
    if ( v4 >= a2 )
      return 0;
  }
  return ((1 << a4) & *(a1 + 24 * v4)) != 0;
}

//----- (01243710) --------------------------------------------------------
HWND __cdecl ResizeTab(HWND hWnd)
{
  HWND hParent; // eax
  HWND hWndTab; // eax
  HWND hTabCtrl; // edi
  struct tagRECT Rect; // [esp+8h] [ebp-14h]

  hParent = GetParent(hWnd);
  hWndTab = GetDlgItem(hParent, IDD_PROCPROPSHEET_CTRL_TABCTRL);
  hTabCtrl = hWndTab;
  if ( hWndTab )
  {
    GetWindowRect(hWndTab, &Rect);
    SendMessageW(hTabCtrl, TCM_ADJUSTRECT, 0, &Rect);
    MapWindowPoints(0, hWnd, &Rect, 2u);
    SetWindowPos(hWnd, 0, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 0x10u);
    hWndTab = EnableThemeDialogTexture;
    if ( EnableThemeDialogTexture )
      hWndTab = EnableThemeDialogTexture(hWnd, 6);
  }
  return hWndTab;
}
// 12E9E88: using guessed type int (__stdcall *EnableThemeDialogTexture)(_DWORD, _DWORD);

//----- (012437B0) --------------------------------------------------------
signed int __cdecl sub_12437B0(unsigned __int64 a1, unsigned __int64 a2)
{
  signed int result; // eax

  if ( HIDWORD(a1) < HIDWORD(a2) )
    goto LABEL_10;
  if ( HIDWORD(a1) > HIDWORD(a2) || a1 > a2 )
    return 1;
  if ( a1 >= a2 )
    result = 0;
  else
LABEL_10:
    result = -1;
  return result;
}

//----- (012437F0) --------------------------------------------------------
BOOL __cdecl sub_12437F0(char a1)
{
  DWORD v1; // esi
  HKEY phkResult; // [esp+4h] [ebp-418h]
  BYTE Data[2]; // [esp+8h] [ebp-414h]
  char v5; // [esp+Ah] [ebp-412h]

  *Data = 0;
  memset(&v5, 0, 0x40Eu);
  FillDebuggerInfo(Data, 0x208u);
  if ( gdwOsType < 1 )
  {
    v1 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, 2u, &phkResult);
    if ( v1 )
    {
LABEL_10:
      SetLastError(v1);
      ErrMsgBox(L"Error configuring auto start", ghWndNewOwner);
      return v1 == 0;
    }
    if ( a1 )
    {
      wcscat_s(Data, 0x208u, L" /t");
      v1 = RegSetValueEx(phkResult, L"Process Explorer", 0, 1u, Data, 2 * wcslen(Data) + 2);
    }
    else
    {
      v1 = RegDeleteValueW(phkResult, L"Process Explorer");
      if ( v1 == 2 )
        v1 = 0;
    }
    RegCloseKey(phkResult);
  }
  else
  {
    v1 = sub_1241E50(a1, Data);
  }
  if ( v1 )
    goto LABEL_10;
  return v1 == 0;
}
// 12E4E54: using guessed type int gdwOsType;

//----- (01243940) --------------------------------------------------------
LRESULT __cdecl InitToolTips(HWND hWnd)
{
  SendMessageW(hWnd, TTM_SETDELAYTIME, 3u, 0);
  SendMessageW(hWnd, TTM_SETMAXTIPWIDTH, 0, 4000);
  return SendMessageW(hWnd, TTM_SETDELAYTIME, 2u, 1000000);
}

//----- (01243980) --------------------------------------------------------
BOOL __cdecl DrawWindowEx(HWND hWnd, int a2)
{
  HPEN v2; // eax
  HPEN v3; // esi
  HPEN ho; // ST1C_4
  HDC v5; // eax
  HDC v6; // ebx
  HDC hdc; // ST24_4
  HGDIOBJ v8; // edi
  struct tagRECT Rect; // [esp+18h] [ebp-14h]

  v2 = CreatePen(0, 5, 0);
  v3 = v2;
  ho = v2;
  GetClientRect(hWnd, &Rect);
  v5 = GetDC(hWnd);
  v6 = v5;
  hdc = v5;
  v8 = SelectObject(v5, v3);
  SetROP2(v6, 6);
  MoveToEx(hdc, 0, a2 + 6, 0);
  LineTo(hdc, Rect.right, a2 + 6);
  SelectObject(hdc, v8);
  SetROP2(hdc, 11);
  ReleaseDC(hWnd, hdc);
  return DeleteObject(ho);
}

//----- (01243A30) --------------------------------------------------------
char __cdecl GetDependsFileName(LPCWSTR lpszFileName, wchar_t *pszSource, int nLen, wchar_t *pszResult)
{
  char result; // al
  rsize_t nLength; // ebx
  wchar_t *pSource; // edi
  wchar_t *szFileName; // esi
  wchar_t *v8; // eax
  wchar_t *pszNextName; // eax

  if ( GetFileAttributesW(lpszFileName) == INVALID_FILE_ATTRIBUTES )
  {
    nLength = wcslen(lpszFileName) + nLen + 2;
    pSource = pszSource;
    szFileName = malloc(2 * nLength);
    if ( pszSource )
    {
      while ( *pSource )
      {
        tcscpy_s(szFileName, nLength, pSource);
        v8 = wcschr(szFileName, ';');
        if ( v8 )
          // 截取第一个文件名
          *v8 = 0;
        wcscat_s(szFileName, nLength, L"\\");
        wcscat_s(szFileName, nLength, lpszFileName);
        if ( GetFileAttributesW(szFileName) != INVALID_FILE_SIZE )
        {
          tcscpy_s(pszResult, 0x104u, szFileName);
          j__free(szFileName);
          return 1;
        }
        // 取下一个文件名称
        pszNextName = wcschr(pSource, ';');
        if ( pszNextName )
        {
          pSource = pszNextName + 1;
          if ( pszNextName != 0xFFFFFFFE )
            continue;
        }
        break;
      }
    }
    j__free(szFileName);
    result = 0;
  }
  else
  {
    tcscpy_s(pszResult, 0x104u, lpszFileName);
    result = 1;
  }
  return result;
}

//----- (01243B30) --------------------------------------------------------
HWND __cdecl FindWindowByPid(int dwPid)
{
  HWND v1; // edi
  HWND hwnd; // esi
  HWND v3; // eax
  HWND hparentwnd; // eax
  DWORD dwProcessId; // [esp+8h] [ebp-1004h]
  WINDOWPLACEMENT wndpl; // [esp+Ch] [ebp-1000h]
  WCHAR String[2024]; // [esp+38h] [ebp-FD4h]

  v1 = 0;
  hwnd = FindWindowExW(0, 0, 0, 0);
  if ( !hwnd )
    return 0;
  do
  {
    GetWindowThreadProcessId(hwnd, &dwProcessId);
    if ( dwProcessId == dwPid && (IsWindowVisible(hwnd) || IsIconic(hwnd)) )
    {
      if ( !IsIconic(hwnd)
        || (GetWindowPlacement(hwnd, &wndpl), wndpl.rcNormalPosition.right - wndpl.rcNormalPosition.left > 1) )
      {
        if ( GetWindowTextW(hwnd, String, 2024) )
        {
          v1 = hwnd;
          if ( !GetParent(hwnd) )
            break;
          v3 = GetParent(hwnd);
          if ( !GetParent(v3) )
          {
            hparentwnd = GetParent(hwnd);
            if ( !IsWindowVisible(hparentwnd) )
              break;
          }
        }
      }
    }
    hwnd = FindWindowExW(0, hwnd, 0, 0);
  }
  while ( hwnd );
  return v1;
}

//----- (01243C40) --------------------------------------------------------
int __cdecl sub_1243C40(wchar_t *a1, size_t SizeInWords, __int64 a3)
{
  double v3; // xmm0_8
  const wchar_t *v5; // [esp+8h] [ebp-4Ch]
  wchar_t Dst; // [esp+10h] [ebp-44h]
  char v7; // [esp+12h] [ebp-42h]

  Dst = 0;
  memset(&v7, 0, 0x3Eu);
  v3 = *&a3;
  if ( *&a3 < 1073741824.0 )
  {
    if ( *&a3 < 1048576.0 )
    {
      if ( *&a3 < 1024.0 )
        goto LABEL_8;
      v3 = *&a3 * 0.0009765625;
      v5 = L" KB";
    }
    else
    {
      v3 = *&a3 * 0.00000095367431640625;
      v5 = L" MB";
    }
  }
  else
  {
    v3 = *&a3 * 9.313225746154785e-10;
    v5 = L" GB";
  }
  tcscpy_s(&Dst, 0x20u, v5);
LABEL_8:
  if ( Dst )
    return swprintf_s(a1, SizeInWords, L"%0.1f %s", LODWORD(v3), HIDWORD(v3), &Dst);
  if ( v3 == 0.0 )
    return swprintf_s(a1, SizeInWords, L"0");
  return swprintf_s(a1, SizeInWords, L"%0.0f B", LODWORD(v3), HIDWORD(v3));
}
// 12BCBE0: using guessed type wchar_t aGb[4];

//----- (01243D60) --------------------------------------------------------
// 查询账户信息
char __cdecl QuerySID(PSID Sid, LPWSTR Name, DWORD cchName, LPWSTR ReferencedDomainName, DWORD cchReferencedDomainName)
{
  SIDDATA *pSID; // esi
  SIDDATA *Buffer; // edi
  DWORD Length; // eax
  void *v8; // eax
  void *SidBuffer; // ST14_4
  DWORD SidLength; // eax
  char result; // al
  _SID_NAME_USE peUse; // [esp+Ch] [ebp-4h]

  pSID = gSIDDATA;
  if ( gSIDDATA )
  {
    while ( !EqualSid(pSID->m_SID, Sid) )
    {
      pSID = pSID->m_Next;
      if ( !pSID )
        goto LABEL_4;
    }
    tcscpy_s(Name, cchName, pSID->m_Name);
    tcscpy_s(ReferencedDomainName, cchReferencedDomainName, pSID->m_DomainName);
    result = 1;
  }
  else
  {
LABEL_4:
    if ( LookupAccountSidW(gpszTargetName, Sid, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
    {
      Buffer = malloc(0x418u);
      Length = GetLengthSid(Sid);
      v8 = malloc(Length);
      Buffer->m_SID = v8;
      SidBuffer = v8;
      SidLength = GetLengthSid(Sid);
      CopySid(SidLength, SidBuffer, Sid);
      tcscpy_s(Buffer->m_Name, _MAX_PATH, Name);
      tcscpy_s(Buffer->m_DomainName, _MAX_PATH, ReferencedDomainName);
      Buffer->m_Next = gSIDDATA;
      result = 1;
      gSIDDATA = Buffer;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (01243E70) --------------------------------------------------------
_DWORD *__cdecl sub_1243E70(PROCAFFINITY *a1, int a2, signed int a3, signed int *a4, _DWORD *a5)
{
  int v5; // edi
  signed int v6; // ecx
  signed int v7; // ebx
  unsigned int v8; // esi
  signed int v9; // edx
  int *v10; // ecx
  int v11; // eax
  _DWORD *result; // eax
  signed int v13; // [esp+Ch] [ebp-4h]

  v5 = a2;
  v6 = -1;
  v7 = -1;
  v13 = -1;
  v8 = -1;
  v9 = 0;
  if ( !a2 )
    goto LABEL_18;
  v10 = &a1->field_4;
  do
  {
    if ( (1 << a3) & *(v10 - 1) )
    {
      v11 = *v10;
      if ( *v10 == 1 )
      {
        v13 = v10[1];
      }
      else
      {
        if ( v11 )
          goto LABEL_10;
        v7 = v9;
      }
    }
    v11 = *v10;
    if ( !*v10 )
    {
      ++v9;
      goto LABEL_12;
    }
LABEL_10:
    if ( v11 == 1 )
      ++v8;
LABEL_12:
    v10 += 6;
    --v5;
  }
  while ( v5 );
  if ( v8 > 1 )
  {
    v6 = v13;
LABEL_18:
    *a4 = v6;
    result = a5;
    *a5 = 1;
    return result;
  }
  if ( v7 == -1 )
  {
    *a4 = a3;
    result = a5;
    *a5 = -1;
  }
  else
  {
    *a4 = v7;
    result = a5;
    *a5 = 0;
  }
  return result;
}

//----- (01243F20) --------------------------------------------------------
int __cdecl sub_1243F20(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // edx
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  int v7; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v7 = 0;
  if ( a2 )
  {
    v4 = a1;
    while ( 2 )
    {
      v5 = 0;
      do
      {
        if ( !v4[1] )
        {
          if ( (1 << v5) & *v4 && a3 == v3 )
            return v5;
          ++v3;
        }
        ++v5;
      }
      while ( v5 < 0x20 );
      v4 += 6;
      if ( ++v7 < a2 )
        continue;
      break;
    }
  }
  return a3;
}

//----- (01243F80) --------------------------------------------------------
void __cdecl sub_1243F80(wchar_t *Str, int a2, int a3, int a4, int a5)
{
  wchar_t *v5; // ecx
  wchar_t v6; // ax
  BSTR v7; // esi
  const wchar_t *v8; // eax
  const wchar_t *v9; // eax
  wchar_t *v10; // eax
  CComBSTR *v11; // edi
  const WCHAR **v12; // eax
  const WCHAR *v13; // eax
  bool v14; // bl
  OLECHAR *v15; // eax
  HKEY v16; // ST20_4
  _bstr_t *v17; // eax
  const WCHAR **v18; // eax
  const WCHAR *v19; // eax
  bool v20; // bl
  WCHAR *v21; // eax
  wchar_t *v22; // edi
  WCHAR *v23; // ecx
  int v24; // edx
  WCHAR v25; // ax
  wchar_t *v26; // eax
  DWORD v27; // ST10_4
  DWORD cbData; // [esp+Ch] [ebp-2A8h]
  DWORD dwLen; // [esp+10h] [ebp-2A4h]
  CComBSTR *ppComBSTR; // [esp+14h] [ebp-2A0h]
  CComBSTR *ppComBSTR1; // [esp+18h] [ebp-29Ch]
  HKEY phkResult; // [esp+1Ch] [ebp-298h]
  CComBSTR *ppv; // [esp+20h] [ebp-294h]
  CComBSTR v34; // [esp+24h] [ebp-290h]
  wchar_t Dst; // [esp+230h] [ebp-84h]

  ppComBSTR1 = a2;
  v5 = Str;
  dwLen = a4;
  v34.bstr = 0;
  do
  {
    v6 = *v5;
    ++v5;
  }
  while ( v6 );
  _wcsupr_s(Str, v5 - (Str + 1) + 1);
  bstr_t::Assign(&v34, Str);
  v7 = v34.bstr;
  if ( v34.bstr )
    v8 = *v34.bstr;
  else
    v8 = 0;
  if ( wcsstr(v8, L"/PROCESSID:") )
  {
    if ( v7 )
      v9 = *v7;
    else
      v9 = 0;
    v10 = wcsstr(v9, L"/PROCESSID:");
    v11 = bstr_t::EqualAssign(&ppv, v10 + 11);
    if ( &v34 != v11 )
    {
      bstr_t::Data_t::Free(&v34);
      v7 = v11->bstr;
      v34.bstr = v7;
      if ( v7 )
        InterlockedIncrement(v7 + 2);
    }
    bstr_t::Data_t::Free(&ppv);
    v12 = *sub_11F3B50(&ppv, L"CLSID\\", &v34);
    if ( v12 )
      v13 = *v12;
    else
      v13 = 0;
    v14 = RegOpenKeyExW(HKEY_CLASSES_ROOT, v13, 0, 0x20019u, &phkResult) == 0;
    bstr_t::Data_t::Free(&ppv);
    if ( v14 )
    {
      cbData = 520;
      if ( !RegQueryValueExW(phkResult, 0, 0, 0, &v34.hKey, &cbData) )
      {
        v15 = _wcsdup(&v34.hKey);
        v16 = phkResult;
        ppComBSTR1->bstr = v15;
        RegCloseKey(v16);
      }
      bstr_t::EqualAssign(&ppv, L"\\InProcServer32");
      v17 = sub_11F3B50(&ppComBSTR, L"CLSID\\", &v34);
      v18 = *CComBSTR::AppendTail(v17, &ppComBSTR1, &ppv);
      if ( v18 )
        v19 = *v18;
      else
        v19 = 0;
      v20 = RegOpenKeyExW(HKEY_CLASSES_ROOT, v19, 0, 0x20019u, &phkResult) == 0;
      bstr_t::Data_t::Free(&ppComBSTR1);
      bstr_t::Data_t::Free(&ppComBSTR);
      bstr_t::Data_t::Free(&ppv);
      if ( v20 )
      {
        v21 = CReg::ReadEnvString(phkResult, 0);
        v22 = v21;
        if ( v21 )
        {
          v23 = v21;
          v24 = (v21 + 1);
          do
          {
            v25 = *v23;
            ++v23;
          }
          while ( v25 );
          _wcslwr_s(v22, ((v23 - v24) >> 1) + 1);
          v26 = _wcsdup(v22);
          v27 = dwLen;
          *a3 = v26;
          GetImageVersionInfo(v22, &Dst, 0x40u, v27, a5);
          free(v22);
        }
        RegCloseKey(phkResult);
      }
    }
  }
  if ( v7 && !InterlockedDecrement(v7 + 2) )
  {
    if ( *v7 )
    {
      SysFreeString(*v7);
      *v7 = 0;
    }
    if ( *(v7 + 1) )
    {
      j_j__free(*(v7 + 1));
      *(v7 + 1) = 0;
    }
    j__free(v7);
  }
}

//----- (01244280) --------------------------------------------------------
wchar_t *__cdecl sub_1244280(wchar_t *a1)
{
  rsize_t v1; // ebx
  wchar_t *v2; // esi
  wchar_t *v3; // eax
  wchar_t *result; // eax
  WCHAR Buffer; // [esp+Ch] [ebp-20Ch]
  wchar_t v6; // [esp+12h] [ebp-206h]

  GetSystemDirectoryW(&Buffer, 0x104u);
  v1 = wcslen(&Buffer) + wcslen(a1) + 19;
  v2 = malloc(2 * v1);
  *wcschr(&v6, 0x5Cu) = 0;
  if ( _wcsnicmp(a1, L"\\SystemRoot\\", 0xCu) )
  {
    if ( !wcsncmp(a1, L"\\??\\", 4u) )
    {
      tcscpy_s(v2, v1, a1 + 4);
      result = v2;
    }
    else
    {
      if ( *a1 == 92 )
        swprintf_s(v2, v1, L"%c:%s", Buffer, a1);
      else
        swprintf_s(v2, v1, L"%s\\System32\\Drivers\\%s", &Buffer, a1);
      result = v2;
    }
  }
  else
  {
    v3 = wcschr(a1 + 1, 0x5Cu);
    swprintf_s(v2, v1, L"%s%s", &Buffer, v3);
    result = v2;
  }
  return result;
}
// 12BEF74: using guessed type wchar_t aCS[6];

//----- (012443C0) --------------------------------------------------------
DWORD __cdecl GetImageVersionInfo(LPCWSTR lptstrFilename, wchar_t *szVersion, rsize_t SizeInWords, DWORD dwLen, WCHAR *szDesc)
{
  _DWORD *v5; // edi
  DWORD VerInfoSize; // eax
  int *VerInfo; // esi
  const wchar_t *desc; // eax
  const wchar_t *desc2; // eax
  DWORD dwHandle; // [esp+8h] [ebp-4h]
  DWORD dwLena; // [esp+20h] [ebp+14h]

  tcscpy_s(szVersion, SizeInWords, gpszTargetName);
  v5 = dwLen;
  *dwLen = 0;
  *szDesc = 0;
  VerInfoSize = GetFileVersionInfoSizeW(lptstrFilename, &dwHandle);
  dwLena = VerInfoSize;
  if ( !VerInfoSize )
    return GetLastError();
  VerInfo = malloc(VerInfoSize);
  if ( GetFileVersionInfoW(lptstrFilename, 0, dwLena, VerInfo) )
  {
    sub_125BEC0(VerInfo[13], VerInfo[12], szVersion, SizeInWords);
    desc = GetDescInfo(VerInfo, L"FileDescription");
    if ( desc || (desc = GetDescInfo(VerInfo, L"ProductDescription")) != 0 )
      *v5 = _wcsdup(desc);
    desc2 = GetDescInfo(VerInfo, L"CompanyName");
    if ( desc2 || (desc2 = GetDescInfo(VerInfo, L"Copyright")) != 0 )
      *szDesc = _wcsdup(desc2);
  }
  free(VerInfo);
  return 0;
}
// 12AD200: using guessed type wchar_t aFiledescriptio[16];
// 12AD220: using guessed type wchar_t aCompanyname[12];
// 12BEBB8: using guessed type wchar_t aProductdescrip[19];
// 12BEBE0: using guessed type wchar_t aCopyright[10];

//----- (012444B0) --------------------------------------------------------
char __cdecl sub_12444B0(int a1, char a2, int a3, u_long hostlong, int a5, wchar_t *Dst, size_t SizeInWords)
{
  unsigned int v7; // eax
  unsigned int v8; // ebx
  int v9; // ST28_4
  int v10; // ST24_4
  int v11; // ST20_4
  int v12; // ST1C_4
  int v13; // ST18_4
  int v14; // ST14_4
  int v15; // ST10_4
  u_short v16; // ax
  char result; // al
  _DWORD *v18; // eax
  __m128i *v19; // ecx

  v7 = htonl(hostlong);
  v8 = v7;
  if ( a2 )
  {
    if ( sub_1242910(a1, v7, a5, Dst, SizeInWords) )
    {
      result = 1;
    }
    else
    {
      swprintf_s(Dst, SizeInWords, L"%d.%d.%d.%d", v8 >> 24, (v8 >> 16) & 0xFF, v8 >> 8, v8);
      EnterCriticalSection(&gLock2);
      v18 = dword_12E9E7C;
      if ( dword_12E9E7C )
      {
        while ( v18[67] != v8 )
        {
          v18 = v18[72];
          if ( !v18 )
            goto LABEL_11;
        }
      }
      else
      {
LABEL_11:
        v19 = malloc(0x124u);
        v19->m128i_i32[0] = a1;
        v19[16].m128i_i32[2] = hostlong;
        v19[16].m128i_i32[3] = v8;
        if ( a5 )
          _mm_storeu_si128(v19 + 17, _mm_loadu_si128(a5));
        v19[18].m128i_i32[0] = dword_12E9E7C;
        dword_12E9E7C = v19;
        _beginthread(sub_1242A70, 0, v19);
      }
      LeaveCriticalSection(&gLock2);
      result = 0;
    }
  }
  else if ( a1 && a1 != 1 )
  {
    v9 = htons(*(a5 + 14));
    v10 = htons(*(a5 + 12));
    v11 = htons(*(a5 + 10));
    v12 = htons(*(a5 + 8));
    v13 = htons(*(a5 + 6));
    v14 = htons(*(a5 + 4));
    v15 = htons(*(a5 + 2));
    v16 = htons(*a5);
    swprintf_s(Dst, SizeInWords, L"[%x:%x:%x:%x:%x:%x:%x:%x]", v16, v15, v14, v13, v12, v11, v10, v9);
    result = 0;
  }
  else
  {
    swprintf_s(Dst, SizeInWords, L"%d.%d.%d.%d", v7 >> 24, (v7 >> 16) & 0xFF, v7 >> 8, v7);
    result = 0;
  }
  return result;
}

//----- (01244670) --------------------------------------------------------
wchar_t *__cdecl sub_1244670(char a1, int port, char *proto, wchar_t *Dst, size_t SizeInWords)
{
  u_short v5; // ax
  struct servent *v6; // eax

  if ( a1 )
  {
    v6 = getservbyport(port, proto);
    if ( v6 )
    {
      swprintf_s(Dst, SizeInWords, L":%S", v6->s_name);
      return Dst;
    }
    v5 = htons(port);
  }
  else
  {
    v5 = htons(port);
  }
  swprintf_s(Dst, SizeInWords, L":%d", v5);
  return Dst;
}

//----- (012446D0) --------------------------------------------------------
wchar_t *__cdecl IsProcessComment(wchar_t *str)
{
  int icomment; // esi
  WCHAR **strProcessComments; // eax
  int idx; // ecx
  bool found; // zf

  icomment = 0;
  if ( !str )
    return 0;
  strProcessComments = gstrProcessComments;
  if ( !gstrProcessComments || !*gstrProcessComments )
    return 0;
  idx = 0;
  while ( 1 )
  {
    found = _wcsicmp(str, strProcessComments[idx]) == 0;
    strProcessComments = gstrProcessComments;
    if ( found )
      break;
    idx = 2 * ++icomment;
    if ( !gstrProcessComments[2 * icomment] )
      return 0;
  }
  return _wcsdup(gstrProcessComments[2 * icomment + 1]);
}

//----- (01244730) --------------------------------------------------------
wchar_t *__cdecl sub_1244730(wchar_t *a1, int a2)
{
  wchar_t *result; // eax

  *a2 = 0;
  result = wcsstr(a1, L"-k");
  if ( result )
  {
    result = wcsstr(a1, L"-k") + 3;
    if ( result )
    {
      result = _wcsdup(result);
      *a2 = result;
    }
  }
  return result;
}

//----- (01244780) --------------------------------------------------------
WCHAR *__cdecl GetSVCHostsFilePath(wchar_t *a1, LPCWSTR lpServiceName)
{
  WCHAR *szBinPathName; // ebx
  wchar_t *v3; // esi
  wchar_t *v4; // ecx
  wchar_t v5; // ax
  LPCWSTR v6; // ecx
  WCHAR v7; // ax
  wchar_t *szKeyName; // esi
  WCHAR *result; // eax
  DWORD v10; // esi
  DWORD cbSize; // ST10_4
  SC_HANDLE ServiceHandle; // esi
  DWORD v13; // eax
  DWORD v14; // edi
  DWORD nSize; // eax
  DWORD nBufferLength; // edi
  WCHAR *lpBuffer; // esi
  LPWSTR FilePart; // [esp+Ch] [ebp-14h]
  QUERY_SERVICE_CONFIGW *pszConfig; // [esp+10h] [ebp-10h]
  DWORD pcbBytesNeeded; // [esp+14h] [ebp-Ch]
  SC_HANDLE hService; // [esp+18h] [ebp-8h]
  HKEY hSubKey; // [esp+1Ch] [ebp-4h]

  szBinPathName = 0;
  v3 = _wcsdup(a1);
  v4 = v3;
  do
  {
    v5 = *v4;
    ++v4;
  }
  while ( v5 );
  _wcsupr_s(v3, v4 - (v3 + 1) + 1);
  if ( wcsstr(v3, L"SVCHOST.EXE") )
  {
    v6 = lpServiceName;
    do
    {
      v7 = *v6;
      ++v6;
    }
    while ( v7 );
    hService = (v6 - (lpServiceName + 1) + 46);
    szKeyName = malloc(2 * hService);
    swprintf_s(szKeyName, hService, L"System\\CurrentControlSet\\Services\\%s", lpServiceName);
    if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hSubKey) )
    {
      szBinPathName = CReg::ReadEnvString(hSubKey, L"ServiceDll");
      if ( !szBinPathName )
      {
        RegCloseKey(hSubKey);
        swprintf_s(szKeyName, hService, L"System\\CurrentControlSet\\Services\\%s\\Parameters", lpServiceName);
        if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hSubKey) )
        {
          szBinPathName = CReg::ReadEnvString(hSubKey, L"ServiceDll");
          RegCloseKey(hSubKey);
        }
      }
    }
  }
  else
  {
    result = OpenServiceW(ghSCManager, lpServiceName, 5u);
    hService = result;
    if ( !result )
      return result;
    QueryServiceConfigW(result, 0, 0, &pcbBytesNeeded);
    v10 = pcbBytesNeeded;
    pszConfig = malloc(pcbBytesNeeded);
    cbSize = v10;
    ServiceHandle = hService;
    QueryServiceConfigW(hService, pszConfig, cbSize, &pcbBytesNeeded);
    CloseServiceHandle(ServiceHandle);
    szKeyName = pszConfig;
    v13 = ExpandEnvironmentStringsW(pszConfig->lpBinaryPathName, 0, 0);
    v14 = v13;
    if ( v13 )
    {
      szBinPathName = malloc(2 * v13);
      ExpandEnvironmentStringsW(pszConfig->lpBinaryPathName, szBinPathName, v14);
    }
  }
  free(szKeyName);
  if ( GetFileAttributesW(szBinPathName) == -1 )
  {
    nSize = SearchPathW(0, szBinPathName, 0, 0, 0, 0);
    nBufferLength = nSize;
    if ( nSize )
    {
      lpBuffer = malloc(2 * nSize);
      SearchPathW(0, szBinPathName, 0, nBufferLength, lpBuffer, &FilePart);
      _wcslwr_s(lpBuffer, nBufferLength);
      free(szBinPathName);
      szBinPathName = lpBuffer;
    }
  }
  return szBinPathName;
}

//----- (01244990) --------------------------------------------------------
wchar_t *__cdecl sub_1244990(int a1)
{
  wchar_t *v1; // ebx
  CComBSTR *v2; // esi
  LPVOID v3; // ecx
  int v4; // edx
  int v5; // edi
  int v6; // ecx
  LONG i; // ebx
  __m128i v8; // xmm0
  CComBSTR *v9; // edx
  int v10; // edi
  CComBSTR **v11; // eax
  int *v12; // eax
  CComBSTR **v13; // eax
  _bstr_t *v14; // eax
  CComBSTR **v15; // eax
  _bstr_t *v16; // eax
  _bstr_t *v17; // eax
  int v19; // [esp-40h] [ebp-FCh]
  int v20; // [esp-3Ch] [ebp-F8h]
  int v21; // [esp-38h] [ebp-F4h]
  int v22; // [esp-34h] [ebp-F0h]
  int v23; // [esp-30h] [ebp-ECh]
  int v24; // [esp-2Ch] [ebp-E8h]
  int v25; // [esp-28h] [ebp-E4h]
  int v26; // [esp-24h] [ebp-E0h]
  int v27; // [esp-20h] [ebp-DCh]
  int v28; // [esp-1Ch] [ebp-D8h]
  int v29; // [esp-18h] [ebp-D4h]
  int v30; // [esp-14h] [ebp-D0h]
  int v31; // [esp-10h] [ebp-CCh]
  LPVOID v32; // [esp-Ch] [ebp-C8h]
  CComBSTR **v33; // [esp-8h] [ebp-C4h]
  int *v34; // [esp-4h] [ebp-C0h]
  __int128 v35; // [esp+Ch] [ebp-B0h]
  __int128 v36; // [esp+1Ch] [ebp-A0h]
  __int128 v37; // [esp+2Ch] [ebp-90h]
  VARIANTARG v38; // [esp+3Ch] [ebp-80h]
  VARIANTARG v39; // [esp+4Ch] [ebp-70h]
  VARIANTARG pvarg; // [esp+5Ch] [ebp-60h]
  VARIANTARG v41; // [esp+6Ch] [ebp-50h]
  OLECHAR *psz; // [esp+7Ch] [ebp-40h]
  CComBSTR *ppComBSTR; // [esp+80h] [ebp-3Ch]
  OLECHAR **v44; // [esp+84h] [ebp-38h]
  int v45; // [esp+88h] [ebp-34h]
  CComBSTR *v46; // [esp+8Ch] [ebp-30h]
  OLECHAR *v47; // [esp+90h] [ebp-2Ch]
  BSTR *v48; // [esp+94h] [ebp-28h]
  BSTR *v49; // [esp+98h] [ebp-24h]
  CComBSTR *v50; // [esp+9Ch] [ebp-20h]
  BSTR *v51; // [esp+A0h] [ebp-1Ch]
  int v52; // [esp+A4h] [ebp-18h]
  BSTR *v53; // [esp+A8h] [ebp-14h]
  CComBSTR **v54; // [esp+ACh] [ebp-10h]
  LPVOID ppv; // [esp+B0h] [ebp-Ch]
  CComBSTR **v56; // [esp+B4h] [ebp-8h]
  CComBSTR *ppComBSTR1; // [esp+B8h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  ppv = 0;
  ppComBSTR1 = 0;
  if ( CoCreateInstance(&stru_12BF100, 0, 1u, &stru_12BF110, &ppv) >= 0 )
  {
    VariantInit(&pvarg);
    _mm_storeu_si128(&v37, _mm_loadu_si128(&pvarg));
    VariantInit(&v39);
    _mm_storeu_si128(&v36, _mm_loadu_si128(&v39));
    VariantInit(&v38);
    _mm_storeu_si128(&v35, _mm_loadu_si128(&v38));
    VariantInit(&v41);
    v3 = ppv;
    v4 = *ppv;
    _mm_storeu_si128(&v31, _mm_loadu_si128(&v37));
    _mm_storeu_si128(&v27, _mm_loadu_si128(&v36));
    _mm_storeu_si128(&v23, _mm_loadu_si128(&v35));
    _mm_storeu_si128(&v19, _mm_loadu_si128(&v41));
    v5 = (*(v4 + 40))(v3, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);
    VariantClear(&v41);
    VariantClear(&v38);
    VariantClear(&v39);
    VariantClear(&pvarg);
    if ( v5 >= 0 )
    {
      v34 = &v56;
      v56 = 0;
      v33 = 1;
      v6 = *ppv;
      v32 = ppv;
      if ( (*(v6 + 32))(ppv, 1, &v56) >= 0 )
      {
        v34 = &v52;
        v33 = v56;
        ((*v56)[2].hKey)(v56, &v52);
        for ( i = 1; i < v52 + 1; ++i )
        {
          v41.vt = 3;
          v34 = &v54;
          v41.lVal = i;
          v8 = _mm_loadu_si128(&v41);
          v9 = *v56;
          v29 = v56;
          _mm_storeu_si128(&v30, v8);
          v10 = (v9[2].Length)(v29, v30, v31, v32, v33, v34);
          VariantClear(&v41);
          if ( v10 >= 0 )
          {
            v34 = &v45;
            v33 = v54;
            if ( ((*v54)[4].Length)(v54, &v45) >= 0 && v45 == a1 )
            {
              v34 = &psz;
              v33 = v54;
              if ( ((*v54)[3].Length)(v54, &psz) >= 0 )
              {
                if ( v2 )
                {
                  if ( v2->bstr )
                  {
                    v34 = v2->bstr;
                    if ( SysStringLen(v34) )
                    {
                      v11 = bstr_t::EqualAssign(&v48, L"\n");
                      v12 = CComBSTR::AppendTail(&ppComBSTR1, &v44, v11);
                      sub_11F3A50(&ppComBSTR1, v12);
                      bstr_t::Data_t::Free(&v44);
                      bstr_t::Data_t::Free(&v48);
                    }
                  }
                }
                v13 = bstr_t::EqualAssign(&v51, psz);
                v14 = sub_11F3B50(&ppComBSTR, L"   ", v13);
                bstr_t::Append(&ppComBSTR1, v14);
                bstr_t::Data_t::Free(&ppComBSTR);
                bstr_t::Data_t::Free(&v51);
                v34 = &v47;
                v33 = v54;
                if ( ((*v54)[3].bstr)(v54, &v47) >= 0 )
                {
                  bstr_t::EqualAssign(&v53, L"]");
                  v34 = &v53;
                  v33 = &v46;
                  v15 = bstr_t::EqualAssign(&v49, v47);
                  v16 = sub_11F3B50(&v50, L" [", v15);
                  v17 = CComBSTR::AppendTail(v16, v33, v34);
                  bstr_t::Append(&ppComBSTR1, v17);
                  bstr_t::Data_t::Free(&v46);
                  bstr_t::Data_t::Free(&v50);
                  bstr_t::Data_t::Free(&v49);
                  bstr_t::Data_t::Free(&v53);
                }
                v2 = ppComBSTR1;
              }
            }
            v34 = v54;
            ((*v54)->Length)(v54);
          }
        }
        v34 = v56;
        ((*v56)->Length)(v56);
        v1 = 0;
      }
    }
    v34 = ppv;
    (*(*ppv + 8))(ppv);
    if ( v2 )
    {
      if ( v2->bstr )
      {
        v34 = v2->bstr;
        if ( SysStringLen(v34) )
        {
          v34 = v2->bstr;
          v1 = _wcsdup(v34);
        }
      }
      if ( !InterlockedDecrement(&v2->Length) )
      {
        if ( v2->bstr )
        {
          SysFreeString(v2->bstr);
          v2->bstr = 0;
        }
        if ( v2->hKey )
        {
          j_j__free(v2->hKey);
          v2->hKey = 0;
        }
        j__free(v2);
      }
    }
  }
  return v1;
}

//----- (01244CC0) --------------------------------------------------------
BOOL __cdecl DrawWindow(HWND hWnd)
{
  int v1; // esi
  HDC v2; // eax
  HDC v3; // edi
  HDC hdc; // ST24_4
  int v5; // ebx
  HPEN v6; // edi
  HGDIOBJ v7; // eax
  struct tagRECT Rect; // [esp+14h] [ebp-14h]

  v1 = 3 * GetSystemMetrics(SM_CXBORDER);
  v2 = GetWindowDC(hWnd);
  v3 = v2;
  hdc = v2;
  GetWindowRect(hWnd, &Rect);
  v5 = SaveDC(v3);
  SetROP2(v3, 6);
  v6 = CreatePen(6, v1, 0);
  SelectObject(hdc, v6);
  v7 = GetStockObject(5);
  SelectObject(hdc, v7);
  Rectangle(hdc, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top);
  RestoreDC(hdc, v5);
  ReleaseDC(hWnd, hdc);
  return DeleteObject(v6);
}

//----- (01244D80) --------------------------------------------------------
bool __usercall MayRunAtLogon@<al>(int a1, _DWORD *a2)
{
  int v2; // ebp
  _DWORD *v3; // edi
  ITaskService *pTaskService1; // ecx
  ITaskServiceVtbl *vtptr; // edx
  int hres; // edi
  CComBSTR *bstrBuffer; // eax
  OLECHAR *szPathName; // edx
  HRESULT hRes; // esi
  OLECHAR *v10; // eax
  CComBSTR **v11; // eax
  OLECHAR *v12; // edx
  LSTATUS ret; // esi
  VARIANT vtServerName; // [esp-310h] [ebp-31Ch]
  VARIANT vtUserName; // [esp-300h] [ebp-30Ch]
  VARIANT vtDoMain; // [esp-2F0h] [ebp-2FCh]
  VARIANT vtPassword; // [esp-2E0h] [ebp-2ECh]
  _DWORD *v19; // [esp-2D0h] [ebp-2DCh]
  RECT v20; // [esp-2C0h] [ebp-2CCh]
  RECT v21; // [esp-2B0h] [ebp-2BCh]
  RECT v22; // [esp-2A0h] [ebp-2ACh]
  VARIANT vUserName; // [esp-290h] [ebp-29Ch]
  VARIANT vDomain; // [esp-280h] [ebp-28Ch]
  VARIANT vPassword; // [esp-270h] [ebp-27Ch]
  VARIANT vServerName; // [esp-260h] [ebp-26Ch]
  int szProcExpPathName; // [esp-244h] [ebp-250h]
  signed int SizeReturned; // [esp-240h] [ebp-24Ch]
  _DWORD *v29; // [esp-23Ch] [ebp-248h]
  ITaskFolder *pTaskFolder; // [esp-238h] [ebp-244h]
  HKEY hKey; // [esp-234h] [ebp-240h]
  int bstrFolder; // [esp-230h] [ebp-23Ch]
  ITaskService *pTaskService; // [esp-22Ch] [ebp-238h]
  OLECHAR *v34; // [esp-228h] [ebp-234h]
  unsigned int v35; // [esp-214h] [ebp-220h]
  int v36; // [esp-210h] [ebp-21Ch]
  unsigned int v37; // [esp-4h] [ebp-10h]
  int v38; // [esp+0h] [ebp-Ch]
  int v39; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v38 = v2;
  v39 = retaddr;
  v37 = &v38 ^ __security_cookie;
  v19 = v3;
  if ( gdwOsType < WINDOWS_VISTA )
  {
    ret = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, 1u, &hKey);
    if ( !ret )
    {
      SizeReturned = 520;
      ret = RegQueryValueExW(hKey, L"Process Explorer", 0, &szProcExpPathName, &v36, &SizeReturned);
      RegCloseKey(hKey);
    }
    return ret == 0;
  }
  sub_12426B0(&v34);
  pTaskService = 0;
  if ( CoCreateInstance(&CLSID_TaskScheduler, 0, 1u, &IID_ITaskService, &pTaskService) >= 0 )
  {
    VariantInit(&vPassword);
    _mm_store_si128(&v21, _mm_load_si128(&vPassword));
    VariantInit(&vDomain);
    _mm_store_si128(&v22, _mm_load_si128(&vDomain));
    VariantInit(&vUserName);
    _mm_store_si128(&v20, _mm_load_si128(&vUserName));
    VariantInit(&vServerName);
    pTaskService1 = pTaskService;
    vtptr = pTaskService->lpVtbl;
    _mm_storeu_si128(&vtPassword, _mm_load_si128(&v21));
    _mm_storeu_si128(&vtDoMain, _mm_load_si128(&v22));
    _mm_storeu_si128(&vtUserName, _mm_load_si128(&v20));
    _mm_storeu_si128(&vtServerName, _mm_loadu_si128(&vServerName));
    // Connect(out serverName: Variant; out user: Variant; out domain: Variant; out password: Variant)
    hres = (vtptr->Connect)(
             pTaskService1,
             *&vtServerName.vt,
             vtServerName.decVal.Hi32,
             vtServerName.lVal,
             vtServerName.cyVal.Hi,
             *&vtUserName.vt,
             vtUserName.decVal.Hi32,
             vtUserName.lVal,
             vtUserName.cyVal.Hi,
             *&vtDoMain.vt,
             vtDoMain.decVal.Hi32,
             vtDoMain.lVal,
             vtDoMain.cyVal.Hi,
             *&vtPassword.vt,
             vtPassword.decVal.Hi32,
             vtPassword.lVal,
             vtPassword.cyVal.Hi,
             v19);
    VariantClear(&vServerName);
    VariantClear(&vUserName);
    VariantClear(&vDomain);
    VariantClear(&vPassword);
    if ( hres >= 0 )
    {
      pTaskFolder = 0;
      bstrBuffer = *bstr_t::EqualAssign(&bstrFolder, L"\\");
      szPathName = bstrBuffer ? bstrBuffer->bstr : 0;
      v19 = &pTaskFolder;
      vtPassword.cyVal.int64 = __PAIR__(szPathName, pTaskService);
      hRes = pTaskService->lpVtbl->GetFolder(pTaskService, szPathName, &pTaskFolder);
      bstr_t::Data_t::Free(&bstrFolder);
      if ( hRes >= 0 )
      {
        v10 = &v34;
        if ( v35 >= 8 )
          v10 = v34;
        v11 = bstr_t::EqualAssign(&bstrFolder, v10);
        if ( *v11 )
          v12 = (*v11)->bstr;
        else
          v12 = 0;
        v19 = &v29;
        vtPassword.cyVal.int64 = __PAIR__(v12, pTaskFolder);
        ret = pTaskFolder->lpVtbl->GetTask(pTaskFolder, v12, &v29);
        bstr_t::Data_t::Free(&bstrFolder);
        if ( !ret )
        {
          v19 = v29;
          (*(*v29 + 8))(v29);
        }
        v19 = &pTaskService->lpVtbl;
        (pTaskService->lpVtbl->Release)(pTaskService);
        sub_11F3820(&v34);
        return ret == 0;
      }
    }
    v19 = &pTaskService->lpVtbl;
    (pTaskService->lpVtbl->Release)(pTaskService);
  }
  if ( v35 >= 8 )
    j__free(v34);
  return 0;
}
// 1244D80: could not find valid save-restore pair for ebp
// 1244D80: could not find valid save-restore pair for edi
// 12E4E54: using guessed type int gdwOsType;

//----- (01245050) --------------------------------------------------------
bool sub_1245050()
{
  HMODULE v0; // eax
  FARPROC v1; // eax
  int v3; // [esp+0h] [ebp-18h]
  unsigned int v4; // [esp+4h] [ebp-14h]
  __int64 v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+10h] [ebp-8h]

  v0 = LoadLibraryW(L"comctl32.dll");
  v1 = GetProcAddress(v0, "DllGetVersion");
  if ( !v1 )
    return 0;
  v3 = 20;
  v4 = 0;
  v5 = 0i64;
  v6 = 0;
  return (v1)(&v3) >= 0 && v4 >= 6;
}

//----- (012450E0) --------------------------------------------------------
char __cdecl sub_12450E0(wchar_t *a1)
{
  WCHAR **v1; // eax
  int v2; // esi
  int v3; // eax

  v1 = gpHiddenProcs;
  if ( !*gpHiddenProcs )
    return 0;
  v2 = 0;
  while ( 1 )
  {
    v3 = _wcsicmp(v1[v2], a1);
    ++v2;
    if ( !v3 )
      break;
    v1 = gpHiddenProcs;
    if ( !gpHiddenProcs[v2] )
      return 0;
  }
  return 1;
}

//----- (01245120) --------------------------------------------------------
BOOL __stdcall IsProcessorFeaturePresent_0(DWORD ProcessorFeature)
{
  HMODULE v1; // eax
  BOOL IsProcessorFeaturePresent; // eax

  v1 = GetModuleHandle(L"Kernel32.dll");
  IsProcessorFeaturePresent = GetProcAddress(v1, "IsProcessorFeaturePresent");
  if ( IsProcessorFeaturePresent )
    return (IsProcessorFeaturePresent)();
  LOBYTE(IsProcessorFeaturePresent) = 0;
  return IsProcessorFeaturePresent;
}

//----- (01245150) --------------------------------------------------------
char TaskMgrIsDebugger()
{
  wchar_t *pszDebugger; // esi
  wchar_t *pszFileName; // eax
  int ret; // eax
  DWORD cbData; // [esp+4h] [ebp-41Ch]
  HKEY hKey; // [esp+8h] [ebp-418h]
  wchar_t szDebugger[260]; // [esp+Ch] [ebp-414h]
  __int16 szFileName[262]; // [esp+214h] [ebp-20Ch]

  if ( !RegOpenKeyW(
          HKEY_LOCAL_MACHINE,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe",
          &hKey) )
  {
    cbData = 520;
    if ( !RegQueryValueExW(hKey, L"Debugger", 0, 0, szDebugger, &cbData) )
    {
      _wcsupr_s(szDebugger, _MAX_PATH);
      GetModuleFileNameW(0, &szFileName[1], 0x102u);
      szFileName[0] = '"';
      wcscat_s(szFileName, _MAX_PATH, L"\"");
      _wcsupr_s(szFileName, _MAX_PATH);
      pszDebugger = wcsrchr(szDebugger, '\\');
      pszFileName = wcsrchr(szFileName, '\\');
      if ( pszFileName )
      {
        if ( pszDebugger )
        {
          ret = wcscmp(pszDebugger, pszFileName);
          if ( ret )
            ret = -(ret < 0) | 1;
          if ( !ret )
          {
            RegCloseKey(hKey);
            return 1;
          }
        }
      }
    }
    RegCloseKey(hKey);
  }
  return 0;
}

//----- (012452B0) --------------------------------------------------------
// 检测操作系统是否是否为Server版本?还不是很确认、
int __cdecl IsWinServer()
{
  DWORD v0; // eax
  HMODULE v2; // eax
  ULONGLONG (__stdcall *VerSetConditionMask)(ULONGLONG, DWORD, BYTE); // eax
  HMODULE v4; // eax
  FARPROC VerifyVersionInfoA; // esi
  OSVERSIONINFOEXA VersionInfo; // [esp+4h] [ebp-A0h]

  v0 = GetVersion();
  if ( (v0 & 0x80000000) != 0 )
    return 0;
  if ( v0 <= 4u )
    return IsTerminalServer(L"Terminal Server");
  if ( v0 >= 5u && v0 >> 16 > 0x893 )
    return 1;
  v2 = GetModuleHandle(L"ntdll.dll");
  if ( !v2 )
    return 0;
  VerSetConditionMask = GetProcAddress(v2, "VerSetConditionMask");
  if ( !VerSetConditionMask )
    return 0;
  (VerSetConditionMask)();
  v4 = GetModuleHandle(L"KERNEL32.DLL");
  if ( !v4 )
    return 0;
  VerifyVersionInfoA = GetProcAddress(v4, "VerifyVersionInfoA");
  if ( !VerifyVersionInfoA )
    return 0;
  memset(&VersionInfo, 0, 0x9Cu);
  VersionInfo.dwOSVersionInfoSize = 156;
  VersionInfo.wReserved[0] = 16;
  return (VerifyVersionInfoA)(&VersionInfo, VER_SUITENAME);
}
// 12452B0: could not find valid save-restore pair for ebx
// 12452B0: could not find valid save-restore pair for esi

//----- (012453F0) --------------------------------------------------------
BOOL __cdecl MainWnd_Hide(HWND hWnd)
{
  BOOL result; // eax

  result = ShowWindow(hWnd, SW_HIDE);
  gbProcessExplorerHide = 1;
  return result;
}
// 12EA389: using guessed type char gbProcessExplorerHide;

//----- (01245420) --------------------------------------------------------
PROCAFFINITY *__cdecl sub_1245420(unsigned int *pdwLogicalProcessorInformationCount)
{
  unsigned int *v1; // esi
  DWORD_PTR (__stdcall *SetThreadAffinityMask)(HANDLE, DWORD_PTR); // ebx
  DWORD_PTR v3; // edi
  HANDLE v4; // eax
  char v15; // cl
  unsigned int v16; // esi
  unsigned int i; // eax
  unsigned int idx; // eax
  unsigned int v19; // edx
  unsigned int v20; // ecx
  int v21; // ebx
  bool v22; // sf
  unsigned __int8 v23; // of
  HANDLE v24; // eax
  ULONG_PTR v25; // ST08_4
  HANDLE v26; // eax
  unsigned int dwLogicalProcessorInformationCount; // esi
  PROCAFFINITY *pBuffer; // eax
  unsigned int dwIndex; // edx
  PROCAFFINITY *res; // edi
  int pItem; // ecx
  int v32; // eax
  int count; // [esp+20h] [ebp-118h]
  ULONG_PTR ProcessAffinityMask; // [esp+24h] [ebp-114h]
  ULONG64 Buffer[32]; // [esp+28h] [ebp-110h]
  int v37; // [esp+128h] [ebp-10h]
  int v38; // [esp+12Ch] [ebp-Ch]
  int v39; // [esp+130h] [ebp-8h]

  v1 = pdwLogicalProcessorInformationCount;
  *pdwLogicalProcessorInformationCount = 0;
  LODWORD(Buffer[0]) = 0;
  memset(Buffer + 4, 0, 252u);
  SetThreadAffinityMask = ::SetThreadAffinityMask;
  count = 0;
  v3 = 1;
  do
  {
    v4 = GetCurrentThread();
    if ( !SetThreadAffinityMask(v4, v3) )
      break;
    Sleep(0);
    _EAX = 0;
    // 返回的信息分两部分:基本信息与扩展信息.在EAX输入0-3参数时,它返回的CPU的基本信息;而在EAX输入0x8000000至0x800000x时,它返回的是CPU的扩展信息(extended function information).扩展信息只包含在Pentium 4及以后的CPU上,Pentium 4以前的CPU无法取得它的扩展信息.
    __asm { cpuid }
    v37 = _EBX;
    v38 = _EDX;
    v39 = _ECX;
    _EAX = 1;
    __asm { cpuid }
    if ( ((_EAX & 0xF00) == 0xF00 || _EAX & 0xF00000)
      && v37 == 'uneG'
      && v38 == 'Ieni'
      && v39 == 'letn'
      // EDX 特征信息(Feature Information)
      && (_EDX >> 28) & 1 )
    {
      v15 = 0;
      // 当输入0x1时,EBX返回值是:

      // 第 0 - 7位: CPU字串索引 (Brand Index)

      // 第 8 - 15位: CLFLUSH线大小(CLFLUSH line size) (返回值*8 = cache line size)

      // 第16 - 23位: 保留

      // 第24 - 31位: 处理器APIC物理标号 (Processor local APIC physical ID)

      // 当输入0x1时,EDX返回的扩展信息解释如下:

      // 位 标号 解释

      // 0 FPU Floating Point Unit On-Chip. CPU是否内置浮点计算单元

      // 1 VME Virtual 8086 Mode Enhancements. 是否支持虚拟8086模式

      // 2 DE Debugging Extensions. 是否支持调试功能.

      // 3 PSE Page Size Extension. 是否支持大于4MB的分页.

      // 4 TSC Time Stamp Counter. 是否支持RDTSC指令.(注:RDTSC指令可以计算出CPU的频率)

      // 5 MSR Module Specific Registers RDMSR and WRMSR Instructions. 是否支持RDMSR与WRMSR (*注1)

      // 6 PAE Physical Address Extension. 是否支持大于32bit的物理地址.

      // 7 MCE Machine Check Exception. (*注2)

      // 8 CX8 CMPXCHG8B Instruction. 是否支持8bytes(64bit)数的比较与交换指令.

      // 9 APIC APIC On-Chip.是否支持APIC(Advanced Programmable Interrupt Controller)

      // 10 保留

      // 11 SEP SYSENTER and SYSEXIT Instructions.是否支持SYSENTER与SYSEXIT指令.(*注3)

      // 12 MTRR Memory Type Range Registers. 是否支持MTTR(*注4)

      // 13 PGE PTE Global Bit. 是否支持全局页面目录入口标志位 (global bit in page directory entries)

      // 14 MCA Machine Check Architecture. 是否支持MCA,MCA是Pentium4,Xeon,P6级处理器的一个错误报告机制

      // 15 CMOV Conditional Move Instructions. CMOV指令是否可用.(请问谁可以解释一下CMOV是什么命令?)

      // 16 PAT Page Attribute Table. 是否支持PAT,PAT允许操作系统指定4K大小的线性内存空间

      // 17 PSE-36 32-bit Page Size Extension. 是否支持4GB的扩展内存

      // 18 PSN Processor Serial Number. 是否支持处理器序列号.(P3有效)

      // 19 CLFSH CLFLUSH Instruction.是否支持CLFLUSH.(*注5)

      // 20 保留

      // 21 DS Debug Store. 是否支持把调试信息写入缓存,

      // 22 ACPI ACPI Processor Performance Modulation Registers. 处理器使用特别的寄存器以允许软件控制处理器的运行周期.

      // 23 MMX Inter MMX Technology.是否支持MMX

      // 24 FXSR FXSAVE and FXRSTOR Instructions. FXSAVE与FXRSTOR指令是否可用(*注6)

      // 25 SSE SSE.是否支持SSE.

      // 26 SSE2 是否支持SSE2.

      // 27 SS Self Snoop. 处理器是否支持总线监视,以防止储存器冲突.

      // 28 保留

      // 29 TM Thermal Monitor.CPU是否支持温度控制.

      // 30 & 31 保留
      v16 = (_EBX >> 16) & 0xFF;
      for ( i = 1; i < v16; ++v15 )
        i *= 2;
      v1 = pdwLogicalProcessorInformationCount;
      idx = 0;
      v19 = _EBX >> 24 >> v15;
      v20 = *pdwLogicalProcessorInformationCount;
      if ( *pdwLogicalProcessorInformationCount )
      {
        do
        {
          if ( v19 == LODWORD(Buffer[idx]) )
            break;
          ++idx;
        }
        while ( idx < v20 );
      }
      if ( idx >= v20 )
        *pdwLogicalProcessorInformationCount = v20 + 1;
      HIDWORD(Buffer[idx]) |= v3;
      LODWORD(Buffer[idx]) = v19;
    }
    v21 = count + 1;
    v3 = __ROL4__(v3, 1);
    count = v21;
    v23 = __OFSUB__(v21, 32);
    v22 = v21 - 32 < 0;
    SetThreadAffinityMask = ::SetThreadAffinityMask;
  }
  while ( v22 ^ v23 );
  ProcessAffinityMask = -1;
  v24 = GetCurrentProcess();
  GetProcessAffinityMask(v24, &ProcessAffinityMask, &ProcessAffinityMask);
  v25 = ProcessAffinityMask;
  v26 = GetCurrentThread();
  SetThreadAffinityMask(v26, v25);
  dwLogicalProcessorInformationCount = *v1;
  if ( !dwLogicalProcessorInformationCount )
    return 0;
  pBuffer = malloc(0x18 * dwLogicalProcessorInformationCount);
  dwIndex = 0;
  res = pBuffer;
  if ( dwLogicalProcessorInformationCount )
  {
    pItem = &pBuffer->m_ID;
    do
    {
      v32 = HIDWORD(Buffer[dwIndex]);
      pItem += 0x18;
      ++dwIndex;
      *(pItem - 0x1C) = 0;                      // pBuffer[dwIndex].feild_4=0;
      *(pItem - 0x18) = 1;                      // pBuffer[dwIndex].feild_8=1;
      *(pItem - 0x20) = v32;                    // pBuffer[dwIndex].feild_0=HIDWORD(Buffer[dwIndex]);
    }
    while ( dwIndex < dwLogicalProcessorInformationCount );
  }
  return res;
}

//----- (01245670) --------------------------------------------------------
BOOL __cdecl SetPropSheetRect(HWND hWnd, int x, int y)
{
  int right; // esi
  int bottom_1; // edi
  int ScreenHeight; // eax
  int bottom; // ecx
  int cy; // eax
  int ScreenHight; // eax
  WINDOWPLACEMENT wndpl; // [esp+10h] [ebp-40h]
  RECT Rect; // [esp+3Ch] [ebp-14h]

  right = x;
  bottom_1 = y;
  if ( x < 0 )
    right = 10;
  if ( y < 0 )
    bottom_1 = 10;
  GetClientRect(hWnd, &Rect);
  if ( GetSystemMetrics(SM_CXVIRTUALSCREEN) )
  {
    if ( GetSystemMetrics(SM_CXVIRTUALSCREEN) - Rect.right < right )
      right = GetSystemMetrics(SM_CXVIRTUALSCREEN) - Rect.right;
    ScreenHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    bottom = Rect.bottom;
    if ( ScreenHeight - Rect.bottom < bottom_1 )
    {
      cy = GetSystemMetrics(SM_CYVIRTUALSCREEN);
LABEL_14:
      bottom = Rect.bottom;
      bottom_1 = cy - Rect.bottom;
      goto LABEL_15;
    }
  }
  else
  {
    if ( GetSystemMetrics(SM_CXSCREEN) - Rect.right < right )
      right = GetSystemMetrics(SM_CXSCREEN) - Rect.right;
    ScreenHight = GetSystemMetrics(SM_CYSCREEN);
    bottom = Rect.bottom;
    if ( ScreenHight - Rect.bottom < bottom_1 )
    {
      cy = GetSystemMetrics(SM_CYSCREEN);
      goto LABEL_14;
    }
  }
LABEL_15:
  wndpl.flags = 1;
  wndpl.rcNormalPosition.right = right + Rect.right;
  wndpl.rcNormalPosition.bottom = bottom + bottom_1;
  wndpl.rcNormalPosition.left = right;
  wndpl.rcNormalPosition.top = bottom_1;
  return SetWindowPlacement(hWnd, &wndpl);
}

//----- (01245750) --------------------------------------------------------
char __cdecl sub_1245750(int a1, char a2, wchar_t *Src)
{
  wchar_t *v3; // edi
  LSTATUS v4; // esi
  wchar_t *v5; // esi
  wchar_t *v6; // eax
  const wchar_t *v7; // ebx
  wchar_t *v8; // eax
  int v9; // esi
  wchar_t v10; // ax
  char result; // al
  OLECHAR *psz; // [esp+Ch] [ebp-224h]
  wchar_t *Dst; // [esp+10h] [ebp-220h]
  HWND hWnd; // [esp+14h] [ebp-21Ch]
  unsigned int SizeInWords; // [esp+18h] [ebp-218h]
  DWORD cbData; // [esp+1Ch] [ebp-214h]
  HKEY phkResult; // [esp+20h] [ebp-210h]
  BYTE Data[2]; // [esp+24h] [ebp-20Ch]
  wchar_t v19; // [esp+26h] [ebp-20Ah]

  v3 = Src;
  v4 = RegOpenKeyExW(
         HKEY_CURRENT_USER,
         L"Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
         0,
         0x20019u,
         &phkResult);
  if ( !v4 )
  {
    cbData = 260;
    v4 = RegQueryValueExW(phkResult, L"ProgId", 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
    if ( !v4 )
    {
      wcscat_s(Data, 0x104u, L"\\shell\\open\\command");
      if ( RegOpenKeyExW(HKEY_CLASSES_ROOT, Data, 0, 0x20019u, &phkResult) )
        goto LABEL_22;
      cbData = 260;
      v4 = RegQueryValueExW(phkResult, 0, 0, 0, Data, &cbData);
      RegCloseKey(phkResult);
      if ( !v4 )
        goto LABEL_22;
    }
  }
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, L"http\\shell\\open\\command", 0, 0x20019u, &phkResult) )
  {
    cbData = 260;
    v4 = RegQueryValueExW(phkResult, 0, 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
  }
  if ( v4 )
  {
    MessageBoxW(a1, L"No web browser is configured.", L"Process Explorer Error", 0x10u);
    result = 0;
  }
  else
  {
LABEL_22:
    SizeInWords = wcslen(Data) + wcslen(Src) + 6;
    v5 = malloc(2 * SizeInWords);
    Dst = v5;
    psz = Data;
    if ( *Data == 34 )
    {
      strcpy(Data, "\"");
      psz = &v19;
      v6 = wcschr(&v19, 0x22u);
    }
    else
    {
      v6 = wcschr(Data, 0x20u);
    }
    v7 = v6;
    if ( v6 )
    {
      *v6 = 0;
      v7 = v6 + 1;
    }
    if ( a2 )
    {
      v8 = wcsstr(Data, L"\"%1\"");
      hWnd = v8;
      if ( v8 )
      {
        v9 = v8 - v7;
        wcsncpy_s(Dst, SizeInWords, v7, v9 + 1);
        tcscpy_s(&Dst[v9 + 1], SizeInWords - v9 - 1, L"? ");
        v5 = Dst;
        wcscat_s(Dst, SizeInWords, Src);
        wcscat_s(Dst, SizeInWords, hWnd + 3);
      }
      else
      {
        swprintf_s(v5, SizeInWords, L"\"? %s\"", Src);
      }
    }
    else
    {
      do
      {
        v10 = *v3;
        ++v3;
        *(v3 + v5 - Src - 2) = v10;
      }
      while ( v10 );
    }
    sub_1219580(v5, psz, v5, 0);
    free(v5);
    result = 1;
  }
  return result;
}

//----- (01245A60) --------------------------------------------------------
int __cdecl sub_1245A60(const void *a1, const void *a2)
{
  return _stricmp(*a1, *a2);
}

//----- (01245A80) --------------------------------------------------------
LSTATUS LoadHiddenProcsFromRegistry()
{
  WCHAR **v0; // eax
  LSTATUS result; // eax
  WCHAR *pBuffer; // ebx
  WCHAR *szName; // esi
  int idx; // edi
  TCHAR *pszName; // eax
  __int16 Len; // cx
  TCHAR *pszNameBegin; // [esp+0h] [ebp-10h]
  DWORD Type; // [esp+4h] [ebp-Ch]
  HKEY phkResult; // [esp+8h] [ebp-8h]
  DWORD cbData; // [esp+Ch] [ebp-4h]

  cbData = 0;
  v0 = malloc(4u);
  gpHiddenProcs = v0;
  *v0 = 0;
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", 0, KEY_READ, &phkResult);
  if ( !result )
  {
    if ( !RegQueryValueExW(phkResult, L"HiddenProcs", 0, &Type, 0, &cbData) )
    {
      pBuffer = malloc(cbData);
      RegQueryValueExW(phkResult, L"HiddenProcs", 0, &Type, pBuffer, &cbData);
      szName = pBuffer;
      if ( pBuffer < &pBuffer[cbData] )
      {
        idx = 0;
        do
        {
          if ( !*szName )
            break;
          gpHiddenProcs = realloc(gpHiddenProcs, idx * 4 + 8);
          gpHiddenProcs[idx] = _wcsdup(szName);
          pszName = gpHiddenProcs[idx];
          pszNameBegin = pszName + 2;
          do
          {
            Len = *pszName;
            pszName += 2;
          }
          while ( Len );
          gpHiddenProcs[idx + 1] = 0;
          ++idx;
          szName += ((pszName - pszNameBegin) >> 1) + 1;
        }
        while ( szName < &pBuffer[cbData] );
      }
    }
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (01245BA0) --------------------------------------------------------
LSTATUS RetrieveProcessComments()
{
  DWORD idx; // esi
  LSTATUS result; // eax
  DWORD Type; // [esp+4h] [ebp-814h]
  DWORD cbData; // [esp+8h] [ebp-810h]
  HKEY phkResult; // [esp+Ch] [ebp-80Ch]
  DWORD cchValueName; // [esp+10h] [ebp-808h]
  __int16 ValueName[1024]; // [esp+14h] [ebp-804h]

  idx = 0;
  result = RegOpenKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Sysinternals\\Process Explorer\\ProcessComments",
             0,
             0x20019u,
             &phkResult);
  if ( !result )
  {
    cchValueName = 1024;
    if ( !RegEnumValueW(phkResult, 0, ValueName, &cchValueName, 0, &Type, 0, &cbData) )
    {
      do
      {
        gstrProcessComments = realloc(gstrProcessComments, 8 * idx + 16);
        gstrProcessComments[2 * idx] = _wcsdup(ValueName);
        gstrProcessComments[2 * idx + 1] = malloc(cbData);
        cchValueName += 2;
        RegEnumValueW(phkResult, idx, ValueName, &cchValueName, 0, &Type, gstrProcessComments[2 * idx + 1], &cbData);
        gstrProcessComments[2 * idx + 2] = 0;
        cchValueName = 1024;
        ++idx;
      }
      while ( !RegEnumValueW(phkResult, idx, ValueName, &cchValueName, 0, &Type, 0, &cbData) );
    }
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (01245D10) --------------------------------------------------------
char __cdecl ReplaceTaskMgr(int a1, char bReportError)
{
  DWORD v2; // eax
  DWORD v3; // esi
  char result; // al
  HKEY hKey; // [esp+0h] [ebp-418h]
  WCHAR Data[520]; // [esp+4h] [ebp-414h]

  Data[0] = 0;
  memset(&Data[1], 0, 0x40Eu);
  FillDebuggerInfo(Data, 0x208u);
  v2 = RegCreateKey(
         HKEY_LOCAL_MACHINE,
         L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe",
         &hKey);
  if ( v2 )
  {
    if ( bReportError )
    {
      SetLastError(v2);
      ErrMsgBox(L"Error replacing Task Manager", ghWndNewOwner);
    }
    result = 0;
  }
  else
  {
    v3 = RegSetValueEx(hKey, L"Debugger", 0, 1u, Data, 2 * wcslen(Data) + 2);
    RegCloseKey(hKey);
    if ( v3 )
    {
      if ( bReportError )
      {
        SetLastError(v3);
        ErrMsgBox(L"Error replacing Task Manager", ghWndNewOwner);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}

//----- (01245E40) --------------------------------------------------------
char __thiscall sub_1245E40(HKEY this)
{
  DWORD v1; // eax
  HKEY phkResult; // [esp+0h] [ebp-4h]

  phkResult = this;
  if ( !TaskMgrIsDebugger() )
    return 1;
  v1 = RegOpenKeyW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe",
         &phkResult);
  if ( !v1 )
  {
    RegDeleteValueW(phkResult, L"Debugger");
    RegCloseKey(phkResult);
    return 1;
  }
  SetLastError(v1);
  ErrMsgBox(L"Error restoring Task Manager", ghWndNewOwner);
  return 0;
}

//----- (01245EB0) --------------------------------------------------------
DWORD __cdecl StartProcExp64(int bWait, WORD wShowMode)
{
  DWORD result; // eax
  unsigned __int16 nBinResId; // si
  wchar_t *pszText; // eax
  WCHAR *lpszCommandLine; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+0h] [ebp-46Ch]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+44h] [ebp-428h]
  HKEY phkResult; // [esp+54h] [ebp-418h]
  WCHAR szEnvCmd[260]; // [esp+58h] [ebp-414h]
  WCHAR szFileName[260]; // [esp+260h] [ebp-20Ch]

  StartupInfo.cb = sizeof(_STARTUPINFOW);
  StartupInfo.lpReserved = 0;
  memset(&StartupInfo.lpDesktop, 0, 0x3Cu);
  _mm_storeu_si128(&ProcessInformation, 0i64);
  result = GetModuleFileNameW(NULL, szFileName, 0x103u);
  if ( result )
  {
    if ( !RegCreateKey(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &phkResult) )
    {
      RegSetValueEx(phkResult, L"OriginalPath", 0, REG_SZ, szFileName, 2 * wcslen(szFileName));
      RegCloseKey(phkResult);
    }
    *wcsrchr(szFileName, '.') = 0;
    wcscat_s(szFileName, _MAX_PATH, L"64.exe");
    if ( gSystemInfo.anonymous_0.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 )
    {
      nBinResId = 153;
    }
    else
    {
      if ( gSystemInfo.anonymous_0.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64 )
      {
        stprintf(szFileName, L"Unsupported processor type: %d\n", gSystemInfo.anonymous_0.wProcessorArchitecture);
        MessageBoxW(0, szFileName, L"Process Explorer", MB_ICONERROR);
        return FALSE;
      }
      nBinResId = 152;
    }
    ExpandEnvironmentStringsW(L"%TEMP%", szEnvCmd, _MAX_PATH);
    pszText = wcsrchr(szFileName, '\\');
    wcscat_s(szEnvCmd, _MAX_PATH, pszText);
    tcscpy_s(szFileName, _MAX_PATH, szEnvCmd);
    if ( !CDriver::LoadFromResource(nBinResId, szFileName) && GetFileAttributesW(szFileName) == INVALID_HANDLE_VALUE )
      return FALSE;
    if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &phkResult) )
    {
      RegSetValueEx(phkResult, L"Path", 0, REG_SZ, szFileName, 2 * wcslen(szFileName));
      RegCloseKey(phkResult);
    }
    StartupInfo.wShowWindow = wShowMode;
    StartupInfo.dwFlags = SW_NORMAL;
    lpszCommandLine = GetCommandLineW();
    if ( !CreateProcessW(szFileName, lpszCommandLine, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation) )
      return FALSE;
    if ( bWait )
    {
      WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
      DeleteFileW(szFileName);
    }
    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);
    result = TRUE;
  }
  return result;
}

//----- (01246180) --------------------------------------------------------
DWORD __cdecl ExecuteProcess(const WCHAR *pParameters, int nShowCmd, char fWaiting)
{
  SHELLEXECUTEINFOW pExecInfo; // [esp+4h] [ebp-450h]
  TCHAR szFileName[520]; // [esp+40h] [ebp-414h]

  FillDebuggerInfo(szFileName, 0x208u);
  memset(&pExecInfo, 0, 0x3Cu);
  pExecInfo.nShow = nShowCmd;
  pExecInfo.lpFile = szFileName;
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 0x40;
  pExecInfo.hwnd = 0;
  pExecInfo.lpVerb = L"Runas";
  pExecInfo.pParameters = pParameters;
  if ( !ShellExecuteExW(&pExecInfo) )
    return GetLastError();
  if ( fWaiting )
    WaitForSingleObject(pExecInfo.hProcess, INFINITE);
  CloseHandle(pExecInfo.hProcess);
  return 0;
}

//----- (01246260) --------------------------------------------------------
ULONG IsX64()
{
  HMODULE v0; // eax
  void (__stdcall *v1)(); // esi
  ULONG bWow64Process; // [esp+4h] [ebp-4h]

  bWow64Process = 0;
  v0 = GetModuleHandle(L"kernel32.dll");
  v1 = GetProcAddress(v0, "IsWow64Process");
  if ( v1 )
  {
    GetCurrentProcess();
    v1();
  }
  return bWow64Process;
}

//----- (012462A0) --------------------------------------------------------
LSTATUS __cdecl sub_12462A0(int a1, wchar_t *a2)
{
  int v2; // eax
  const wchar_t *v3; // ebx
  int v4; // edi
  #1077 *v5; // esi
  const wchar_t *v6; // eax
  const wchar_t *v7; // eax
  LRESULT v8; // eax
  WCHAR **v9; // ecx
  int v10; // eax
  int v11; // esi
  LSTATUS result; // eax
  LPCWSTR *v13; // edx
  const BYTE *v14; // esi
  LPARAM lParam; // [esp+Ch] [ebp-1Ch]
  #1077 *v16; // [esp+14h] [ebp-14h]
  HKEY phkResult; // [esp+24h] [ebp-4h]

  v2 = a1;
  v3 = *(a1 + 792);
  v4 = 0;
  if ( !v3 )
    v3 = *(a1 + 60);
  v5 = gpTreeListParamList;
  if ( gpTreeListParamList )
  {
    do
    {
      if ( *(v2 + 792) && (v6 = *(v5 + 198)) != 0 && !_wcsicmp(v6, v3) || (v7 = *(v5 + 15)) != 0 && !_wcsicmp(v7, v3) )
      {
        free(*(v5 + 199));
        *(v5 + 199) = *a2 ? _wcsdup(a2) : 0;
        lParam = 1;
        v16 = v5;
        v8 = SendMessageW(ghWndTreeListView, 0x1053u, 0xFFFFFFFF, &lParam);
        if ( v8 != -1 )
          PostMessageW(ghWndNewOwner, 0x7EBu, v8, -1);
      }
      v5 = *(v5 + 364);
      v2 = a1;
    }
    while ( v5 );
    v4 = 0;
  }
  v9 = gstrProcessComments;
  if ( !gstrProcessComments )
    goto LABEL_33;
  if ( *gstrProcessComments )
  {
    v10 = 0;
    while ( _wcsicmp(v9[v10], v3) )
    {
      v9 = gstrProcessComments;
      v10 = 2 * ++v4;
      if ( !gstrProcessComments[2 * v4] )
        goto LABEL_23;
    }
    free(gstrProcessComments[2 * v4 + 1]);
    gstrProcessComments[2 * v4 + 1] = _wcsdup(a2);
    v9 = gstrProcessComments;
  }
LABEL_23:
  if ( !v9 )
    goto LABEL_33;
  v11 = 2 * v4;
  if ( !v9[2 * v4] )
  {
LABEL_33:
    gstrProcessComments = realloc(v9, 8 * v4 + 16);
    v11 = 2 * v4;
    gstrProcessComments[v11] = _wcsdup(v3);
    gstrProcessComments[v11 + 1] = _wcsdup(a2);
    gstrProcessComments[v11 + 2] = 0;
  }
  result = RegCreateKey(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer\\ProcessComments", &phkResult);
  if ( !result )
  {
    v13 = &gstrProcessComments[v11];
    v14 = gstrProcessComments[v11 + 1];
    if ( *v14 )
      RegSetValueEx(phkResult, *v13, 0, 1u, v14, 2 * wcslen(v14) + 2);
    else
      RegDeleteValueW(phkResult, *v13);
    result = RegCloseKey(phkResult);
  }
  return result;
}

//----- (012464C0) --------------------------------------------------------
char __cdecl sub_12464C0(HWND hWnd, LPCWSTR lpFileName)
{
  HANDLE v2; // esi
  char result; // al
  HCURSOR v4; // eax
  LVITEMW lParam; // [esp+8h] [ebp-10048h]
  HCURSOR hCursor; // [esp+3Ch] [ebp-10014h]
  DWORD NumberOfBytesRead; // [esp+40h] [ebp-10010h]
  char Buffer; // [esp+44h] [ebp-1000Ch]

  v2 = CreateFile(lpFileName, 0x80000000, 3u, 0, 3u, 0, 0);
  if ( v2 == -1 )
  {
    lParam.mask = 5;
    lParam.iItem = 0x7FFFFFFF;
    lParam.pszText = L"<Error opening file>";
    lParam.lParam = 1;
    SendMessageW(hWnd, 0x104Du, 0, &lParam);
    result = 0;
  }
  else
  {
    v4 = ghArrowCursor;
    if ( !ghArrowCursor )
    {
      v4 = LoadCursorW(ghArrowCursor, IDC_WAIT);
      ghArrowCursor = v4;
    }
    hCursor = SetCursor(v4);
    while ( ReadFile(v2, &Buffer, 65544u, &NumberOfBytesRead, 0) )
    {
      if ( !NumberOfBytesRead )
        break;
      GetStringFromMemory(hWnd, 3u, &Buffer, NumberOfBytesRead);
      if ( NumberOfBytesRead == 65544 )
        SetFilePointer(v2, -2, 0, 1u);
    }
    CloseHandle(v2);
    SetCursor(hCursor);
    result = 1;
  }
  return result;
}
// 12BEBF4: using guessed type wchar_t aErrorOpeningFi[21];

//----- (01246620) --------------------------------------------------------
HCURSOR __cdecl sub_1246620(HWND hList, HANDLE hProcess, LPCVOID lpBaseAddress, int dwBytesToRead)
{
  HCURSOR v4; // eax
  char *pAddress; // edi
  unsigned int dwBytesRead; // esi
  SIZE_T dwSize; // ecx
  HCURSOR hCursor; // [esp+Ch] [ebp-10010h]
  SIZE_T NumberOfBytesRead; // [esp+14h] [ebp-10008h]
  char Buffer[65536]; // [esp+18h] [ebp-10004h]

  v4 = ghArrowCursor;
  pAddress = lpBaseAddress;
  if ( !ghArrowCursor )
  {
    v4 = LoadCursorW(ghArrowCursor, IDC_WAIT);
    ghArrowCursor = v4;
  }
  dwBytesRead = dwBytesToRead;
  hCursor = SetCursor(v4);
  do
  {
    dwSize = dwBytesRead;
    if ( dwBytesRead > 65536 )
      dwSize = 65536;
    NumberOfBytesRead = dwSize;
    if ( !ReadProcessMemory(hProcess, pAddress, Buffer, dwSize, &NumberOfBytesRead) )
      break;
    GetStringFromMemory(hList, 3u, Buffer, NumberOfBytesRead);
    dwBytesRead -= NumberOfBytesRead;
    pAddress += NumberOfBytesRead;
    if ( NumberOfBytesRead == 65536 )
    {
      dwBytesRead += 2;
      pAddress -= 2;
    }
  }
  while ( dwBytesRead );
  return SetCursor(hCursor);
}

//----- (01246710) --------------------------------------------------------
int __cdecl sub_1246710(int a1, HDC hdc)
{
  if ( !dword_12E9E8C )
    dword_12E9E8C = CreateSolidBrush(0xFFFFFFu);
  SetBkColor(hdc, 0xFFFFFFu);
  return dword_12E9E8C;
}
// 12E9E8C: using guessed type int dword_12E9E8C;

//----- (01246750) --------------------------------------------------------
int __cdecl sub_1246750(HLOCAL *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax
  _DWORD *v5; // edx
  int v6; // [esp+Ch] [ebp-8h]
  _DWORD *v7; // [esp+10h] [ebp-4h]

  if ( *a1 )
  {
    LocalFree(*a1);
    *a4 = 0;
    *a3 = 0;
  }
  v6 = a2;
  v7 = 0;
  result = I_QueryTagInformation(0, 3, &v6);
  if ( !result )
  {
    v5 = v7;
    *a3 = *v7;
    *a4 = v5[1];
    *a1 = v5;
  }
  return result;
}
// 12EB204: using guessed type int (__stdcall *I_QueryTagInformation)(_DWORD, _DWORD, _DWORD);

//----- (012467B0) --------------------------------------------------------
BOOL __cdecl AddShellIcon(int hWnd, int nID, void *pInfo, wchar_t *lpszTipText)
{
  HICON hicon; // edi
  BOOL ret; // esi
  struct _NOTIFYICONDATAW Data; // [esp+14h] [ebp-3CCh]
  int a3a[4]; // [esp+3CCh] [ebp-14h]

  _mm_storeu_si128(a3a, _mm_load_si128(&xmmword_12BF270));
  memset(&Data, 0, 952u);
  Data.uID = nID;
  Data.cbSize = 952;
  Data.hWnd = hWnd;
  Data.uFlags = 7;                              // NIF_MESSAGE |NIM_ICON|NIM_TIP
  Data.uCallbackMessage = WM_SHELLNOTIFY_MSG;
  hicon = PEDrawIcon(pInfo, 0, a3a, gColorGraphBackground, 0, 0.0);
  Data.hIcon = hicon;
  if ( lpszTipText )
    wcsncpy_s(Data.szTip, 0x80u, lpszTipText, 0xFFFFFFFF);
  else
    Data.szTip[0] = 0;
  ret = Shell_NotifyIconW(NIM_ADD, &Data);
  DestroyIcon(hicon);
  return ret;
}
// 12BF270: using guessed type __int128 xmmword_12BF270;

//----- (012468A0) --------------------------------------------------------
BOOL __cdecl RemoveShellIcon(HWND hWnd, UINT uID)
{
  struct _NOTIFYICONDATAW Data; // [esp+4h] [ebp-3BCh]

  memset(&Data, 0, 0x3B8u);
  Data.uID = uID;
  Data.cbSize = 952;
  Data.hWnd = hWnd;
  return Shell_NotifyIconW(NIM_DELETE, &Data);
}

//----- (01246910) --------------------------------------------------------
BOOL __cdecl UpdateTrayIcon(HWND hWnd, UINT uID, HICON hIcon, TCHAR *lpszTipText)
{
  NOTIFYICONDATAW NotifyIconData; // [esp+Ch] [ebp-3BCh]

  tcscpy_s(g_strTrayIconTipText, 0x100u, lpszTipText);
  memset(&NotifyIconData, 0, 0x3B8u);
  NotifyIconData.cbSize = 0x3B8;
  NotifyIconData.hWnd = hWnd;
  NotifyIconData.uID = uID;
  NotifyIconData.uFlags = 6;                    // NIF_ICON|NIF_TEXT
  NotifyIconData.hIcon = hIcon;
  if ( lpszTipText )
    wcsncpy_s(NotifyIconData.szTip, 0x80u, lpszTipText, 0xFFFFFFFF);
  else
    NotifyIconData.szTip[0] = 0;
  return Shell_NotifyIconW(NIM_MODIFY, &NotifyIconData);
}

//----- (012469D0) --------------------------------------------------------
BOOL __cdecl sub_12469D0(TREELISTITEMPARAM *a1)
{
  char v1; // bl
  int v2; // eax
  bool v3; // zf
  const WCHAR *v4; // eax
  const WCHAR *v5; // ST10_4
  HMENU v6; // eax
  _WORD *v7; // eax
  HMENU v8; // eax

  v1 = 0;
  v2 = a1[1].field_140[3];
  if ( !v2 || (v3 = *(v2 + 4) == 6, v4 = L"&Submit to VirusTotal", !v3) )
    v4 = L"&Check VirusTotal";
  v5 = v4;
  v6 = GetMenu(ghWndNewOwner);
  ModifyMenuW(
    v6,
    IDS_PROCEXPLORERMENU_PROCESS_CHECK_VIRUSTOTALCOM,
    0,
    IDS_PROCEXPLORERMENU_PROCESS_CHECK_VIRUSTOTALCOM,
    v5);
  v7 = a1[1].field_100[6];
  if ( v7 )
  {
    if ( *v7 != 91 )
    {
      v1 = 0;
      if ( sub_1281C10(a1[1].field_140[3]) )
        v1 = 1;
    }
  }
  v8 = GetMenu(ghWndNewOwner);
  return EnableMenuItem(v8, IDS_PROCEXPLORERMENU_PROCESS_CHECK_VIRUSTOTALCOM, v1 == 0);
}
// 12BE374: using guessed type wchar_t aCheckVirustota[18];

//----- (01246A70) --------------------------------------------------------
BOOL __cdecl CheckProcessWindowMenuItems(void *a1)
{
  HMENU hMainMenu; // edi
  HWND v2; // eax
  HMENU v3; // eax
  BOOL result; // eax
  HMENU v5; // eax
  BOOL v6; // eax
  BOOL v7; // eax
  BOOL v8; // eax

  hMainMenu = GetMenu(ghWndNewOwner);
  v2 = FindWindowByPid(*(a1 + 0x11));
  *(a1 + 0x9A) = v2;
  if ( v2 )
  {
    v5 = GetSubMenu(hMainMenu, 3);
    EnableMenuItem(v5, 0, MF_BYPOSITION);
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT, 0);
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_CLOSE, 0);
    v6 = !IsIconic(*(a1 + 0x9A)) && !IsZoomed(*(a1 + 0x9A));
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_RESTORE, v6);
    v7 = IsIconic(*(a1 + 0x9A));
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MINIMIZE, v7 != 0);
    v8 = IsZoomed(*(a1 + 0x9A));
    result = EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MAXIMIZE, v8 != 0);
  }
  else
  {
    v3 = GetSubMenu(hMainMenu, 3);
    EnableMenuItem(v3, 0, 0x401u);
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT, 1u);
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_CLOSE, 1u);
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_RESTORE, 1u);
    EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MINIMIZE, 1u);
    result = EnableMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MAXIMIZE, 1u);
  }
  return result;
}

//----- (01246B90) --------------------------------------------------------
bool __cdecl ShowMainWindow(HWND hWnd, int uMenuId, int dwPid)
{
  HWND hwnd; // esi
  HMODULE v5; // eax
  FARPROC v6; // eax
  HWND v7; // ecx

  hwnd = FindWindowByPid(dwPid);
  if ( !hwnd )
  {
    v7 = ghWndNewOwner;
    if ( hWnd )
      v7 = hWnd;
    MessageBoxW(v7, L"No visible windows found for this process", L"Process Explorer Warning", 0x30u);
    return hwnd != 0;
  }
  if ( uMenuId <= IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MINIMIZE )
  {
    if ( uMenuId == IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MINIMIZE )
    {
      ShowWindowAsync(hwnd, SW_MINIMIZE);
      return hwnd != 0;
    }
    if ( uMenuId == IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT )
    {
      if ( IsIconic(hwnd) )
        ShowWindowAsync(hwnd, SW_RESTORE);
      SetForegroundWindow(hwnd);
      return hwnd != 0;
    }
    return hwnd != 0;
  }
  if ( uMenuId == IDS_PROCEXPLORERMENU_PROCESS_WINDOW_MAXIMIZE )
  {
    ShowWindowAsync(hwnd, SW_SHOWMAXIMIZED);
    return hwnd != 0;
  }
  if ( uMenuId != IDS_PROCEXPLORERMENU_PROCESS_WINDOW_CLOSE )
  {
    if ( uMenuId == 40641 )
    {
      ShowWindowAsync(hwnd, SW_RESTORE);
      return hwnd != 0;
    }
    return hwnd != 0;
  }
  v5 = GetModuleHandle(L"user32.dll");
  v6 = GetProcAddress(v5, "EndTask");
  if ( v6 )
    (v6)(hwnd, 0, 0);
  else
    PostMessageW(hwnd, WM_CLOSE, 0, 0);
  return hwnd != 0;
}

//----- (01246C90) --------------------------------------------------------
LSTATUS sub_1246C90()
{
  int v0; // ebx
  int v1; // esi
  LSTATUS result; // eax
  WCHAR **v3; // edi
  WCHAR **v4; // eax
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  rsize_t v8; // ebx
  wchar_t *v9; // eax
  int v10; // esi
  int v11; // edx
  WCHAR *v12; // ecx
  int v13; // esi
  WCHAR v14; // ax
  int v15; // ecx
  BYTE *lpData; // [esp+8h] [ebp-14h]
  wchar_t *v17; // [esp+10h] [ebp-Ch]
  int v18; // [esp+14h] [ebp-8h]
  HKEY phkResult; // [esp+18h] [ebp-4h]

  v0 = 0;
  v1 = 0;
  result = RegCreateKey(HKEY_CURRENT_USER, L"Software\\Sysinternals\\Process Explorer", &phkResult);
  if ( !result )
  {
    v3 = gpHiddenProcs;
    if ( *gpHiddenProcs )
    {
      v4 = gpHiddenProcs;
      do
      {
        v5 = *v4;
        ++v1;
        v6 = (v5 + 1);
        do
        {
          v7 = *v5;
          ++v5;
        }
        while ( v7 );
        v0 += ((v5 - v6) >> 1) + 1;
        v4 = &gpHiddenProcs[v1];
      }
      while ( gpHiddenProcs[v1] );
    }
    v8 = v0 + 1;
    if ( v1 )
    {
      v9 = malloc(2 * v8);
      lpData = v9;
      v18 = 0;
      v17 = v9;
      if ( *v3 )
      {
        v10 = 0;
        do
        {
          tcscpy_s(v9, v8, *v3);
          v11 = v18++ + 1;
          v12 = gpHiddenProcs[v10];
          v13 = (v12 + 1);
          do
          {
            v14 = *v12;
            ++v12;
          }
          while ( v14 );
          v15 = (v12 - v13) >> 1;
          v10 = v11;
          v3 = &gpHiddenProcs[v11];
          v9 = &v17[v15 + 1];
          v17 += v15 + 1;
        }
        while ( *v3 );
      }
      *v9 = 0;
      RegSetValueEx(phkResult, L"HiddenProcs", 0, 7u, lpData, 2 * v8);
      result = RegCloseKey(phkResult);
    }
    else
    {
      RegDeleteValueW(phkResult, L"HiddenProcs");
      result = RegCloseKey(phkResult);
    }
  }
  return result;
}

//----- (01246DB0) --------------------------------------------------------
HANDLE __cdecl sub_1246DB0(HANDLE TokenHandle)
{
  DWORD v1; // esi
  unsigned int *v2; // ebx
  int v3; // edi
  unsigned int v4; // esi
  unsigned int *v5; // ecx
  unsigned int v6; // eax
  const __m128i *v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // edx
  _DWORD *v10; // eax
  char *v11; // edx
  void *v12; // ebx
  HMODULE v13; // eax
  FARPROC v14; // eax
  DWORD v15; // eax
  DWORD v16; // esi
  DWORD v17; // eax
  DWORD v18; // esi
  ACL *v19; // edi
  ACL *v20; // ecx
  DWORD v21; // esi
  void *v22; // esi
  struct _SID_AND_ATTRIBUTES SidsToDisable; // [esp+4h] [ebp-6Ch]
  LPVOID pAce; // [esp+Ch] [ebp-64h]
  PSECURITY_DESCRIPTOR ppSecurityDescriptor; // [esp+10h] [ebp-60h]
  ACL *v27; // [esp+14h] [ebp-5Ch]
  HANDLE ExistingTokenHandle; // [esp+18h] [ebp-58h]
  PSID TokenInformation; // [esp+1Ch] [ebp-54h]
  int v30; // [esp+20h] [ebp-50h]
  DWORD TokenInformationLength; // [esp+24h] [ebp-4Ch]
  PSID hMem; // [esp+28h] [ebp-48h]
  PSID AccountSid; // [esp+2Ch] [ebp-44h]
  PSID pSid; // [esp+30h] [ebp-40h]
  void *v35; // [esp+34h] [ebp-3Ch]
  PACL ppDacl; // [esp+38h] [ebp-38h]
  unsigned int v37; // [esp+3Ch] [ebp-34h]
  DWORD ReturnLength; // [esp+40h] [ebp-30h]
  void *v39; // [esp+44h] [ebp-2Ch]
  HANDLE handle; // [esp+48h] [ebp-28h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+4Ch] [ebp-24h]
  __int128 v42; // [esp+54h] [ebp-1Ch]
  __int64 v43; // [esp+64h] [ebp-Ch]

  _mm_storeu_si128(&v42, _mm_loadu_si128(L"S-1-16-4096"));
  ExistingTokenHandle = TokenHandle;
  *pIdentifierAuthority.Value = 0;
  *&pIdentifierAuthority.Value[4] = 1280;
  pSid = 0;
  AccountSid = 0;
  handle = 0;
  v43 = *L"096";
  hMem = 0;
  TokenInformation = 0;
  v30 = 0;
  AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &pSid);
  SidsToDisable.Sid = pSid;
  SidsToDisable.Attributes = 0;
  GetTokenInformation(TokenHandle, TokenPrivileges, 0, 0, &ReturnLength);
  v1 = ReturnLength;
  v35 = malloc(ReturnLength);
  GetTokenInformation(TokenHandle, TokenPrivileges, v35, v1, &ReturnLength);
  v39 = malloc(ReturnLength);
  *v39 = 0;
  AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x221u, 0, 0, 0, 0, 0, 0, &AccountSid);
  v2 = sub_1247450(AccountSid);
  if ( !v2 )
  {
    v2 = malloc(0x4Cu);
    v3 = 0;
    v4 = 0;
    *v2 = 0;
    do
    {
      if ( LookupPrivilegeValueW(0, off_12DE0BC[v4], &v2[v3 + 1]) )
        ++*v2;
      ++v4;
      v3 += 3;
    }
    while ( v4 < 5 );
  }
  v5 = v35;
  v6 = 0;
  v37 = 0;
  if ( *v35 )
  {
    v7 = (v35 + 4);
    do
    {
      v8 = *v2;
      v9 = 0;
      if ( *v2 )
      {
        v10 = v2 + 1;
        do
        {
          if ( v7->m128i_i32[0] == *v10 && v7->m128i_i32[1] == v10[1] )
            break;
          ++v9;
          v10 += 3;
        }
        while ( v9 < v8 );
        v6 = v37;
        v5 = v35;
      }
      if ( v9 == v8 )
      {
        v11 = v39 + 12 * *v39;
        v5 = v35;
        ++*v39;
        _mm_storel_epi64((v11 + 4), _mm_loadl_epi64(v7));
        *(v11 + 3) = v7->m128i_i32[2];
        v6 = v37;
      }
      ++v6;
      v7 = (v7 + 12);
      v37 = v6;
    }
    while ( v6 < *v5 );
  }
  free(v5);
  free(v2);
  v12 = v39;
  if ( CreateRestrictedToken(ExistingTokenHandle, 0, 1u, &SidsToDisable, *v39, (v39 + 4), 0, 0, &handle) )
  {
    v13 = LoadLibraryW(L"Advapi32.dll");
    v14 = GetProcAddress(v13, "ConvertStringSidToSidA");
    *ConvertStringSidToSidA = v14;
    if ( v14 && (v14)(&v42, &hMem) )
    {
      v30 = 32;
      TokenInformation = hMem;
      v15 = GetLengthSid(hMem);
      SetTokenInformation(handle, TokenIntegrityLevel, &TokenInformation, v15 + 8);
      LocalFree(hMem);
    }
  }
  else
  {
    handle = 0;
  }
  GetTokenInformation(handle, TokenUser, 0, 0, &TokenInformationLength);
  v16 = TokenInformationLength;
  v39 = malloc(TokenInformationLength);
  GetTokenInformation(handle, TokenUser, v39, v16, &TokenInformationLength);
  GetSecurityInfo(handle, SE_KERNEL_OBJECT, 4u, 0, 0, &ppDacl, 0, &ppSecurityDescriptor);
  v17 = GetLengthSid(*v39);
  v18 = v17 + ppDacl->AclSize + 8;
  v19 = malloc(v17 + ppDacl->AclSize + 8);
  InitializeAcl(v19, v18, 2u);
  v20 = ppDacl;
  v21 = 0;
  if ( ppDacl->AceCount > 0u )
  {
    do
    {
      GetAce(v20, v21, &pAce);
      AddAce(v19, 2u, v21, pAce, *(pAce + 1));
      v20 = ppDacl;
      ++v21;
    }
    while ( v21 < ppDacl->AceCount );
  }
  v22 = v39;
  AddAccessAllowedAce(v19, 2u, 0x10000000u, *v39);
  SetSecurityInfo(handle, SE_KERNEL_OBJECT, 4u, 0, 0, v19, 0);
  v27 = v19;
  SetTokenInformation(handle, TokenDefaultDacl, &v27, v19->AclSize);
  free(v19);
  free(v22);
  LocalFree(ppSecurityDescriptor);
  FreeSid(pSid);
  FreeSid(AccountSid);
  free(v12);
  return handle;
}
// 12BF37C: using guessed type wchar_t gszS1164096[12];
// 12DE0BC: using guessed type wchar_t *off_12DE0BC[5];

//----- (01247140) --------------------------------------------------------
BOOL __cdecl GetSidIndentityAuthInfo(wchar_t **szSidIndentityAuthInfo)
{
  HANDLE v1; // eax
  wchar_t *v2; // eax
  HANDLE TokenHandle; // [esp+4h] [ebp-80Ch]
  DWORD ReturnLength; // [esp+8h] [ebp-808h]
  int TokenInformation[512]; // [esp+Ch] [ebp-804h]

  v1 = GetCurrentProcess();
  OpenProcessToken(v1, TOKEN_QUERY, &TokenHandle);
  ReturnLength = 2048;
  GetTokenInformation(TokenHandle, TokenUser, TokenInformation, 0x800u, &ReturnLength);
  ReturnLength = 0;
  FormatSID(TokenInformation[0], *szSidIndentityAuthInfo, &ReturnLength);
  v2 = malloc(2 * ReturnLength);
  *szSidIndentityAuthInfo = v2;
  FormatSID(TokenInformation[0], v2, &ReturnLength);
  return CloseHandle(TokenHandle);
}

//----- (01247200) --------------------------------------------------------
BOOL __cdecl FormatSID(PSID pSid, wchar_t *szText, DWORD *pdwLength)
{
  BOOL result; // eax
  PSID_IDENTIFIER_AUTHORITY pIdentity; // edi
  DWORD dwLength; // ecx
  int nRet; // eax
  int v7; // esi
  int res; // eax
  DWORD dwIndex; // edi
  int nOffset; // esi
  PDWORD dwAuth; // eax
  DWORD dwCount; // [esp+4h] [ebp-4h]

  result = IsValidSid(pSid);
  if ( result )
  {
    pIdentity = GetSidIdentifierAuthority(pSid);
    dwCount = *GetSidSubAuthorityCount(pSid);
    dwLength = 12 * dwCount + 28;
    if ( *pdwLength >= dwLength )
    {
      nRet = swprintf_s(szText, *pdwLength, L"S-%lu-", 1);
      v7 = nRet;
      if ( pIdentity->Value[0] || pIdentity->Value[1] )
        res = swprintf_s(
                &szText[nRet],
                *pdwLength - nRet,
                L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                // Identifier authority    Value
                // SECURITY_NULL_SID_AUTHORITY 0
                // SECURITY_WORLD_SID_AUTHORITY    1
                // SECURITY_LOCAL_SID_AUTHORITY    2
                // SECURITY_CREATOR_SID_AUTHORITY  3
                // SECURITY_NON_UNIQUE_AUTHORITY   4
                // SECURITY_NT_AUTHORITY   5
                // SECURITY_RESOURCE_MANAGER_AUTHORITY 9
                pIdentity->Value[0],
                pIdentity->Value[1],
                pIdentity->Value[2],
                pIdentity->Value[3],
                pIdentity->Value[4],
                pIdentity->Value[5]);
      else
        res = swprintf_s(
                &szText[nRet],
                *pdwLength - nRet,
                L"%lu",
                pIdentity->Value[5]
              + ((pIdentity->Value[4] + ((pIdentity->Value[3] + (pIdentity->Value[2] << 8)) << 8)) << 8));
      dwIndex = 0;
      nOffset = res + v7;
      if ( dwCount )
      {
        do
        {
          dwAuth = GetSidSubAuthority(pSid, dwIndex++);
          nOffset += swprintf_s(&szText[nOffset], *pdwLength - nOffset, L"-%lu", *dwAuth);
        }
        while ( dwIndex < dwCount );
      }
      result = 1;
    }
    else
    {
      *pdwLength = dwLength;
      SetLastError(ERROR_INSUFFICIENT_BUFFER);
      result = 0;
    }
  }
  return result;
}

//----- (01247330) --------------------------------------------------------
char IsBuiltinAndAnministrative()
{
  HANDLE hProcess; // eax
  DWORD TokenInfoSize; // esi
  _TOKEN_GROUPS *TokenInformation; // ebx
  DWORD nGroupIndex; // edi
  bool v4; // zf
  _SID_AND_ATTRIBUTES *v5; // esi
  DWORD ReturnLength; // [esp+0h] [ebp-18h]
  PSID pSid; // [esp+4h] [ebp-14h]
  HANDLE TokenHandle; // [esp+8h] [ebp-10h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+Ch] [ebp-Ch]

  *pIdentifierAuthority.Value = 0;
  *&pIdentifierAuthority.Value[4] = 0x500;
  pSid = 0;
  if ( !sbInited )
  {
    hProcess = GetCurrentProcess();
    OpenProcessToken(hProcess, TOKEN_QUERY, &TokenHandle);
    //  // Create a SID for the BUILTIN\Administrators group.
    AllocateAndInitializeSid(
      &pIdentifierAuthority,
      2u,
      SECURITY_BUILTIN_DOMAIN_RID,
      DOMAIN_ALIAS_RID_ADMINS,
      0,
      0,
      0,
      0,
      0,
      0,
      &pSid);
    GetTokenInformation(TokenHandle, TokenGroups, 0, 0, &ReturnLength);
    TokenInfoSize = ReturnLength;
    TokenInformation = malloc(ReturnLength);
    if ( GetTokenInformation(TokenHandle, TokenGroups, TokenInformation, TokenInfoSize, &ReturnLength) )
    {
      nGroupIndex = 0;
      v4 = TokenInformation->GroupCount == 0;
      if ( TokenInformation->GroupCount > 0 )
      {
        v5 = &TokenInformation[1];
        do
        {
          if ( EqualSid(pSid, v5[-1].Attributes) && v5->Sid & 4 && v5->Sid & 0xFFFFFFEF )
            break;
          ++nGroupIndex;
          ++v5;
        }
        while ( nGroupIndex < TokenInformation->GroupCount );
        v4 = nGroupIndex == TokenInformation->GroupCount;
      }
      gbHasBuiltinAndAnministrativePriviledge = !v4;
    }
    free(TokenInformation);
    FreeSid(pSid);
    CloseHandle(TokenHandle);
    sbInited = 1;
  }
  return gbHasBuiltinAndAnministrativePriviledge;
}
// 12EA094: using guessed type char sbInited;
// 12EA095: using guessed type char gbHasBuiltinAndAnministrativePriviledge;

//----- (01247450) --------------------------------------------------------
_DWORD *__cdecl sub_1247450(PSID AccountSid)
{
  _DWORD *v1; // ebx
  ULONG v2; // esi
  _DWORD *v3; // eax
  ULONG v4; // esi
  struct _LUID *v5; // edi
  struct _LSA_OBJECT_ATTRIBUTES ObjectAttributes; // [esp+4h] [ebp-24h]
  PVOID PolicyHandle; // [esp+1Ch] [ebp-Ch]
  PLSA_UNICODE_STRING UserRights; // [esp+20h] [ebp-8h]
  ULONG CountOfRights; // [esp+24h] [ebp-4h]

  *&ObjectAttributes.SecurityDescriptor = 0i64;
  v1 = 0;
  _mm_storeu_si128(&ObjectAttributes, 0i64);
  if ( !LsaOpenPolicy(0, &ObjectAttributes, 0x800u, &PolicyHandle) )
  {
    if ( !LsaEnumerateAccountRights(PolicyHandle, AccountSid, &UserRights, &CountOfRights) )
    {
      v2 = CountOfRights;
      if ( CountOfRights )
      {
        v3 = malloc(12 * CountOfRights + 16);
        v1 = v3;
        *v3 = v2;
        v4 = 0;
        if ( CountOfRights )
        {
          v5 = (v3 + 1);
          do
          {
            LookupPrivilegeValueW(0, UserRights[v4++].Buffer, v5);
            v5 = (v5 + 12);
          }
          while ( v4 < CountOfRights );
        }
        LsaFreeMemory(UserRights);
      }
    }
    LsaClose(PolicyHandle);
  }
  return v1;
}

//----- (01247500) --------------------------------------------------------
int sub_1247500(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x80u, Format, ArgList);
}

//----- (01247520) --------------------------------------------------------
_DWORD *__thiscall sub_1247520(_DWORD *this, int (__stdcall ***a2)(_DWORD, void *, _DWORD *))
{
  _DWORD *v2; // esi
  bool v3; // sf
  _DWORD *result; // eax

  v2 = this;
  *this = 0;
  if ( !a2 )
    return this;
  v3 = (**a2)(a2, &stru_12BFC40, this) < 0;
  result = v2;
  if ( v3 )
    *v2 = 0;
  return result;
}
// 12BFC40: using guessed type GUID stru_12BFC40;

//----- (01247560) --------------------------------------------------------
_DWORD *__thiscall sub_1247560(_DWORD *this, int (__stdcall ***a2)(_DWORD, void *, _DWORD *))
{
  _DWORD *v2; // esi
  bool v3; // sf
  _DWORD *result; // eax

  v2 = this;
  *this = 0;
  if ( !a2 )
    return this;
  v3 = (**a2)(a2, &stru_12BFD30, this) < 0;
  result = v2;
  if ( v3 )
    *v2 = 0;
  return result;
}
// 12BFD30: using guessed type GUID stru_12BFD30;

//----- (012475A0) --------------------------------------------------------
#516 *__thiscall MixedModeStackWalker::MixedModeStackWalker(#516 *this)
{
  #516 *result; // eax

  *this = &MixedModeStackWalker::`vftable';
  result = this;
  *(this + 1) = 1;
  *(this + 6) = 0;
  *(this + 7) = 0;
  *(this + 8) = 0;
  *(this + 9) = 0;
  *(this + 3) = 0;
  *(this + 4) = 0;
  return result;
}
// 12BF470: using guessed type void *MixedModeStackWalker::`vftable';

//----- (01247600) --------------------------------------------------------
int __thiscall sub_1247600(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax

  v2 = this;
  if ( *this == a2 )
    return *v2;
  if ( a2 )
    (*(*a2 + 4))(a2);
  v3 = *v2;
  *v2 = a2;
  if ( v3 )
  {
    (*(*v3 + 8))(v3);
    return *v2;
  }
  return a2;
}

//----- (01247640) --------------------------------------------------------
_DWORD *__thiscall MixedModeStackWalker::`scalar deleting destructor'(void *this, char a2)
{
  _DWORD *v2; // esi
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx

  v2 = this;
  *this = &MixedModeStackWalker::`vftable';
  if ( *(this + 3) )
    *(this + 3) = 0;
  v3 = *(this + 9);
  if ( v3 )
    (*(*v3 + 8))(v2[9]);
  v4 = v2[8];
  if ( v4 )
    (*(*v4 + 8))(v4);
  v5 = v2[7];
  if ( v5 )
    (*(*v5 + 8))(v5);
  v6 = v2[6];
  if ( v6 )
    (*(*v6 + 8))(v6);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12BF470: using guessed type void *MixedModeStackWalker::`vftable';

//----- (012476F0) --------------------------------------------------------
unsigned int __thiscall sub_12476F0(_DWORD *this, int *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // edi
  int *v4; // ecx
  int v5; // eax

  v2 = this;
  v3 = this[1];
  if ( v3 >= this[2] && !sub_12488A0(this, v3 + 1) )
    AtlThrow(-2147024882);
  v4 = (*v2 + 4 * v3);
  if ( v4 )
  {
    v5 = *a2;
    *v4 = *a2;
    if ( v5 )
      (*(*v5 + 4))(v5);
  }
  ++v2[1];
  return v3;
}

//----- (01247740) --------------------------------------------------------
_DWORD *__thiscall sub_1247740(_DWORD *this, int *a2)
{
  _DWORD *v2; // edi
  int v3; // ebx
  _DWORD *v4; // esi
  int v5; // edx
  int v6; // ecx
  _DWORD *v7; // eax
  _DWORD *result; // eax
  int v9; // [esp+18h] [ebp-10h]

  v2 = this;
  v3 = this[1];
  sub_1247F70(this);
  v4 = v2[4];
  v5 = *v4;
  v9 = *v4;
  if ( v4 )
  {
    v6 = *a2;
    v4[2] = *a2;
    if ( v6 )
    {
      (*(*v6 + 4))(v6);
      v5 = v9;
    }
  }
  v2[4] = v5;
  v4[1] = v3;
  *v4 = 0;
  ++v2[2];
  v7 = v2[1];
  if ( v7 )
    *v7 = v4;
  else
    *v2 = v4;
  result = v4;
  v2[1] = v4;
  return result;
}

//----- (012477E0) --------------------------------------------------------
void __stdcall sub_12477E0(int *a1)
{
  int *v1; // edx
  unsigned int v2; // edi
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  int v5; // edx
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  _DWORD *v10; // eax
  wchar_t *v11; // ST00_4
  int v12; // eax
  const char *v13; // [esp-4h] [ebp-24h]
  void *v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-4h]

  v1 = a1;
  v2 = a1[1] - 1;
  v3 = a1[1] - 2;
  if ( (v3 & 0x80000000) == 0 )
  {
    while ( 1 )
    {
      v4 = v1[1];
      if ( v2 >= v4 )
LABEL_26:
        AtlThrow(-2147024809);
      v5 = *v1;
      if ( *(*(v5 + 4 * v2) + 24) == 3 )
      {
        if ( v3 >= v4 )
          goto LABEL_26;
        v6 = *(v5 + 4 * v3);
        if ( *(v6 + 24) == 1 || !*(v6 + 24) )
          break;
      }
      if ( v3 >= v4 )
        goto LABEL_26;
      if ( *(*(v5 + 4 * v3) + 24) == 3 )
      {
        v9 = *(v5 + 4 * v2);
        if ( *(v9 + 24) == 1 || !*(v9 + 24) )
        {
          v10 = operator new(0x20u);
          v8 = v10;
          v14 = v10;
          v15 = 2;
          if ( v10 )
          {
            *v10 = &SymbolInfo::`vftable';
            v10[1] = 1;
            v10[7] = operator new[](0x800u);
          }
          else
          {
            v8 = 0;
          }
          v15 = -1;
          v14 = v8;
          if ( v8 )
            (*(*v8 + 4))(v8);
          v15 = 3;
          v13 = "[Managed to Unmanaged Transition]";
          goto LABEL_23;
        }
      }
LABEL_24:
      --v2;
      if ( (--v3 & 0x80000000) != 0 )
        return;
      v1 = a1;
    }
    v7 = operator new(0x20u);
    v8 = v7;
    v14 = v7;
    v15 = 0;
    if ( v7 )
    {
      *v7 = &SymbolInfo::`vftable';
      v7[1] = 1;
      v7[7] = operator new[](0x800u);
    }
    else
    {
      v8 = 0;
    }
    v15 = -1;
    v14 = v8;
    if ( v8 )
      (*(*v8 + 4))(v8);
    v15 = 1;
    v13 = "[Unmanaged to Managed Transition]";
LABEL_23:
    v11 = v8[7];
    v8[4] = 0;
    v8[5] = 0;
    swprintf_s(v11, 0x400u, L"%S", v13);
    v8[6] = 1;
    sub_1248AE0(a1, v2, &v14, 1u);
    v12 = *v8;
    v15 = -1;
    (*(v12 + 8))(v8);
    goto LABEL_24;
  }
}
// 12BF420: using guessed type void *SymbolInfo::`vftable';

//----- (012479A0) --------------------------------------------------------
void __cdecl sub_12479A0(_DWORD *a1, int a2)
{
  int v2; // ecx
  _DWORD *v3; // eax

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( v3 )
        *v3 = 0;
      ++v3;
      --v2;
    }
    while ( v2 );
  }
}

//----- (012479D0) --------------------------------------------------------
int __cdecl sub_12479D0(int a1, unsigned int a2)
{
  unsigned int v2; // esi
  int v3; // ecx
  int result; // eax

  v2 = 0;
  if ( a2 )
  {
    do
    {
      v3 = *(a1 + 4 * v2);
      if ( v3 )
        result = (*(*v3 + 8))(*(a1 + 4 * v2));
      ++v2;
    }
    while ( v2 < a2 );
  }
  return result;
}

//----- (01247A00) --------------------------------------------------------
int __cdecl sub_1247A00(HWND hWnd, int Pid, char a3)
{
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // edi
  int v4; // esi
  LRESULT nItemCount; // eax
  char v6; // al
  int v7; // ecx
  unsigned int Index; // eax
  ICorPublishAppDomainEnum *pObject; // eax
  int nItem; // esi
  int v11; // eax
  int v12; // eax
  char v13; // al
  char v14; // cl
  int v15; // eax
  LVITEMUSERDATA2 UserData; // [esp-22Ch] [ebp-6D0h]
  const IID *clsid; // [esp-14h] [ebp-4B8h]
  ICorPublishAppDomainEnum *v19; // [esp-10h] [ebp-4B4h]
  DWORD v20; // [esp-Ch] [ebp-4B0h]
  const IID *iid; // [esp-8h] [ebp-4ACh]
  LPVOID *pppv; // [esp-4h] [ebp-4A8h]
  LVITEMW item; // [esp+Ch] [ebp-498h]
  int v24; // [esp+40h] [ebp-464h]
  ICorPublishProcess *pCorPublishProcess; // [esp+44h] [ebp-460h]
  int v26; // [esp+48h] [ebp-45Ch]
  ICorPublishAppDomainEnum **pObjects; // [esp+4Ch] [ebp-458h]
  unsigned int v28; // [esp+50h] [ebp-454h]
  ICorPublish *pCorPublish; // [esp+54h] [ebp-450h]
  int v30; // [esp+58h] [ebp-44Ch]
  ICorPublishAppDomainEnum *pEnum; // [esp+5Ch] [ebp-448h]
  unsigned int nCount; // [esp+60h] [ebp-444h]
  int a5; // [esp+67h] [ebp-43Dh]
  LVITEMUSERDATA2 Buffer; // [esp+6Ch] [ebp-438h]
  __int16 Src[260]; // [esp+298h] [ebp-20Ch]

  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  pppv = &pCorPublish;
  iid = &IID_ICorPublish;
  v20 = 1;
  v19 = 0;
  if ( byte_12EA09A )
    clsid = &stru_12BF40C;
  else
    clsid = &CLSID_CorpubPublish;
  CoCreateInstance(clsid, v19, v20, iid, pppv);
  SendMessageW = ::SendMessageW;
  v4 = 0;
  BYTE1(a5) = 0;
  v30 = 0;
  v26 = 0;
  item.mask = LVIF_PARAM;
  nItemCount = ::SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
  item.iSubItem = 0;
  item.iItem = nItemCount - 1;
  if ( ::SendMessageW(hWnd, LVM_GETITEMW, 0, &item) )
  {
    do
    {
      v6 = DeleteItemFromListCtrl(hWnd, hWnd, &item, item.lParam, &a5);
      v7 = BYTE1(a5);
      if ( v6 )
        v7 = 1;
      *(&a5 + 1) = v7;
      item.lParam->field_8 = 0;
      if ( a5 )
        ++v4;
    }
    while ( ::SendMessageW(hWnd, LVM_GETITEMW, 0, &item) );
    v26 = v4;
  }
  if ( !(pCorPublish->vtptr->GetProcess)(pCorPublish, Pid, &pCorPublishProcess) )
  {
    (pCorPublishProcess->vtptr->EnumAppDomains)(pCorPublishProcess, &pEnum);
    (pEnum->vtptr->GetCount)(pEnum, &nCount);
    pObjects = operator new[](4 * nCount);
    (pEnum->vtptr->Next)(pEnum, nCount, pObjects, &nCount);
    SendMessageW = ::SendMessageW;
    Index = 0;
    v28 = 0;
    if ( nCount )
    {
      do
      {
        pppv = Src;
        v24 = 260;
        iid = &v24;
        pObject = pObjects[Index];
        v20 = 260;
        v19 = pObject;
        (pObject->vtptr->Reset)(pObject, 260, &v24, Src);
        nItem = 0;
        SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
        if ( v11 > 0 )
        {
          while ( 1 )
          {
            item.mask = LVIF_PARAM;
            item.iItem = nItem;
            item.iSubItem = 0;
            SendMessageW(hWnd, LVM_GETITEMW, 0, &item);
            v12 = item.lParam->field_10;
            if ( (v12 == 1 || !v12) && !_wcsicmp(Src, &item.lParam->ImgName) )
              break;
            if ( ++nItem >= (SendMessageW)(hWnd, LVM_GETITEMCOUNT, 0, 0) )
              goto LABEL_22;
          }
          ++v30;
          v13 = sub_1278A20(item.lParam);
          v14 = BYTE1(a5);
          if ( v13 )
            v14 = 1;
          BYTE1(a5) = v14;
        }
LABEL_22:
        if ( nItem == (SendMessageW)(hWnd, LVM_GETITEMCOUNT, 0, 0) )
        {
          BYTE1(a5) = 1;
          memset(&Buffer, 0, 0x22Cu);
          tcscpy_s(Buffer.m_Text, _MAX_PATH, Src);
          Buffer.field_4 = 4;
          v15 = 2;
          Buffer.dwTotalHighlightDuration = 0;
          if ( a3 )
            v15 = 0;
          Buffer.isHandlesList = v15;
          qmemcpy(&UserData, &Buffer, sizeof(UserData));
          AddRowToListCtrl(hWnd, UserData.field_0);
          SendMessageW = ::SendMessageW;
        }
        Index = v28 + 1;
        v28 = Index;
      }
      while ( Index < nCount );
      v4 = v26;
    }
    pppv = &pEnum->vtptr;
    (pEnum->vtptr->Release)(pEnum);
    j__free(pObjects);
    if ( v30 != v4 || BYTE1(a5) )
      InvalidateRect(hWnd, 0, 0);
    pppv = &pCorPublishProcess->vtptr;
    (pCorPublishProcess->vtptr->Release)(pCorPublishProcess);
  }
  if ( BYTE1(a5) )
    SendMessageW(hWnd, 0xBu, 1u, 0);
  pppv = &pCorPublish->vtptr;
  return (pCorPublish->vtptr->Release)(pCorPublish);
}
// 12BF40C: using guessed type GUID stru_12BF40C;
// 12EA09A: using guessed type char byte_12EA09A;

//----- (01247DD0) --------------------------------------------------------
signed int __stdcall sub_1247DD0(int (__stdcall ***a1)(_DWORD, void *, int *))
{
  int (__stdcall ***v1)(_DWORD, void *, int *); // esi
  int (__stdcall **v2)(_DWORD, GUID *, int *); // eax
  int (__stdcall ***v3)(_DWORD, void *, int *); // eax
  signed int v4; // esi
  int (__stdcall **v5)(_DWORD, GUID *, int *); // eax
  int v6; // eax
  int (__stdcall **v7)(_DWORD, GUID *, int *); // eax
  int v8; // ecx
  int *v10; // [esp+8h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-10h]
  int v12; // [esp+18h] [ebp-4h]

  v1 = a1;
  if ( !a1 )
    return 3;
  a1 = 0;
  v2 = *v1;
  v12 = 0;
  if ( (*v2)(v1, &stru_12BFBB8, &a1) || (v3 = a1) == 0 )
  {
    v11 = 0;
    v5 = *v1;
    LOBYTE(v12) = 1;
    if ( !(*v5)(v1, &stru_12BFBC8, &v11) )
    {
      v6 = v11;
      if ( v11 )
      {
        v4 = 1;
LABEL_11:
        LOBYTE(v12) = 0;
        if ( v6 )
          (*(*v6 + 8))(v6);
        v3 = a1;
        goto LABEL_14;
      }
    }
    v10 = 0;
    v7 = *v1;
    LOBYTE(v12) = 2;
    if ( !(*v7)(v1, &stru_12BFBD8, &v10) && v10 )
    {
      v8 = *v10;
      v4 = 2;
      LOBYTE(v12) = 1;
      (*(v8 + 8))(v10);
      v6 = v11;
      goto LABEL_11;
    }
    LOBYTE(v12) = 1;
    if ( v10 )
      (*(*v10 + 8))(v10);
    LOBYTE(v12) = 0;
    if ( v11 )
      (*(*v11 + 8))(v11);
    v12 = -1;
    if ( a1 )
      ((*a1)[2])(a1);
    return 3;
  }
  v4 = 0;
LABEL_14:
  v12 = -1;
  if ( v3 )
    ((*v3)[2])(v3);
  return v4;
}
// 12BFBB8: using guessed type GUID stru_12BFBB8;
// 12BFBC8: using guessed type GUID stru_12BFBC8;
// 12BFBD8: using guessed type GUID stru_12BFBD8;

//----- (01247F10) --------------------------------------------------------
int __cdecl sub_1247F10(int a1, LPCWSTR lpsz, int a3)
{
  wchar_t **v3; // eax
  void **v4; // edi

  *a3 = 0;
  *(a3 + 4) = 0;
  v3 = sub_124E760(a1, lpsz);
  v4 = v3;
  if ( v3 && sub_124ECA0(v3, a3, 0) )
  {
    sub_124EC80(v4);
    j__free(v4);
  }
  return a3;
}

//----- (01247F60) --------------------------------------------------------
int __thiscall sub_1247F60(_DWORD *this)
{
  return this[7];
}

//----- (01247F70) --------------------------------------------------------
void __thiscall sub_1247F70(_DWORD *this)
{
  _DWORD *v1; // esi
  unsigned int v2; // edi
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // eax
  int i; // edx

  v1 = this;
  if ( !this[4] )
  {
    v2 = 12 * this[5];
    if ( !is_mul_ok(0xCu, this[5]) || v2 > 0xFFFFFFFF || -1 - v2 < 4 || (v3 = malloc(v2 + 4)) == 0 )
      AtlThrow(-2147024882);
    *v3 = v1[3];
    v1[3] = v3;
    v4 = v1[5];
    v5 = &v3[3 * v4 - 2];
    for ( i = v4 - 1; i >= 0; --i )
    {
      *v5 = v1[4];
      v1[4] = v5;
      v5 -= 3;
    }
  }
}

//----- (01247FF0) --------------------------------------------------------
signed int __stdcall sub_1247FF0(unsigned int a1, _DWORD *a2, unsigned int *a3)
{
  int *v3; // edi
  unsigned int v5; // edx
  void *v6; // esi
  void *v7; // eax
  int v8; // ecx
  void *v9; // eax
  _DWORD *v10; // edi
  unsigned int v11; // edx
  int v12; // [esp+4h] [ebp-4h]

  v3 = a1;
  if ( (*(*a1 + 16))(a1, 0, &a1, 0) )
    return 0;
  v5 = a1;
  v6 = 0;
  if ( a1 )
  {
    v7 = operator new[](4 * a1);
    v8 = *v3;
    v6 = v7;
    v12 = 0;
    if ( (*(v8 + 16))(v3, a1, &v12, v7) )
    {
      j_j__free(v6);
      return 0;
    }
    v5 = a1;
  }
  *a3 = v5;
  if ( v5 )
  {
    v9 = operator new[](4 * v5);
    v10 = a2;
    v11 = 0;
    *a2 = v9;
    if ( a1 )
    {
      do
      {
        *(*v10 + 4 * v11) = *(v6 + v11);
        ++v11;
      }
      while ( v11 < a1 );
    }
  }
  j_j__free(v6);
  return 1;
}

//----- (012480C0) --------------------------------------------------------
signed int __stdcall sub_12480C0(int (__stdcall ***a1)(_DWORD, void *, int *), _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  signed int v6; // esi
  int (__stdcall **v7)(_DWORD, void *, int *); // eax
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // eax
  int (__stdcall **v11)(_DWORD, void *, int *); // eax
  int v12; // ecx
  wchar_t *v13; // ecx
  signed int v14; // edx
  wchar_t v15; // ax
  char v17; // [esp+Ch] [ebp-1B38h]
  char v18; // [esp+10h] [ebp-1B34h]
  char v19; // [esp+14h] [ebp-1B30h]
  char v20; // [esp+18h] [ebp-1B2Ch]
  char v21; // [esp+1Ch] [ebp-1B28h]
  char v22; // [esp+20h] [ebp-1B24h]
  char v23; // [esp+24h] [ebp-1B20h]
  char v24; // [esp+28h] [ebp-1B1Ch]
  char v25; // [esp+2Ch] [ebp-1B18h]
  int v26; // [esp+30h] [ebp-1B14h]
  int v27; // [esp+34h] [ebp-1B10h]
  int v28; // [esp+38h] [ebp-1B0Ch]
  int v29; // [esp+3Ch] [ebp-1B08h]
  int v30; // [esp+40h] [ebp-1B04h]
  int v31; // [esp+44h] [ebp-1B00h]
  int v32; // [esp+48h] [ebp-1AFCh]
  int v33; // [esp+4Ch] [ebp-1AF8h]
  int (__stdcall ***v34)(_DWORD, GUID *, int *); // [esp+50h] [ebp-1AF4h]
  _DWORD *v35; // [esp+54h] [ebp-1AF0h]
  _DWORD *v36; // [esp+58h] [ebp-1AECh]
  int v37; // [esp+5Ch] [ebp-1AE8h]
  int v38; // [esp+60h] [ebp-1AE4h]
  int *v39; // [esp+64h] [ebp-1AE0h]
  int v40; // [esp+68h] [ebp-1ADCh]
  int v41; // [esp+12Ch] [ebp-1A18h]
  wchar_t Dst; // [esp+334h] [ebp-1810h]
  char v43; // [esp+B34h] [ebp-1010h]
  char v44; // [esp+F34h] [ebp-C10h]
  wchar_t Ext; // [esp+1334h] [ebp-810h]
  wchar_t Filename; // [esp+1534h] [ebp-610h]
  wchar_t FullPath; // [esp+1734h] [ebp-410h]
  int v48; // [esp+1B40h] [ebp-4h]

  if ( sub_1247DD0(a1) == 1 )
  {
    v2 = 0;
    v36 = 0;
    if ( a1 )
    {
      v3 = (**a1)(a1, &stru_12BFBC8, &v36);
      v2 = v36;
      if ( v3 < 0 )
        v2 = 0;
      v36 = v2;
    }
    v4 = *v2;
    v48 = 0;
    if ( (*(v4 + 44))(v2, &v29) )
    {
LABEL_15:
      v5 = v36;
      v6 = 0;
    }
    else
    {
      switch ( v29 )
      {
        case 3:
          sub_1248A30(a2, "[AppDomain Transition]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 4:
          sub_1248A30(a2, "[Lightweight function]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 5:
          sub_1248A30(a2, "[Func Eval]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 7:
          sub_1248A30(a2, "[Class Init]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 8:
          sub_1248A30(a2, "[Exception]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 9:
          sub_1248A30(a2, "[Security]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        case 10:
          sub_1248A30(a2, "[JIT Compilation]", 0, 0, 1);
          v5 = v36;
          v6 = 1;
          break;
        default:
          goto LABEL_15;
      }
    }
  }
  else
  {
    v34 = 0;
    v7 = *a1;
    v48 = 1;
    if ( (*v7)(a1, &stru_12BFBB8, &v34) )
    {
      v6 = 0;
    }
    else
    {
      v8 = 0;
      v35 = 0;
      if ( v34 )
      {
        v9 = (**v34)(v34, &stru_12BFD30, &v35);
        v8 = v35;
        if ( v9 < 0 )
          v8 = 0;
        v35 = v8;
      }
      v33 = 0;
      v10 = *v8;
      LOBYTE(v48) = 3;
      if ( (*(v10 + 52))(v8, &v33) || (memset(&v40, 0, 0x2CCu), v40 = 65539, (*(*v33 + 24))(v33, 716, &v40)) )
      {
        v6 = 0;
      }
      else
      {
        v37 = 0;
        v11 = *a1;
        LOBYTE(v48) = 4;
        if ( (v11[5])(a1, &v37) || (*(*v37 + 20))(v37, &v30) )
        {
          v6 = 0;
        }
        else
        {
          v39 = 0;
          LOBYTE(v48) = 5;
          if ( (*(*v37 + 12))(v37, &v39) )
          {
            v6 = 0;
          }
          else
          {
            v38 = 0;
            v12 = *v39;
            LOBYTE(v48) = 6;
            if ( (*(v12 + 56))(v39, &stru_12BF3CC, &v38)
              || (*(*v38 + 120))(v38, v30, &v28, &v44, 512, &v21, &v23, &v24, &v18, &v22, &v25)
              || (*(*v38 + 48))(v38, v28, &v43, 512, &v20, &v17, &v19) )
            {
              v6 = 0;
            }
            else
            {
              sub_1247560(&v31, a1);
              LOBYTE(v48) = 7;
              if ( (*(*v31 + 44))(v31, &v27) )
              {
                v6 = 0;
              }
              else
              {
                v32 = 0;
                LOBYTE(v48) = 8;
                if ( (*(*v39 + 20))(v39, &v32) )
                {
                  v6 = 0;
                }
                else
                {
                  v26 = 512;
                  if ( (*(*v39 + 24))(v39, 512, &v26, &FullPath)
                    || _wsplitpath_s(&FullPath, 0, 0, 0, 0, &Filename, 0x100u, &Ext, 0x100u) )
                  {
                    v13 = &FullPath;
                    v14 = 512;
                    while ( v14 != -2147483134 )
                    {
                      v15 = *(v13 + L"<Unresolved>" - &FullPath);
                      if ( !v15 )
                        break;
                      *v13 = v15;
                      ++v13;
                      if ( !--v14 )
                        goto LABEL_44;
                    }
                    if ( v14 )
                      goto LABEL_45;
LABEL_44:
                    --v13;
LABEL_45:
                    *v13 = 0;
                  }
                  else
                  {
                    swprintf_s(&FullPath, 0x200u, L"%s%s", &Filename, &Ext);
                  }
                  swprintf_s(&Dst, 0x400u, L"%s!%s.%s+0x%x", &FullPath, &v43, &v44, v27);
                  sub_1248A90(a2, &Dst, v41, 0, 0);
                  v6 = 1;
                }
                LOBYTE(v48) = 7;
                if ( v32 )
                  (*(*v32 + 8))(v32);
              }
              LOBYTE(v48) = 6;
              if ( v31 )
                (*(*v31 + 8))(v31);
            }
            LOBYTE(v48) = 5;
            if ( v38 )
              (*(*v38 + 8))(v38);
          }
          LOBYTE(v48) = 4;
          if ( v39 )
            (*(*v39 + 8))(v39);
        }
        LOBYTE(v48) = 3;
        if ( v37 )
          (*(*v37 + 8))(v37);
      }
      LOBYTE(v48) = 2;
      if ( v33 )
        (*(*v33 + 8))(v33);
      LOBYTE(v48) = 1;
      if ( v35 )
        (*(*v35 + 8))(v35);
    }
    v5 = v34;
  }
  v48 = -1;
  if ( v5 )
    (*(*v5 + 8))(v5);
  return v6;
}
// 12BF3CC: using guessed type GUID stru_12BF3CC;
// 12BFBB8: using guessed type GUID stru_12BFBB8;
// 12BFBC8: using guessed type GUID stru_12BFBC8;
// 12BFD30: using guessed type GUID stru_12BFD30;
// 12BFD40: using guessed type wchar_t aUnresolved[13];

//----- (012486C0) --------------------------------------------------------
int __stdcall sub_12486C0(int a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

//----- (012486E0) --------------------------------------------------------
int *__cdecl sub_12486E0(wchar_t *a1, int a2)
{
  int *result; // eax
  int *v3; // esi
  wchar_t Dst; // [esp+Ch] [ebp-20Ch]

  result = sub_124ED60(a2);
  v3 = result;
  if ( result )
  {
    do
    {
      if ( sub_124E850(v3, &Dst, 0x104u) && !_wcsnicmp(a1, &Dst, wcslen(a1)) )
        break;
      if ( v3 )
        j__free(v3);
      v3 = sub_124EE00(a2);
    }
    while ( v3 );
    result = v3;
  }
  return result;
}

//----- (01248790) --------------------------------------------------------
int __cdecl sub_1248790(wchar_t *Src, wchar_t *Dst)
{
  wchar_t *v2; // eax
  int result; // eax

  tcscpy_s(Dst, 0x104u, Src);
  v2 = wcsrchr(Dst, 0x2Eu);
  if ( v2 && v2 != Dst )
    *v2 = 0;
  result = 0;
  Dst[14] = 0;
  return result;
}

//----- (012487D0) --------------------------------------------------------
int __stdcall sub_12487D0(int a1, DWORD dwThreadId, int a3, int a4, int a5)
{
  HANDLE v5; // edi
  HANDLE v7; // eax
  void *v8; // esi
  THREADENTRY32 te; // [esp+10h] [ebp-20h]

  v5 = CreateToolhelp32Snapshot(4u, *(a1 + 12));
  if ( v5 == -1 )
    return -2147467259;
  te.dwSize = 28;
  if ( !Thread32First(v5, &te) )
    goto LABEL_6;
  while ( te.th32OwnerProcessID != *(a1 + 12) || te.th32ThreadID != dwThreadId )
  {
    if ( !Thread32Next(v5, &te) )
      goto LABEL_6;
  }
  v7 = OpenThread(0x1F03FFu, 1, dwThreadId);
  v8 = v7;
  if ( !v7 )
  {
LABEL_6:
    CloseHandle(v5);
    return -2147467259;
  }
  if ( !GetThreadContext(v7, a5) )
  {
    CloseHandle(v8);
    CloseHandle(v5);
    return -2147467259;
  }
  CloseHandle(v8);
  CloseHandle(v5);
  return 0;
}

//----- (012488A0) --------------------------------------------------------
char __thiscall sub_12488A0(const void **this, unsigned int a2)
{
  char *v2; // esi
  const void **v3; // edi
  unsigned int v4; // edx
  void *v5; // eax
  char *v7; // ecx
  void *v8; // ecx
  int v9; // eax
  const void *v10; // [esp+10h] [ebp+8h]

  v2 = a2;
  v3 = this;
  v4 = this[2];
  if ( a2 > v4 )
  {
    if ( *this )
    {
      v7 = this[3];
      if ( !v7 )
      {
        v7 = (v4 >> 1);
        if ( a2 - v4 > v4 >> 1 )
          v7 = (a2 - v4);
      }
      if ( a2 < &v7[v4] )
        v2 = &v7[v4];
      v8 = calloc(v2, 4u);
      v10 = v8;
      if ( !v8 )
        return 0;
      v9 = memmove_s(v8, 4 * v3[1], *v3, 4 * v3[1]);
      sub_122B650(v9);
      free(*v3);
      *v3 = v10;
    }
    else
    {
      if ( this[3] > a2 )
        v2 = this[3];
      v5 = calloc(v2, 4u);
      *v3 = v5;
      if ( !v5 )
        return 0;
    }
    v3[2] = v2;
  }
  return 1;
}

//----- (01248940) --------------------------------------------------------
FARPROC __thiscall sub_1248940(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // esi
  HMODULE v3; // eax
  FARPROC result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  _DWORD *v10; // eax
  int v11; // edi
  int v12; // ecx
  int v13; // ecx

  v2 = this;
  this[5] = a2;
  this[2] = *a2;
  this[3] = a2[3];
  v3 = LoadLibraryW(L"mscoree.dll");
  result = GetProcAddress(v3, "CLRCreateInstance");
  if ( result )
  {
    if ( (result)(&stru_12BF3EC, &stru_12BF3DC, v2 + 6) )
    {
      result = 0;
    }
    else
    {
      v5 = operator new(0x10u);
      v6 = v5;
      if ( v5 )
      {
        v7 = v2[3];
        v8 = v2[2];
        *v5 = &CCorDebugDataTarget::`vftable';
        v5[1] = 1;
        v5[2] = v7;
        v5[3] = v8;
      }
      else
      {
        v6 = 0;
      }
      v9 = v2[8];
      if ( v9 )
        (*(*v9 + 8))(v2[8]);
      v2[8] = v6;
      v10 = operator new(0xCu);
      v11 = v10;
      if ( v10 )
      {
        v12 = v2[2];
        *v10 = &CCLRDebuggingLibraryProvider::`vftable';
        v10[1] = 1;
        v10[2] = v12;
      }
      else
      {
        v11 = 0;
      }
      v13 = v2[9];
      if ( v13 )
        (*(*v13 + 8))(v2[9]);
      v2[9] = v11;
      result = (sub_1249500(v2, v2[8], v2[6], v11) == 0);
    }
  }
  return result;
}
// 12BF3DC: using guessed type GUID stru_12BF3DC;
// 12BF3EC: using guessed type GUID stru_12BF3EC;
// 12BF440: using guessed type void *CCorDebugDataTarget::`vftable';
// 12BF45C: using guessed type void *CCLRDebuggingLibraryProvider::`vftable';

//----- (01248A30) --------------------------------------------------------
int __thiscall sub_1248A30(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  wchar_t *v6; // ST00_4
  int result; // eax

  v5 = this;
  if ( a2 )
  {
    v6 = this[7];
    this[4] = a3;
    this[5] = a4;
    swprintf_s(v6, 0x400u, L"%S", a2);
    result = a5;
  }
  else
  {
    result = a5;
    this[4] = 0;
    this[5] = 0;
  }
  v5[6] = a5;
  return result;
}

//----- (01248A90) --------------------------------------------------------
int __thiscall sub_1248A90(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  wchar_t *v6; // ST00_4
  int result; // eax

  v5 = this;
  if ( a2 )
  {
    v6 = this[7];
    this[4] = a3;
    this[5] = a4;
    swprintf_s(v6, 0x400u, L"%s", a2);
    result = a5;
  }
  else
  {
    result = a5;
    this[7] = 0;
  }
  v5[6] = a5;
  return result;
}

//----- (01248AE0) --------------------------------------------------------
void __thiscall sub_1248AE0(int *this, unsigned int a2, int *a3, unsigned int a4)
{
  int *v4; // ebx
  unsigned int v5; // edi
  unsigned int v6; // esi
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // ebx
  int v11; // ecx
  int v12; // eax
  const void *v13; // edx
  int v14; // eax
  _DWORD *v15; // eax
  int *v16; // ebx
  int v17; // edi
  int v18; // eax
  int v19; // [esp+0h] [ebp-30h]
  unsigned int v20; // [esp+10h] [ebp-20h]
  int *v21; // [esp+14h] [ebp-1Ch]
  unsigned int v22; // [esp+18h] [ebp-18h]
  unsigned int v23; // [esp+1Ch] [ebp-14h]
  int *v24; // [esp+20h] [ebp-10h]
  int v25; // [esp+2Ch] [ebp-4h]

  v24 = &v19;
  v4 = this;
  v21 = this;
  v5 = this[1];
  v6 = a2;
  v23 = v5;
  if ( a2 >= v5 )
  {
    if ( -1 - a2 >= a4 )
    {
      v22 = a2 + a4;
      if ( !sub_1249B80(this, a2 + a4, -1) )
        AtlThrow(-2147024882);
      goto LABEL_16;
    }
LABEL_5:
    AtlThrow(-2147024362);
  }
  v20 = v5;
  if ( -1 - v5 < a4 )
    goto LABEL_5;
  if ( !sub_1249B80(this, v5 + a4, -1) )
    AtlThrow(-2147024882);
  v7 = *v4 + 4 * v5;
  v8 = 0;
  v22 = v7;
  v9 = a4;
  if ( a4 )
  {
    v10 = v22;
    do
    {
      v11 = *(v10 + 4 * v8);
      if ( v11 )
      {
        (*(*v11 + 8))(*(v10 + 4 * v8));
        v9 = a4;
      }
      ++v8;
    }
    while ( v8 < v9 );
    v4 = v21;
  }
  v12 = *v4;
  v13 = (*v4 + 4 * a2);
  v23 -= a2;
  v22 = a2 + a4;
  v14 = memmove_s((v12 + 4 * (a2 + a4)), 4 * v23, v13, 4 * v23);
  sub_122B650(v14);
  v15 = (4 * a2 + *v4);
  v25 = 0;
  sub_12479A0(v15, a4);
  v25 = -1;
LABEL_16:
  if ( a2 < v22 )
  {
    do
    {
      v16 = (*v4 + 4 * v6);
      v17 = *a3;
      if ( *v16 != *a3 )
      {
        if ( v17 )
          (*(*v17 + 4))(*a3);
        v18 = *v16;
        *v16 = v17;
        if ( v18 )
          (*(*v18 + 8))(v18);
      }
      v4 = v21;
      ++v6;
    }
    while ( v6 < v22 );
  }
}

//----- (01248C80) --------------------------------------------------------
int (__stdcall ***__stdcall sub_1248C80(int (__stdcall ***a1)(_DWORD, void *, int *)))(_DWORD, void *, int *)
{
  _DWORD *v1; // ecx
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int (__stdcall ***v5)(_DWORD, void *, int *); // esi
  _DWORD *v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+14h] [ebp-4h]

  v1 = 0;
  v7 = 0;
  if ( a1 )
  {
    v2 = (**a1)(a1, &stru_12BFBC8, &v7);
    v1 = v7;
    if ( v2 < 0 )
      v1 = 0;
    v7 = v1;
  }
  v3 = *v1;
  v8 = 0;
  v4 = (*(v3 + 44))(v1, &a1);
  v5 = a1;
  v8 = -1;
  if ( v4 )
    v5 = 0;
  if ( v7 )
    (*(*v7 + 8))(v7);
  return v5;
}
// 12BFBC8: using guessed type GUID stru_12BFBC8;

//----- (01248D10) --------------------------------------------------------
signed int __thiscall sub_1248D10(_DWORD *this, int a2)
{
  int v2; // ST08_4
  int v3; // esi
  signed int v4; // esi
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-4h]

  v8 = 0;
  v2 = this[7];
  v9 = 0;
  if ( !(*(*v2 + 28))(v2, &v8) )
  {
    v7 = 0;
    if ( !(*(*v8 + 28))(v8, 1, &v6, &v7) )
    {
      v3 = a2;
      do
      {
        a2 = 0;
        if ( (*(*v6 + 16))(v6, &a2) )
          break;
        if ( a2 == v3 )
        {
          v4 = 1;
          goto LABEL_8;
        }
      }
      while ( !(*(*v8 + 28))(v8, 1, &v6, &v7) );
    }
  }
  v4 = 0;
LABEL_8:
  v9 = -1;
  if ( v8 )
    (*(*v8 + 8))(v8);
  return v4;
}

//----- (01248DE0) --------------------------------------------------------
BOOL __cdecl sub_1248DE0(int a1)
{
  return !(*(*a1 + 44))(a1, &a1) && (a1 == 6 || a1 == 7 || a1 == 8 || a1 == 9 || a1 == 10);
}

//----- (01248E20) --------------------------------------------------------
int __thiscall sub_1248E20(void *this, int a2, int a3, int *a4, _DWORD *a5, _DWORD *a6, int a7, unsigned int a8, unsigned int *a9)
{
  int v9; // edx
  bool v10; // zf
  int (__stdcall ***v11)(_DWORD, void *, int *); // eax
  int v12; // eax
  int v13; // esi
  unsigned int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // esi
  int v19; // eax
  unsigned int v20; // eax
  int v21; // ecx
  int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // ebx
  int v25; // eax
  int v26; // [esp+10h] [ebp-5E4h]
  __int64 v27; // [esp+14h] [ebp-5E0h]
  __int64 v28; // [esp+1Ch] [ebp-5D8h]
  int v29; // [esp+24h] [ebp-5D0h]
  int *v30; // [esp+28h] [ebp-5CCh]
  __int64 v31; // [esp+2Ch] [ebp-5C8h]
  int *v32; // [esp+34h] [ebp-5C0h]
  _DWORD *v33; // [esp+38h] [ebp-5BCh]
  _DWORD *v34; // [esp+3Ch] [ebp-5B8h]
  int (__stdcall ***v35)(_DWORD, void *, int *); // [esp+40h] [ebp-5B4h]
  void *v36; // [esp+44h] [ebp-5B0h]
  int v37; // [esp+48h] [ebp-5ACh]
  int v38; // [esp+4Ch] [ebp-5A8h]
  int v39; // [esp+318h] [ebp-2DCh]
  unsigned int v40; // [esp+3DCh] [ebp-218h]
  int v41; // [esp+5F0h] [ebp-4h]

  v36 = this;
  v9 = a3;
  v10 = *a5 == 1;
  HIDWORD(v28) = a2;
  v30 = a4;
  v37 = a3;
  v29 = a7;
  if ( v10 )
    return 0;
  v10 = *a6 == 1;
  v31 = 0i64;
  if ( !v10 )
  {
    *a6 = 1;
    HIDWORD(v31) = 1;
    goto LABEL_29;
  }
  if ( *v30 )
  {
    if ( sub_1247DD0(*v30) == 1 )
    {
      if ( *a9 < a8 )
        ++*a9;
      v11 = sub_1248C80(*v30);
      v9 = v37;
      if ( v11 == 5 )
        LODWORD(v31) = 1;
      goto LABEL_29;
    }
    v9 = v37;
  }
  v12 = (*(*v9 + 20))(v9);
  if ( v12 == 1250084 )
  {
    *a5 = 1;
    goto LABEL_12;
  }
  if ( v12 < 0 )
    _CxxThrowException(0, 0);
  v9 = v37;
LABEL_29:
  if ( *a5 )
  {
LABEL_12:
    if ( *a9 < a8 )
    {
      v13 = v29;
      while ( 1 )
      {
        v34 = 0;
        v14 = *a9;
        v41 = 8;
        v10 = (***(v13 + 4 * v14))(*(v13 + 4 * v14), &stru_12BFBC8, &v34) == 0;
        v15 = v34;
        if ( !v10 )
          break;
        if ( (*(*v34 + 44))(v34, &v31 + 4)
          || HIDWORD(v31) != 6 && HIDWORD(v31) != 7 && HIDWORD(v31) != 8 && HIDWORD(v31) != 9 && HIDWORD(v31) != 10 )
        {
          *v30 = *(v13 + 4 * *a9);
          v25 = v34;
          goto LABEL_95;
        }
        v41 = -1;
        if ( v34 )
          (*(*v34 + 8))(v34);
        if ( ++*a9 >= a8 )
          return 0;
      }
LABEL_45:
      v41 = -1;
      if ( v15 )
        (*(*v15 + 8))(v15);
    }
    return 0;
  }
  v33 = 0;
  v16 = *v9;
  v41 = 0;
  (*(v16 + 24))(v9, &v33);
  v17 = v33;
  if ( !v33 )
  {
    *v30 = v33;
    return v17 + 1;
  }
  v19 = *v33;
  v34 = v33;
  (*(v19 + 4))(v33);
  if ( *a9 >= a8 )
    goto LABEL_92;
  while ( 1 )
  {
    v35 = 0;
    v20 = *a9;
    LOBYTE(v41) = 2;
    if ( (***(v29 + 4 * v20))(*(v29 + 4 * v20), &stru_12BFBC8, &v35) )
      goto LABEL_42;
    if ( !sub_1248DE0(v35) )
      break;
    LOBYTE(v41) = 1;
    if ( v35 )
      ((*v35)[2])(v35);
    if ( ++*a9 >= a8 )
      goto LABEL_92;
  }
  sub_1247520(&v32, v35);
  v21 = *v32;
  LOBYTE(v41) = 3;
  if ( (*(v21 + 16))(v32, v17, &v26) )
  {
LABEL_40:
    LOBYTE(v41) = 2;
    if ( v32 )
      (*(*v32 + 8))(v32);
LABEL_42:
    LOBYTE(v41) = 1;
    if ( v35 )
      ((*v35)[2])(v35);
    v22 = *v17;
    LOBYTE(v41) = 0;
    (*(v22 + 8))(v17);
    v15 = v33;
    goto LABEL_45;
  }
  if ( !v26 )
  {
    if ( sub_1248C80(v35) != 1 )
      goto LABEL_88;
    memset(&v38, 0, 0x2CCu);
    v38 = 65539;
    if ( (*(*v37 + 12))(v37, 65539, 716, &v29, &v38) )
      goto LABEL_40;
    v37 = 0;
    LOBYTE(v41) = 4;
    if ( (*(*HIDWORD(v28) + 12))(HIDWORD(v28), &v37) )
    {
LABEL_54:
      LOBYTE(v41) = 3;
      if ( v37 )
        (*(*v37 + 8))(v37);
      goto LABEL_40;
    }
    if ( v31 == 1 || HIDWORD(v31) == 1 )
      (*(*v37 + 16))(v37, 1, 716, &v38);
    else
      (*(*v37 + 16))(v37, 2, 716, &v38);
    v36 = 0;
    v28 = 0i64;
    v27 = 0i64;
    LOBYTE(v41) = 5;
    if ( (*(*v37 + 24))(v37, &v36) )
    {
      v31 = __PAIR__(v28, HIDWORD(v28));
    }
    else
    {
      memset(&v39, 0, 0x2CCu);
      v39 = 65539;
      if ( (*(*v37 + 12))(v37, 65539, 716, &v28 + 4, &v39) )
        goto LABEL_62;
      HIDWORD(v31) = v40;
      LODWORD(v31) = 0;
    }
    LOBYTE(v41) = 4;
    if ( v36 )
      (*(*v36 + 8))(v36);
    if ( (*(*v37 + 20))(v37) )
    {
      v24 = HIDWORD(v27);
      v23 = v27;
    }
    else
    {
      v36 = 0;
      LOBYTE(v41) = 6;
      if ( (*(*v37 + 24))(v37, &v36) )
      {
        v24 = HIDWORD(v27);
        v23 = v27;
      }
      else
      {
        memset(&v39, 0, 0x2CCu);
        v39 = 65539;
        if ( (*(*v37 + 12))(v37, 65539, 716, &v28 + 4, &v39) )
          goto LABEL_62;
        v23 = v40;
        v24 = 0;
      }
      LOBYTE(v41) = 4;
      if ( v36 )
        (*(*v36 + 8))(v36);
    }
    if ( !v31 || !(v24 | v23) || v31 > v24 || v31 >= v24 && HIDWORD(v31) >= v23 )
    {
LABEL_86:
      LOBYTE(v41) = 3;
      if ( v37 )
        (*(*v37 + 8))(v37);
      goto LABEL_88;
    }
    v36 = 0;
    LOBYTE(v41) = 7;
    (*(*v37 + 24))(v37, &v36);
    if ( !(*(*v32 + 16))(v32, v36, &v28 + 4) )
    {
      if ( HIDWORD(v28) )
      {
        sub_1247600(&v34, v35);
        v17 = v34;
      }
      LOBYTE(v41) = 4;
      if ( v36 )
        (*(*v36 + 8))(v36);
      goto LABEL_86;
    }
LABEL_62:
    LOBYTE(v41) = 4;
    if ( v36 )
      (*(*v36 + 8))(v36);
    goto LABEL_54;
  }
  sub_1247600(&v34, *(v29 + 4 * *a9));
  v17 = v34;
LABEL_88:
  LOBYTE(v41) = 2;
  if ( v32 )
    (*(*v32 + 8))(v32);
  LOBYTE(v41) = 1;
  if ( v35 )
    ((*v35)[2])(v35);
LABEL_92:
  LOBYTE(v41) = 0;
  *v30 = v17;
  if ( v17 )
    (*(*v17 + 8))(v17);
  v25 = v33;
LABEL_95:
  v41 = -1;
  if ( v25 )
    (*(*v25 + 8))(v25);
  return 1;
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12BFBC8: using guessed type GUID stru_12BFBC8;

//----- (01249500) --------------------------------------------------------
signed int __thiscall sub_1249500(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // edi
  DWORD v5; // ST24_4
  HANDLE v6; // esi
  char v8; // [esp+14h] [ebp-45Ch]
  int v9; // [esp+18h] [ebp-458h]
  int v10; // [esp+1Ch] [ebp-454h]
  MODULEENTRY32W me; // [esp+20h] [ebp-450h]
  __int16 v12; // [esp+448h] [ebp-28h]
  __int16 v13; // [esp+454h] [ebp-1Ch]
  int v14; // [esp+456h] [ebp-1Ah]
  int v15; // [esp+45Ah] [ebp-16h]
  int v16; // [esp+46Ch] [ebp-4h]

  v4 = this;
  v9 = a2;
  v10 = a4;
  v14 = 4;
  v15 = -1;
  v13 = 0;
  v5 = this[2];
  v16 = 0;
  v12 = 0;
  v6 = CreateToolhelp32Snapshot(8u, v5);
  if ( v6 == -1 )
    return -2147467259;
  me.dwSize = 1064;
  if ( !Module32FirstW(v6, &me) )
  {
LABEL_6:
    CloseHandle(v6);
    return -2147467259;
  }
  while ( me.th32ProcessID != v4[2]
       || (*(*a3 + 12))(a3, me.modBaseAddr, me.modBaseAddr >> 31, v9, v10, &v13, &stru_12BFBA8, v4 + 7, &v12, &v8) )
  {
    if ( !Module32NextW(v6, &me) )
      goto LABEL_6;
  }
  CloseHandle(v6);
  return 0;
}
// 12BFBA8: using guessed type GUID stru_12BFBA8;

//----- (01249620) --------------------------------------------------------
signed int __stdcall sub_1249620(int a1, int a2, int a3, int a4, HMODULE *a5)
{
  signed int v5; // edi
  HANDLE v6; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // eax
  HMODULE v11; // eax
  MODULEENTRY32W me; // [esp+10h] [ebp-638h]
  WCHAR LibFileName; // [esp+438h] [ebp-210h]

  v5 = 0;
  v6 = CreateToolhelp32Snapshot(8u, *(a1 + 8));
  if ( v6 != -1 )
  {
    me.dwSize = 1064;
    if ( Module32FirstW(v6, &me) )
    {
      while ( 1 )
      {
        if ( me.th32ProcessID == *(a1 + 8) )
        {
          v7 = wcscmp(L"clr.dll", me.szModule);
          if ( v7 )
            v7 = -(v7 < 0) | 1;
          if ( !v7 )
            break;
        }
        if ( !Module32NextW(v6, &me) )
          goto LABEL_11;
      }
      v8 = lstrlenW(me.szExePath);
      v9 = lstrlenW(me.szModule);
      sub_124A440(&LibFileName, 0x105u, me.szExePath, v8 - v9);
      v5 = 1;
LABEL_11:
      CloseHandle(v6);
      if ( !v5 )
        return -2147467259;
      sub_124A3A0(&LibFileName, 0x105u, a2);
      v11 = LoadLibraryExW(&LibFileName, 0, 8u);
      if ( !v11 )
        return -2147467259;
      *a5 = v11;
    }
    else
    {
      CloseHandle(v6);
    }
  }
  return 0;
}

//----- (01249780) --------------------------------------------------------
signed int __stdcall sub_1249780(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  GUID *v5; // esi
  unsigned int v6; // edi
  bool v7; // cf
  GUID *v9; // edx
  unsigned int v10; // esi

  v3 = a2;
  v4 = a2;
  v5 = &CLSID_IUnknown;
  v6 = 12;
  while ( *v4 == v5->Data1 )
  {
    ++v4;
    v5 = (v5 + 4);
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      return 0;
    }
  }
  v9 = &stru_12BF3FC;
  v10 = 12;
  while ( *v3 == v9->Data1 )
  {
    ++v3;
    v9 = (v9 + 4);
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      (*(*a1 + 4))(a1, v9, a1);
      return 0;
    }
  }
  return -2147467262;
}
// 12BF3FC: using guessed type GUID stru_12BF3FC;
// 12C7BBC: using guessed type GUID CLSID_IUnknown;

//----- (01249800) --------------------------------------------------------
signed int __stdcall sub_1249800(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  GUID *v5; // esi
  unsigned int v6; // edi
  bool v7; // cf
  GUID *v9; // edx
  unsigned int v10; // esi

  v3 = a2;
  v4 = a2;
  v5 = &CLSID_IUnknown;
  v6 = 12;
  while ( *v4 == v5->Data1 )
  {
    ++v4;
    v5 = (v5 + 4);
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      return 0;
    }
  }
  v9 = &stru_12BFB98;
  v10 = 12;
  while ( *v3 == v9->Data1 )
  {
    ++v3;
    v9 = (v9 + 4);
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
    {
      *a3 = a1;
      (*(*a1 + 4))(a1, v9, a1);
      return 0;
    }
  }
  return -2147467262;
}
// 12BFB98: using guessed type GUID stru_12BFB98;
// 12C7BBC: using guessed type GUID CLSID_IUnknown;

//----- (01249880) --------------------------------------------------------
signed int __stdcall sub_1249880(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  GUID *v4; // edx
  unsigned int v5; // esi
  bool v6; // cf

  v3 = a2;
  v4 = &CLSID_IUnknown;
  v5 = 12;
  while ( *v3 == v4->Data1 )
  {
    ++v3;
    v4 = (v4 + 4);
    v6 = v5 < 4;
    v5 -= 4;
    if ( v6 )
    {
      *a3 = a1;
      (*(*a1 + 4))(a1, v4, a1);
      return 0;
    }
  }
  return -2147467262;
}
// 12C7BBC: using guessed type GUID CLSID_IUnknown;

//----- (012498D0) --------------------------------------------------------
signed int __stdcall sub_12498D0(int a1, int a2, int a3)
{
  return -2147467262;
}

//----- (012498E0) --------------------------------------------------------
int __stdcall sub_12498E0(int a1, LPCVOID lpBaseAddress, int a3, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
{
  return ReadProcessMemory(*(a1 + 8), lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead) != 1 ? 0x80004005 : 0;
}

//----- (01249910) --------------------------------------------------------
int __stdcall sub_1249910(void *a1)
{
  bool v1; // zf

  v1 = (*(a1 + 1))-- == 1;
  if ( !v1 )
    return *(a1 + 1);
  j__free(a1);
  return 0;
}

//----- (01249940) --------------------------------------------------------
int __stdcall sub_1249940(_DWORD *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = a1[1]-- == 1;
  result = a1[1];
  if ( v1 )
  {
    (*(*a1 + 12))(1);
    result = 0;
  }
  return result;
}

//----- (01249960) --------------------------------------------------------
int __stdcall sub_1249960(void *a1)
{
  bool v1; // zf
  void *v2; // eax

  v1 = (*(a1 + 1))-- == 1;
  if ( !v1 )
    return *(a1 + 1);
  v2 = *(a1 + 6);
  *a1 = &NativeFrame::`vftable';
  if ( v2 )
  {
    j__free(v2);
    *(a1 + 6) = 0;
  }
  j__free(a1);
  return 0;
}
// 12BF430: using guessed type void *NativeFrame::`vftable';

//----- (012499B0) --------------------------------------------------------
int __stdcall sub_12499B0(void *a1)
{
  bool v1; // zf
  void *v2; // eax

  v1 = (*(a1 + 1))-- == 1;
  if ( !v1 )
    return *(a1 + 1);
  v2 = *(a1 + 7);
  *a1 = &SymbolInfo::`vftable';
  if ( v2 )
  {
    j__free(v2);
    *(a1 + 7) = 0;
  }
  j__free(a1);
  return 0;
}
// 12BF420: using guessed type void *SymbolInfo::`vftable';

//----- (01249A00) --------------------------------------------------------
int __cdecl sub_1249A00(void *Dst, void *Src, int a3)
{
  int v3; // eax

  v3 = memmove_s(Dst, 4 * a3, Src, 4 * a3);
  return sub_122B650(v3);
}

//----- (01249A30) --------------------------------------------------------
_DWORD *__thiscall sub_1249A30(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int v3; // ecx
  bool v4; // zf
  _DWORD *result; // eax
  _DWORD *v6; // edi

  v1 = this;
  while ( v1[2] )
  {
    v2 = *v1;
    if ( !*v1 )
      AtlThrow(E_FAIL);
    *v1 = *v2;
    v3 = v2[2];
    if ( v3 )
      (*(*v3 + 8))(v2[2]);
    *v2 = v1[4];
    v4 = v1[2]-- == 1;
    v1[4] = v2;
    if ( v4 )
      sub_1249A30(v1);
  }
  result = v1[3];
  *v1 = 0;
  v1[1] = 0;
  v1[4] = 0;
  if ( result )
  {
    do
    {
      v6 = *result;
      free(result);
      result = v6;
    }
    while ( v6 );
    v1[3] = 0;
  }
  return result;
}

//----- (01249AC0) --------------------------------------------------------
_DWORD *__thiscall sub_1249AC0(int *this, _DWORD *a2)
{
  int *v2; // esi
  int *v3; // edi
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  bool v7; // zf

  v2 = this;
  v3 = *this;
  if ( !*this )
    AtlThrow(E_FAIL);
  v4 = v3[2];
  *a2 = v4;
  if ( v4 )
    (*(*v4 + 4))(v4);
  v5 = *v3;
  *v2 = *v3;
  if ( v5 )
    *(v5 + 4) = 0;
  else
    v2[1] = 0;
  v6 = v3[2];
  if ( v6 )
    (*(*v6 + 8))(v3[2]);
  *v3 = v2[4];
  v7 = v2[2]-- == 1;
  v2[4] = v3;
  if ( v7 )
    sub_1249A30(v2);
  return a2;
}

//----- (01249B40) --------------------------------------------------------
int __stdcall sub_1249B40(DWORD dwThreadId)
{
  HANDLE v1; // eax
  void *v2; // esi

  v1 = OpenThread(0x1F03FFu, 1, dwThreadId);
  v2 = v1;
  if ( !v1 )
    return E_FAIL;
  ResumeThread(v1);
  CloseHandle(v2);
  return 0;
}

//----- (01249B80) --------------------------------------------------------
char __thiscall sub_1249B80(int this, unsigned int a2, int a3)
{
  int v3; // esi
  unsigned int v4; // edi
  int v5; // ebx
  unsigned int v6; // eax
  int v7; // ecx
  char result; // al
  unsigned int v9; // ecx
  unsigned int v10; // [esp+14h] [ebp+Ch]

  v3 = this;
  if ( a3 != -1 )
    *(this + 12) = a3;
  v4 = a2;
  if ( a2 )
  {
    if ( a2 > *(this + 8) )
    {
      result = sub_12488A0(this, a2);
      if ( !result )
        return result;
      v9 = *(v3 + 4);
    }
    else
    {
      v9 = *(this + 4);
      if ( v9 >= a2 )
      {
        if ( v9 > a2 )
        {
          sub_12479D0(*v3 + 4 * a2, v9 - a2);
          *(v3 + 4) = a2;
          return 1;
        }
        goto LABEL_18;
      }
    }
    sub_12479A0((*v3 + 4 * v9), a2 - v9);
LABEL_18:
    *(v3 + 4) = a2;
    return 1;
  }
  v5 = *this;
  if ( *this )
  {
    v6 = *(this + 4);
    v10 = v6;
    if ( v6 )
    {
      do
      {
        v7 = *(v5 + 4 * v4);
        if ( v7 )
        {
          (*(*v7 + 8))(*(v5 + 4 * v4));
          v6 = v10;
        }
        ++v4;
      }
      while ( v4 < v6 );
    }
    free(*v3);
    *v3 = 0;
  }
  *(v3 + 4) = 0;
  result = 1;
  *(v3 + 8) = 0;
  return result;
}

//----- (01249C50) --------------------------------------------------------
int __thiscall sub_1249C50(_DWORD *this, int a2, int a3, int a4)
{
  int *v4; // edi
  int v5; // ebx
  int result; // eax
  int *v7; // ecx
  void *v8; // esi
  int *v9; // eax
  int *v10; // edi
  unsigned int v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // edi
  _DWORD *v14; // esi
  int v15; // ecx
  wchar_t *v16; // ST00_4
  unsigned int v17; // eax
  _DWORD *v18; // eax
  int v19; // eax
  int v20; // eax
  int *v21; // ecx
  void *v22; // esi
  bool v23; // zf
  int v24; // edi
  int (__stdcall **v25)(void *, GUID *, int *); // eax
  _DWORD *v26; // eax
  _DWORD *v27; // ebx
  _DWORD *v28; // ecx
  void *v29; // eax
  _DWORD *v30; // eax
  int *v31; // eax
  void *v32; // ecx
  void *v33; // eax
  _DWORD *v34; // eax
  _DWORD *v35; // ebx
  int v36; // ecx
  wchar_t *v37; // ST00_4
  void *v38; // eax
  _DWORD *v39; // eax
  int v40; // ecx
  int v41; // ecx
  int v42; // eax
  int *v43; // ecx
  int (__stdcall ***v44)(_DWORD, void *, int *); // edi
  _DWORD *v45; // eax
  void *v46; // eax
  int v47; // ecx
  _DWORD *v48; // eax
  void *v49; // eax
  int v50; // ecx
  unsigned __int64 v51; // [esp+10h] [ebp-103Ch]
  void *v52; // [esp+18h] [ebp-1034h]
  int (__stdcall ***v53)(_DWORD, void *, int *); // [esp+1Ch] [ebp-1030h]
  int *v54; // [esp+20h] [ebp-102Ch]
  _DWORD *v55; // [esp+24h] [ebp-1028h]
  int *v56; // [esp+28h] [ebp-1024h]
  void *v57; // [esp+2Ch] [ebp-1020h]
  void *v58; // [esp+30h] [ebp-101Ch]
  int v59; // [esp+34h] [ebp-1018h]
  int v60; // [esp+38h] [ebp-1014h]
  wchar_t v61; // [esp+3Ch] [ebp-1010h]
  wchar_t Dst; // [esp+83Ch] [ebp-810h]
  int v63; // [esp+1048h] [ebp-4h]

  v55 = this;
  v4 = a3;
  v5 = a4;
  v54 = a3;
  result = *(a3 + 8);
  v59 = a4;
  if ( !result )
  {
    if ( *(a2 + 8) )
    {
      if ( *(a2 + 8) > 0u )
      {
        v7 = *a2;
        if ( *a2 )
        {
          while ( v7 )
          {
            v8 = v7[2];
            v60 = *v7;
            v57 = v8;
            if ( v8 )
              (*(*v8 + 4))(v8);
            v63 = 0;
            v54 = 0;
            v9 = operator new(0x20u);
            v10 = v9;
            v52 = v9;
            LOBYTE(v63) = 2;
            if ( v9 )
            {
              *v9 = &SymbolInfo::`vftable';
              v9[1] = 1;
              v9[7] = operator new[](0x800u);
            }
            else
            {
              v10 = 0;
            }
            LOBYTE(v63) = 1;
            v54 = v10;
            result = sub_12480C0(v8, v10);
            if ( result )
            {
              v11 = *(a4 + 4);
              v59 = v11;
              if ( v11 >= *(a4 + 8) && !sub_12488A0(a4, v11 + 1) )
                goto LABEL_24;
              result = *a4 + 4 * v59;
              if ( result )
              {
                *result = v10;
                if ( v10 )
                  result = (*(*v10 + 4))(v10);
              }
              ++*(a4 + 4);
            }
            LOBYTE(v63) = 0;
            if ( v10 )
              result = (*(*v10 + 8))(v10);
            v63 = -1;
            if ( v8 )
              result = (*(*v8 + 8))(v8);
            v7 = v60;
            if ( !v60 )
              return result;
          }
          goto LABEL_41;
        }
      }
    }
    return result;
  }
  if ( !*(a2 + 8) )
  {
    while ( 1 )
    {
      sub_1249AC0(v4, &v59);
      v63 = 3;
      v55 = 0;
      LOBYTE(v63) = 4;
      v12 = operator new(0x20u);
      v13 = v12;
      v57 = v12;
      LOBYTE(v63) = 5;
      if ( v12 )
      {
        *v12 = &SymbolInfo::`vftable';
        v12[1] = 1;
        v12[7] = operator new[](0x800u);
      }
      else
      {
        v13 = 0;
      }
      v14 = v59;
      LOBYTE(v63) = 4;
      v55 = v13;
      if ( v59 )
        (*(*v59 + 4))(v59);
      swprintf_s(&Dst, 0x400u, L"%s", v14[6]);
      v15 = v14[3];
      v13[4] = v14[2];
      v16 = v13[7];
      v13[5] = v15;
      swprintf_s(v16, 0x400u, L"%s", &Dst);
      v13[6] = 3;
      (*(*v14 + 8))(v14);
      v17 = *(a4 + 4);
      v60 = v17;
      if ( v17 >= *(a4 + 8) && !sub_12488A0(a4, v17 + 1) )
        break;
      v18 = (*a4 + 4 * v60);
      if ( v18 )
      {
        *v18 = v13;
        (*(*v13 + 4))(v13);
      }
      ++*(a4 + 4);
      v19 = *v13;
      LOBYTE(v63) = 3;
      (*(v19 + 8))(v13);
      v20 = *v14;
      v63 = -1;
      result = (*(v20 + 8))(v14);
      v4 = v54;
      if ( !v54[2] )
        return result;
    }
    goto LABEL_24;
  }
  if ( !result || !*(a2 + 8) )
    return result;
  v21 = *a2;
  v56 = v21;
  result = v21 != 0;
  if ( !v21 )
    goto LABEL_41;
  v22 = v21[2];
  v52 = v22;
  if ( v22 )
    result = (*(*v22 + 4))(v22);
  v23 = *(a3 + 8) == 0;
  v63 = 6;
  if ( !v23 )
  {
    while ( 1 )
    {
      sub_1249AC0(v4, &v53);
      v24 = v53;
      while ( 1 )
      {
        v60 = 0;
        v25 = *v22;
        LOBYTE(v63) = 8;
        if ( (*v25)(v22, &stru_12BFC40, &v60) )
          break;
        (*(*v60 + 12))(v60, &v51);
        LOBYTE(v63) = 7;
        if ( v60 )
          (*(*v60 + 8))(v60);
        if ( !v56 || v51 >= *(v24 + 8) )
          goto LABEL_71;
        v60 = 0;
        LOBYTE(v63) = 9;
        v26 = operator new(0x20u);
        v27 = v26;
        v57 = v26;
        LOBYTE(v63) = 10;
        if ( v26 )
        {
          *v26 = &SymbolInfo::`vftable';
          v26[1] = 1;
          v26[7] = operator new[](0x800u);
        }
        else
        {
          v27 = 0;
        }
        LOBYTE(v63) = 9;
        v60 = v27;
        if ( sub_12480C0(v22, v27) )
        {
          v28 = v59;
          v29 = *(v59 + 4);
          v58 = v29;
          if ( v29 >= *(v59 + 8) )
          {
            if ( !sub_12488A0(v59, v29 + 1) )
              goto LABEL_24;
            v28 = v59;
          }
          v30 = (*v28 + 4 * v58);
          if ( v30 )
          {
            *v30 = v27;
            if ( v27 )
            {
              (*(*v27 + 4))(v27);
              v28 = v59;
            }
          }
          ++v28[1];
        }
        v31 = v56;
        v56 = *v56;
        v32 = v31[2];
        v58 = v32;
        if ( v22 != v32 )
        {
          if ( v32 )
          {
            (*(*v32 + 4))(v32);
            v32 = v58;
          }
          v33 = v22;
          v22 = v32;
          v52 = v32;
          if ( v33 )
            (*(*v33 + 8))(v33);
        }
        LOBYTE(v63) = 7;
        if ( v27 )
          (*(*v27 + 8))(v27);
      }
      LOBYTE(v63) = 7;
      if ( v60 )
        (*(*v60 + 8))(v60);
LABEL_71:
      v58 = 0;
      LOBYTE(v63) = 11;
      v34 = operator new(0x20u);
      v35 = v34;
      v60 = v34;
      v57 = v34;
      LOBYTE(v63) = 12;
      if ( v34 )
      {
        *v34 = &SymbolInfo::`vftable';
        v34[1] = 1;
        v34[7] = operator new[](0x800u);
      }
      else
      {
        v35 = 0;
        v60 = 0;
      }
      LOBYTE(v63) = 11;
      v58 = v35;
      if ( v24 )
        (*(*v24 + 4))(v24);
      swprintf_s(&v61, 0x400u, L"%s", *(v24 + 24));
      v36 = *(v24 + 12);
      v35[4] = *(v24 + 8);
      v37 = v35[7];
      v35[5] = v36;
      swprintf_s(v37, 0x400u, L"%s", &v61);
      v35[6] = 3;
      (*(*v24 + 8))(v24);
      v5 = v59;
      v38 = *(v59 + 4);
      v57 = v38;
      if ( v38 >= *(v59 + 8) && !sub_12488A0(v59, v38 + 1) )
        break;
      v39 = (*v5 + 4 * v57);
      if ( v39 )
      {
        v40 = v60;
        *v39 = v60;
        (*(*v40 + 4))(v40);
      }
      v41 = v60;
      ++*(v5 + 4);
      LOBYTE(v63) = 7;
      (*(*v41 + 8))(v41);
      v42 = *v24;
      LOBYTE(v63) = 6;
      result = (*(v42 + 8))(v24);
      v4 = v54;
      if ( !v54[2] )
        goto LABEL_81;
    }
LABEL_24:
    AtlThrow(-2147024882);
  }
LABEL_81:
  v43 = v56;
  if ( v56 )
  {
    while ( v43 )
    {
      v44 = v43[2];
      v56 = *v43;
      v53 = v44;
      if ( v44 )
        ((*v44)[1])(v44);
      v57 = 0;
      LOBYTE(v63) = 14;
      v45 = operator new(0x20u);
      v60 = v45;
      v58 = v45;
      LOBYTE(v63) = 15;
      if ( v45 )
      {
        *v45 = &SymbolInfo::`vftable';
        v45[1] = 1;
        v46 = operator new[](0x800u);
        v47 = v60;
        *(v60 + 28) = v46;
        v48 = v47;
      }
      else
      {
        v48 = 0;
        v60 = 0;
      }
      LOBYTE(v63) = 14;
      v57 = v48;
      result = sub_12480C0(v44, v48);
      if ( result )
      {
        v49 = *(v5 + 4);
        v58 = v49;
        if ( v49 >= *(v5 + 8) && !sub_12488A0(v5, v49 + 1) )
          goto LABEL_24;
        result = *v5 + 4 * v58;
        if ( result )
        {
          v50 = v60;
          *result = v60;
          if ( v50 )
            result = (*(*v50 + 4))(v50);
        }
        ++*(v5 + 4);
      }
      LOBYTE(v63) = 13;
      if ( v60 )
        result = (*(*v60 + 8))(v60);
      LOBYTE(v63) = 6;
      if ( v44 )
        result = ((*v44)[2])(v44);
      v43 = v56;
      if ( !v56 )
        goto LABEL_100;
    }
LABEL_41:
    AtlThrow(-2147467259);
  }
LABEL_100:
  v63 = -1;
  if ( v22 )
    result = (*(*v22 + 8))(v22);
  return result;
}
// 12BF420: using guessed type void *SymbolInfo::`vftable';
// 12BFC40: using guessed type GUID stru_12BFC40;

//----- (0124A3A0) --------------------------------------------------------
signed int __stdcall sub_124A3A0(_WORD *a1, unsigned int a2, int a3)
{
  signed int result; // eax
  _WORD *v4; // eax
  unsigned int v5; // edx
  signed int v6; // ecx
  int v7; // edi
  __int16 v8; // si
  int v9; // [esp+8h] [ebp-4h]

  result = sub_124A500(a1, a2, &v9, 0x7FFFFFFFu);
  if ( result >= 0 )
  {
    v4 = &a1[v9];
    v5 = a2 - v9;
    if ( a2 == v9 )
      goto LABEL_13;
    v6 = 0x7FFFFFFF;
    v7 = a3 - v4;
    while ( v6 )
    {
      v8 = *(v4 + v7);
      if ( !v8 )
        break;
      *v4 = v8;
      --v6;
      ++v4;
      if ( !--v5 )
      {
        *(v4 - 1) = 0;
        return -2147024774;
      }
    }
    if ( v5 )
    {
      *v4 = 0;
      result = 0;
    }
    else
    {
LABEL_13:
      *(v4 - 1) = 0;
      result = -2147024774;
    }
  }
  return result;
}

//----- (0124A440) --------------------------------------------------------
signed int __stdcall sub_124A440(_WORD *a1, unsigned int a2, int a3, unsigned int a4)
{
  signed int result; // eax

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    if ( a4 <= 0x7FFFFFFE )
    {
      result = sub_124A490(a1, a2, 0, a3, a4);
    }
    else
    {
      *a1 = 0;
      result = -2147024809;
    }
  }
  return result;
}

//----- (0124A490) --------------------------------------------------------
signed int __stdcall sub_124A490(_WORD *a1, int a2, _DWORD *a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  _WORD *v7; // eax
  int v8; // esi
  __int16 v9; // di
  signed int v10; // edi

  v5 = a2;
  v6 = 0;
  v7 = a1;
  if ( !a2 )
    goto LABEL_15;
  v8 = a5;
  while ( v8 )
  {
    v9 = *(v7 + a4 - a1);
    if ( !v9 )
      break;
    *v7 = v9;
    --v8;
    ++v7;
    ++v6;
    if ( !--v5 )
    {
      --v7;
      v10 = -2147024774;
      --v6;
      goto LABEL_10;
    }
  }
  if ( v5 )
  {
    v10 = 0;
  }
  else
  {
LABEL_15:
    --v7;
    v10 = -2147024774;
    --v6;
  }
LABEL_10:
  *v7 = 0;
  if ( a3 )
    *a3 = v6;
  return v10;
}

//----- (0124A500) --------------------------------------------------------
signed int __stdcall sub_124A500(_WORD *a1, unsigned int a2, _DWORD *a3, unsigned int a4)
{
  signed int result; // eax
  _WORD *v5; // eax
  unsigned int v6; // ecx
  signed int v7; // esi

  result = 0;
  if ( !a2 || a2 > a4 )
    result = -2147024809;
  if ( result < 0 )
  {
    *a3 = 0;
  }
  else
  {
    v5 = a1;
    v6 = a2;
    v7 = 0;
    if ( !a2 )
      goto LABEL_10;
    while ( *v5 )
    {
      ++v5;
      if ( !--v6 )
        goto LABEL_10;
    }
    if ( !v6 )
LABEL_10:
      v7 = -2147024809;
    if ( a3 )
    {
      if ( v7 >= 0 )
      {
        *a3 = a2 - v6;
        return v7;
      }
      *a3 = 0;
    }
    result = v7;
  }
  return result;
}

//----- (0124A570) --------------------------------------------------------
HANDLE __thiscall sub_124A570(void *this, DWORD dwThreadId, int a3, int a4, int a5, int a6, int a7)
{
  _DWORD *v7; // edi
  HANDLE result; // eax
  int v9; // ecx
  unsigned int v10; // eax
  signed int v11; // esi
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // esi
  unsigned int v15; // kr00_4
  wchar_t *v16; // eax
  int *v17; // edi
  int v18; // eax
  int **v19; // eax
  int v20; // eax
  int v21; // [esp+0h] [ebp-3E0h]
  int *v22; // [esp+10h] [ebp-3D0h]
  int *v23; // [esp+14h] [ebp-3CCh]
  int v24; // [esp+18h] [ebp-3C8h]
  int v25; // [esp+1Ch] [ebp-3C4h]
  _DWORD *v26; // [esp+20h] [ebp-3C0h]
  int v27; // [esp+24h] [ebp-3BCh]
  int v28; // [esp+28h] [ebp-3B8h]
  HANDLE hThread; // [esp+2Ch] [ebp-3B4h]
  PVOID ContextRecord; // [esp+30h] [ebp-3B0h]
  struct _tagSTACKFRAME64 StackFrame; // [esp+34h] [ebp-3ACh]
  char v32; // [esp+13Ch] [ebp-2A4h]
  char v33; // [esp+170h] [ebp-270h]
  int *v34; // [esp+3D0h] [ebp-10h]
  int v35; // [esp+3DCh] [ebp-4h]

  v34 = &v21;
  v7 = this;
  v26 = this;
  ContextRecord = a3;
  result = OpenThread(0x1F03FFu, 1, dwThreadId);
  hThread = result;
  if ( result )
  {
    memset(&StackFrame, 0, 0x108u);
    v9 = *(a3 + 184);
    StackFrame.AddrStack.Offset = *(a3 + 196);
    v10 = *(a3 + 180);
    v11 = 0;
    StackFrame.AddrFrame.Offset = v10;
    StackFrame.AddrBStore.Offset = v10;
    StackFrame.AddrPC.Offset = v9;
    StackFrame.AddrPC.Mode = 3;
    StackFrame.AddrStack.Mode = 3;
    StackFrame.AddrFrame.Mode = 3;
    StackFrame.AddrBStore.Mode = 3;
    StackFrame.AddrReturn.Mode = 3;
    do
    {
      v35 = 0;
      if ( StackFrame.Virtual == 1 )
        v11 = 1;
      v12 = v7[5];
      v28 = v11;
      sub_125DD60(1, v9, &v32, v7[3], 0, 0, *(v12 + 20), *(v12 + 16));
      if ( v11 )
      {
        v25 = 0;
        LOBYTE(v35) = 1;
        v13 = operator new(0x20u);
        v14 = v13;
        if ( v13 )
        {
          *v13 = &NativeFrame::`vftable';
          v13[1] = 1;
          v13[6] = 0;
        }
        else
        {
          v14 = 0;
        }
        *(v14 + 8) = StackFrame.AddrFrame.Offset;
        v25 = v14;
        v15 = wcslen(&v33);
        v16 = operator new[](2 * (v15 + 1));
        *(v14 + 24) = v16;
        swprintf_s(v16, v15 + 1, L"%s", &v33);
        v27 = *(a7 + 4);
        sub_1247F70(a7);
        v17 = *(a7 + 16);
        v23 = v17;
        v22 = v17;
        v18 = *v17;
        v24 = *v17;
        LOBYTE(v35) = 2;
        if ( v17 )
        {
          v17[2] = v14;
          (*(*v14 + 4))(v14);
          v18 = v24;
        }
        *(a7 + 16) = v18;
        v17[1] = v27;
        *v17 = 0;
        ++*(a7 + 8);
        v19 = *(a7 + 4);
        if ( v19 )
          *v19 = v17;
        else
          *a7 = v17;
        *(a7 + 4) = v17;
        v20 = *v14;
        LOBYTE(v35) = 0;
        (*(v20 + 8))(v14);
        v11 = v28;
        v7 = v26;
      }
      if ( !StackWalk64(
              0x14Cu,
              v7[3],
              hThread,
              &StackFrame,
              ContextRecord,
              0,
              SymFunctionTableAccess64,
              SymGetModuleBase64,
              0) )
        break;
      v9 = StackFrame.AddrPC.Offset;
      v35 = -1;
      if ( !StackFrame.AddrPC.Offset )
        break;
    }
    while ( StackFrame.AddrFrame.Offset < __PAIR__(a6, a5) );
    result = HANDLE_FLAG_INHERIT;
  }
  return result;
}
// 12BF430: using guessed type void *NativeFrame::`vftable';

//----- (0124A870) --------------------------------------------------------
char __cdecl sub_124A870(int a1, WPARAM wParam)
{
  char v2; // bl
  wchar_t *v3; // eax
  int v4; // esi
  _DWORD *v5; // eax
  WPARAM v6; // edi
  int *v7; // eax
  _QWORD *v8; // eax
  HWND v9; // ST10_4
  unsigned __int8 v10; // al
  char v11; // bl
  double v12; // xmm0_8
  HWND v13; // ST10_4
  bool v14; // al
  _DWORD *v15; // eax
  int *v16; // eax
  _QWORD *v17; // eax
  HWND v18; // ST10_4
  unsigned __int8 v19; // al
  char v20; // bl
  _QWORD *v21; // eax
  HWND v22; // ST10_4
  unsigned __int8 v23; // al
  char v24; // bl
  _QWORD *v25; // eax
  HWND v26; // ST10_4
  unsigned __int8 v27; // al
  char v28; // bl
  _QWORD *v29; // eax
  HWND v30; // ST10_4
  unsigned __int8 v31; // al
  char v32; // bl
  _QWORD *v33; // eax
  HWND v34; // ST10_4
  unsigned __int8 v35; // al
  char v36; // bl
  _QWORD *v37; // eax
  HWND v38; // ST10_4
  unsigned __int8 v39; // al
  _DWORD *v40; // eax
  int *v41; // eax
  _QWORD *v42; // eax
  HWND v43; // ST10_4
  unsigned __int8 v44; // al
  _DWORD *v45; // eax
  int *v46; // eax
  _QWORD *v47; // eax
  HWND v48; // ST10_4
  unsigned __int8 v49; // al
  char v50; // bl
  _QWORD *v51; // eax
  HWND v52; // ST10_4
  unsigned __int8 v53; // al
  char v54; // bl
  _QWORD *v55; // eax
  HWND v56; // ST10_4
  unsigned __int8 v57; // al
  char v58; // bl
  _QWORD *v59; // eax
  HWND v60; // ST10_4
  unsigned __int8 v61; // al
  char v62; // bl
  int v63; // edi
  signed __int64 v64; // rax
  int v65; // ecx
  HWND v66; // ST10_4
  unsigned __int8 v67; // al
  char v68; // bl
  double v69; // xmm0_8
  HWND v70; // ST10_4
  bool v71; // al
  _DWORD *v72; // eax
  int *v73; // eax
  _QWORD *v74; // eax
  HWND v75; // ST10_4
  unsigned __int8 v76; // al
  char v78; // [esp+2Ch] [ebp-250h]
  int v79[2]; // [esp+3Ch] [ebp-240h]
  int v80; // [esp+44h] [ebp-238h]
  unsigned int v81; // [esp+4Ch] [ebp-230h]
  int v82; // [esp+54h] [ebp-228h]
  int v83; // [esp+58h] [ebp-224h]
  void *v84[2]; // [esp+60h] [ebp-21Ch]
  void *v85; // [esp+68h] [ebp-214h]
  void *v86; // [esp+6Ch] [ebp-210h]
  wchar_t Dst; // [esp+70h] [ebp-20Ch]
  __int16 v88; // [esp+8Ch] [ebp-1F0h]

  v2 = 0;
  if ( !*(a1 + 1284) )
    return 0;
  tcscpy_s(&Dst, 0x104u, *(a1 + 60));
  v3 = wcsrchr(&Dst, 0x2Eu);
  if ( v3 && v3 != &Dst )
    *v3 = 0;
  v4 = *(a1 + 1284);
  v82 = *(a1 + 1284);
  v88 = 0;
  unknown_libname_3(&dword_12EA0C4, &Data);
  v5 = sub_124E8B0(&v78, L".NET CLR Jit");
  v6 = wParam;
  v85 = v5;
  if ( v5 )
  {
    v7 = sub_12486E0(&Dst, v5);
    v86 = v7;
    if ( v7 )
    {
      v8 = sub_1247F10(v7, L"# of methods Jitted", &v83);
      v9 = ghWndTreeListView;
      v10 = sub_127F920(*v8, *v8 >> 32, v4);
      v11 = ColumnIDIsIllegal(v10, v9, 1094, wParam);
      sub_1247F10(v86, L"% time in JIT", &v80);
      v84[1] = sub_124E840(v86);
      sub_124ECA0(v84[1], &v81, 0);
      v12 = 0.0;
      if ( v81 != 0.0 )
        v12 = v80 * 100.0 / v81;
      v13 = ghWndTreeListView;
      v14 = sub_127F8F0(v12, (v4 + 8));
      v2 = ColumnIDIsIllegal(v14, v13, 1095, wParam) | v11;
      if ( v84[1] )
      {
        sub_124EC80(v84[1]);
        j__free(v84[1]);
      }
      j__free(v86);
    }
    j__free(v85);
  }
  v15 = sub_124E8B0(&v78, L".NET CLR Loading");
  v85 = v15;
  if ( v15 )
  {
    v16 = sub_12486E0(&Dst, v15);
    v86 = v16;
    if ( v16 )
    {
      v17 = sub_1247F10(v16, L"Current AppDomains", &v83);
      v18 = ghWndTreeListView;
      v19 = sub_127F920(*v17, *v17 >> 32, (v4 + 16));
      v20 = ColumnIDIsIllegal(v19, v18, 1096, wParam) | v2;
      v21 = sub_1247F10(v86, L"Current Assemblies", &v83);
      v22 = ghWndTreeListView;
      v23 = sub_127F920(*v21, *v21 >> 32, (v4 + 48));
      v24 = ColumnIDIsIllegal(v23, v22, 1097, wParam) | v20;
      v25 = sub_1247F10(v86, L"Current Classes Loaded", &v83);
      v26 = ghWndTreeListView;
      v27 = sub_127F920(*v25, *v25 >> 32, (v4 + 32));
      v28 = ColumnIDIsIllegal(v27, v26, 1098, wParam) | v24;
      v29 = sub_1247F10(v86, L"Total AppDomains", &v83);
      v30 = ghWndTreeListView;
      v31 = sub_127F920(*v29, *v29 >> 32, (v4 + 24));
      v32 = ColumnIDIsIllegal(v31, v30, 1099, wParam) | v28;
      v33 = sub_1247F10(v86, L"Total Assemblies", &v83);
      v34 = ghWndTreeListView;
      v35 = sub_127F920(*v33, *v33 >> 32, (v4 + 56));
      v36 = ColumnIDIsIllegal(v35, v34, 1100, wParam) | v32;
      v37 = sub_1247F10(v86, L"Total Classes Loaded", &v83);
      v38 = ghWndTreeListView;
      v39 = sub_127F920(*v37, *v37 >> 32, (v4 + 40));
      v2 = ColumnIDIsIllegal(v39, v38, 1101, wParam) | v36;
      j__free(v86);
    }
    j__free(v85);
  }
  v40 = sub_124E8B0(&v78, L".NET CLR LocksAndThreads");
  v84[1] = v40;
  if ( v40 )
  {
    v41 = sub_12486E0(&Dst, v40);
    v85 = v41;
    if ( v41 )
    {
      v42 = sub_1247F10(v41, L"Total # of contentions", &v83);
      v43 = ghWndTreeListView;
      v44 = sub_127F920(*v42, *v42 >> 32, (v4 + 128));
      v2 |= ColumnIDIsIllegal(v44, v43, 1110, wParam);
      j__free(v85);
    }
    j__free(v84[1]);
  }
  v45 = sub_124E8B0(&v78, L".NET CLR Memory");
  v85 = v45;
  if ( v45 )
  {
    v46 = sub_12486E0(&Dst, v45);
    v86 = v46;
    if ( v46 )
    {
      v47 = sub_1247F10(v46, L"# bytes in all heaps", &v83);
      v48 = ghWndTreeListView;
      v49 = sub_127F920(*v47, *v47 >> 32, (v4 + 112));
      v50 = ColumnIDIsIllegal(v49, v48, 1103, wParam) | v2;
      v51 = sub_1247F10(v86, L"# Gen 0 collections", &v83);
      v52 = ghWndTreeListView;
      v53 = sub_127F920(*v51, *v51 >> 32, (v4 + 64));
      v54 = ColumnIDIsIllegal(v53, v52, 1104, wParam) | v50;
      v55 = sub_1247F10(v86, L"# Gen 1 collections", &v83);
      v56 = ghWndTreeListView;
      v57 = sub_127F920(*v55, *v55 >> 32, (v4 + 72));
      v58 = ColumnIDIsIllegal(v57, v56, 1105, wParam) | v54;
      v59 = sub_1247F10(v86, L"# Gen 2 collections", &v83);
      v60 = ghWndTreeListView;
      v61 = sub_127F920(*v59, *v59 >> 32, (v4 + 80));
      v62 = ColumnIDIsIllegal(v61, v60, 1106, wParam) | v58;
      sub_1247F10(v86, L"Allocated bytes/sec", v79);
      v63 = v79[1];
      *v84 = *v79;
      *v84 = *v79 - *(v82 + 96);
      v64 = (*v84 / ((*&SystemTimeAsFileTime - qword_12EA0A8) / 10000000.0));
      v65 = v64;
      LODWORD(v64) = v82;
      *(v82 + 96) = v79[0];
      v4 = v64;
      *(v64 + 100) = v63;
      v6 = wParam;
      v66 = ghWndTreeListView;
      v67 = sub_127F920(v65, SHIDWORD(v64), (v64 + 104));
      v68 = ColumnIDIsIllegal(v67, v66, 1108, wParam) | v62;
      sub_1247F10(v86, L"% time in GC", &v80);
      v84[1] = sub_124E840(v86);
      sub_124ECA0(v84[1], &v81, 0);
      v69 = 0.0;
      if ( v81 != 0.0 )
        v69 = v80 * 100.0 / v81;
      v70 = ghWndTreeListView;
      v71 = sub_127F8F0(v69, (v4 + 88));
      v2 = ColumnIDIsIllegal(v71, v70, 1107, wParam) | v68;
      if ( v84[1] )
      {
        sub_124EC80(v84[1]);
        j__free(v84[1]);
      }
      j__free(v86);
    }
    j__free(v85);
  }
  v72 = sub_124E8B0(&v78, L".NET CLR Security");
  v84[1] = v72;
  if ( v72 )
  {
    v73 = sub_12486E0(&Dst, v72);
    v85 = v73;
    if ( v73 )
    {
      v74 = sub_1247F10(v73, L"Total runtime checks", &v83);
      v75 = ghWndTreeListView;
      v76 = sub_127F920(*v74, *v74 >> 32, (v4 + 120));
      v2 |= ColumnIDIsIllegal(v76, v75, 1109, v6);
      j__free(v85);
    }
    j__free(v84[1]);
  }
  return v2;
}
// 124E890: using guessed type _DWORD __stdcall unknown_libname_3(_DWORD, _DWORD);
// 12BCDC0: using guessed type double gdbMaxValue;
// 12EA0A8: using guessed type __int64 qword_12EA0A8;
// 12EA0C4: using guessed type int dword_12EA0C4;

//----- (0124B0A0) --------------------------------------------------------
int __thiscall sub_124B0A0(_DWORD *this, DWORD dwThreadId, int a3)
{
  _DWORD *v3; // ebx
  int result; // eax
  int *v5; // ST20_4
  int v6; // ecx
  HANDLE v7; // eax
  void *v8; // esi
  signed int v9; // ebx
  HANDLE v10; // eax
  void *v11; // esi
  int *v12; // ecx
  int v13; // eax
  int v14; // eax
  int (__stdcall ***v15)(int, GUID *, void **); // edi
  int (__stdcall ***v16)(int, GUID *, void **); // esi
  int v17; // eax
  int v18; // ecx
  int (__stdcall ***v19)(int, GUID *, void **); // eax
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  int (__stdcall **pfnQueryInterface)(int, GUID *, void **); // eax
  int v24; // eax
  int v25; // ecx
  int (__stdcall ***v26)(int, GUID *, void **); // eax
  int (__stdcall **pfnQueryInterface2)(int, GUID *, void **); // eax
  int v28[2]; // [esp+10h] [ebp-62Ch]
  int v29; // [esp+18h] [ebp-624h]
  int v30; // [esp+1Ch] [ebp-620h]
  int v31; // [esp+20h] [ebp-61Ch]
  int v32; // [esp+24h] [ebp-618h]
  int v33; // [esp+28h] [ebp-614h]
  int v34; // [esp+2Ch] [ebp-610h]
  int v35; // [esp+30h] [ebp-60Ch]
  int v36; // [esp+34h] [ebp-608h]
  int v37; // [esp+38h] [ebp-604h]
  int v38; // [esp+3Ch] [ebp-600h]
  int v39; // [esp+40h] [ebp-5FCh]
  int v40; // [esp+44h] [ebp-5F8h]
  int v41; // [esp+48h] [ebp-5F4h]
  unsigned int v42; // [esp+4Ch] [ebp-5F0h]
  int v43; // [esp+50h] [ebp-5ECh]
  int v44; // [esp+54h] [ebp-5E8h]
  int v45; // [esp+58h] [ebp-5E4h]
  int v46; // [esp+5Ch] [ebp-5E0h]
  int (__stdcall ***v47)(int, GUID *, void **); // [esp+60h] [ebp-5DCh]
  int v48; // [esp+64h] [ebp-5D8h]
  int v49; // [esp+68h] [ebp-5D4h]
  int (__stdcall ***v50)(int, GUID *, void **); // [esp+6Ch] [ebp-5D0h]
  int v51; // [esp+70h] [ebp-5CCh]
  int v52; // [esp+74h] [ebp-5C8h]
  int v53; // [esp+78h] [ebp-5C4h]
  int v54; // [esp+7Ch] [ebp-5C0h]
  int v55; // [esp+80h] [ebp-5BCh]
  int v56; // [esp+84h] [ebp-5B8h]
  int v57; // [esp+88h] [ebp-5B4h]
  unsigned int v58; // [esp+8Ch] [ebp-5B0h]
  int v59; // [esp+90h] [ebp-5ACh]
  int v60; // [esp+94h] [ebp-5A8h]
  int v61; // [esp+360h] [ebp-2DCh]
  int v62; // [esp+638h] [ebp-4h]

  v3 = this;
  v52 = a3;
  result = sub_1248D10(this, dwThreadId);
  if ( !result )
    return result;
  v53 = 0;
  v5 = v3[7];
  v6 = *v5;
  v62 = 0;
  (*(v6 + 60))(v5, dwThreadId, &v53);
  if ( !v53 )
  {
    v7 = OpenThread(0x1F03FFu, 1, dwThreadId);
    v8 = v7;
    if ( v7 )
    {
      ResumeThread(v7);
      CloseHandle(v8);
    }
    v9 = 0;
    goto LABEL_72;
  }
  v10 = OpenThread(0x1F03FFu, 1, dwThreadId);
  v11 = v10;
  if ( v10 )
  {
    SuspendThread(v10);
    CloseHandle(v11);
  }
  v12 = 0;
  v58 = 0;
  if ( v53 )
  {
    v13 = (**v53)(v53, &stru_12BFC50, &v58);
    v12 = v58;
    if ( v13 < 0 )
      v12 = 0;
    v58 = v12;
  }
  if ( !v12 )
  {
    sub_1249B40(dwThreadId);
    v9 = 0;
    goto LABEL_70;
  }
  v54 = 0;
  v14 = *v12;
  LOBYTE(v62) = 2;
  if ( (*(v14 + 12))(v12, &v54) )
  {
    sub_1249B40(dwThreadId);
    v9 = 0;
    goto LABEL_68;
  }
  v43 = 0;
  v44 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 10;
  v48 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 10;
  LOBYTE(v62) = 4;
  if ( !sub_1247FF0(v58, &v41, &v42) )
  {
    v9 = 0;
    goto LABEL_67;
  }
  v51 = 0;
  v15 = 0;
  *v28 = 0i64;
  v46 = 0;
  v49 = 0;
  v16 = 0;
  v50 = 0;
  LOBYTE(v62) = 6;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v51 == 1 )
      {
        v47 = v15;
        if ( v15 )
          ((*v15)[1])(v15);
        LOBYTE(v62) = 7;
        if ( v15 )
        {
          v55 = 0;
          v56 = 0;
          v17 = (**v15)(v15, &stru_12BFC60, &v56);
          v18 = v56;
          if ( v17 < 0 )
            v18 = 0;
          v56 = v18;
          LOBYTE(v62) = 8;
          if ( v18 )
          {
            (*(*v18 + 12))(v18, &v55);
            if ( v55 == 1 && v16 != v15 )
            {
              ((*v15)[1])(v15);
              v19 = v16;
              v16 = v15;
              v50 = v15;
              if ( v19 )
                ((*v19)[2])(v19);
            }
            v18 = v56;
          }
          LOBYTE(v62) = 7;
          if ( v18 )
            (*(*v18 + 8))(v18);
        }
        LOBYTE(v62) = 6;
        if ( v15 )
          ((*v15)[2])(v15);
      }
      v49 = 0;
      v55 = v15;
      v20 = sub_1248E20(v3, v58, v54, &v55, &v46, &v51, v41, v42, &v48);
      v15 = v55;
      v49 = v55;
      if ( v20 )
      {
        if ( v16 )
          break;
      }
      if ( v20 != 1 )
      {
        sub_124A570(v3, dwThreadId, &v61, 716, -1, 0x7FFFFFFF, &v35);
        sub_1249C50(v3, &v29, &v35, v52);
        sub_1249A30(&v35);
        sub_1249B40(dwThreadId);
        sub_12477E0(v52);
        v9 = 1;
        goto LABEL_63;
      }
      if ( !sub_124B680(v3, dwThreadId, v55, v54, &v29, &v35, &v43, &v60, &v44, &v61, v28, v52) )
      {
        sub_1249B40(dwThreadId);
        v9 = 0;
        goto LABEL_63;
      }
    }
    v47 = v55;
    if ( v55 )
      (*(*v55 + 4))(v55);
    LOBYTE(v62) = 9;
    if ( v15 )
      break;
LABEL_52:
    LOBYTE(v62) = 6;
    if ( v15 )
      ((*v15)[2])(v15);
  }
  v59 = 0;
  v21 = (**v16)(v16, &stru_12BFC60, &v59);
  v22 = v59;
  if ( v21 < 0 )
    v22 = 0;
  v59 = v22;
  v57 = 0;
  pfnQueryInterface = *v15;
  LOBYTE(v62) = 10;
  v24 = (*pfnQueryInterface)(v15, &stru_12BFC60, &v57);
  v25 = v57;
  if ( v24 < 0 )
    v25 = 0;
  v57 = v25;
  LOBYTE(v62) = 11;
  if ( !(*(*v59 + 16))(v59, v25, &v45) )
  {
    if ( v45 == 1 )
    {
      v26 = v16;
      v16 = 0;
      v50 = 0;
      if ( v26 )
        ((*v26)[2])(v26);
    }
    LOBYTE(v62) = 10;
    if ( v57 )
      (*(*v57 + 8))(v57);
    LOBYTE(v62) = 9;
    if ( v59 )
      (*(*v59 + 8))(v59);
    goto LABEL_52;
  }
  LOBYTE(v62) = 10;
  if ( v57 )
    (*(*v57 + 8))(v57);
  LOBYTE(v62) = 9;
  if ( v59 )
    (*(*v59 + 8))(v59);
  pfnQueryInterface2 = *v15;
  LOBYTE(v62) = 6;
  (pfnQueryInterface2[2])(v15);
  v9 = 0;
LABEL_63:
  LOBYTE(v62) = 5;
  if ( v16 )
    ((*v16)[2])(v16);
  LOBYTE(v62) = 4;
  if ( v15 )
    ((*v15)[2])(v15);
LABEL_67:
  sub_1249A30(&v35);
  sub_1249A30(&v29);
LABEL_68:
  LOBYTE(v62) = 1;
  if ( v54 )
    (*(*v54 + 8))(v54);
LABEL_70:
  LOBYTE(v62) = 0;
  if ( v58 )
    (*(*v58 + 8))(v58);
LABEL_72:
  v62 = -1;
  if ( v53 )
    (*(*v53 + 8))(v53);
  return v9;
}
// 12BFC50: using guessed type GUID stru_12BFC50;
// 12BFC60: using guessed type GUID stru_12BFC60;

//----- (0124B680) --------------------------------------------------------
int __thiscall sub_124B680(_DWORD *this, DWORD dwThreadId, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  _DWORD *v12; // ebx
  signed int v13; // eax
  _DWORD *v14; // esi
  _DWORD *v16; // edx
  int *v17; // ecx
  int v18; // esi
  int v19; // ST10_4
  _DWORD *v20; // esi
  _DWORD *v21; // ecx
  _DWORD *v22; // eax
  _DWORD *v23; // esi
  int v24; // eax
  signed int v25; // eax
  int v26; // eax

  v12 = this;
  if ( a3 )
  {
    v13 = sub_1247DD0(a3);
    if ( v13 != 2 )
    {
      v14 = a7;
      if ( v13 != 1 )
      {
        if ( (*(*a4 + 12))(a4, 65539, 716, &a4, a8) )
          return 0;
        v16 = a9;
        *v14 = 1;
LABEL_7:
        v17 = a11;
        *a11 = -1;
        v17[1] = 0x7FFFFFFF;
        if ( *v14 == 1 )
        {
          *v17 = *(a8 + 196);
          v17[1] = 0;
        }
        v18 = a6;
        if ( *v16 == 1 )
          sub_124A570(v12, dwThreadId, a10, 716, *v17, v17[1], a6);
        v19 = v18;
        v20 = a5;
        sub_1249C50(v12, a5, v19, a12);
        v21 = a6;
        *a9 = 0;
        sub_1249A30(v21);
        sub_1249A30(v20);
        a9 = 0;
        v22 = operator new(0x20u);
        v23 = v22;
        a8 = v22;
        if ( v22 )
        {
          *v22 = &SymbolInfo::`vftable';
          v22[1] = 1;
          v22[7] = operator new[](0x800u);
        }
        else
        {
          v23 = 0;
        }
        a9 = v23;
        v25 = sub_1247DD0(a3);
        if ( v25 && (v26 = v25 - 1) != 0 )
        {
          if ( v26 != 2 )
            goto LABEL_22;
          sub_1248A30(v23, "[Native Frame: IL Method without Metadata]", 0, 0, 3);
        }
        else if ( !sub_12480C0(a3, v23) )
        {
          goto LABEL_22;
        }
        sub_12476F0(a12, &a9);
LABEL_22:
        if ( v23 )
          (*(*v23 + 8))(v23);
        return 1;
      }
      v16 = a9;
      if ( !*a9 )
        goto LABEL_7;
      v24 = *a3;
      a12 = a3;
      (*(v24 + 4))(a3);
      sub_1247740(a5, &a12);
      (*(*a3 + 8))(a3);
    }
  }
  else
  {
    if ( (*(*a4 + 12))(a4, 65539, 716, &a8, a10) )
      return 0;
    *a9 = 1;
    *a7 = 0;
  }
  return 1;
}
// 12BF420: using guessed type void *SymbolInfo::`vftable';

//----- (0124B8A0) --------------------------------------------------------
void sub_124B8A0()
{
  int v0; // [esp+0h] [ebp-44h]
  char v1; // [esp+10h] [ebp-34h]
  void *Data[3]; // [esp+20h] [ebp-24h]
  void *v3[2]; // [esp+2Ch] [ebp-18h]
  int *v4; // [esp+34h] [ebp-10h]
  int v5; // [esp+40h] [ebp-4h]

  v4 = &v0;
  SetEnvironmentVariableW(L"COMPLUS_FodPath", L"c:\\no-fod.exe");
  v5 = 0;
  sub_1232AE0(Data, 0);
  LOBYTE(v5) = 1;
  sub_124EEA0(v3, Data);
  LOBYTE(v5) = 2;
  sub_124EFB0(v3, 0, L".NET CLR Memory");
  unknown_libname_3(v3, Data);
  gbDotNetProcess = sub_124E8B0(&v1, L".NET CLR Memory") != 0;
  if ( gbDotNetProcess )
  {
    CoInitialize(0);
    if ( gbDotNetProcess )
    {
      qword_12EA0A8 = SystemTimeAsFileTime;
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      sub_124EFB0(
        &dword_12EA0C4,
        0,
        L".NET CLR Memory,.NET CLR Exceptions,.NET CLR Remoting,.NET CLR LocksAndThreads,.NET CLR Security,.NET CLR Jit,.N"
         "ET CLR Loading,.NET CLR Interop,.NET CLR Data");
    }
  }
  LOBYTE(v5) = 1;
  sub_1259F70(v3);
  LOBYTE(v5) = 0;
  sub_1232C80(Data);
}
// 124E890: using guessed type _DWORD __stdcall unknown_libname_3(_DWORD, _DWORD);
// 12EA098: using guessed type char gbDotNetProcess;
// 12EA0A8: using guessed type __int64 qword_12EA0A8;
// 12EA0C4: using guessed type int dword_12EA0C4;

//----- (0124B9D0) --------------------------------------------------------
void *__cdecl sub_124B9D0(int a1)
{
  void *v1; // esi
  int v3; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  LPVOID ppv; // [esp+8h] [ebp-4h]

  if ( !gbDotNetProcess )
    return 0;
  v3 = 0;
  if ( byte_12EA09A )
    CoCreateInstance(&stru_12BF40C, 0, 1u, &IID_ICorPublish, &ppv);
  else
    CoCreateInstance(&CLSID_CorpubPublish, 0, 1u, &IID_ICorPublish, &ppv);
  if ( !ppv )
    return 0;
  if ( !(*(*ppv + 16))(ppv, a1, &v4) )
  {
    (*(*v4 + 12))(v4, &v3);
    (*(*v4 + 8))(v4);
  }
  (*(*ppv + 8))(ppv);
  if ( !v3 )
    return 0;
  v1 = malloc(0x88u);
  memset(v1, 0, 0x88u);
  return v1;
}
// 12BF40C: using guessed type GUID stru_12BF40C;
// 12EA098: using guessed type char gbDotNetProcess;
// 12EA09A: using guessed type char byte_12EA09A;

//----- (0124BA80) --------------------------------------------------------
int __stdcall ProcNetWndProc(HWND hWnd, unsigned int a2, unsigned int wParam, int a4)
{
  HWND v4; // ebx
  LONG v5; // edi
  int result; // eax
  void *v7; // esi
  CResize *v8; // eax
  wchar_t *v9; // edi
  HWND v10; // eax
  LONG v11; // eax
  HWND v12; // eax
  HWND v13; // ST0C_4
  HWND v14; // eax
  HWND v15; // eax
  LONG v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  HWND v19; // ST08_4
  HWND v20; // eax
  LRESULT v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  wchar_t **v24; // esi
  int v25; // ebx
  int v26; // eax
  HWND v27; // ST08_4
  int v28; // ST10_4
  HWND v29; // eax
  _DWORD *v30; // eax
  LRESULT v31; // esi
  HWND v32; // ST08_4
  wchar_t **v33; // eax
  void **v34; // esi
  double v35; // xmm0_8
  HWND v36; // ST08_4
  int v37; // eax
  HWND v38; // ST08_4
  unsigned int ArgList; // [esp+0h] [ebp-3BCh]
  LPARAM lParam; // [esp+14h] [ebp-3A8h]
  int v41; // [esp+1Ch] [ebp-3A0h]
  int v42; // [esp+20h] [ebp-39Ch]
  int v43; // [esp+24h] [ebp-398h]
  char *v44; // [esp+28h] [ebp-394h]
  int v45; // [esp+2Ch] [ebp-390h]
  char v46; // [esp+48h] [ebp-374h]
  LPARAM v47; // [esp+58h] [ebp-364h]
  WPARAM v48; // [esp+5Ch] [ebp-360h]
  int v49; // [esp+60h] [ebp-35Ch]
  WCHAR *v50; // [esp+6Ch] [ebp-350h]
  int v51; // [esp+70h] [ebp-34Ch]
  int uIDs; // [esp+8Ch] [ebp-330h]
  int v53; // [esp+90h] [ebp-32Ch]
  unsigned int v54; // [esp+94h] [ebp-328h]
  HWND v55; // [esp+98h] [ebp-324h]
  int Indent; // [esp+9Ch] [ebp-320h]
  int nWidths; // [esp+A0h] [ebp-31Ch]
  char v58[4]; // [esp+A4h] [ebp-318h]
  int v59; // [esp+A8h] [ebp-314h]
  int a3; // [esp+ACh] [ebp-310h]
  WPARAM v61; // [esp+B0h] [ebp-30Ch]
  NMHDR *pNMhdr; // [esp+B4h] [ebp-308h]
  char v63; // [esp+B8h] [ebp-304h]
  WCHAR sz; // [esp+1B8h] [ebp-204h]
  wchar_t Dst; // [esp+2B8h] [ebp-104h]

  v4 = hWnd;
  pNMhdr = a4;
  v55 = hWnd;
  v47 = 0;
  memset(&v48, 0, 0x30u);
  v5 = GetWindowLongW(hWnd, -21);
  uIDs = 1093;
  v53 = 1058;
  LOWORD(nWidths) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(nWidths) = MulDiv(-100, gLogPixelsX, 96);
  Indent = 1096;
  LOWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  if ( a2 > 0x111 )
  {
    switch ( a2 )
    {
      case 0x113u:
        v28 = Pid;
        v29 = GetDlgItem(hWnd, 1094);
        sub_1247A00(v29, v28, 0);
        sub_124EFB0(*(v5 + 804), 0, (v5 + 28));
        unknown_libname_3(*(v5 + 804), &Data);
        v30 = sub_124E8B0(&v46, (v5 + 28));
        if ( v30 )
        {
          pNMhdr = sub_12486E0((v5 + 284), v30);
          GetSystemTimeAsFileTime((v5 + 8));
          v31 = 0;
          v32 = *(v5 + 16);
          v61 = 0;
          if ( SendMessageW(v32, 0x1004u, 0, 0) > 0 )
          {
            do
            {
              v47 = 1;
              v50 = &sz;
              v48 = v31;
              v49 = 0;
              v51 = 128;
              SendMessageW(*(v5 + 16), 0x104Bu, 0, &v47);
              if ( pNMhdr && sub_1247F10(pNMhdr, &sz, v58) )
              {
                v33 = sub_124E760(pNMhdr, &sz);
                v34 = v33;
                if ( v33 && v33[1] & 0x20000 )
                {
                  v34 = sub_124E840(pNMhdr);
                  sub_124ECA0(v34, &v54, 0);
                  v35 = 0.0;
                  if ( v54 != 0.0 )
                    v35 = *v58 * 100.0 / v54;
                  sub_1247500(&Dst, L"%02.02f", LODWORD(v35), HIDWORD(v35));
                }
                else
                {
                  sub_1247500(&Dst, L"%I64d", *v58, v59);
                  GetNumberTextFormat(&Dst, 0x80u);
                }
                if ( v34 )
                {
                  sub_124EC80(v34);
                  j__free(v34);
                }
                v31 = v61;
              }
              else
              {
                sub_1247500(&Dst, L"0");
              }
              v41 = 1;
              v44 = &v63;
              v36 = *(v5 + 16);
              v45 = 128;
              SendMessageW(v36, 0x1073u, v31, &lParam);
              v37 = wcscmp(&v63, &Dst);
              if ( v37 )
                v37 = -(v37 < 0) | 1;
              if ( v37 )
              {
                v47 = 1;
                v50 = &Dst;
                v49 = 1;
                v51 = 128;
                SendMessageW(*(v5 + 16), 0x104Cu, 0, &v47);
                SendMessageW(*(v5 + 16), 0x1015u, v48, v48);
              }
              v38 = *(v5 + 16);
              v61 = ++v31;
            }
            while ( v31 < SendMessageW(v38, 0x1004u, 0, 0) );
          }
        }
        *v5 = *(v5 + 8);
        *(v5 + 4) = *(v5 + 12);
        return 0;
      case 0x133u:
      case 0x136u:
      case 0x138u:
        return sub_1246710(hWnd, wParam);
      default:
        return 0;
    }
    return 0;
  }
  if ( a2 == 273 )
  {
    switch ( wParam )
    {
      case 0x9C41u:
        ArgList = 40014;
        goto LABEL_25;
      case 0x9C42u:
        SetEvent(ghEventRefreshSearchResult);
        break;
      case 0x9C9Cu:
      case 0x9C9Du:
        ArgList = wParam;
LABEL_25:
        v20 = GetParent(hWnd);
        PostMessageW(v20, 0x111u, ArgList, 0);
        break;
      default:
        break;
    }
    if ( wParam >> 16 == 1 && wParam == 1093 )
    {
      SendMessageW(*(v5 + 16), 0x1009u, 0, 0);
      v21 = SendMessageW(*(v5 + 20), 0x147u, 0, 0);
      SendMessageW(*(v5 + 20), 0x148u, v21, v5 + 28);
      sub_124EFB0(*(v5 + 804), 0, (v5 + 28));
      unknown_libname_3(*(v5 + 804), &Data);
      v22 = sub_124E8B0(&v46, (v5 + 28));
      if ( v22 )
      {
        v23 = sub_124ED60(v22);
        v61 = v23;
        if ( v23 )
        {
          v24 = sub_124E830(v23);
          if ( v24 )
          {
            v25 = v61;
            do
            {
              if ( !(v24[1] & 0x400000) )
              {
                tcscpy_s(&Dst, 0x80u, *v24);
                v26 = wcscmp(L"Not Displayed", &Dst);
                if ( v26 )
                  v26 = -(v26 < 0) | 1;
                if ( v26 )
                  InsertJobToList(*(v5 + 16), &Dst, gpszTargetName);
              }
              sub_124EC80(v24);
              j__free(v24);
              v24 = sub_124E840(v25);
            }
            while ( v24 );
            v4 = v55;
          }
        }
      }
      SendMessageW(v4, 0x113u, 0, 0);
      SendMessageW(*(v5 + 16), 0x101Eu, 0, 0xFFFF);
      SendMessageW(*(v5 + 16), 0x101Eu, 1u, 65534);
      v43 = 2;
      v27 = *(v5 + 16);
      v42 = 2;
      SendMessageW(v27, 0x102Bu, 0, &lParam);
    }
    return 0;
  }
  if ( a2 > 0x2C )
  {
    if ( a2 == 256 )
    {
      if ( wParam == 116 )
        PostMessageW(hWnd, 0x113u, 1u, 0);
      return 0;
    }
    if ( a2 != 272 )
      return 0;
    v8 = operator new(0x40u);
    if ( v8 )
      CResize::CResize(v8, hWnd);
    ResizeTab(hWnd);
    v9 = malloc(0x328u);
    memset(v9, 0, 0x328u);
    SetWindowLongW(hWnd, -21, v9);
    v10 = GetDlgItem(hWnd, 1094);
    *(v9 + 6) = v10;
    v11 = GetWindowLongW(v10, -16);
    SetWindowLongW(*(v9 + 6), -16, v11 & 0xFFFFFFFD | 1);
    SetWindowLongW(*(v9 + 6), -21, 1);
    SendMessageW(*(v9 + 6), 0x1036u, 0x4020u, 16416);
    v12 = SendMessageW(*(v9 + 6), 0x104Eu, 0, 0);
    InitToolTips(v12);
    OldListCtrlWndProc = SetWindowLongW(*(v9 + 6), -4, PEListCtrlWndProc);
    SendMessageW(*(v9 + 6), 0x30u, ghDefaultFont, 0);
    InitListCtrl(*(v9 + 6), &Indent, &a3, 1);
    v13 = *(v9 + 6);
    Pid = pNMhdr[5].code;
    sub_1247A00(v13, Pid, 1);
    SendMessageW(*(v9 + 6), 0x101Eu, 0, 65534);
    sub_1248790(pNMhdr[5].hwndFrom, v9 + 142);
    v14 = GetDlgItem(hWnd, 1093);
    *(v9 + 5) = v14;
    SendMessageW(v14, 0x143u, 0, L".NET CLR Memory");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Jit");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Exceptions");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR LocksAndThreads");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Data");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Interop");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Loading");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Remoting");
    SendMessageW(*(v9 + 5), 0x143u, 0, L".NET CLR Security");
    SendMessageW(*(v9 + 5), 0x14Eu, 0, 0);
    v15 = GetDlgItem(hWnd, 1091);
    *(v9 + 4) = v15;
    v16 = GetWindowLongW(v15, -16);
    SetWindowLongW(*(v9 + 4), -16, v16 & 0xFFFFFFFD | 1);
    v17 = operator new(8u);
    if ( v17 )
      v18 = sub_124EEA0(v17, &Data);
    else
      v18 = 0;
    v19 = *(v9 + 4);
    *(v9 + 201) = v18;
    SendMessageW(v19, 0x1036u, 0x4020u, 16416);
    OldListCtrlWndProc = SetWindowLongW(*(v9 + 4), -4, PEListCtrlWndProc);
    SendMessageW(*(v9 + 4), 0x30u, ghDefaultFont, 0);
    InitListCtrl(*(v9 + 4), &uIDs, &nWidths, 2);
    SendMessageW(hWnd, 0x111u, 0x10445u, 0);
    SendMessageW(*(v9 + 4), 0x101Eu, 0, 0xFFFF);
    SendMessageW(*(v9 + 4), 0x101Eu, 1u, 65534);
    *v9 = 0;
    *(v9 + 1) = 0;
    SendMessageW(hWnd, 0x113u, 0, 0);
    result = 1;
  }
  else
  {
    if ( a2 != 44 )
    {
      if ( a2 == 2 )
      {
        v7 = *(v5 + 804);
        if ( v7 )
        {
          sub_1259F70(*(v5 + 804));
          j__free(v7);
        }
        free(v5);
      }
      else if ( a2 == 43 )
      {
        FindDlg_DrawItem(pNMhdr);
      }
      return 0;
    }
    result = HandleMeasureItem(hWnd, 0x2Cu, wParam, pNMhdr);
  }
  return result;
}
// 124E890: using guessed type _DWORD __stdcall unknown_libname_3(_DWORD, _DWORD);
// 12BCDC0: using guessed type double gdbMaxValue;
// 12BF4BC: using guessed type wchar_t aNetClrExceptio[20];
// 12BF518: using guessed type wchar_t aNetClrData[14];
// 12BF534: using guessed type wchar_t aNetClrInterop[17];
// 12BF57C: using guessed type wchar_t aNetClrRemoting[18];
// 12BF5C4: using guessed type wchar_t aNotDisplayed[14];

//----- (0124C500) --------------------------------------------------------
int sub_124C500()
{
  int result; // eax

  if ( gbDotNetProcess )
  {
    qword_12EA0A8 = SystemTimeAsFileTime;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    result = sub_124EFB0(
               &dword_12EA0C4,
               0,
               L".NET CLR Memory,.NET CLR Exceptions,.NET CLR Remoting,.NET CLR LocksAndThreads,.NET CLR Security,.NET CLR"
                " Jit,.NET CLR Loading,.NET CLR Interop,.NET CLR Data");
  }
  return result;
}
// 12EA098: using guessed type char gbDotNetProcess;
// 12EA0A8: using guessed type __int64 qword_12EA0A8;
// 12EA0C4: using guessed type int dword_12EA0C4;

//----- (0124C540) --------------------------------------------------------
char __cdecl sub_124C540(int a1, WPARAM wParam)
{
  char result; // al

  result = 0;
  if ( !byte_12EA099 )
    result = sub_124A870(a1, wParam);
  return result;
}
// 12EA099: using guessed type char byte_12EA099;

//----- (0124C600) --------------------------------------------------------
CMapNode *__thiscall CMapNode::NewNode(CMapNode *this, CMapPair *pair)
{
  CMapNode *result; // eax

  result = CMapNode::NewNode_0(this);
  *&result->_Color = 0;
  if ( result != -16 )
    result->_KeyValue = *pair;
  return result;
}

//----- (0124C630) --------------------------------------------------------
_DWORD *__thiscall sub_124C630(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, _DWORD *dwTid, int a6)
{
  _DWORD *v6; // edi
  CMapNode *v7; // eax
  CMapNode *v8; // ebx
  int v9; // eax
  CMapNode *v10; // eax
  CMapNode *v11; // ecx
  CMapNode *v12; // esi
  CMapNode *v13; // edx
  CMapNode *v14; // edx
  CMapNode **v15; // ecx
  CMapNode *v16; // edx
  CMapNode *v17; // esi
  CMapNode *v18; // ecx
  CMapNode *v19; // ecx
  CMapNode *v20; // edx
  CMapNode *v21; // ecx
  CMapNode *v22; // ecx
  CMapNode *v23; // ecx
  _DWORD *result; // eax

  v6 = this;
  if ( this[1] >= 0xAAAAAA9u )
    std::_Xlength_error("map/set<T> too long");
  v7 = CMapNode::NewNode(this, dwTid);
  ++v6[1];
  v8 = v7;
  v7->_Parent = a4;
  if ( a4 == *v6 )
  {
    *(*v6 + 4) = v7;
    **v6 = v7;
    v9 = *v6;
LABEL_8:
    *(v9 + 8) = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    a4[2] = v7;
    v9 = *v6;
    if ( a4 != *(*v6 + 8) )
      goto LABEL_9;
    goto LABEL_8;
  }
  *a4 = v7;
  if ( a4 == **v6 )
    **v6 = v7;
LABEL_9:
  v10 = v8;
  while ( !v10->_Parent->_Color )
  {
    v11 = v10->_Parent;
    v12 = v11->_Parent;
    v13 = v12->_Left;
    if ( v11 == v12->_Left )
    {
      v13 = v12->_Right;
      if ( v13->_Color )
      {
        if ( v10 == v11->_Right )
        {
          v10 = v10->_Parent;
          v14 = v11->_Right;
          v11->_Right = v14->_Left;
          if ( !v14->_Left->_isnil )
            v14->_Left->_Parent = v11;
          v14->_Parent = v11->_Parent;
          if ( v11 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v14;
          }
          else
          {
            v15 = &v11->_Parent->_Left;
            if ( v10 == *v15 )
              *v15 = v14;
            else
              v15[2] = v14;
          }
          v14->_Left = v10;
          v10->_Parent = v14;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v16 = v10->_Parent->_Parent;
        v17 = v16->_Left;
        v16->_Left = v16->_Left->_Right;
        v18 = v17->_Right;
        if ( !v18->_isnil )
          v18->_Parent = v16;
        v17->_Parent = v16->_Parent;
        if ( v16 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v17;
          v17->_Right = v16;
        }
        else
        {
          v19 = v16->_Parent;
          if ( v16 == v19->_Right )
            v19->_Right = v17;
          else
            v19->_Left = v17;
          v17->_Right = v16;
        }
LABEL_48:
        v16->_Parent = v17;
        continue;
      }
    }
    else if ( v13->_Color )
    {
      if ( v10 == v11->_Left )
      {
        v10 = v10->_Parent;
        v20 = v11->_Left;
        v11->_Left = v11->_Left->_Right;
        v21 = v20->_Right;
        if ( !v21->_isnil )
          v21->_Parent = v10;
        v20->_Parent = v10->_Parent;
        if ( v10 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v20;
        }
        else
        {
          v22 = v10->_Parent;
          if ( v10 == v22->_Right )
            v22->_Right = v20;
          else
            v22->_Left = v20;
        }
        v20->_Right = v10;
        v10->_Parent = v20;
      }
      v10->_Parent->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v16 = v10->_Parent->_Parent;
      v17 = v16->_Right;
      v16->_Right = v17->_Left;
      if ( !v17->_Left->_isnil )
        v17->_Left->_Parent = v16;
      v17->_Parent = v16->_Parent;
      if ( v16 == *(*v6 + 4) )
      {
        *(*v6 + 4) = v17;
      }
      else
      {
        v23 = v16->_Parent;
        if ( v16 == v23->_Left )
          v23->_Left = v17;
        else
          v23->_Right = v17;
      }
      v17->_Left = v16;
      goto LABEL_48;
    }
    v11->_Color = 1;
    v13->_Color = 1;
    v10->_Parent->_Parent->_Color = 0;
    v10 = v10->_Parent->_Parent;
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (0124C840) --------------------------------------------------------
int __thiscall sub_124C840(_DWORD *this, int a2, _DWORD *a3, ThreadInfo *pThreadInfo, int a6)
{
  _DWORD *v5; // ebx
  _DWORD *v6; // ecx
  bool v7; // dl
  ThreadInfo *lpThreadInfo; // edi
  _DWORD *v9; // esi
  int *v10; // eax
  unsigned int dwTid; // ecx
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  int result; // eax
  int v16; // [esp+0h] [ebp-2Ch]
  _DWORD *v17; // [esp+10h] [ebp-1Ch]
  _DWORD *v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int *v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+28h] [ebp-4h]

  v20 = &v16;
  v5 = this;
  v17 = this;
  v6 = *this;
  v7 = 1;
  lpThreadInfo = pThreadInfo;
  v9 = v6;
  v21 = 0;
  v18 = v6;
  v10 = v6[1];
  LOBYTE(v19) = 1;
  if ( !*(v10 + 13) )
  {
    dwTid = pThreadInfo->dwTid;
    do
    {
      v9 = v10;
      if ( a3 )
        v7 = v10[4] >= dwTid;
      else
        v7 = dwTid < v10[4];
      LOBYTE(v19) = v7;
      if ( v7 )
        v10 = *v10;
      else
        v10 = v10[2];
    }
    while ( !*(v10 + 13) );
    v6 = v18;
    v5 = v17;
  }
  v12 = v9;
  a3 = v9;
  if ( v7 )
  {
    if ( v9 == *v6 )
    {
      v13 = sub_124C630(v5, &a3, 1, v9, pThreadInfo, a6);
LABEL_14:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v12 = a3;
  }
  if ( v12[4] < lpThreadInfo->dwTid )
  {
    v13 = sub_124C630(v5, &pThreadInfo, v19, v9, lpThreadInfo, a6);
    goto LABEL_14;
  }
  *a2 = v12;
  result = a2;
  *(a2 + 4) = 0;
  return result;
}

//----- (0124CA10) --------------------------------------------------------
signed int __stdcall BufferCallback(int a1)
{
  return 1;
}

//----- (0124CA20) --------------------------------------------------------
HANDLE sub_124CA20()
{
  HANDLE result; // eax
  HANDLE hSnapHandle; // esi
  int a2; // [esp+4h] [ebp-30h]
  ThreadInfo ThreadInfo; // [esp+Ch] [ebp-28h]
  THREADENTRY32 te; // [esp+14h] [ebp-20h]

  result = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  hSnapHandle = result;
  if ( result != -1 )
  {
    te.dwSize = 28;
    if ( Thread32First(result, &te) )
    {
      do
      {
        ThreadInfo = *&te.th32ThreadID;
        sub_124C840(&Right, &a2, 0, &ThreadInfo, byte_12EA100);
      }
      while ( Thread32Next(hSnapHandle, &te) );
    }
    result = CloseHandle(hSnapHandle);
  }
  return result;
}
// 12EA100: using guessed type char byte_12EA100;

//----- (0124CAB0) --------------------------------------------------------
signed int __thiscall RealTrace(PE_EVENT_TRACE_PROPERTIES *pParam)
{
  PE_EVENT_TRACE_PROPERTIES *lpTraceEventProperties; // edi
  EVENT_TRACE_LOGFILEW *v2; // ebx
  WCHAR *v3; // eax
  __int64 v4; // rax
  int v5; // esi
  WCHAR *v6; // edx
  signed int result; // eax
  EVENT_TRACE_LOGFILEW LogName; // [esp+8h] [ebp-1A4h]

  lpTraceEventProperties = pParam;
  memset(&LogName.LoggerName, 0, 0x19Cu);
  LogName.LogFileName = 0;
  v2 = &lpTraceEventProperties->EventTraceLogFile;
  LogName.Context = 0;
  v3 = L"PROCEXP TRACE";
  LogName.BufferCallback = BufferCallback;
  if ( gdwOsType < 3 )
    v3 = L"NT Kernel Logger";
  LogName.BuffersRead = 0;
  LogName.LoggerName = v3;
  LogName.CurrentTime = 0i64;
  LogName.u2.EventCallback = EventCallback;
  LogName.u.LogFileMode = 0x1100;
  LODWORD(v4) = OpenTraceW_0(&LogName);
  v2->LogFileName = v4;
  lpTraceEventProperties->EventTraceLogFile.LoggerName = HIDWORD(v4);
  if ( v4 )
  {
    do
    {
      v5 = ProcessTrace_0(&lpTraceEventProperties->EventTraceLogFile, 1, 0, 0);
      if ( v5 )
        break;
      if ( WaitForSingleObject(lpTraceEventProperties->hTraceEvent, 0) == WAIT_TIMEOUT )
      {
        v5 = CEventTrace::Start(lpTraceEventProperties, 1);
        v2->LogFileName = OpenTraceW_0(&LogName);
        lpTraceEventProperties->EventTraceLogFile.LoggerName = v6;
        if ( v5 )
          break;
      }
    }
    while ( WaitForSingleObject(lpTraceEventProperties->hTraceEvent, 0) == 258 );
    result = v5;
  }
  else
  {
    result = -1;
  }
  LOBYTE(lpTraceEventProperties->EventTraceLogFile.CurrentTime) = 0;
  return result;
}
// 12C0784: using guessed type wchar_t aProcexpTrace[14];
// 12E4E54: using guessed type int gdwOsType;
// 12EA110: using guessed type int (__stdcall *ProcessTrace_0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0124CBD0) --------------------------------------------------------
signed int __stdcall TraceEventThreadProc(char *a1)
{
  return RealTrace(a1);
}

//----- (0124CBE0) --------------------------------------------------------
unsigned __int64 __thiscall sub_124CBE0(_QWORD *this, __int64 a2)
{
  unsigned __int64 result; // rax

  if ( a2 >= 0 )
    result = (10000000 * (a2 % this[2])) / this[2] + 10000000 * (a2 / this[2]);
  else
    result = -sub_124CBE0(this, -a2);
  return result;
}

//----- (0124CC70) --------------------------------------------------------
unsigned __int8 *__cdecl sub_124CC70(int a1, int a2, int a3, wchar_t *Dst, rsize_t SizeInWords)
{
  int v5; // ecx
  int v6; // eax
  wchar_t *v7; // edi
  wchar_t *v8; // esi
  unsigned int v9; // edx
  wchar_t v10; // ax
  unsigned __int8 *result; // eax
  unsigned int v12; // edx
  wchar_t v13; // ax
  unsigned int v14; // edx
  wchar_t v15; // ax
  int v16; // edi
  int v17; // edi
  int v18; // edi
  double v19; // xmm0_8
  int v20; // ST48_4
  int v21; // ecx
  unsigned int v22; // edx
  int i; // esi
  int v24; // ebx
  rsize_t v25; // edx
  int v26; // esi
  _WORD *v27; // eax
  unsigned int v28; // edx
  unsigned int v29; // edx
  int v30; // edi
  unsigned __int8 *v31; // edi
  int v32; // ebx
  const wchar_t *v33; // eax
  wchar_t *v34; // esi
  const wchar_t *v35; // eax
  int v36; // [esp+14h] [ebp-4h]

  v5 = a3;
  v6 = *(a3 + 8);
  v7 = a1;
  v36 = a1;
  switch ( v6 )
  {
    case 0:
      v8 = Dst;
      v9 = 0;
      if ( *(a3 + 12) )
      {
        do
        {
          v10 = *v7;
          v7 = (v7 + 1);
          v8[v9++] = v10;
        }
        while ( v9 < *(v5 + 12) );
      }
      goto LABEL_4;
    case 1:
      v8 = Dst;
      v14 = 0;
      if ( !*(a3 + 12) )
        goto LABEL_4;
      do
      {
        v15 = *v7;
        ++v7;
        v8[v14++] = v15;
      }
      while ( v14 < *(v5 + 12) );
      v8[*(v5 + 12)] = 0;
      return v7 - v36;
    case 2:
      v8 = Dst;
      v12 = 0;
      if ( *(a3 + 12) )
      {
        do
        {
          v13 = *v7;
          v7 = (v7 + 1);
          v8[v12++] = v13;
        }
        while ( v12 < *(v5 + 12) );
        v8[*(v5 + 12)] = 0;
        result = v7 - v36;
      }
      else
      {
LABEL_4:
        v8[*(v5 + 12)] = 0;
        result = v7 - v36;
      }
      return result;
    case 3:
      swprintf_s(Dst, SizeInWords, L"%d", *a1);
      return (v7 - v36 + 1);
    case 4:
      swprintf_s(Dst, SizeInWords, L"%d", *a1);
      return (v7 - v36 + 2);
    case 5:
      swprintf_s(Dst, SizeInWords, L"%u", *a1);
      return (v7 - v36 + 2);
    case 6:
      swprintf_s(Dst, SizeInWords, L"%d", *a1);
      goto LABEL_69;
    case 7:
      swprintf_s(Dst, SizeInWords, L"%lu", *a1);
      goto LABEL_69;
    case 8:
      goto LABEL_17;
    case 9:
      v16 = a1 + 8;
      swprintf_s(Dst, SizeInWords, L"%I64d", *a1, *(a1 + 4));
      return (v16 - v36);
    case 10:
      v17 = a1 + 8;
      swprintf_s(Dst, SizeInWords, L"%I64u", *a1, *(a1 + 4));
      return (v17 - v36);
    case 11:
      v18 = a1 + 4;
      v19 = *a1;
      goto LABEL_21;
    case 12:
      v19 = *a1;
      v18 = a1 + 8;
LABEL_21:
      swprintf_s(Dst, SizeInWords, L"%f", LODWORD(v19), HIDWORD(v19));
      return (v18 - v36);
    case 13:
    case 15:
    case 17:
    case 22:
      switch ( v6 )
      {
        case 13:
        case 22:
          v21 = a1;
          v22 = strlen(a1);
          for ( i = a1 + 1 + v22; v22; --v22 )
          {
            if ( *(a1 + v22 - 1) != 255 )
              break;
          }
          break;
        case 15:
          v22 = *a1;
          v7 = (a1 + 1);
          v21 = a1 + 1;
          i = v22 + a1 + 1;
          break;
        case 17:
          v22 = *(a1 + 1) + (*a1 << 8);
          v7 = (a1 + 2);
          v21 = a1 + 2;
          i = v22 + a1 + 2;
          break;
        default:
          v21 = a1;
          v22 = a1;
          i = a1;
          break;
      }
      if ( v22 > a2 - v21 )
        v22 = a2 - v21;
      if ( v22 > SizeInWords - 3 )
        v22 = SizeInWords - 3;
      swprintf_s(Dst, SizeInWords, L"\"%*S\"", v22, v7);
      return (i - v36);
    case 14:
    case 16:
    case 18:
    case 23:
      switch ( v6 )
      {
        case 14:
          v24 = a1;
          v25 = wcslen(a1);
          v26 = a1 + 2 + 2 * v25;
          if ( v25 )
          {
            v27 = (a1 - 2 + 2 * v25);
            do
            {
              v7 = a1;
              if ( *v27 != -1 )
                break;
              --v27;
              --v25;
            }
            while ( v25 );
          }
          break;
        case 16:
          v29 = *a1;
          v7 = (a1 + 1);
          v24 = a1 + 1;
          v26 = v29 + a1 + 1;
          v25 = v29 >> 1;
          break;
        case 18:
          v7 = (a1 + 2);
          v24 = a1 + 2;
          v28 = *(a1 + 1) + (*a1 << 8);
          v26 = v28 + a1 + 2;
          v25 = v28 >> 1;
          break;
        case 23:
          v24 = a1;
          v26 = a2;
          v25 = (a2 - a1) >> 1;
          break;
        default:
          v24 = a1;
          v25 = a1;
          v26 = a1;
          break;
      }
      if ( 2 * v25 > a2 - v24 )
        v25 = (a2 - v24) >> 1;
      if ( v25 > SizeInWords - 3 )
        v25 = SizeInWords - 3;
      swprintf_s(Dst, SizeInWords, L"\"%*ws\"", v25, v7);
      return (v26 - v36);
    case 19:
      if ( *a1 )
      {
        if ( dword_12DE0D0 == 64 )
          v31 = (a1 + 16);
        else
          v31 = (a1 + 8);
        v32 = 4 * v31[1] + 8;
        sub_124E4E0(&a1, v31);
        if ( a1 )
          v33 = *a1;
        else
          v33 = 0;
        v34 = Dst;
        tcscpy_s(Dst, SizeInWords, v33);
        *v34 = 0;
        bstr_t::Data_t::Free(&a1);
        result = &v31[v32 - v36];
      }
      else
      {
        v30 = a1 + 4;
        swprintf_s(Dst, SizeInWords, L"0");
        result = (v30 - v36);
      }
      return result;
    case 20:
      swprintf_s(Dst, SizeInWords, L"%03d.%03d.%03d.%03d", *a1, *a1 >> 8, (*a1 >> 16) & 0xFF, *a1 >> 24);
      return (v7 - v36 + 4);
    case 21:
      v20 = ntohs(*a1);
      swprintf_s(Dst, SizeInWords, L"%u", v20);
      return (v7 - v36 + 2);
    case 24:
      if ( dword_12DE0D0 == 64 )
      {
        swprintf_s(Dst, SizeInWords, L"0x%X", *a1);
        result = (v7 - v36 + 8);
      }
      else
      {
LABEL_17:
        swprintf_s(Dst, SizeInWords, L"0x%08X", *a1);
LABEL_69:
        result = (v7 - v36 + 4);
      }
      return result;
    case 25:
      sub_12192A0(Dst, SizeInWords, a1);
      return (v7 - v36 + 16);
    case 26:
      v35 = L"TRUE";
      if ( !*a1 )
        v35 = L"FALSE";
      swprintf_s(Dst, SizeInWords, L"%s", v35);
      goto LABEL_69;
    case 27:
      swprintf_s(
        Dst,
        SizeInWords,
        L"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
        *a1,
        *(a1 + 1),
        *(a1 + 2),
        *(a1 + 3),
        *(a1 + 4),
        *(a1 + 5),
        *(a1 + 6),
        *(a1 + 7),
        *(a1 + 8),
        *(a1 + 9),
        *(a1 + 10),
        *(a1 + 11),
        *(a1 + 12),
        *(a1 + 13),
        *(a1 + 14),
        *(a1 + 15));
      return (v7 - v36 + 16);
    default:
      goto LABEL_69;
  }
}
// 12BE200: using guessed type wchar_t a0x08x[7];
// 12DE0D0: using guessed type int dword_12DE0D0;

//----- (0124D220) --------------------------------------------------------
ULONG __thiscall FlushTrace(PEVENT_TRACE_PROPERTIES Properties)
{
  return FlushTraceW(*&Properties[10].Wnode.Guid.Data1, 0, Properties);
}

//----- (0124D240) --------------------------------------------------------
int __cdecl sub_124D240(const unsigned __int16 *a1)
{
  int v1; // esi
  int v2; // eax

  v1 = 0;
  while ( 1 )
  {
    v2 = wcscmp((&off_12C00F0)[2 * v1], a1);
    if ( v2 )
      v2 = -(v2 < 0) | 1;
    if ( !v2 )
      break;
    if ( ++v1 >= 0x38 )
      return 0;
  }
  return dword_12C00F4[2 * v1];
}
// 12C00F0: using guessed type wchar_t *off_12C00F0;
// 12C00F4: using guessed type int dword_12C00F4[];

//----- (0124D2B0) --------------------------------------------------------
signed int __cdecl sub_124D2B0(unsigned int a1)
{
  CSysProcItem *v1; // ecx
  CSysProcItem *v2; // eax
  signed int result; // eax
  CSysProcItem *v4; // [esp+4h] [ebp-4h]

  v1 = Right._Left;
  v2 = Right._Left->_Parent;
  if ( v2->_Isnil )
    goto LABEL_14;
  do
  {
    if ( v2->dwPid >= a1 )
    {
      v1 = v2;
      v2 = v2->_Left;
    }
    else
    {
      v2 = v2->_Right;
    }
  }
  while ( !v2->_Isnil );
  if ( v1 == Right._Left || (v4 = v1, a1 < v1->dwPid) )
LABEL_14:
    v4 = Right._Left;
  if ( v4 == Right._Left )
    result = -1;
  else
    result = v4->field_14;
  return result;
}

//----- (0124D310) --------------------------------------------------------
signed int __thiscall CEventTrace::Start(PE_EVENT_TRACE_PROPERTIES *pEventTraceProperties, char a2)
{
  PE_EVENT_TRACE_PROPERTIES *pProperties; // ebx
  HMODULE v4; // edi
  signed int v5; // eax
  bool v6; // sf
  unsigned __int8 v7; // of
  const wchar_t *v8; // eax
  ULONG v9; // eax
  int v10; // eax
  int v11; // esi
  void *v12; // ST14_4
  DWORD ThreadId; // [esp+4h] [ebp-4h]

  pProperties = pEventTraceProperties;
  if ( LOBYTE(pEventTraceProperties->EventTraceLogFile.CurrentTime) == a2 )
    return 0;
  if ( !LOBYTE(pEventTraceProperties->field_4B8) )
  {
    v4 = LoadLibraryW(L"advapi32.dll");
    StartTraceW_0 = GetProcAddress(v4, "StartTraceW");
    ControlTraceW_0 = GetProcAddress(v4, "ControlTraceW");
    OpenTraceW_0 = GetProcAddress(v4, "OpenTraceW");
    ProcessTrace_0 = GetProcAddress(v4, "ProcessTrace");
    LOBYTE(pProperties->field_4B8) = 1;
  }
  if ( !StartTraceW_0 )
    return 1;
  v5 = 0;
  pProperties->Wnode.BufferSize = 1200;
  pProperties->Wnode.Flags = 0x20000;
  pProperties->FlushTimer = 1;
  v7 = __OFSUB__(gdwOsType, 3);
  v6 = gdwOsType - 3 < 0;
  pProperties->Wnode.ClientContext = 1;
  if ( !(v6 ^ v7) )
    v5 = 0x2000000;
  pProperties->LogFileMode = v5 | 0x100;
  if ( gdwOsType < 3 )
    _mm_storeu_si128(&pProperties->Wnode.Guid, _mm_loadu_si128(&xmmword_12C00E0));
  pProperties->LoggerNameOffset = 120;
  pProperties->LogFileNameOffset = 640;
  v8 = L"PROCEXP TRACE";
  if ( gdwOsType < 3 )
    v8 = L"NT Kernel Logger";
  tcscpy_s(pProperties->szSessionName, 0x104u, v8);
  tcscpy_s(pProperties->field_280, 0x104u, gpszTargetName);
  v9 = pProperties->EnableFlags | 0x10100;
  pProperties->EnableFlags = v9;
  if ( gdwOsType >= 3 )
    pProperties->EnableFlags = v9 | 2;
  if ( a2 )
  {
    v10 = StartTraceW_0(&pProperties->hTraceHandle, pProperties->szSessionName, pProperties);
    v11 = v10;
    if ( !v10 || v10 == ERROR_ALREADY_EXISTS )
    {
      LOBYTE(pProperties->EventTraceLogFile.CurrentTime) = 1;
      v11 = 0;
      pProperties->hThread = _beginthreadex(0, 0, TraceEventThreadProc, pProperties, 0, &ThreadId);
      if ( gdwOsType >= 3 )
      {
        sub_124CA20();
        return 0;
      }
    }
  }
  else
  {
    SetEvent(pProperties->hTraceEvent);
    v11 = ControlTraceW_0(*&pProperties->hTraceHandle, pProperties->szSessionName, pProperties, 1u);
    WaitForSingleObject(pProperties->hThread, INFINITE);
    CloseHandle(pProperties->hThread);
    v12 = pProperties->hTraceEvent;
    pProperties->hThread = 0;
    ResetEvent(v12);
  }
  return v11;
}
// 12C00E0: using guessed type __int128 xmmword_12C00E0;
// 12C0784: using guessed type wchar_t aProcexpTrace[14];
// 12E4E54: using guessed type int gdwOsType;
// 12EA110: using guessed type int (__stdcall *ProcessTrace_0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0124D510) --------------------------------------------------------
void __cdecl sub_124D510(int a1, int a2)
{
  int v2; // eax
  CComBSTR *v3; // eax
  CComBSTR *v4; // esi
  OLECHAR **v5; // eax
  OLECHAR *v6; // eax
  const unsigned __int16 **v7; // edi
  int v8; // esi
  const unsigned __int16 *v9; // eax
  int v10; // eax
  int v11; // eax
  char v12; // cl
  int v13; // ecx
  _DWORD *v14; // eax
  int *v15; // ebx
  _DWORD *v16; // edi
  _bstr_t *v17; // esi
  unsigned int v18; // eax
  const unsigned __int16 *v19; // eax
  int v20; // eax
  Data_t *v21; // eax
  CComBSTR *v22; // esi
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  unsigned int v31; // eax
  Data_t *v32; // eax
  CComBSTR *v33; // esi
  CComBSTR *v34; // esi
  Data_t *v35; // eax
  CComBSTR *v36; // esi
  Data_t *v37; // eax
  CComBSTR *v38; // edi
  CComBSTR *v39; // esi
  CComBSTR *v40; // esi
  __int64 v41; // [esp-8h] [ebp-894h]
  int v42; // [esp+14h] [ebp-878h]
  int v43; // [esp+18h] [ebp-874h]
  int v44; // [esp+1Ch] [ebp-870h]
  unsigned __int64 v45; // [esp+24h] [ebp-868h]
  int v46; // [esp+2Ch] [ebp-860h]
  int v47; // [esp+30h] [ebp-85Ch]
  int v48; // [esp+34h] [ebp-858h]
  int v49; // [esp+38h] [ebp-854h]
  int v50; // [esp+3Ch] [ebp-850h]
  int v51; // [esp+44h] [ebp-848h]
  int v52; // [esp+48h] [ebp-844h]
  int v53; // [esp+4Ch] [ebp-840h]
  int v54; // [esp+50h] [ebp-83Ch]
  int v55; // [esp+54h] [ebp-838h]
  int v56; // [esp+58h] [ebp-834h]
  int v57; // [esp+5Ch] [ebp-830h]
  int v58; // [esp+60h] [ebp-82Ch]
  CComBSTR *ppComBSTR1; // [esp+64h] [ebp-828h]
  int v60; // [esp+6Ch] [ebp-820h]
  void *v61; // [esp+70h] [ebp-81Ch]
  CComBSTR *ppv; // [esp+74h] [ebp-818h]
  int v63; // [esp+78h] [ebp-814h]
  OLECHAR psz; // [esp+7Ch] [ebp-810h]
  int v65; // [esp+888h] [ebp-4h]

  v63 = a1;
  v60 = a2;
  memset(&v43, 0, 0x4Cu);
  ppComBSTR1 = 0;
  v42 = *(a1 + 12);
  v2 = *(a1 + 8);
  HIDWORD(v41) = 0;
  if ( v2 == -1 )
    v2 = 0;
  v65 = 0;
  v43 = v2;
  LODWORD(v41) = *(a1 + 40) + *(a1 + 44);
  v44 = 1;
  v45 = sub_124CBE0(&gTimeStart, v41);
  v3 = operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    v3->hKey = 0;
    v3->Length = 1;
    v3->bstr = SysAllocString(0);
  }
  else
  {
    v4 = 0;
  }
  LOBYTE(v65) = 0;
  ppComBSTR1 = v4;
  if ( !v4 )
LABEL_7:
    com_error::throw(-2147024882);
  v5 = *(a2 + 32);
  if ( v5 && (v6 = *v5) != 0 && SysStringLen(v6) )
  {
    v7 = *(a2 + 32);
    v8 = 0;
    v44 = 0;
    while ( 1 )
    {
      if ( v7 )
        v9 = *v7;
      else
        v9 = 0;
      v10 = wcscmp(v9, (&off_12C06FC)[2 * v8]);
      if ( v10 )
        v10 = -(v10 < 0) | 1;
      if ( !v10 )
        break;
      if ( ++v8 >= 3 )
        goto LABEL_25;
    }
    v11 = dword_12C0700[2 * v8];
  }
  else
  {
    v12 = *(a1 + 4);
    if ( v12 == 11 )
    {
      v44 = 3;
      goto LABEL_25;
    }
    v11 = (v12 == 10) + 1;
  }
  v44 = v11;
LABEL_25:
  v13 = v63;
  v14 = *(v60 + 24);
  v15 = *(v63 + 72);
  v16 = *v14;
  if ( *v14 != v14 )
  {
    while ( v15 < *(v13 + 72) + *(v13 + 76) )
    {
      v17 = v16[2];
      v18 = &v17[1].m_Data->m_wstr + 1;
      while ( 2 )
      {
        switch ( v18 )
        {
          case 0u:
            if ( v17->m_Data )
              v19 = v17->m_Data->m_wstr;
            else
              v19 = 0;
            v20 = sub_124D240(v19);
            v17[1].m_Data = v20;
            v18 = v20 + 1;
            if ( v18 > 0x15 )
              goto LABEL_33;
            continue;
          case 1u:
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 6u:
          case 7u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
LABEL_33:
            v13 = v63;
            goto LABEL_34;
          case 0xDu:
            v23 = *v15;
            ++v15;
            v46 = v23;
            goto LABEL_69;
          case 0xEu:
            v24 = *v15;
            ++v15;
            v47 = v24;
            goto LABEL_69;
          case 0xFu:
            v25 = *v15;
            ++v15;
            v48 = v25;
            v49 = 0;
            goto LABEL_69;
          case 0x10u:
            v26 = *v15;
            ++v15;
            v50 = v26;
            goto LABEL_69;
          case 0x11u:
            v51 = *v15;
            v27 = v15[1];
            v15 += 2;
            v52 = v27;
            goto LABEL_69;
          case 0x12u:
            v53 = *v15;
            if ( dword_12DE0D0 == 64 )
            {
              v28 = v15[1];
              v15 += 2;
              v54 = v28;
            }
            else
            {
              v54 = 0;
              ++v15;
            }
            goto LABEL_69;
          case 0x13u:
            v55 = *v15;
            if ( dword_12DE0D0 == 64 )
            {
              v29 = v15[1];
              v15 += 2;
              v56 = v29;
            }
            else
            {
              v56 = 0;
              ++v15;
            }
            goto LABEL_69;
          case 0x14u:
            v57 = *v15;
            v30 = v15[1];
            v15 += 2;
            v58 = v30;
            goto LABEL_69;
          case 0x15u:
            v31 = *v15;
            v43 = *v15;
            if ( v42 == -1 )
              v42 = sub_124D2B0(v31);
            goto LABEL_69;
          default:
LABEL_34:
            psz = 0;
            v15 = (v15 + sub_124CC70(v15, *(v13 + 72) + *(v13 + 76), v17, &psz, 0x400u));
            bstr_t::Append(&ppComBSTR1, v17);
            v21 = operator new(0xCu);
            v61 = v21;
            LOBYTE(v65) = 2;
            if ( v21 )
              v22 = ConcatenateBSTR(v21, &ppComBSTR1, &ppComBSTR2);
            else
              v22 = 0;
            LOBYTE(v65) = 0;
            if ( !v22 )
              goto LABEL_7;
            bstr_t::Data_t::Free(&ppComBSTR1);
            ppComBSTR1 = v22;
            bstr_t::EqualAssign(&ppv, &psz);
            LOBYTE(v65) = 3;
            v32 = operator new(0xCu);
            v61 = v32;
            LOBYTE(v65) = 4;
            v33 = (v32 ? ConcatenateBSTR(v32, &ppComBSTR1, &ppv) : 0);
            LOBYTE(v65) = 3;
            if ( !v33 )
              goto LABEL_7;
            bstr_t::Data_t::Free(&ppComBSTR1);
            ppComBSTR1 = v33;
            v34 = ppv;
            LOBYTE(v65) = 0;
            if ( ppv )
            {
              if ( !InterlockedDecrement(&ppv->Length) )
              {
                if ( v34->bstr )
                {
                  SysFreeString(v34->bstr);
                  v34->bstr = 0;
                }
                if ( v34->hKey )
                {
                  j_j__free(v34->hKey);
                  v34->hKey = 0;
                }
                j__free(v34);
              }
              ppv = 0;
            }
            v35 = operator new(0xCu);
            v61 = v35;
            LOBYTE(v65) = 5;
            v36 = (v35 ? ConcatenateBSTR(v35, &ppComBSTR1, &ppComBSTR2) : 0);
            LOBYTE(v65) = 0;
            if ( !v36 )
              goto LABEL_7;
            bstr_t::Data_t::Free(&ppComBSTR1);
            ppComBSTR1 = v36;
LABEL_69:
            v16 = *v16;
            v13 = v63;
            if ( v16 == *(v60 + 24) )
              goto LABEL_70;
            break;
        }
        break;
      }
    }
  }
LABEL_70:
  v37 = operator new(0xCu);
  v61 = v37;
  LOBYTE(v65) = 6;
  if ( v37 )
    v38 = ConcatenateBSTR(v37, &ppComBSTR1, &ppComBSTR2);
  else
    v38 = 0;
  LOBYTE(v65) = 0;
  if ( !v38 )
    com_error::throw(-2147024882);
  v39 = ppComBSTR1;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v39 )
  {
    if ( v39->bstr )
    {
      SysFreeString(v39->bstr);
      v39->bstr = 0;
    }
    if ( v39->hKey )
    {
      j_j__free(v39->hKey);
      v39->hKey = 0;
    }
    j__free(v39);
  }
  ppComBSTR1 = v38;
  sub_1275250(&v42);
  v40 = ppComBSTR1;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v40 )
  {
    if ( v40->bstr )
    {
      SysFreeString(v40->bstr);
      v40->bstr = 0;
    }
    if ( v40->hKey )
    {
      j_j__free(v40->hKey);
      v40->hKey = 0;
    }
    j__free(v40);
  }
}
// 12C06FC: using guessed type wchar_t *off_12C06FC;
// 12C0700: using guessed type int dword_12C0700[];
// 12DE0D0: using guessed type int dword_12DE0D0;

//----- (0124DB10) --------------------------------------------------------
void __stdcall EventCallback(int a1)
{
  int *v1; // eax

  if ( a1 )
  {
    v1 = sub_1218730(&dword_12EA0E8, (a1 + 24), *(a1 + 4), *(a1 + 6), *(a1 + 5));
    if ( v1 )
      sub_124DB50(a1, v1);
  }
}
// 12EA0E8: using guessed type int dword_12EA0E8;

//----- (0124DB50) --------------------------------------------------------
void __cdecl sub_124DB50(_DWORD *a1, const unsigned __int16 ***a2)
{
  const unsigned __int16 **v2; // esi
  const unsigned __int16 *v3; // eax
  int v4; // eax
  const unsigned __int16 *v5; // eax
  int v6; // eax
  const unsigned __int16 *v7; // eax
  int v8; // eax
  const unsigned __int16 *v9; // eax
  int v10; // eax
  const unsigned __int16 *v11; // eax
  int v12; // eax

  if ( a1[18] || !a1[19] )
  {
    v2 = *a2;
    if ( *a2 )
      v3 = *v2;
    else
      v3 = 0;
    v4 = wcscmp(v3, L"DiskIo");
    if ( v4 )
      v4 = -(v4 < 0) | 1;
    if ( v4 )
    {
      if ( v2 )
        v5 = *v2;
      else
        v5 = 0;
      v6 = wcscmp(v5, L"Thread");
      if ( v6 )
        v6 = -(v6 < 0) | 1;
      if ( v6 )
      {
        if ( v2 )
          v7 = *v2;
        else
          v7 = 0;
        v8 = wcscmp(v7, L"TcpIp");
        if ( v8 )
          v8 = -(v8 < 0) | 1;
        if ( !v8 )
          goto LABEL_38;
        if ( v2 )
          v9 = *v2;
        else
          v9 = 0;
        v10 = wcscmp(v9, L"UdpIp");
        if ( v10 )
          v10 = -(v10 < 0) | 1;
        if ( !v10 )
          goto LABEL_38;
        v11 = v2 ? *v2 : 0;
        v12 = wcscmp(v11, L"MSNT_TcpIpInformation");
        if ( v12 )
          v12 = -(v12 < 0) | 1;
        if ( !v12 )
LABEL_38:
          sub_124DCE0(a1, a2);
      }
      else
      {
        sub_124E310(a1, a2);
      }
    }
    else
    {
      sub_124D510(a1, a2);
    }
  }
}
// 12C0730: using guessed type wchar_t aDiskio[7];
// 12C0740: using guessed type wchar_t aTcpip[6];
// 12C074C: using guessed type wchar_t aUdpip[6];
// 12C0758: using guessed type wchar_t aMsntTcpipinfor[22];

//----- (0124DCE0) --------------------------------------------------------
void __cdecl sub_124DCE0(_DWORD *a1, int a2)
{
  int v2; // eax
  CComBSTR *v3; // eax
  CComBSTR *v4; // esi
  int v5; // edi
  const wchar_t *v6; // eax
  OLECHAR **v7; // eax
  OLECHAR *v8; // eax
  const unsigned __int16 **v9; // edi
  int v10; // esi
  const unsigned __int16 *v11; // eax
  int v12; // eax
  _DWORD *v13; // edx
  _DWORD *v14; // eax
  unsigned int v15; // esi
  _DWORD *v16; // edi
  int v17; // ecx
  unsigned int v18; // eax
  char v19; // cl
  const unsigned __int16 *v20; // eax
  int v21; // eax
  CComBSTR *v22; // esi
  Data_t *v23; // eax
  CComBSTR *v24; // edi
  __m128i v25; // xmm0
  int v26; // eax
  __m128i v27; // xmm0
  int v28; // eax
  int v29; // eax
  int v30; // eax
  CComBSTR *v31; // esi
  __m128i v32; // xmm1
  int v33; // edx
  __m128i v34; // xmm0
  __int16 v35; // cx
  __int16 v36; // ax
  CComBSTR *v37; // esi
  unsigned __int8 *v38; // [esp+10h] [ebp-874h]
  _bstr_t *ppComBSTR2; // [esp+14h] [ebp-870h]
  CComBSTR *ppv; // [esp+18h] [ebp-86Ch]
  int v41; // [esp+1Ch] [ebp-868h]
  _DWORD *v42; // [esp+20h] [ebp-864h]
  int v43; // [esp+24h] [ebp-860h]
  int v44; // [esp+28h] [ebp-85Ch]
  int v45; // [esp+2Ch] [ebp-858h]
  unsigned __int64 v46; // [esp+34h] [ebp-850h]
  int v47; // [esp+3Ch] [ebp-848h]
  int v48; // [esp+40h] [ebp-844h]
  __int128 v49; // [esp+44h] [ebp-840h]
  int v50; // [esp+54h] [ebp-830h]
  __int128 v51; // [esp+58h] [ebp-82Ch]
  int v52; // [esp+68h] [ebp-81Ch]
  int v53; // [esp+6Ch] [ebp-818h]
  CComBSTR *ppComBSTR1; // [esp+70h] [ebp-814h]
  OLECHAR psz; // [esp+74h] [ebp-810h]
  int v56; // [esp+880h] [ebp-4h]

  v41 = a2;
  v42 = a1;
  memset(&v44, 0, 0x48u);
  ppComBSTR1 = 0;
  v43 = a1[3];
  v2 = a1[2];
  v56 = 0;
  if ( v2 == -1 )
    v2 = 0;
  v47 = 0;
  v44 = v2;
  v45 = 1;
  v48 = 0;
  v50 = 0;
  v52 = 0;
  v53 = 0;
  _mm_storeu_si128(&v49, 0i64);
  _mm_storeu_si128(&v51, 0i64);
  v3 = operator new(0xCu);
  v4 = v3;
  if ( v3 )
  {
    v3->hKey = 0;
    v3->Length = 1;
    v3->bstr = SysAllocString(0);
  }
  else
  {
    v4 = 0;
  }
  LOBYTE(v56) = 0;
  ppComBSTR1 = v4;
  if ( !v4 )
    com_error::throw(-2147024882);
  v5 = v41;
  v46 = sub_124CBE0(&gTimeStart, (a1[10] + a1[11]));
  if ( *v41 )
    v6 = **v41;
  else
    v6 = 0;
  v47 = 2 - (_wcsnicmp(v6, L"Udp", 3u) != 0);
  v7 = *(v41 + 32);
  if ( !v7 || (v8 = *v7) == 0 || !SysStringLen(v8) )
  {
    v13 = v42;
    v19 = *(v42 + 4);
    if ( v19 == 11 )
      v45 = 3;
    else
      v45 = (v19 == 10) + 1;
    goto LABEL_25;
  }
  v9 = *(v41 + 32);
  v10 = 0;
  v45 = 0;
  while ( 1 )
  {
    if ( v9 )
      v11 = *v9;
    else
      v11 = 0;
    v12 = wcscmp(v11, (&off_12C0410)[2 * v10]);
    if ( v12 )
      v12 = -(v12 < 0) | 1;
    if ( !v12 )
      break;
    if ( ++v10 >= 0x18 )
      goto LABEL_74;
  }
  v45 = dword_12C0414[2 * v10];
  if ( v45 )
  {
    v13 = v42;
    v5 = v41;
LABEL_25:
    v14 = *(v5 + 24);
    v15 = v13[18];
    v16 = *v14;
    if ( *v14 != v14 )
    {
      do
      {
        if ( v15 >= v13[18] + v13[19] )
          break;
        v17 = v16[2];
        ppComBSTR2 = v17;
        v18 = *(v17 + 4) + 1;
        while ( 2 )
        {
          switch ( v18 )
          {
            case 0u:
              if ( *v17 )
                v20 = **v17;
              else
                v20 = 0;
              v21 = sub_124D240(v20);
              v17 = ppComBSTR2;
              ppComBSTR2[1].m_Data = v21;
              v18 = v21 + 1;
              if ( v18 <= 9 )
                continue;
              goto LABEL_36;
            case 1u:
            case 2u:
            case 3u:
LABEL_36:
              v13 = v42;
              goto LABEL_37;
            case 4u:
              if ( *(v17 + 8) == 27 )
              {
                LOBYTE(v51) = 1;
                v25 = _mm_loadu_si128(v15);
                v15 += 16;
                _mm_storeu_si128((&v51 + 4), v25);
              }
              else
              {
                LOBYTE(v51) = 0;
                v26 = *v15;
                v15 += 4;
                DWORD1(v51) = v26;
              }
              break;
            case 5u:
              if ( *(v17 + 8) == 27 )
              {
                LOBYTE(v49) = 1;
                v27 = _mm_loadu_si128(v15);
                v15 += 16;
                _mm_storeu_si128((&v49 + 4), v27);
              }
              else
              {
                LOBYTE(v49) = 0;
                v28 = *v15;
                v15 += 4;
                DWORD1(v49) = v28;
              }
              break;
            case 6u:
              HIWORD(v53) = ntohs(*v15);
              v15 += 2;
              break;
            case 7u:
              LOWORD(v53) = ntohs(*v15);
              v15 += 2;
              break;
            case 8u:
              v29 = *v15;
              v15 += 4;
              v48 = v29;
              break;
            case 9u:
              v30 = *v15;
              v15 += 4;
              v43 = v30;
              break;
            default:
LABEL_37:
              psz = 0;
              v38 = &sub_124CC70(v15, v13[18] + v13[19], v17, &psz, 0x400u)[v15];
              bstr_t::Append(&ppComBSTR1, ppComBSTR2);
              bstr_t::Append(&ppComBSTR1, &::ppComBSTR2);
              bstr_t::EqualAssign(&ppv, &psz);
              LOBYTE(v56) = 2;
              bstr_t::Append(&ppComBSTR1, &ppv);
              v22 = ppv;
              LOBYTE(v56) = 0;
              if ( ppv )
              {
                if ( !InterlockedDecrement(&ppv->Length) )
                {
                  if ( v22->bstr )
                  {
                    SysFreeString(v22->bstr);
                    v22->bstr = 0;
                  }
                  if ( v22->hKey )
                  {
                    j_j__free(v22->hKey);
                    v22->hKey = 0;
                  }
                  j__free(v22);
                }
                ppv = 0;
              }
              bstr_t::Append(&ppComBSTR1, &::ppComBSTR2);
              v15 = v38;
              break;
          }
          break;
        }
        v16 = *v16;
        v13 = v42;
      }
      while ( v16 != *(v41 + 24) );
    }
    v23 = operator new(0xCu);
    LOBYTE(v56) = 3;
    if ( v23 )
      v24 = ConcatenateBSTR(v23, &ppComBSTR1, &::ppComBSTR2);
    else
      v24 = 0;
    LOBYTE(v56) = 0;
    if ( !v24 )
      com_error::throw(-2147024882);
    v31 = ppComBSTR1;
    if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v31 )
    {
      if ( v31->bstr )
      {
        SysFreeString(v31->bstr);
        v31->bstr = 0;
      }
      if ( v31->hKey )
      {
        j_j__free(v31->hKey);
        v31->hKey = 0;
      }
      j__free(v31);
    }
    ppComBSTR1 = v24;
    if ( v47 == 2 && v45 == 3 )
    {
      v32 = _mm_loadu_si128(&v51);
      v33 = v52;
      v34 = _mm_loadu_si128(&v49);
      v35 = HIWORD(v53);
      v52 = v50;
      v36 = v53;
      _mm_storeu_si128(&v51, v34);
      HIWORD(v53) = v36;
      _mm_storeu_si128(&v49, v32);
      v50 = v33;
      LOWORD(v53) = v35;
    }
    sub_1275310(&v43);
  }
LABEL_74:
  v37 = ppComBSTR1;
  if ( ppComBSTR1 && !InterlockedDecrement(&ppComBSTR1->Length) && v37 )
  {
    if ( v37->bstr )
    {
      SysFreeString(v37->bstr);
      v37->bstr = 0;
    }
    if ( v37->hKey )
    {
      j_j__free(v37->hKey);
      v37->hKey = 0;
    }
    j__free(v37);
  }
}
// 12C0410: using guessed type wchar_t *off_12C0410;
// 12C0414: using guessed type int dword_12C0414[];

//----- (0124E310) --------------------------------------------------------
CSysProcItem **__cdecl sub_124E310(int a1, int a2)
{
  signed int v2; // edi
  const unsigned __int16 **v3; // eax
  const unsigned __int16 *v4; // eax
  int v5; // eax
  const unsigned __int16 **v6; // eax
  const unsigned __int16 *v7; // eax
  CSysProcItem **result; // eax
  int v9; // ecx
  int v10; // edx
  _DWORD *v11; // eax
  CSysProcItem **v12; // ebx
  _DWORD *v13; // esi
  int v14; // edi
  int v15; // eax
  const unsigned __int16 *v16; // eax
  CSysProcItem *v17; // eax
  const unsigned __int16 **v18; // eax
  const unsigned __int16 *v19; // eax
  int v20; // eax
  ThreadInfo pThreadInfo; // [esp+8h] [ebp-10h]
  int a2a; // [esp+10h] [ebp-8h]
  CSysProcItem *_Right; // [esp+14h] [ebp-4h]

  v2 = -1;
  _Right = -1;
  pThreadInfo.dwPid = -1;
  v3 = *(a2 + 32);
  if ( v3 )
    v4 = *v3;
  else
    v4 = 0;
  v5 = wcscmp(v4, L"Start");
  if ( v5 )
    v5 = -(v5 < 0) | 1;
  if ( !v5 )
    goto LABEL_39;
  v6 = *(a2 + 32);
  if ( v6 )
    v7 = *v6;
  else
    v7 = 0;
  result = wcscmp(v7, L"End");
  if ( result )
    result = (-(result < 0) | 1);
  if ( !result )
  {
LABEL_39:
    v9 = a1;
    v10 = a2;
    v11 = *(a2 + 24);
    v12 = *(a1 + 72);
    v13 = *v11;
    if ( *v11 != v11 )
    {
      while ( 1 )
      {
        if ( v12 >= *(v9 + 72) + *(v9 + 76) )
          goto LABEL_29;
        v14 = v13[2];
        v15 = *(v14 + 4);
        if ( v15 == -1 )
        {
          do
          {
            if ( *v14 )
              v16 = **v14;
            else
              v16 = 0;
            v15 = sub_124D240(v16);
            *(v14 + 4) = v15;
          }
          while ( v15 == -1 );
          v9 = a1;
          v10 = a2;
        }
        if ( v15 == 53 )
          break;
        v2 = pThreadInfo.dwPid;
        if ( v15 != 54 )
          goto LABEL_25;
        v17 = *v12;
        ++v12;
        _Right = v17;
LABEL_26:
        if ( v2 == -1 || v17 == -1 )
        {
          v13 = *v13;
          if ( v13 != *(v10 + 24) )
            continue;
        }
        goto LABEL_29;
      }
      v2 = *v12;
      ++v12;
      pThreadInfo.dwPid = v2;
LABEL_25:
      v17 = _Right;
      goto LABEL_26;
    }
LABEL_29:
    v18 = *(v10 + 32);
    if ( v18 )
      v19 = *v18;
    else
      v19 = 0;
    v20 = wcscmp(v19, L"Start");
    if ( v20 )
      v20 = -(v20 < 0) | 1;
    if ( v20 )
    {
      sub_124E560(&Right, &a2a, &pThreadInfo.dwPid);
      result = sub_1275510(&Right, &a2, a2a, _Right);
    }
    else
    {
      pThreadInfo.dwPid = _Right;
      pThreadInfo.dwTid = v2;
      result = sub_124C840(&Right, &a2a, 0, &pThreadInfo, byte_12EA100);
    }
  }
  return result;
}
// 12C06F4: using guessed type wchar_t aEnd[4];
// 12EA100: using guessed type char byte_12EA100;

//----- (0124E4E0) --------------------------------------------------------
int __cdecl sub_124E4E0(int a1, PSID Sid)
{
  LPWSTR StringSid; // [esp+Ch] [ebp-10h]
  int v4; // [esp+18h] [ebp-4h]

  StringSid = 0;
  *a1 = 0;
  v4 = 0;
  if ( ConvertSidToStringSidW(Sid, &StringSid) )
  {
    bstr_t::Assign(a1, StringSid);
    LocalFree(StringSid);
  }
  return a1;
}

//----- (0124E560) --------------------------------------------------------
_DWORD *__thiscall sub_124E560(int *this, _DWORD *a2, unsigned int *a3)
{
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // edi
  unsigned int v8; // esi
  _DWORD *result; // eax

  v3 = *this;
  v4 = *this;
  v5 = *(*this + 4);
  v6 = *(*this + 4);
  if ( !*(v6 + 13) )
  {
    v7 = *a3;
    do
    {
      v8 = *(v6 + 16);
      if ( v8 >= v7 )
      {
        if ( *(v4 + 13) && v7 < v8 )
          v4 = v6;
        v3 = v6;
        v6 = *v6;
      }
      else
      {
        v6 = *(v6 + 8);
      }
    }
    while ( !*(v6 + 13) );
  }
  if ( !*(v4 + 13) )
    v5 = *v4;
  while ( !*(v5 + 13) )
  {
    if ( *a3 >= *(v5 + 16) )
    {
      v5 = *(v5 + 8);
    }
    else
    {
      v4 = v5;
      v5 = *v5;
    }
  }
  result = a2;
  *a2 = v3;
  a2[1] = v4;
  return result;
}

//----- (0124E5E0) --------------------------------------------------------
void __stdcall sub_124E5E0(void *a1)
{
  void *v1; // edi
  void **v2; // esi

  v1 = a1;
  v2 = a1;
  if ( !*(a1 + 13) )
  {
    do
    {
      sub_124E5E0(v2[2]);
      v2 = *v2;
      j__free(v1);
      v1 = v2;
    }
    while ( !*(v2 + 13) );
  }
}

//----- (0124E620) --------------------------------------------------------
int __thiscall sub_124E620(_DWORD *this)
{
  _DWORD *v1; // edi
  _DWORD *v2; // ebx
  _DWORD *i; // esi
  int result; // eax

  v1 = this;
  v2 = *(*this + 4);
  for ( i = v2; !*(i + 13); v2 = i )
  {
    sub_124E5E0(i[2]);
    i = *i;
    j__free(v2);
  }
  *(*v1 + 4) = *v1;
  **v1 = *v1;
  result = *v1;
  *(result + 8) = result;
  v1[1] = 0;
  return result;
}

//----- (0124E670) --------------------------------------------------------
_DWORD *__thiscall sub_124E670(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  *this = a2;
  this[3] = a3;
  this[1] = a4;
  this[4] = a5;
  this[6] = a6;
  return this;
}

//----- (0124E6A0) --------------------------------------------------------
wchar_t **__thiscall sub_124E6A0(int **this, wchar_t *a2)
{
  int **v2; // edi
  wchar_t *v3; // eax
  int *v4; // esi
  int v5; // ebx
  wchar_t **v6; // eax
  wchar_t **result; // eax
  wchar_t *v8; // [esp+28h] [ebp+8h]

  v2 = this;
  v3 = a2;
  if ( a2 >= this[1] )
    goto LABEL_13;
  v4 = this[3];
  if ( a2 )
  {
    do
    {
      v4 = (v4 + *v4);
      v3 = (v3 - 1);
    }
    while ( v3 );
  }
  if ( *v4 && ((v8 = sub_1232D20(this[4], v4[1]), !v2[6]) ? (v5 = **v2) : (v5 = 0), (v6 = operator new(0x10u)) != 0) )
    result = sub_124EC40(v6, v8, v4[7], *v2 + v4[9] + v5, v4[8]);
  else
LABEL_13:
    result = 0;
  return result;
}

//----- (0124E760) --------------------------------------------------------
wchar_t **__thiscall sub_124E760(_DWORD **this, LPCWSTR lpsz)
{
  _DWORD **v2; // esi
  int v3; // eax
  _DWORD *v4; // ecx
  _DWORD *v5; // edi
  wchar_t **result; // eax
  signed int v7; // ebx
  wchar_t **v8; // eax
  wchar_t *lpsza; // [esp+28h] [ebp+8h]

  v2 = this;
  v3 = sub_1232CB0(this[4], lpsz);
  if ( !v3 )
    goto LABEL_5;
  v4 = v2[1];
  v5 = v2[3];
  v2[2] = 0;
  if ( !v4 )
    goto LABEL_5;
  while ( v5[1] != v3 )
  {
    v5 = (v5 + *v5);
    v2[2] = (v2[2] + 1);
    if ( v2[2] >= v4 )
      goto LABEL_5;
  }
  lpsza = sub_1232D20(v2[4], v5[1]);
  v7 = v2[6] ? 0 : **v2;
  v8 = operator new(0x10u);
  if ( v8 )
    result = sub_124EC40(v8, lpsza, v5[7], *v2 + v5[9] + v7, v5[8]);
  else
LABEL_5:
    result = 0;
  return result;
}

//----- (0124E830) --------------------------------------------------------
wchar_t **__thiscall sub_124E830(int this)
{
  *(this + 8) = 0;
  return sub_124E6A0(this, 0);
}

//----- (0124E840) --------------------------------------------------------
wchar_t **__thiscall sub_124E840(int this)
{
  return sub_124E6A0(this, ++*(this + 8));
}

//----- (0124E850) --------------------------------------------------------
int __thiscall sub_124E850(int *this, wchar_t *Dst, rsize_t SizeInWords)
{
  int v4; // ecx

  if ( this[6] )
  {
    *Dst = 0;
    return 0;
  }
  v4 = *this;
  if ( SizeInWords < *(v4 + 20) >> 1 )
    return 0;
  tcscpy_s(Dst, SizeInWords, (v4 + *(v4 + 16)));
  return 1;
}

//----- (0124E8B0) --------------------------------------------------------
_DWORD *__thiscall sub_124E8B0(int **this, LPCWSTR lpsz)
{
  int **v2; // ebx
  _DWORD *v3; // esi
  unsigned int v4; // edi
  _DWORD *result; // eax
  _DWORD *v6; // eax
  LPCWSTR lpsza; // [esp+24h] [ebp+8h]

  v2 = this;
  lpsza = sub_1232CB0(this[1], lpsz);
  if ( !lpsza )
    goto LABEL_5;
  v3 = sub_124EFA0(*v2);
  v4 = 0;
  if ( !sub_124EF90(*v2) )
    goto LABEL_5;
  while ( v3[3] != lpsza )
  {
    ++v4;
    v3 = (v3 + *v3);
    if ( v4 >= sub_124EF90(*v2) )
      goto LABEL_5;
  }
  v6 = operator new(0x10u);
  if ( v6 )
    result = sub_124ED40(v6, v3, v2[1]);
  else
LABEL_5:
    result = 0;
  return result;
}

//----- (0124E970) --------------------------------------------------------
char __cdecl OpenExeFromFile(LPCWSTR lpFileName, DWORD *pdwTime, HANDLE *hMapping, LPCVOID lpBaseAddress)
{
  _WORD *v4; // ebx
  HANDLE *v5; // edi
  HANDLE v6; // eax
  void *v7; // esi
  HANDLE v8; // eax
  _IMAGE_DOS_HEADER *pDosHeader; // eax
  _IMAGE_NT_HEADERS *pNtHeaders1; // esi
  WORD v12; // ax
  _IMAGE_NT_HEADERS *pNtHeaders; // esi
  IMAGE_SECTION_HEADER *pSectionHeader; // eax
  signed int section; // edx
  signed int NumberOfSections; // esi
  DWORD v17; // ecx
  _IMAGE_NT_HEADERS *v18; // ecx
  signed int v19; // esi
  signed int v20; // edi
  DWORD v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // eax
  HANDLE v24; // [esp+Ch] [ebp-8h]
  char v25; // [esp+13h] [ebp-1h]
  HANDLE hObjecta; // [esp+24h] [ebp+10h]
  _IMAGE_DOS_HEADER *lpBaseAddressa; // [esp+28h] [ebp+14h]

  v4 = lpBaseAddress;
  v5 = hMapping;
  *lpBaseAddress = 0;
  *pdwTime = 0;
  v25 = 0;
  *hMapping = 0;
  v6 = CreateFile(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v7 = v6;
  v24 = v6;
  if ( v6 == -1 )
    return 0;
  v8 = CreateFileMappingW(v6, 0, 2u, 0, 0, 0);
  hObjecta = v8;
  if ( !v8 )
  {
    CloseHandle(v7);
    return 0;
  }
  pDosHeader = MapViewOfFile(v8, 4u, 0, 0, 0);
  lpBaseAddressa = pDosHeader;
  if ( !pDosHeader )
  {
    CloseHandle(hObjecta);
    CloseHandle(v24);
    return 0;
  }
  if ( pDosHeader->e_magic == 0x5A4D )
  {
    pNtHeaders1 = (pDosHeader + pDosHeader->e_lfanew);
    if ( pNtHeaders1->FileHeader.Characteristics & 0x100
      && (v12 = pNtHeaders1->FileHeader.Machine, v12 != 0x8664u)
      && v12 != 0x200 )
    {
      *v5 = 1;
    }
    else
    {
      *v5 = 2;
    }
    *pdwTime = pNtHeaders1->FileHeader.TimeDateStamp;
    *v4 = pNtHeaders1->OptionalHeader.DllCharacteristics | 1;
    if ( *v5 == 2 )
    {
      pNtHeaders = (lpBaseAddressa + lpBaseAddressa->e_lfanew);
      if ( IsBadReadPtr(lpBaseAddressa + lpBaseAddressa->e_lfanew, 0x108u) )
        goto __exit;
      if ( pNtHeaders->Signature != 0x4550 )
        goto __exit;
      pSectionHeader = &pNtHeaders[1].FileHeader.NumberOfSymbols;
      section = 1;
      NumberOfSections = pNtHeaders->FileHeader.NumberOfSections;
      if ( NumberOfSections < 1 )
        goto __exit;
      while ( 1 )
      {
        if ( !pSectionHeader->SizeOfRawData
          && (*pSectionHeader->Name != 'xet.' || *&pSectionHeader->Name[4] != 'ssbt')
          && (*pSectionHeader->Name != 'slt.' || *&pSectionHeader->Name[4])
          && (*pSectionHeader->Name != 'ssb.'
           || *&pSectionHeader->Name[4] && (*pSectionHeader->Name != 'ssb.' || *&pSectionHeader->Name[4]))
          && (*pSectionHeader->Name != 'b_tr' || *&pSectionHeader->Name[4] != 'ss') )
        {
          v17 = pSectionHeader->Characteristics;
          if ( v17 & 0x20000000 )
          {
            if ( v17 & 0xC0 )
              break;
          }
        }
        ++section;
        ++pSectionHeader;
        if ( section > NumberOfSections )
          goto __exit;
      }
    }
    else
    {
      if ( IsBadReadPtr(pNtHeaders1, 0xF8u) )
        goto __exit;
      if ( pNtHeaders1->Signature != 0x4550 )
        goto __exit;
      v18 = pNtHeaders1 + 1;
      v19 = pNtHeaders1->FileHeader.NumberOfSections;
      v20 = 1;
      if ( v19 < 1 )
        goto __exit;
      while ( 1 )
      {
        v21 = v18->OptionalHeader.SizeOfUninitializedData;
        if ( v21 & 0x20 )
        {
          v22 = v18->FileHeader.TimeDateStamp;
          if ( v22 > 0x1000 && v18->FileHeader.NumberOfSymbols < v22 - 0x1000 )
            break;
        }
        if ( v18->Signature == 'xet.' && *&v18->FileHeader.Machine == 't' )
        {
          v23 = v18->FileHeader.TimeDateStamp;
          if ( v23 > 0x1000 && v18->FileHeader.NumberOfSymbols < v23 - 4096 )
            break;
        }
        if ( !LOBYTE(v18->Signature) && v18->FileHeader.NumberOfSymbols < v18->FileHeader.TimeDateStamp
          || !v18->FileHeader.NumberOfSymbols
          && v18->FileHeader.TimeDateStamp >= 0x1000
          && (v18->Signature != 'xet.' || *&v18->FileHeader.Machine != 'ssbt')
          && (v18->Signature != 'slt.' || *&v18->FileHeader.Machine)
          && (v18->Signature != 'ssb.' || *&v18->FileHeader.Machine)
          && (v18->Signature != 'tad.' || *&v18->FileHeader.Machine != 'a')
          && v21 & 0x20000000
          && v21 & 0xC0 )
        {
          break;
        }
        ++v20;
        v18 = (v18 + 40);
        if ( v20 > v19 )
          goto __exit;
      }
    }
    v25 = 1;
  }
__exit:
  UnmapViewOfFile(lpBaseAddressa);
  CloseHandle(hObjecta);
  CloseHandle(v24);
  return v25;
}

//----- (0124EC40) --------------------------------------------------------
wchar_t **__thiscall sub_124EC40(wchar_t **this, wchar_t *a2, int a3, void *a4, unsigned int a5)
{
  wchar_t **v5; // esi
  wchar_t *v6; // eax
  size_t v7; // ST08_4

  v5 = this;
  *this = _wcsdup(a2);
  v5[1] = a3;
  v5[3] = a5;
  v6 = operator new[](a5);
  v7 = v5[3];
  v5[2] = v6;
  memmove_0(v6, a4, v7);
  return v5;
}

//----- (0124EC80) --------------------------------------------------------
void __thiscall sub_124EC80(void **this)
{
  void **v1; // esi

  v1 = this;
  free(*this);
  j_j__free(v1[2]);
}

//----- (0124ECA0) --------------------------------------------------------
signed int __thiscall sub_124ECA0(int this, _DWORD *a2, int a3)
{
  __int64 v3; // rax
  signed int result; // eax
  __int64 v5; // rax
  _DWORD *v6; // edx

  switch ( *(this + 12) )
  {
    case 1:
      v3 = **(this + 8);
      *a2 = v3;
      result = 1;
      a2[1] = HIDWORD(v3);
      break;
    case 2:
      v5 = **(this + 8);
      *a2 = v5;
      result = 1;
      a2[1] = HIDWORD(v5);
      break;
    case 4:
      *a2 = **(this + 8);
      result = 1;
      a2[1] = 0;
      break;
    case 8:
      v6 = *(this + 8);
      *a2 = *v6;
      a2[1] = v6[1];
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0124ED40) --------------------------------------------------------
_DWORD *__thiscall sub_124ED40(_DWORD *this, int a2, int a3)
{
  *this = a2;
  this[3] = a3;
  return this;
}

//----- (0124ED60) --------------------------------------------------------
_DWORD *__thiscall sub_124ED60(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  _DWORD *v3; // edi
  _DWORD *result; // eax

  v1 = this;
  v2 = *this;
  v1[1] = 0;
  if ( *(v2 + 40) && (v1[2] = v2 + *(v2 + 4), (v3 = operator new(0x1Cu)) != 0) )
    result = sub_124E670(v3, v1[2], *v1 + *(*v1 + 8), *(*v1 + 32), v1[3], *(*v1 + 40) == -1);
  else
    result = 0;
  return result;
}

//----- (0124EE00) --------------------------------------------------------
_DWORD *__thiscall sub_124EE00(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  _DWORD *result; // eax

  v1 = this;
  v2 = *this;
  if ( *(v2 + 40) != -1
    && (++v1[1], v1[1] < *(v2 + 40))
    && (v3 = (*v1[2] + v1[2]), v1[2] = v3 + *v3, (v4 = operator new(0x1Cu)) != 0) )
  {
    result = sub_124E670(v4, v1[2], *v1 + *(*v1 + 8), *(*v1 + 32), v1[3], 0);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0124EEA0) --------------------------------------------------------
_DWORD *__thiscall sub_124EEA0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = a2;
  result = this;
  *this = 0;
  return result;
}

//----- (0124EEC0) --------------------------------------------------------
int __thiscall sub_124EEC0(_DWORD **this, LPCWSTR lpsz, wchar_t *Dst, int a4)
{
  wchar_t *v5; // esi
  wchar_t *v6; // edi
  int v7; // eax
  int v8; // eax
  wchar_t *v9; // [esp+4h] [ebp-Ch]
  _DWORD **v10; // [esp+8h] [ebp-8h]
  wchar_t *Context; // [esp+Ch] [ebp-4h]
  LPCWSTR lpsza; // [esp+18h] [ebp+8h]

  v10 = this;
  if ( IsBadStringPtrW(lpsz, 0xFFFFFFFF) )
    return 0;
  v9 = _wcsdup(lpsz);
  v5 = Dst;
  Context = 0;
  v6 = wcstok_s(v9, ",", &Context);
  if ( v6 )
  {
    lpsza = (2 * a4);
    do
    {
      v7 = sub_1232CB0(v10[1], v6);
      if ( v7 )
        v8 = swprintf_s(v5, (Dst + lpsza - v5) >> 1, L"%u ", v7);
      else
        v8 = swprintf_s(v5, (Dst + lpsza - v5) >> 1, L"%s ", v6);
      v5 += v8;
      v6 = wcstok_s(0, ",", &Context);
    }
    while ( v6 );
  }
  free(v9);
  return 1;
}
// 12C0800: using guessed type wchar_t aU_0[4];

//----- (0124EF90) --------------------------------------------------------
int __thiscall sub_124EF90(void *this)
{
  int result; // eax

  if ( *this )
    result = *(*this + 28);
  else
    result = 0;
  return result;
}

//----- (0124EFA0) --------------------------------------------------------
int __thiscall sub_124EFA0(int *this)
{
  int v1; // ecx
  int result; // eax

  v1 = *this;
  if ( v1 )
    result = v1 + *(v1 + 24);
  else
    result = 0;
  return result;
}

//----- (0124EFB0) --------------------------------------------------------
int __thiscall sub_124EFB0(void **this, LPCWSTR lpMachineName, LPCWSTR lpsz)
{
  void **v3; // edi
  unsigned int v4; // esi
  LSTATUS v5; // eax
  BYTE *v6; // eax
  HKEY phkResult; // [esp+Ch] [ebp-20Ch]
  DWORD cbData; // [esp+10h] [ebp-208h]
  WCHAR ValueName; // [esp+14h] [ebp-204h]

  v3 = this;
  j__free(*this);
  *v3 = 0;
  if ( lpMachineName )
  {
    if ( RegConnectRegistryW(lpMachineName, HKEY_PERFORMANCE_DATA, &phkResult) )
      return 0;
  }
  else
  {
    phkResult = HKEY_PERFORMANCE_DATA;
  }
  if ( sub_124EEC0(v3, lpsz, &ValueName, 256) )
  {
    v4 = 0;
    cbData = 0;
    *v3 = 0;
    v5 = RegQueryValueExW(phkResult, &ValueName, 0, 0, 0, &cbData);
    if ( v5 )
    {
      while ( v5 == 234 )
      {
        j_j__free(*v3);
        if ( cbData <= v4 )
          v4 += 4096;
        else
          v4 = cbData + 4096;
        v6 = operator new[](v4);
        *v3 = v6;
        if ( !v6 )
          break;
        cbData = v4;
        v5 = RegQueryValueExW(phkResult, &ValueName, 0, 0, v6, &cbData);
        if ( !v5 )
          goto LABEL_13;
      }
    }
    else
    {
LABEL_13:
      if ( **v3 == 4522064 && *(*v3 + 1) == 4587602 )
        return 1;
    }
    j_j__free(*v3);
    *v3 = 0;
  }
  return 0;
}

//----- (0124F110) --------------------------------------------------------
int __cdecl sub_124F110(int a1, int a2, int a3, #1077 *a4)
{
  DestroyTreeListItemData(a4);
  return 0;
}

//----- (0124F130) --------------------------------------------------------
int __cdecl HandleDeviceChange(int a1, int a2, int a3, int a4)
{
  if ( a3 == 0x8000 && *(a4 + 4) == 2 )
    sub_1278790();
  return 0;
}

//----- (0124F150) --------------------------------------------------------
int __cdecl sub_124F150(int a1, int a2, int a3, int a4)
{
  #1077 *v4; // esi
  #1077 *v5; // ebx
  int v6; // edi
  char v7; // dl
  const wchar_t *v8; // ecx
  const wchar_t **v9; // eax
  const wchar_t *v10; // eax
  LVITEMUSERDATA *v11; // esi
  char v12; // bl
  const wchar_t *v13; // eax
  const wchar_t **v14; // ecx
  const wchar_t *v15; // ecx
  char v17; // [esp+23h] [ebp+17h]

  v4 = gpTreeListParamList;
  v5 = 0;
  v6 = a4;
  if ( a4 )
  {
    v7 = 0;
    v17 = 0;
    if ( gpTreeListParamList )
    {
      do
      {
        v8 = *(v4 + 198);
        if ( *(v4 + 17) == g_dwProcessId )
          v5 = v4;
        if ( v8 )
        {
          v9 = *(v6 + 20);
          if ( v9 )
            v10 = *v9;
          else
            v10 = 0;
          if ( _wcsicmp(v8, v10) )
          {
            v7 = v17;
          }
          else
          {
            v7 = 1;
            *(v4 + 211) = v6;
            v17 = 1;
          }
        }
        v4 = *(v4 + 364);
      }
      while ( v4 );
      if ( v7 )
      {
        if ( ColumnIDIsIllegal(1, ghWndTreeListView, 1670, 0) )
        {
          InvalidateRect(ghWndTreeListView, 0, 0);
          sub_123FAA0(0x65);
        }
        else if ( IsIllegalID(ghWndTreeListView, 1670) )
        {
          InvalidateRect(ghWndTreeListView, 0, 0);
        }
      }
      if ( v5 )
      {
        if ( IsWindowVisible(ghWndDllsListCtrl) )
        {
          v11 = gpUserDataInVerifySignature;
          v12 = 0;
          if ( gpUserDataInVerifySignature )
          {
            do
            {
              v13 = v11->szPathName;
              if ( v13 )
              {
                v14 = *(v6 + 20);
                if ( v14 )
                  v15 = *v14;
                else
                  v15 = 0;
                if ( !_wcsicmp(v13, v15) )
                {
                  v11->field_16C = v6;
                  v12 = 1;
                }
              }
              v11 = v11->Prev;
            }
            while ( v11 );
            if ( v12 )
            {
              InvalidateRect(ghWndDllsListCtrl, 0, 0);
              sub_123FAA0(0x68);
              return 0;
            }
          }
        }
      }
    }
  }
  else
  {
    if ( ColumnIDIsIllegal(1, ghWndTreeListView, 1670, 0) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      sub_123FAA0(0x65);
    }
    else if ( IsIllegalID(ghWndTreeListView, 1670) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
    }
    if ( IsWindowVisible(ghWndDllsListCtrl) )
    {
      InvalidateRect(ghWndDllsListCtrl, 0, 0);
      sub_123FAA0(0x68);
    }
  }
  return 0;
}

//----- (0124F350) --------------------------------------------------------
int __cdecl OnDumpProcess(int a1, __int16 a2)
{
  HWND v2; // esi
  LRESULT v3; // eax
  int v4; // esi
  HANDLE v5; // ebx
  int result; // eax
  HANDLE v7; // edi
  HCURSOR v8; // eax
  LPARAM lParam; // [esp+Ch] [ebp-4A4h]
  LRESULT v10; // [esp+10h] [ebp-4A0h]
  int v11; // [esp+14h] [ebp-49Ch]
  int v12; // [esp+2Ch] [ebp-484h]
  struct tagOFNW ofn; // [esp+40h] [ebp-470h]
  HCURSOR hCursor; // [esp+98h] [ebp-418h]
  wchar_t szLog; // [esp+9Ch] [ebp-414h]
  wchar_t Dst; // [esp+2A4h] [ebp-20Ch]
  char v17; // [esp+2A6h] [ebp-20Ah]

  lParam = 0;
  memset(&v10, 0, 0x30u);
  Dst = 0;
  memset(&v17, 0, 0x206u);
  v2 = ghWndTreeListView;
  v3 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v3 == -1
    || (v10 = v3, v11 = 0, lParam = 4, !SendMessageW(v2, 0x104Bu, 0, &lParam))
    || (v4 = v12, SetFocus(ghWndTreeListView), !v4) )
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  v5 = OpenProcess(0x10000000u, 0, *(v4 + 68));
  if ( !v5 )
  {
    ErrMsgBox(L"Error opening process", ghWndNewOwner);
    return 0;
  }
  tcscpy_s(&Dst, 0x104u, *(v4 + 60));
  if ( wcschr(&Dst, 0x2Eu) )
    *wcschr(&Dst, 0x2Eu) = 0;
  stprintf(&szLog, L"Create dump of %s", *(v4 + 60));
  wcscat_s(&Dst, 0x104u, L".dmp");
  ofn.hwndOwner = ghWndNewOwner;
  ofn.hInstance = ghInstance;
  ofn.lpstrFile = &Dst;
  *&ofn.nFileOffset = 0;
  ofn.lpfnHook = 0;
  ofn.lpstrTitle = &szLog;
  ofn.lStructSize = 76;
  ofn.lpstrCustomFilter = 0;
  ofn.nMaxCustFilter = 0;
  ofn.nFilterIndex = 1;
  ofn.nMaxFile = 256;
  ofn.lpstrFileTitle = 0;
  ofn.nMaxFileTitle = 0;
  ofn.lpstrInitialDir = 0;
  ofn.Flags = 2097156;
  ofn.lpstrDefExt = L"*.dmp";
  ofn.lpstrFilter = L"Dump File (*.DMP)";
  if ( !GetSaveFileNameW(&ofn) )
    return 0;
  v7 = CreateFile(&Dst, 0x40000000u, 7u, 0, 2u, 0x80u, 0);
  if ( v7 == -1 )
  {
    ErrMsgBox(L"Error creating dump file", ghWndNewOwner);
    result = 0;
  }
  else
  {
    v8 = LoadCursorW(0, 0x7F02);
    hCursor = SetCursor(v8);
    if ( !DumpProcessToFile(v7, v5, a2 == -24806) )
    {
      ErrMsgBox(L"Error writing dump file", ghWndNewOwner);
      DeleteFileW(&Dst);
    }
    SetCursor(hCursor);
    CloseHandle(v5);
    CloseHandle(v7);
    result = 0;
  }
  return result;
}
// 12C20E4: using guessed type wchar_t aDmp_0[6];
// 12C20F0: using guessed type wchar_t aDumpFileDmp[18];

//----- (0124F670) --------------------------------------------------------
int OnRestartProcess()
{
  HWND v0; // esi
  LRESULT v1; // eax
  int v2; // esi
  const unsigned __int16 *v3; // eax
  int v4; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+4h] [ebp-88h]
  LPARAM lParam; // [esp+48h] [ebp-44h]
  LRESULT v8; // [esp+4Ch] [ebp-40h]
  int v9; // [esp+50h] [ebp-3Ch]
  int v10; // [esp+68h] [ebp-24h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+7Ch] [ebp-10h]

  lParam = 0;
  memset(&v8, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 == -1
    || (v8 = v1, v9 = 0, lParam = 4, !SendMessageW(v0, 0x104Bu, 0, &lParam))
    || (v2 = v10, SetFocus(ghWndTreeListView), !v2) )
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  v3 = *(v2 + 88);
  if ( !v3 )
    goto LABEL_18;
  v4 = wcscmp(&gszMainTitle, v3);
  if ( v4 )
    v4 = -(v4 < 0) | 1;
  if ( v4 )
  {
LABEL_18:
    if ( MessageBoxW(
           ghWndTreeListView,
           L"The selected process is running in a different account than Process Explorer and so may fail to run, behave d"
            "ifferently, and run with different security rights when restarted under Process Explorer's credentials.\n"
            "\n"
            "Continue with process restart?",
           L"Process Explorer Warning",
           0x34u) == 7 )
      return 0;
  }
  if ( !sub_1278030(*(v2 + 60), *(v2 + 68)) )
    return 0;
  memset(&StartupInfo, 0, 0x44u);
  StartupInfo.cb = 68;
  StartupInfo.dwFlags = 1;
  StartupInfo.wShowWindow = 5;
  if ( CreateProcessW(
         *(v2 + 792),
         *(v2 + 800),
         0,
         0,
         0,
         0x400u,
         *(v2 + 808),
         *(v2 + 804),
         &StartupInfo,
         &ProcessInformation) )
  {
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);
  }
  else
  {
    ErrMsgBox(L"Error restarting process", ghWndNewOwner);
  }
  return 0;
}

//----- (0124F820) --------------------------------------------------------
int OnKillProcessTree()
{
  LRESULT v0; // eax
  LPARAM v2; // [esp+4h] [ebp-68h]
  int v3; // [esp+10h] [ebp-5Ch]
  int v4; // [esp+14h] [ebp-58h]
  LPARAM lParam; // [esp+38h] [ebp-34h]
  LRESULT v6; // [esp+3Ch] [ebp-30h]
  int v7; // [esp+40h] [ebp-2Ch]
  int v8; // [esp+58h] [ebp-14h]

  lParam = 0;
  memset(&v6, 0, 0x30u);
  v0 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v0 == -1 )
  {
    MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
  }
  else
  {
    v6 = v0;
    v7 = 0;
    lParam = 4;
    if ( SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam) )
    {
      sub_1278140(*(v8 + 60), *(v8 + 68));
      SetEvent(ghEventRefreshSearchResult);
      v4 = 2;
      v3 = 2;
      SendMessageW(ghWndTreeListView, 0x102Bu, 0, &v2);
      return 0;
    }
  }
  return 0;
}

//----- (0124F8F0) --------------------------------------------------------
int __cdecl OnExit(HWND hWnd)
{
  DestroyWindow(hWnd);
  return 0;
}

//----- (0124F900) --------------------------------------------------------
int OnShowProcessExplorer()
{
  int result; // eax
  WINDOWPLACEMENT wndpl; // [esp+0h] [ebp-30h]

  wndpl.length = 44;
  GetWindowPlacement(ghWndNewOwner, &wndpl);
  ShowWindow(ghWndNewOwner, 4 * (wndpl.showCmd == SW_SHOWMINIMIZED) + 5);
  SetForegroundWindow(ghWndNewOwner);
  SetFocus(ghWndNewOwner);
  result = 0;
  gbProcessExplorerShow = 1;
  gbProcessExplorerHide = 0;
  return result;
}
// 12EA389: using guessed type char gbProcessExplorerHide;
// 12EA393: using guessed type char gbProcessExplorerShow;

//----- (0124F980) --------------------------------------------------------
int OnThreadStackCopy()
{
  HWND v0; // eax
  HWND v1; // esi
  HGLOBAL v2; // ebx
  wchar_t *v3; // edi
  LONG v4; // eax
  HWND v5; // edx
  int v6; // ecx
  LPARAM v8; // [esp+4h] [ebp-1074h]
  int v9; // [esp+Ch] [ebp-106Ch]
  wchar_t *v10; // [esp+18h] [ebp-1060h]
  int v11; // [esp+1Ch] [ebp-105Ch]
  LPARAM lParam; // [esp+38h] [ebp-1040h]
  WPARAM wParam; // [esp+3Ch] [ebp-103Ch]
  int v14; // [esp+40h] [ebp-1038h]
  int v15; // [esp+58h] [ebp-1020h]
  int v16; // [esp+6Ch] [ebp-100Ch]
  int v17; // [esp+70h] [ebp-1008h]
  wchar_t Dst; // [esp+74h] [ebp-1004h]

  lParam = 0;
  memset(&wParam, 0, 0x30u);
  v0 = GetFocus();
  v1 = v0;
  if ( v0 == ghWndTreeListView || v0 == ghWndDllsListCtrl || v0 == ghWndHandlesListCtrl )
  {
    wParam = SendMessageW(v0, 0x100Cu, 0xFFFFFFFF, 2);
    if ( wParam != -1 )
    {
      v2 = 0;
      v3 = 0;
      v16 = 0;
      v14 = 0;
      v4 = GetWindowLongW(v1, -21);
      v5 = ghWndTreeListView;
      v17 = v4;
      if ( v1 == ghWndTreeListView )
        v17 = ++v4;
      v6 = 0;
      v14 = 0;
      if ( v4 > 0 )
      {
        while ( 1 )
        {
          if ( v1 != v5 || v3 )
          {
            v9 = v6;
            v10 = &Dst;
            v11 = 2048;
            SendMessageW(v1, 0x1073u, wParam, &v8);
          }
          else
          {
            lParam = 4;
            if ( SendMessageW(v1, 0x104Bu, 0, &lParam) )
            {
              tcscpy_s(&Dst, 0x800u, *(v15 + 60));
              --v14;
              --v17;
            }
          }
          v16 += 2 * wcslen(&Dst) + 1;
          if ( v3 )
          {
            v2 = GlobalReAlloc(v2, 2 * v16 + 2, 0);
            v3 = GlobalLock(v2);
            wcscat_s(v3, v16 + 1, L"\t");
          }
          else
          {
            v2 = GlobalAlloc(0x2002u, 2 * v16 + 2);
            v3 = GlobalLock(v2);
            *v3 = 0;
          }
          wcscat_s(v3, v16 + 1, &Dst);
          GlobalUnlock(v2);
          v6 = v14 + 1;
          v14 = v6;
          if ( v6 >= v17 )
            break;
          v5 = ghWndTreeListView;
        }
        if ( v2 && OpenClipboard(ghWndNewOwner) )
        {
          EmptyClipboard();
          SetClipboardData(0xDu, v2);
          CloseClipboard();
        }
      }
    }
  }
  return 0;
}

//----- (0124FBD0) --------------------------------------------------------
int OnRefreshNow()
{
  SetEvent(ghRefreshEvent);
  return 0;
}

//----- (0124FBE0) --------------------------------------------------------
int __cdecl OnSelectColumn(int a1, signed __int16 uId)
{
  signed __int16 v2; // di
  HWND v3; // eax
  UINT startpage; // eax
  signed int count; // esi
  char v6; // al
  HINSTANCE hinst; // ecx
  signed int v8; // eax
  int v9; // esi
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  UINT defpage; // edx
  int v14; // esi
  int v15; // eax
  int pagecount; // esi
  int v17; // eax
  int v18; // eax
  PROPSHEETHEADERW PropertyHeaderItem; // [esp+Ch] [ebp-4E8h]
  char lparam; // [esp+43h] [ebp-4B1h]
  _PROPSHEETPAGEWV4 pageinfo[10]; // [esp+44h] [ebp-4B0h]
  wchar_t szLog; // [esp+2E8h] [ebp-20Ch]

  lparam = 0;
  v2 = uId;
  PropertyHeaderItem.nStartPage = 0;
  if ( uId == 40041 )
  {
    v3 = GetFocus();
    if ( v3 == ghWndTreeListView )
    {
      v2 = 40105;
    }
    else if ( v3 == ghWndDllsListCtrl )
    {
      v2 = 40104;
    }
    else if ( v3 == ghWndHandlesListCtrl )
    {
      v2 = 40106;
    }
  }
  pageinfo[0].lParam = &lparam;
  startpage = PropertyHeaderItem.nStartPage;
  pageinfo[0].dwSize = sizeof(_PROPSHEETPAGEWV4);
  pageinfo[0].dwFlags = PSP_USETITLE;
  if ( v2 == 40105 )
    startpage = 0;
  pageinfo[0].hInstance = ghInstance;
  PropertyHeaderItem.nStartPage = startpage;
  count = 3;
  pageinfo[0].anonymous_0.pszTemplate = L"PROCCOLUMNS";
  pageinfo[0].anonymous_1.hIcon = 0;
  pageinfo[0].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
  pageinfo[0].pszTitle = L"Process Image";
  pageinfo[0].pfnCallback = 0;
  pageinfo[1].dwSize = 52;
  pageinfo[1].dwFlags = PSP_USETITLE;
  pageinfo[1].hInstance = ghInstance;
  pageinfo[1].anonymous_0.pszTemplate = L"PROCPERFCOLUMNS";
  pageinfo[1].anonymous_1.hIcon = 0;
  pageinfo[1].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
  pageinfo[1].pszTitle = L"Process Performance";
  pageinfo[1].lParam = &lparam;
  pageinfo[1].pfnCallback = 0;
  pageinfo[2].dwSize = 52;
  pageinfo[2].dwFlags = PSP_USETITLE;
  pageinfo[2].hInstance = ghInstance;
  pageinfo[2].anonymous_0.pszTemplate = L"PROCIOCOLUMNS";
  pageinfo[2].anonymous_1.hIcon = 0;
  pageinfo[2].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
  pageinfo[2].pszTitle = L"Process I/O";
  pageinfo[2].lParam = &lparam;
  pageinfo[2].pfnCallback = 0;
  v6 = IsBuiltinAndAnministrative();
  hinst = ghInstance;
  if ( v6 || gbETWstandardUserWarning == 1 )
  {
    pageinfo[3].dwSize = 52;
    pageinfo[3].dwFlags = PSP_USETITLE;
    count = 5;
    pageinfo[3].hInstance = ghInstance;
    pageinfo[3].anonymous_0.pszTemplate = L"PROCNETWORKCOLUMNS";
    pageinfo[3].anonymous_1.hIcon = 0;
    pageinfo[3].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
    pageinfo[3].pszTitle = L"Process Network";
    pageinfo[3].lParam = &lparam;
    pageinfo[3].pfnCallback = 0;
    pageinfo[4].dwSize = 52;
    pageinfo[4].dwFlags = PSP_USETITLE;
    pageinfo[4].hInstance = ghInstance;
    pageinfo[4].anonymous_0.pszTemplate = L"PROCDISKCOLUMNS";
    pageinfo[4].anonymous_1.hIcon = 0;
    pageinfo[4].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
    pageinfo[4].pszTitle = L"Process Disk";
    pageinfo[4].lParam = &lparam;
    pageinfo[4].pfnCallback = 0;
  }
  v8 = count;
  v9 = count + 1;
  v10 = gdwAdapterRuntingTime == 0;
  pageinfo[v8].dwSize = 52;
  pageinfo[v8].dwFlags = PSP_USETITLE;
  pageinfo[v8].hInstance = hinst;
  pageinfo[v8].anonymous_0.pszTemplate = L"PROCMEMCOLUMNS";
  pageinfo[v8].anonymous_1.hIcon = 0;
  pageinfo[v8].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
  pageinfo[v8].pszTitle = L"Process Memory";
  pageinfo[v8].lParam = &lparam;
  pageinfo[v8].pfnCallback = 0;
  if ( !v10 )
  {
    v11 = v9++;
    pageinfo[v11].dwSize = 52;
    pageinfo[v11].dwFlags = PSP_USETITLE;
    pageinfo[v11].hInstance = hinst;
    pageinfo[v11].anonymous_0.pszTemplate = L"PROCGPUCOLUMNS";
    pageinfo[v11].anonymous_1.hIcon = 0;
    pageinfo[v11].pfnDlgProc = SelectColumnForProcessImagePageWndProc;
    pageinfo[v11].pszTitle = L"Process GPU";
    pageinfo[v11].lParam = &lparam;
    pageinfo[v11].pfnCallback = 0;
  }
  v12 = v9;
  pageinfo[v12].lParam = &lparam;
  defpage = PropertyHeaderItem.nStartPage;
  pageinfo[v12].dwSize = 52;
  if ( v2 == 40106 )
    defpage = v9;
  pageinfo[v12].dwFlags = PSP_USETITLE;
  v14 = v9 + 1;
  pageinfo[v12].hInstance = hinst;
  pageinfo[v12].anonymous_0.pszTemplate = L"HANDLECOLUMNS";
  pageinfo[v12].anonymous_1.hIcon = 0;
  pageinfo[v12].pfnDlgProc = SelectColumnForProcHandlePageWndProc;
  pageinfo[v12].pszTitle = L"Handle";
  pageinfo[v12].pfnCallback = 0;
  v15 = v14;
  pageinfo[v15].dwSize = 52;
  pageinfo[v15].dwFlags = PSP_USETITLE;
  pageinfo[v15].hInstance = hinst;
  pageinfo[v15].anonymous_0.pszTemplate = L"DLLCOLUMNS";
  pageinfo[v15].anonymous_1.hIcon = 0;
  pageinfo[v15].pfnDlgProc = SelectColumnForProcDLLPageWndProc;
  pageinfo[v15].pszTitle = L"DLL";
  pageinfo[v15].lParam = &lparam;
  pageinfo[v15].pfnCallback = 0;
  if ( v2 == 40104 )
    defpage = v14;
  pagecount = v14 + 1;
  if ( gbDotNetProcess )
  {
    v17 = pagecount++;
    pageinfo[v17].dwSize = 52;
    pageinfo[v17].dwFlags = PSP_USETITLE;
    pageinfo[v17].hInstance = hinst;
    pageinfo[v17].anonymous_0.pszTemplate = L"NETCOLUMNS";
    pageinfo[v17].anonymous_1.hIcon = 0;
    pageinfo[v17].pfnDlgProc = SelectColumnForDotNetProcPageWndProc;
    pageinfo[v17].pszTitle = L".NET";
    pageinfo[v17].lParam = &lparam;
    pageinfo[v17].pfnCallback = 0;
  }
  v18 = pagecount;
  // Uses the ppsp member and ignores the phpage member when creating the pages for the property sheet.
  PropertyHeaderItem.dwFlags = 0x88;            // PSH_NOAPPLYNOW|PSH_PROPSHEETPAGE
  PropertyHeaderItem.dwSize = 52;
  PropertyHeaderItem.hInstance = hinst;
  pageinfo[v18].dwSize = 52;
  pageinfo[v18].dwFlags = PSP_USETITLE;
  pageinfo[v18].hInstance = hinst;
  pageinfo[v18].anonymous_0.pszTemplate = L"STATUSBARCOLUMNS";
  pageinfo[v18].anonymous_1.hIcon = 0;
  pageinfo[v18].pfnDlgProc = SelectColumnForStatusBarPageWndProc;
  pageinfo[v18].pszTitle = L"Status Bar";
  pageinfo[v18].lParam = 0;
  pageinfo[v18].pfnCallback = 0;
  PropertyHeaderItem.nPages = pagecount + 1;
  PropertyHeaderItem.ppsp = pageinfo;
  if ( v2 == 40107 )
    defpage = pagecount;
  PropertyHeaderItem.hwndParent = ghWndNewOwner;
  PropertyHeaderItem.nStartPage = defpage;
  stprintf(&szLog, L"Select Columns");
  PropertyHeaderItem.pfnCallback = 0;
  PropertyHeaderItem.pszCaption = &szLog;
  PropertySheetW(&PropertyHeaderItem);
  if ( lparam )
    CMainWnd::Reset(ghWndNewOwner, 1);
  return 0;
}
// 12C1188: using guessed type wchar_t aProccolumns[12];
// 12C11A0: using guessed type wchar_t aProcessImage[14];
// 12C11BC: using guessed type wchar_t aProcperfcolumn[16];
// 12C11DC: using guessed type wchar_t aProcessPerform[20];
// 12C1204: using guessed type wchar_t aProciocolumns[14];
// 12C1220: using guessed type wchar_t aProcessIO[12];
// 12C1238: using guessed type wchar_t aProcnetworkcol[19];
// 12C1260: using guessed type wchar_t aProcessNetwork[16];
// 12C1280: using guessed type wchar_t aProcdiskcolumn[16];
// 12C12A0: using guessed type wchar_t aProcessDisk[13];
// 12C12BC: using guessed type wchar_t aProcmemcolumns[15];
// 12C12DC: using guessed type wchar_t aProcessMemory[15];
// 12C12FC: using guessed type wchar_t aProcgpucolumns[15];
// 12C131C: using guessed type wchar_t aProcessGpu[12];
// 12C1334: using guessed type wchar_t aHandlecolumns_0[14];
// 12C1350: using guessed type wchar_t aHandle[7];
// 12C1360: using guessed type wchar_t aDllcolumns_0[11];
// 12C1380: using guessed type wchar_t aNetcolumns[11];
// 12C1398: using guessed type wchar_t aNet[5];
// 12C13A4: using guessed type wchar_t aStatusbarcolum_0[17];
// 12C13C8: using guessed type wchar_t aStatusBar[11];
// 12E96E2: using guessed type char gbETWstandardUserWarning;
// 12EA098: using guessed type char gbDotNetProcess;

//----- (01250150) --------------------------------------------------------
int __cdecl OnViewDlls(HWND hWnd)
{
  HMENU v1; // eax
  signed int v2; // eax
  UINT v3; // ST10_4
  HMENU v4; // eax
  LPARAM v5; // eax
  int v6; // eax
  int v7; // eax
  HMENU v8; // eax
  UINT_PTR v9; // ST0C_4
  HMENU v10; // eax
  LRESULT v11; // eax

  gbShowDllView = 1;
  v1 = GetMenu(hWnd);
  CheckMenuItem(v1, 0x9C4Bu, 8u);
  v2 = 0;
  if ( !gbShowDllView )
    v2 = 8;
  v3 = v2;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C46u, v3);
  v5 = 1;
  if ( gbShowDllView )
    v5 = 4;
  PostMessageW(ghWndToolbar, 0x42Bu, 0x9C5Eu, v5);
  InvalidateRect(ghWndToolbar, 0, 1);
  if ( hWnd )
    SetEvent(ghEventRefreshSearchResult);
  v6 = 5;
  if ( gbShowDllView )
    v6 = 0;
  ShowWindow(ghWndHandlesListCtrl, v6);
  v7 = 0;
  if ( gbShowDllView )
    v7 = 5;
  ShowWindow(ghWndDllsListCtrl, v7);
  if ( gbShowLowerpane )
  {
    v8 = GetMenu(ghWndNewOwner);
    RemoveMenu(v8, 5u, 0x400u);
    v9 = ghMenuDllsMenu;
    v10 = GetMenu(ghWndNewOwner);
    InsertMenuW(v10, 5u, 0x410u, v9, L"&DLL");
  }
  v11 = SendMessageW(ghWndDllsListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
  UpdateMenu(v11 != -1, 5);
  DrawMenuBar(ghWndNewOwner);
  if ( !gbShowLowerpane )
    OnShowLowerPane(ghWndNewOwner);
  return 0;
}
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (012502B0) --------------------------------------------------------
int __cdecl OnViewHandles(HWND hWnd)
{
  HMENU v1; // eax
  signed int v2; // eax
  UINT v3; // ST10_4
  HMENU v4; // eax
  LPARAM v5; // eax
  int v6; // eax
  int v7; // eax
  HMENU v8; // eax
  UINT_PTR v9; // ST0C_4
  HMENU v10; // eax
  LRESULT v11; // eax

  gbShowDllView = 0;
  v1 = GetMenu(hWnd);
  CheckMenuItem(v1, 0x9C4Bu, 0);
  v2 = 0;
  if ( !gbShowDllView )
    v2 = 8;
  v3 = v2;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C46u, v3);
  v5 = 1;
  if ( gbShowDllView )
    v5 = 4;
  PostMessageW(ghWndToolbar, 0x42Bu, 0x9C5Eu, v5);
  PostMessageW(ghWndToolbar, 0x401u, 0x9C47u, gbShowDllView == 0);
  InvalidateRect(ghWndToolbar, 0, 1);
  if ( hWnd )
    SetEvent(ghEventRefreshSearchResult);
  v6 = 5;
  if ( gbShowDllView )
    v6 = 0;
  ShowWindow(ghWndHandlesListCtrl, v6);
  v7 = 0;
  if ( gbShowDllView )
    v7 = 5;
  ShowWindow(ghWndDllsListCtrl, v7);
  if ( !gbShowLowerpane )
    goto LABEL_17;
  v8 = GetMenu(ghWndNewOwner);
  RemoveMenu(v8, 5u, 0x400u);
  v9 = ghMenuHandlesMenu;
  v10 = GetMenu(ghWndNewOwner);
  InsertMenuW(v10, 5u, 0x410u, v9, L"H&andle");
  v11 = SendMessageW(ghWndHandlesListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
  UpdateMenu(v11 != -1, 5);
  DrawMenuBar(ghWndNewOwner);
  if ( !gbShowLowerpane )
LABEL_17:
    OnShowLowerPane(ghWndNewOwner);
  return 0;
}
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (01250430) --------------------------------------------------------
int __cdecl OnViewHandles2(HWND hWnd)
{
  if ( gbShowDllView )
    OnViewHandles(hWnd);
  else
    OnViewDlls(hWnd);
  if ( ghDlgFindDialog )
    SendMessageW(ghDlgFindDialog, 0x18u, 0, 0);
  return 0;
}
// 12E96CC: using guessed type char gbShowDllView;

//----- (01250480) --------------------------------------------------------
int __cdecl OnShowUnnamedHandlesAndMappings(HWND hWnd)
{
  MACRO_MF v1; // eax
  bool v2; // zf
  UINT v3; // ST0C_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gbShowUnnamedHandles != 0;
  gbShowUnnamedHandles = gbShowUnnamedHandles == 0;
  if ( !v2 )
    v1 = MF_CHECKED;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, IDS_PROCEXPLORERMENU_SHOW_UNNAMED_HANDLES_AND_MAPPINGS, v3);
  if ( gbShowLowerpane && g_dwProcessId != -1 )
    SetEvent(ghStartToResumeProcessEvent);
  SendMessageW(
    ghWndToolbar,
    TB_PRESSBUTTON,
    IDS_PROCEXPLORERMENU_SHOW_UNNAMED_HANDLES_AND_MAPPINGS,
    gbShowUnnamedHandles);
  return 0;
}
// 12E96CA: using guessed type char gbShowUnnamedHandles;
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (01250500) --------------------------------------------------------
int __cdecl OnHiliteRelocatedDlls(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST08_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gbHighlightRelocatedDlls != 0;
  gbHighlightRelocatedDlls = gbHighlightRelocatedDlls == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C50u, v3);
  InvalidateRgn(ghWndDllsListCtrl, 0, 1);
  return 0;
}
// 12E96CE: using guessed type char gbHighlightRelocatedDlls;

//----- (01250550) --------------------------------------------------------
int __cdecl OnScrollToNewProcesses(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST08_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gbShowNewProcesses != 0;
  gbShowNewProcesses = gbShowNewProcesses == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9F0Du, v3);
  CMainWnd::Reset(ghWndNewOwner, 1);
  return 0;
}
// 12E96DB: using guessed type char gbShowNewProcesses;

//----- (012505A0) --------------------------------------------------------
int __cdecl OnHelp(int a1)
{
  wchar_t *v1; // eax
  WCHAR FileName; // [esp+4h] [ebp-414h]
  WCHAR Filename; // [esp+20Ch] [ebp-20Ch]

  GetModuleFileNameW(0, &Filename, 0x104u);
  v1 = wcsrchr(&Filename, 0x5Cu);
  tcscpy_s(v1, 260 - (v1 - &Filename), L"\\procexp.chm");
  stprintf(&FileName, L"%s:Zone.Identifier", &Filename);
  DeleteFileW(&FileName);
  if ( !HtmpHelpImpl(a1, &Filename, 0, 0) )
  {
    SetLastError(0);
    ErrMsgBox(L"Unable to open help file", ghWndNewOwner);
  }
  return 0;
}

//----- (01250660) --------------------------------------------------------
int __cdecl OnSearchOnline(int a1, __int16 a2)
{
  HWND v2; // esi
  HWND v3; // eax
  LRESULT v4; // eax
  wchar_t *v5; // eax
  int v6; // esi
  LPARAM lParam; // [esp+4h] [ebp-34h]
  LRESULT v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+24h] [ebp-14h]

  lParam = 0;
  memset(&v9, 0, 0x30u);
  if ( a2 == -25424 )
  {
    v2 = ghWndDllsListCtrl;
  }
  else
  {
    v3 = GetFocus();
    v2 = ghWndTreeListView;
    if ( v3 == ghWndDllsListCtrl )
      v2 = ghWndDllsListCtrl;
  }
  v4 = SendMessageW(v2, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v4 != -1 )
  {
    v9 = v4;
    v10 = 0;
    lParam = 4;
    if ( SendMessageW(v2, 0x104Bu, 0, &lParam) )
    {
      if ( v2 == ghWndTreeListView )
      {
        v5 = *(v11 + 60);
      }
      else
      {
        v6 = v11;
        if ( *(v11 + 44) & 8 )
        {
          MessageBoxW(
            ghWndTreeListView,
            L"Search not supported on pagefile-backed sections",
            L"Process Explorer Error",
            0x10u);
          return 0;
        }
        if ( wcsrchr(*(v11 + 344), 0x5Cu) )
          v5 = wcsrchr(*(v6 + 344), 0x5Cu) + 1;
        else
          v5 = *(v6 + 344);
      }
      sub_1245750(a1, 1, v5);
    }
  }
  return 0;
}

//----- (01250770) --------------------------------------------------------
int __cdecl OnFindHandlerOrDll(int a1, __int16 uId)
{
  gbFindHandlesOrDlls = uId == IDS_PROCEXPLORERMENU_FIND_HANDLE_OR_DLL;
  if ( ghDlgFindDialog )
  {
    ShowWindow(ghDlgFindDialog, SW_SHOW);
    SetFocus(ghDlgFindDialog);
  }
  else
  {
    ghDlgFindDialog = CreateDialogParamW(ghInstance, L"FINDDIALOG", ghWndNewOwner, FindDialogDlgProc, ghDlgFindDialog);
  }
  return 0;
}
// 12DE104: using guessed type char gbFindHandlesOrDlls;

//----- (012507D0) --------------------------------------------------------
int __cdecl OnDestroy(HWND hWnd)
{
  int result; // eax

  if ( gbIsFinding )
  {
    FindProcessByWindow(hWnd);
    result = 0;
  }
  else
  {
    if ( gbHideWhenMinimized )
      MainWnd_Hide(ghWndNewOwner);
    else
      HandleDestroy(hWnd);
    result = 0;
  }
  return result;
}
// 12E96D1: using guessed type char gbHideWhenMinimized;
// 12EA38B: using guessed type char gbIsFinding;

//----- (01250830) --------------------------------------------------------
int sub_1250830()
{
  WCHAR **v0; // eax
  int v1; // esi
  WCHAR **v2; // ecx
  WCHAR **v3; // eax
  #1077 *i; // eax
  HMENU v5; // eax

  v0 = gpHiddenProcs;
  v1 = 0;
  if ( *gpHiddenProcs )
  {
    v2 = gpHiddenProcs;
    do
    {
      free(*v2);
      v0 = gpHiddenProcs;
      v2 = &gpHiddenProcs[++v1];
    }
    while ( *v2 );
  }
  free(v0);
  v3 = malloc(4u);
  gpHiddenProcs = v3;
  *v3 = 0;
  for ( i = gpTreeListParamList; i; i = *(i + 364) )
    *(i + 10) &= 0xFFFFFFFE;
  sub_1246C90();
  v5 = GetMenu(ghWndNewOwner);
  EnableMenuItem(v5, 0x9C9Bu, 1u);
  SetEvent(ghRefreshEvent);
  return 0;
}

//----- (012508C0) --------------------------------------------------------
int __cdecl OnSelectFont(HWND hWnd)
{
  sub_1239980(hWnd);
  return 0;
}

//----- (012508E0) --------------------------------------------------------
int sub_12508E0()
{
  HWND v0; // esi
  LRESULT v1; // eax
  LPARAM lParam; // [esp+4h] [ebp-34h]
  LRESULT v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+Ch] [ebp-2Ch]
  volatile LONG *lpAddend; // [esp+24h] [ebp-14h]

  lParam = 0;
  memset(&v4, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 != -1 )
  {
    v4 = v1;
    v5 = 0;
    lParam = 4;
    if ( SendMessageW(v0, 0x104Bu, 0, &lParam) )
    {
      InterlockedIncrement(lpAddend);
      *(lpAddend + 17) = g_dwProcessId;
      _beginthread(LaunchDllPropDlg, 0, lpAddend);
    }
  }
  return 0;
}

//----- (01250970) --------------------------------------------------------
int __cdecl sub_1250970(int a1, __int16 a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // eax
  LRESULT v7; // eax
  LPARAM v9; // [esp+0h] [ebp-80h]
  int v10; // [esp+Ch] [ebp-74h]
  int v11; // [esp+10h] [ebp-70h]
  LPARAM lParam; // [esp+34h] [ebp-4Ch]
  LRESULT v13; // [esp+38h] [ebp-48h]
  int v14; // [esp+3Ch] [ebp-44h]
  int v15; // [esp+54h] [ebp-2Ch]
  int v16; // [esp+68h] [ebp-18h]
  int v17; // [esp+70h] [ebp-10h]

  if ( GetFocus() != ghWndTreeListView )
    return 0;
  v13 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v13 != -1 )
  {
    v14 = 0;
    lParam = 4;
    if ( SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam) )
    {
      v2 = v15;
      if ( a2 == -25449 )
      {
        if ( *(v15 + 40) & 4 )
        {
          v11 = 3;
          ++v13;
          v10 = 3;
          SendMessageW(ghWndTreeListView, 0x102Bu, v13, &v9);
LABEL_20:
          v7 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
          SendMessageW(ghWndTreeListView, 0x1013u, v7, 0);
          return 0;
        }
      }
      else if ( a2 == -25448 && !(*(v15 + 40) & 4) )
      {
        v3 = *(v15 + 84);
        if ( v3 )
        {
          while ( 1 )
          {
            v4 = *(v3 + 40);
            if ( v4 & 2 )
            {
              if ( !(v4 & 1) || !byte_12E96D6 )
                break;
            }
            v3 = *(v3 + 84);
            if ( !v3 )
              goto LABEL_20;
          }
          v17 = v3;
          v16 = 1;
          v13 = SendMessageW(ghWndTreeListView, 0x1053u, 0xFFFFFFFF, &v16);
          v11 = 3;
          v10 = 3;
          SendMessageW(ghWndTreeListView, 0x102Bu, v13, &v9);
        }
        goto LABEL_20;
      }
      v5 = *(v15 + 40);
      if ( v5 & 4 )
        v6 = v5 & 0xFFFFFFFB;
      else
        v6 = v5 | 4;
      *(v15 + 40) = v6;
      SendMessageW(ghWndTreeListView, 0x2001u, *(v2 + 1464), (v6 >> 2) & 1);
      sub_1238DA0(v2);
      goto LABEL_20;
    }
  }
  return 0;
}
// 12E96D6: using guessed type char byte_12E96D6;

//----- (01250B10) --------------------------------------------------------
int OnConfirmKill()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gbConfirmKill != 0;
  gbConfirmKill = gbConfirmKill == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghWndNewOwner);
  CheckMenuItem(v3, 0x9C96u, v2);
  CMainWnd::Reset(ghWndNewOwner, 1);
  return 0;
}
// 12E96D4: using guessed type char gbConfirmKill;

//----- (01250B60) --------------------------------------------------------
int OnFormatIoBytes()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gbFormatIoBytes != 0;
  gbFormatIoBytes = gbFormatIoBytes == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghWndNewOwner);
  CheckMenuItem(v3, IDM_OTHER_FormatIoBytes, v2);
  CMainWnd::Reset(ghWndNewOwner, 1);
  InvalidateRect(ghWndNewOwner, 0, 0);
  return 0;
}
// 12E96D5: using guessed type char gbFormatIoBytes;

//----- (01250BC0) --------------------------------------------------------
int sub_1250BC0()
{
  LRESULT v0; // eax
  #1077 *v1; // esi
  int i; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // esi
  HMENU v6; // eax
  WCHAR **v8; // eax
  int v9; // ecx
  bool v10; // zf
  WCHAR **j; // ecx
  LPARAM lParam; // [esp+4h] [ebp-34h]
  LRESULT v13; // [esp+8h] [ebp-30h]
  int v14; // [esp+Ch] [ebp-2Ch]
  int v15; // [esp+24h] [ebp-14h]

  lParam = 0;
  memset(&v13, 0, 0x30u);
  v0 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v0 == -1 )
    return 0;
  v13 = v0;
  v14 = 0;
  lParam = 4;
  if ( !SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam) )
    return 0;
  v1 = gpTreeListParamList;
  for ( i = v15; v1; v1 = *(v1 + 364) )
  {
    if ( !_wcsicmp(*(v1 + 15), *(i + 60)) )
    {
      v3 = *(v1 + 10);
      if ( v3 & 1 )
        v4 = v3 & 0xFFFFFFFE;
      else
        v4 = v3 | 1;
      *(v1 + 10) = v4;
    }
  }
  v5 = 0;
  if ( !(*(i + 40) & 1) )
  {
    v8 = gpHiddenProcs;
    if ( *gpHiddenProcs )
    {
      v9 = 0;
      while ( 1 )
      {
        v10 = _wcsicmp(v8[v9], *(i + 60)) == 0;
        v8 = gpHiddenProcs;
        if ( v10 )
          break;
        v9 = ++v5;
        if ( !gpHiddenProcs[v5] )
        {
          sub_1246C90();
          return 0;
        }
      }
      free(gpHiddenProcs[v5]);
      for ( j = &gpHiddenProcs[v5]; gpHiddenProcs[v5]; j = &gpHiddenProcs[v5] )
      {
        ++v5;
        *j = j[1];
      }
    }
    sub_1246C90();
    return 0;
  }
  if ( *gpHiddenProcs )
  {
    do
      ++v5;
    while ( gpHiddenProcs[v5] );
  }
  gpHiddenProcs = realloc(gpHiddenProcs, 4 * v5 + 8);
  gpHiddenProcs[v5] = _wcsdup(*(i + 60));
  gpHiddenProcs[v5 + 1] = 0;
  SetEvent(ghRefreshEvent);
  v6 = GetMenu(ghWndNewOwner);
  EnableMenuItem(v6, 0x9C9Bu, 0);
  sub_1246C90();
  return 0;
}

//----- (01250D80) --------------------------------------------------------
int __cdecl OnHiliteDuration(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"DIFFDURATION", hWndParent, DiffDurationDlgProc, 0);
  return 0;
}

//----- (01250DB0) --------------------------------------------------------
int OnFileSave()
{
  sub_127E3B0(0);
  return 0;
}

//----- (01250DC0) --------------------------------------------------------
int __cdecl OnCpuHistory_0(HWND hWndParent)
{
  HWND hWndTreeListView; // esi
  int iItem; // eax
  HANDLE ProcessHandle; // eax
  void *v4; // esi
  LVITEMEXW item; // [esp+4h] [ebp-34h]

  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  hWndTreeListView = ghWndTreeListView;
  iItem = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, LVIS_SELECTED);
  if ( iItem != -1 )
  {
    item.iItem = iItem;
    item.iSubItem = 0;
    item.mask = LVIF_PARAM;
    if ( SendMessageW(hWndTreeListView, LVM_GETITEMW, 0, &item) )
    {
      if ( hWndTreeListView == ghWndTreeListView )
      {
        ProcessHandle = OpenProcess(0x600u, 0, item.lParam[1].field_8);
        v4 = ProcessHandle;
        if ( !ProcessHandle )
        {
          ErrMsgBox(L"Unable to set process affinity", ghWndNewOwner);
          return 0;
        }
        DialogBoxParamW(ghInstance, L"CPUAFFINITY", hWndParent, CpuAffinityDlgProc, ProcessHandle);
        CloseHandle(v4);
      }
    }
  }
  return 0;
}

//----- (01250E90) --------------------------------------------------------
int OnFileSaveas()
{
  sub_127E3B0(1);
  return 0;
}

//----- (01250EA0) --------------------------------------------------------
int OnKillProcess()
{
  HWND v0; // esi
  LRESULT v1; // eax
  _DWORD *v2; // esi
  LPARAM v4; // [esp+8h] [ebp-78h]
  int v5; // [esp+14h] [ebp-6Ch]
  int v6; // [esp+18h] [ebp-68h]
  LPARAM lParam; // [esp+3Ch] [ebp-44h]
  LRESULT v8; // [esp+40h] [ebp-40h]
  int v9; // [esp+44h] [ebp-3Ch]
  _DWORD *v10; // [esp+5Ch] [ebp-24h]
  int InBuffer; // [esp+70h] [ebp-10h]
  int v12; // [esp+74h] [ebp-Ch]
  int v13; // [esp+7Ch] [ebp-4h]

  lParam = 0;
  memset(&v8, 0, 0x30u);
  v0 = GetFocus();
  if ( v0 == ghWndDllsListCtrl )
    v0 = ghWndTreeListView;
  v1 = SendMessageW(v0, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 == -1 )
  {
    if ( v0 == ghWndTreeListView )
    {
      MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
      return 0;
    }
    if ( v0 == ghWndHandlesListCtrl )
    {
      MessageBoxW(ghWndTreeListView, L"No handle selected", L"Process Explorer Error", 0x10u);
      return 0;
    }
    MessageBoxW(ghWndTreeListView, L"No handle or process selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  v8 = v1;
  v9 = 0;
  lParam = 4;
  if ( !SendMessageW(v0, LVM_GETITEMW, 0, &lParam) )
    return 0;
  if ( v0 == ghWndTreeListView || v0 == ghWndDllsListCtrl )
  {
    if ( sub_1278030(v10[15], v10[17]) )
    {
      SetEvent(ghEventRefreshSearchResult);
      v6 = 3;
      v5 = 3;
      SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, v8 - 1, &v4);
      return 0;
    }
    return 0;
  }
  if ( v0 != ghWndHandlesListCtrl )
    return 0;
  v2 = v10;
  if ( !IsBuiltinAndAnministrative() )
  {
    MessageBoxW(
      ghWndHandlesListCtrl,
      L"Closing handles requires administrative rights.",
      L"Process Explorer Error",
      0x10u);
    return 0;
  }
  if ( !v2[9] )
  {
    MessageBoxW(
      ghWndHandlesListCtrl,
      L"Handles in the Idle process cannot be closed.",
      L"Process Explorer Error",
      0x10u);
    return 0;
  }
  if ( gbConfirmKill
    && MessageBoxW(
         ghWndHandlesListCtrl,
         L"Forcing a handle closed can lead to an application crash and system instability.\nContinue with close?",
         L"Process Explorer Warning",
         0x34u) != 6 )
  {
    return 0;
  }
  v13 = v2[11];
  InBuffer = v2[9];
  v12 = v2[10];
  if ( DeviceIoControl_0(IoCtrlID_OpenProcess, &InBuffer, 0x10u, 0, 0) )
  {
    SetEvent(ghEventRefreshSearchResult);
    v6 = 3;
    v5 = 3;
    SendMessageW(ghWndHandlesListCtrl, LVM_SETITEMSTATE, v8 - 1, &v4);
    SetFocus(ghWndHandlesListCtrl);
  }
  else
  {
    ErrMsgBox(L"Error opening process", ghWndNewOwner);
  }
  return 0;
}
// 12E96D4: using guessed type char gbConfirmKill;

//----- (012510F0) --------------------------------------------------------
int OnSuspendProcess()
{
  HWND v0; // esi
  LRESULT v1; // eax
  int v2; // esi
  int v3; // eax
  unsigned int v4; // eax
  const WCHAR *v5; // eax
  const WCHAR *v6; // ST10_4
  HMENU v7; // eax
  int result; // eax
  LPARAM lParam; // [esp+8h] [ebp-38h]
  WPARAM wParam; // [esp+Ch] [ebp-34h]
  int v11; // [esp+10h] [ebp-30h]
  int v12; // [esp+28h] [ebp-18h]
  char v13; // [esp+3Ch] [ebp-4h]

  lParam = 0;
  memset(&wParam, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v1 != -1
    && (wParam = v1, v11 = 0, lParam = 4, SendMessageW(v0, 0x104Bu, 0, &lParam))
    && (v2 = v12, SetFocus(ghWndTreeListView), v2) )
  {
    if ( sub_127F0A0(~(*(v2 + 40) >> 7) & 1, *(v2 + 68), &v13) )
    {
      ErrMsgBox(L"Unable to suspend the process", ghWndNewOwner);
    }
    else
    {
      v3 = *(v2 + 40);
      if ( (v3 & 0x80u) == 0 )
        v4 = v3 | 0x80;
      else
        v4 = v3 & 0xFFFFFF7F;
      *(v2 + 40) = v4;
    }
    SendMessageW(ghWndTreeListView, 0x1015u, wParam, wParam);
    v5 = L"R&esume";
    if ( *(v12 + 40) >= 0 )
      v5 = L"S&uspend";
    v6 = v5;
    v7 = GetMenu(ghWndNewOwner);
    ModifyMenuW(v7, 0x9C6Au, 0, 0x9C6Au, v6);
    result = 0;
  }
  else
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
    result = 0;
  }
  return result;
}
// 12BE398: using guessed type wchar_t aREsume[8];

//----- (01251230) --------------------------------------------------------
int __cdecl OnShowLowerPane(int a1)
{
  HMENU v1; // ebx
  UINT v2; // ecx
  bool v3; // zf
  HMENU v4; // eax
  HWND v6; // edi
  LRESULT v7; // eax
  const WCHAR *v8; // eax
  UINT_PTR v9; // eax
  LRESULT v10; // eax
  const WCHAR *v11; // [esp-4h] [ebp-24h]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v1 = GetMenu(ghWndNewOwner);
  v2 = 0;
  v3 = gbShowLowerpane != 0;
  gbShowLowerpane = gbShowLowerpane == 0;
  if ( !v3 )
    v2 = 8;
  CheckMenuItem(v1, 0x9C6Eu, v2);
  SendMessageW(ghWndToolbar, 0x42Bu, 0x9C6Eu, (gbShowLowerpane != 0) + 9);
  InvalidateRect(ghWndToolbar, 0, 1);
  GetClientRect(ghWndNewOwner, &Rect);
  if ( gbShowLowerpane )
  {
    *&gdSavedDividerCopy = gdSavedDivider;
    HandleSize(
      ghWndNewOwner,
      0,
      0,
      (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
    v6 = ghWndHandlesListCtrl;
    if ( gbShowDllView )
      v6 = ghWndDllsListCtrl;
    v7 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
    SendMessageW(ghWndTreeListView, 0x1013u, v7, 0);
    ShowWindow(v6, 5);
    if ( a1 )
      SetEvent(ghEventRefreshSearchResult);
    v8 = L"&DLL";
    if ( !gbShowDllView )
      v8 = L"H&andle";
    v11 = v8;
    v9 = ghMenuHandlesMenu;
    if ( gbShowDllView )
      v9 = ghMenuDllsMenu;
    InsertMenuW(v1, 5u, 0x410u, v9, v11);
    DrawMenuBar(ghWndNewOwner);
    v10 = SendMessageW(v6, 0x100Cu, 0xFFFFFFFF, 2);
    UpdateMenu(v10 != -1, 5);
  }
  else if ( IsWindowVisible(ghWndHandlesListCtrl) || IsWindowVisible(ghWndDllsListCtrl) )
  {
    ShowWindow(ghWndHandlesListCtrl, 0);
    ShowWindow(ghWndDllsListCtrl, 0);
    v4 = GetMenu(ghWndNewOwner);
    RemoveMenu(v4, 5u, 0x400u);
    DrawMenuBar(ghWndNewOwner);
    gdSavedDivider = *&gdSavedDividerCopy;
    gdSavedDividerCopy = doubleOnePointZero;
    HandleSize(
      ghWndNewOwner,
      0,
      0,
      (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
    return 0;
  }
  return 0;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12E5528: using guessed type __int64 gdSavedDivider;
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (01251490) --------------------------------------------------------
int __cdecl OnShowProcessProperties(HWND hWnd, UINT uMenuId, BOOL bMenuMsg, LPARAM lParam)
{
  HWND hListCtrl; // esi
  int nSelectedItem; // eax
  HANDLESANDDLLSLISTUSERPARAM *pInfo; // esi
  LVITEMW item; // [esp+4h] [ebp-34h]

  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  switch ( uMenuId )
  {
    case IDS_DLLMENU_PROPERTIES:
      hListCtrl = ghWndDllsListCtrl;
      break;
    case IDS_HANDLEMENU_PROPERTIES:
      hListCtrl = ghWndHandlesListCtrl;
      break;
    case IDS_PROCEXPLORERMENU_PROCESS_PROPERTIES:
      hListCtrl = ghWndTreeListView;
      break;
    default:
      hListCtrl = GetFocus();
      break;
  }
  nSelectedItem = SendMessageW(hListCtrl, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
  if ( nSelectedItem == -1 )
  {
    if ( hListCtrl == ghWndTreeListView )
    {
      MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", MB_ICONERROR);
      return 0;
    }
    if ( hListCtrl == ghWndDllsListCtrl )
    {
      MessageBoxW(ghWndTreeListView, L"No DLL is selected", L"Process Explorer Error", MB_ICONHAND);
      return 0;
    }
    if ( hListCtrl == ghWndHandlesListCtrl )
      MessageBoxW(ghWndTreeListView, L"No object is selected", L"Process Explorer Error", MB_ICONHAND);
    return 0;
  }
  item.iItem = nSelectedItem;
  item.iSubItem = 0;
  item.mask = LVIF_PARAM;
  // 获得保存在每个item.lParam中的用户数据
  if ( !SendMessageW(hListCtrl, LVM_GETITEMW, 0, &item) )
    return 0;
  // 启动DLL的属性窗口，线程进行
  if ( hListCtrl == ghWndDllsListCtrl )
  {
    pInfo = item.lParam;
    if ( item.lParam->szText[2] & 8 )
    {
      MessageBoxW(
        ghWndTreeListView,
        L"Properties not supported on pagefile-backed sections",
        L"Process Explorer Error",
        0x10u);
      return 0;
    }
    if ( *&item.lParam[1].szText[0x3C] )
    {
      InterlockedIncrement(&item.lParam->field_0);
      *pInfo->szText = g_dwProcessId;
      _beginthread(LaunchDllPropDlg, 0, pInfo);
      return 0;
    }
    return 0;
  }
  // 显示HANDLE的属性
  if ( hListCtrl == ghWndHandlesListCtrl )
    ShowHandleProperties(hListCtrl, item.lParam);
  else
    // 显示指定进程的属性，后台线程表示
    StartProcessPropSheet(item.lParam);
  return 0;
}

//----- (01251620) --------------------------------------------------------
int __cdecl OnRefreshTime(int a1, UINT a2)
{
  signed int v2; // eax
  UINT v3; // ebx
  signed int v4; // eax
  HMENU v5; // eax
  HMENU v6; // eax
  UINT v8; // [esp-14h] [ebp-14h]

  v2 = gdwRefreshRateOfSearch;
  if ( gdwRefreshMenuId == -1 )
  {
    if ( gdwRefreshRateOfSearch > 2000 )
    {
      if ( gdwRefreshRateOfSearch == 5000 )
      {
        gdwRefreshMenuId = 40020;
      }
      else if ( gdwRefreshRateOfSearch == 10000 )
      {
        gdwRefreshMenuId = 40022;
      }
    }
    else if ( gdwRefreshRateOfSearch == 2000 )
    {
      gdwRefreshMenuId = 40019;
    }
    else if ( gdwRefreshRateOfSearch )
    {
      if ( gdwRefreshRateOfSearch == 500 )
      {
        gdwRefreshMenuId = 40023;
      }
      else if ( gdwRefreshRateOfSearch == 1000 )
      {
        gdwRefreshMenuId = 40021;
      }
    }
    else
    {
      gdwRefreshMenuId = 40018;
    }
  }
  LOWORD(v3) = a2;
  if ( a2 == -25518 && !gdwRefreshRateOfSearch )
  {
    SendMessageW(ghWndStatusBar, 0x40Bu, gdwStatusBarCount - 1, gpszTargetName);
    v4 = gdwRefreshMenuId;
    if ( gdwRefreshMenuId == -1 )
      v4 = 1000;
    v3 = v4;
    gdwRefreshMenuId = v4;
    v2 = gdwRefreshRateOfSearch;
    a2 = v3;
  }
  if ( v2 > 2000 )
  {
    if ( v2 == 5000 )
    {
      v8 = 40020;
    }
    else
    {
      if ( v2 != 10000 )
        goto LABEL_34;
      v8 = 40022;
    }
  }
  else if ( v2 == 2000 )
  {
    v8 = 40019;
  }
  else if ( v2 )
  {
    if ( v2 == 500 )
    {
      v8 = 40023;
    }
    else
    {
      if ( v2 != 1000 )
        goto LABEL_34;
      v8 = 40021;
    }
  }
  else
  {
    v8 = 40018;
  }
  v5 = GetMenu(ghWndNewOwner);
  CheckMenuItem(v5, v8, 0);
LABEL_34:
  v3 = v3;
  switch ( v3 )
  {
    case 0x9C52u:
      gdwRefreshRateOfSearch = 0;
      SendMessageW(ghWndStatusBar, 0x40Bu, gdwStatusBarCount - 1, L"Paused");
      break;
    case 0x9C53u:
      gdwRefreshRateOfSearch = 2000;
      break;
    case 0x9C54u:
      gdwRefreshRateOfSearch = 5000;
      break;
    case 0x9C55u:
      gdwRefreshRateOfSearch = 1000;
      break;
    case 0x9C56u:
      gdwRefreshRateOfSearch = 10000;
      break;
    case 0x9C57u:
      gdwRefreshRateOfSearch = 500;
      break;
    default:
      break;
  }
  v6 = GetMenu(ghWndNewOwner);
  CheckMenuItem(v6, v3, 8u);
  if ( a2 != -25518 )
  {
    SendMessageW(ghWndStatusBar, 0x40Bu, gdwStatusBarCount - 1, gpszTargetName);
    SetEvent(ghEventRefreshSearchResult);
    gdwRefreshMenuId = v3;
  }
  return 0;
}
// 12C0D80: using guessed type wchar_t aPaused[7];
// 12DE10C: using guessed type int gdwRefreshMenuId;
// 1305720: using guessed type int gdwStatusBarCount;

//----- (01251850) --------------------------------------------------------
int OnShowProcessTree()
{
  DWORD dwID; // [esp+0h] [ebp-2Ch]
  __int128 v2; // [esp+4h] [ebp-28h]
  __int128 v3; // [esp+14h] [ebp-18h]
  __int64 v4; // [esp+24h] [ebp-8h]

  dwID = ghWndTreeListView;
  _mm_storeu_si128(&v2, 0i64);
  gbShowProcessTree = 0;
  gbProcessSortDirection = 0;
  _mm_storeu_si128(&v3, 0i64);
  v4 = 0i64;
  HIDWORD(v2) = 0;
  OnTreeListColumnClick(0x65, &dwID, dwID, 101);
  return 0;
}
// 12E5742: using guessed type char gbShowProcessTree;
// 12E598C: using guessed type char gbProcessSortDirection;

//----- (012518A0) --------------------------------------------------------
int __usercall OnProcessSetPriority@<eax>(int a1@<edi>, int a2, __int16 a3)
{
  HWND v3; // esi
  LRESULT v4; // eax
  signed int v5; // ebx
  UINT v6; // esi
  signed int v7; // edi
  HANDLE v8; // eax
  DWORD v9; // ST0C_4
  void *v10; // edi
  HMENU v11; // eax
  int v13; // [esp-4h] [ebp-4Ch]
  int v14; // [esp+0h] [ebp-48h]
  LPARAM lParam; // [esp+8h] [ebp-40h]
  WPARAM wParam; // [esp+Ch] [ebp-3Ch]
  int v17; // [esp+10h] [ebp-38h]
  int v18; // [esp+28h] [ebp-20h]
  UINT v19; // [esp+3Ch] [ebp-Ch]
  int v20; // [esp+40h] [ebp-8h]
  int v21; // [esp+44h] [ebp-4h]

  lParam = 0;
  memset(&wParam, 0, 0x30u);
  v3 = ghWndTreeListView;
  v4 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v4 == -1 )
  {
    if ( v3 == ghWndTreeListView )
      MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  wParam = v4;
  v17 = 0;
  lParam = 4;
  if ( !SendMessageW(v3, 0x104Bu, 0, &lParam) || v3 != ghWndTreeListView )
    return 0;
  v13 = a1;
  switch ( a3 )
  {
    case 0x9CBB:
      v5 = 4;
      v6 = 40123;
      v7 = 64;
      break;
    case 0x9CBC:
      v5 = 4;
      v6 = 40124;
      v7 = 64;
      break;
    case 0x9CBD:
      v5 = 6;
      v6 = 40125;
      v7 = 0x4000;
      break;
    case 0x9CBE:
      v5 = 8;
      v6 = 40126;
      v7 = 32;
      break;
    case 0x9CBF:
      v5 = 10;
      v6 = 40127;
      v7 = 0x8000;
      break;
    case 0x9CC0:
      v5 = 13;
      v6 = 40128;
      v7 = 128;
      break;
    case 0x9CC1:
      v5 = 24;
      v6 = 40129;
      v7 = 256;
      break;
    default:
      v5 = v19;
      v6 = v19;
      v7 = v19;
      break;
  }
  v8 = OpenProcess(0x200u, 0, *(v18 + 68));
  if ( v8 )
  {
    v9 = v7;
    v10 = v8;
    if ( SetPriorityClass(v8, v9) )
    {
      if ( v6 == 40124 )
      {
        v21 = 0;
        NtSetInformationProcess(v10, 33, &v21, 4, v13);
        v20 = 1;
      }
      else
      {
        v21 = 2;
        NtSetInformationProcess(v10, 33, &v21, 4, v13);
        v20 = 5;
      }
      NtSetInformationProcess(v10, 39, &v20, 4, v14);
      *(v18 + 1368) = v5;
      v11 = GetMenu(ghWndNewOwner);
      CheckMenuRadioItem(v11, 0x9CBBu, 0x9CC1u, v6, 0);
      SendMessageW(ghWndTreeListView, 0x1015u, wParam, wParam);
      goto LABEL_21;
    }
  }
  else
  {
    v10 = 0;
  }
  MessageBoxW(ghWndTreeListView, L"Unable to set process priority", L"Process Explorer Error", 0x10u);
LABEL_21:
  if ( v10 )
    CloseHandle(v10);
  return 0;
}
// 12518A0: could not find valid save-restore pair for edi
// 12EB1C8: using guessed type int (__stdcall *NtSetInformationProcess)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (01251AD0) --------------------------------------------------------
int OnOnlyOneInstanceCheck()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gbAllOneInstance != 0;
  gbAllOneInstance = gbAllOneInstance == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghWndNewOwner);
  CheckMenuItem(v3, 0x9C83u, v2);
  CMainWnd::Reset(ghWndNewOwner, 1);
  return 0;
}
// 12E96D3: using guessed type char gbAllOneInstance;

//----- (01251B20) --------------------------------------------------------
int __cdecl OnRunFileDlg(HWND hWndParent, int a2)
{
  HMODULE v2; // eax
  FARPROC v3; // eax

  v2 = LoadLibraryW(L"shell32.dll");
  v3 = GetProcAddress(v2, 0x3D);
  RunFileDlg = v3;
  if ( v3 )
    (v3)(hWndParent, 0, 0, 0, 0, 0);
  else
    DialogBoxParamW(ghInstance, L"RUNDLG", hWndParent, RunDlgProc, a2);
  return 0;
}
// 12EA8D8: using guessed type int RunFileDlg;

//----- (01251B80) --------------------------------------------------------
int __cdecl OnRunDlg(HWND hWndParent, int a2)
{
  DialogBoxParamW(ghInstance, L"RUNDLG", hWndParent, RunDlgProc, a2);
  return 0;
}

//----- (01251BB0) --------------------------------------------------------
int __cdecl OnHideWhenMinimized(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST0C_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gbHideWhenMinimized != 0;
  gbHideWhenMinimized = gbHideWhenMinimized == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, IDS_PROCEXPLORERMENU_HIDE_WHEN_MINIMIZED, v3);
  if ( gbHideWhenMinimized && !gbTrayCPUHistory && !gbShowCommitTray && !gbShowPhysTray && !gbShowIoTray )
    OnCpuHistory(hWnd);
  CMainWnd::Reset(ghWndNewOwner, 1);
  return 0;
}
// 12E96C2: using guessed type char gbTrayCPUHistory;
// 12E96C3: using guessed type char gbShowCommitTray;
// 12E96C4: using guessed type char gbShowPhysTray;
// 12E96C5: using guessed type char gbShowIoTray;
// 12E96D1: using guessed type char gbHideWhenMinimized;

//----- (01251C40) --------------------------------------------------------
int __cdecl OnPacityShowMRU(HWND hWnd, int a2)
{
  UINT v2; // ST08_4
  HMENU v3; // eax
  LONG v4; // eax
  UINT v5; // ST08_4
  HMENU v6; // eax

  v2 = (((1717986919i64 * *gdwOpacity) >> 32) >> 2) + (((1717986919i64 * *gdwOpacity) >> 32) >> 31) + 40093;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, v2, 0);
  *gdwOpacity = 10 * (a2 - 40093);
  v4 = GetWindowLongW(ghWndNewOwner, -20);
  if ( *gdwOpacity == 100 )
  {
    SetWindowLongW(ghWndNewOwner, -20, v4 & 0xFFF7FFFF);
  }
  else
  {
    SetWindowLongW(ghWndNewOwner, -20, v4 | 0x80000);
    SetLayeredWindowAttributes(ghWndNewOwner, 0, 255 * *gdwOpacity / 100, 2);
  }
  RedrawWindow(ghWndNewOwner, 0, 0, 0x485u);
  v5 = (((1717986919i64 * *gdwOpacity) >> 32) >> 2) + (((1717986919i64 * *gdwOpacity) >> 32) >> 31) + 40093;
  v6 = GetMenu(hWnd);
  CheckMenuItem(v6, v5, 8u);
  return 0;
}
// 12EA8EC: using guessed type int (__stdcall *SetLayeredWindowAttributes)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (01251D40) --------------------------------------------------------
int __cdecl OnShutdown(int a1, __int16 a2)
{
  char v2; // al
  char v4; // [esp+7h] [ebp-405h]
  WCHAR Text; // [esp+8h] [ebp-404h]
  wchar_t Dst; // [esp+208h] [ebp-204h]

  switch ( a2 )
  {
    case 0x9C84:
      tcscpy_s(&Dst, 0x100u, L"logoff");
      break;
    case 0x9C85:
      tcscpy_s(&Dst, 0x100u, L"shutdown");
      break;
    case 0x9C86:
      tcscpy_s(&Dst, 0x100u, L"restart");
      break;
    case 0x9C87:
      tcscpy_s(&Dst, 0x100u, L"hibernate");
      break;
    case 0x9C88:
      tcscpy_s(&Dst, 0x100u, L"stand by");
      break;
    case 0x9C92:
      tcscpy_s(&Dst, 0x100u, L"lock the computer");
      break;
    default:
      break;
  }
  VLogEntry(&Text, L"Do you really want to %s?", &Dst);
  if ( MessageBoxW(ghWndTreeListView, &Text, L"Process Explorer Shutdown", 0x24u) != 7 )
  {
    CMainWnd::Reset(ghWndNewOwner, 1);
    TmAdjustPrivilege(L"SeShutdownPrivilege");
    switch ( a2 )
    {
      case 0:
        v2 = ExitWindowsEx(0, 0);
        break;
      case 1:
        if ( ExitWindowsEx(8u, 0) )
          return 0;
        v2 = ExitWindowsEx(1u, 0);
        break;
      case 2:
        v2 = ExitWindowsEx(2u, 0);
        break;
      case 3:
        v2 = SetSuspendState(1u, 1u, 0);
        break;
      case 4:
        v2 = SetSuspendState(0, 1u, 0);
        break;
      case 0xE:
        v2 = LockWorkStation();
        break;
      default:
        v2 = v4;
        break;
    }
    if ( !v2 )
    {
      VLogEntry(&Text, L"Error trying to %s", &Dst);
      ErrMsgBox(&Text, ghWndNewOwner);
    }
  }
  return 0;
}
// 12C1C74: using guessed type wchar_t aShutdown[9];
// 12C1C88: using guessed type wchar_t aRestart[8];
// 12C1C98: using guessed type wchar_t aLogoff[7];
// 12C1CA8: using guessed type wchar_t aHibernate[10];
// 12C1CBC: using guessed type wchar_t aStandBy[9];

//----- (01251F10) --------------------------------------------------------
int __cdecl sub_1251F10(HWND hWnd)
{
  HKEY v1; // ecx
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( gdwOsType < 1 || IsBuiltinAndAnministrative() )
  {
    if ( TaskMgrIsDebugger() )
      sub_1245E40(v1);
    else
      ReplaceTaskMgr(hWnd, 1);
  }
  else
  {
    ExecuteProcess(L"/rt", 5, 1);
  }
  v2 = TaskMgrIsDebugger() != 0 ? 8 : 0;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, 40059u, v2);
  return 0;
}
// 12E4E54: using guessed type int gdwOsType;

//----- (01251F80) --------------------------------------------------------
int __cdecl sub_1251F80(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"SYMBOLCONFIG", hWndParent, SymbolConfigDlgProc, 0);
  return 0;
}

//----- (01251FB0) --------------------------------------------------------
int OnShowSystemInformation()
{
  HCURSOR v1; // eax
  HCURSOR v2; // esi

  if ( ghSysinfoPropSheetDlg )
  {
    ShowWindow(ghSysinfoPropSheetDlg, SW_RESTORE);
    SetFocus(ghSysinfoPropSheetDlg);
    SetForegroundWindow(ghSysinfoPropSheetDlg);
  }
  else
  {
    v1 = LoadCursorW(0, IDC_WAIT);
    v2 = SetCursor(v1);
    _beginthread(StartSystemInfoSheetThreadProc, 0, 0);
    WaitForSingleObject(ghSystemInfoSheetThreadEvent, INFINITE);
    SetCursor(v2);
  }
  return 0;
}

//----- (01252020) --------------------------------------------------------
int __cdecl sub_1252020(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST08_4
  HMENU v4; // eax

  v1 = 0;
  v2 = gbShowCpuFractions != 0;
  gbShowCpuFractions = gbShowCpuFractions == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C6Du, v3);
  InvalidateRgn(ghWndTreeListView, 0, 1);
  return 0;
}
// 12E96C9: using guessed type char gbShowCpuFractions;

//----- (01252070) --------------------------------------------------------
int __cdecl OnChooseColor(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"CHOOSECOLORS", hWndParent, ChooseColorDlgProc, 0);
  return 0;
}

//----- (012520A0) --------------------------------------------------------
int OnTrimtProcessWorkingsetSize()
{
  HWND hWnd; // esi
  int nSelectedItem; // eax
  HANDLE hProcess; // eax
  void *v3; // esi
  LVITEMW item; // [esp+4h] [ebp-34h]

  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  hWnd = ghWndTreeListView;
  nSelectedItem = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
  if ( nSelectedItem == -1 )
  {
    if ( hWnd == ghWndTreeListView )
      MessageBoxW(ghWndTreeListView, L"No process selected", L"Process Explorer Error", 0x10u);
  }
  else
  {
    item.iItem = nSelectedItem;
    item.iSubItem = 0;
    item.mask = LVIF_PARAM;
    if ( SendMessageW(hWnd, LVM_GETITEMW, 0, &item) )
    {
      hProcess = OpenProcess(PROCESS_SET_QUOTA, 0, *&item.lParam->szText[0xE]);
      v3 = hProcess;
      if ( hProcess && SetProcessWorkingSetSize(hProcess, 0xFFFFFFFF, 0xFFFFFFFF) )
        SetEvent(ghEventRefreshSearchResult);
      else
        ErrMsgBox(L"Unable to trim process working set", ghWndNewOwner);
      if ( v3 )
      {
        CloseHandle(v3);
        return 0;
      }
    }
  }
  return 0;
}

//----- (01252190) --------------------------------------------------------
int __cdecl OnProcessWindowShow(int a1, int uMenuId)
{
  HWND v2; // esi
  int v3; // eax
  HANDLESANDDLLSLISTUSERPARAM *v4; // esi
  LVITEMW lParam; // [esp+4h] [ebp-34h]

  lParam.mask = 0;
  memset(&lParam.iItem, 0, 0x30u);
  v2 = ghWndTreeListView;
  v3 = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  if ( v3 != -1 )
  {
    lParam.iItem = v3;
    lParam.iSubItem = 0;
    lParam.mask = LVIF_PARAM;
    if ( SendMessageW(v2, LVM_GETITEMW, 0, &lParam) )
    {
      v4 = lParam.lParam;
      ShowMainWindow(NULL, uMenuId, *&lParam.lParam->szText[0xE]);
      CheckProcessWindowMenuItems(v4);
    }
  }
  return 0;
}

//----- (01252210) --------------------------------------------------------
int OnShowHeatmaps()
{
  signed int v0; // eax
  bool v1; // zf
  UINT v2; // ST08_4
  HMENU v3; // eax

  v0 = 0;
  v1 = gbShowColumnHeatmaps != 0;
  gbShowColumnHeatmaps = gbShowColumnHeatmaps == 0;
  if ( !v1 )
    v0 = 8;
  v2 = v0;
  v3 = GetMenu(ghWndNewOwner);
  CheckMenuItem(v3, 0x9C99u, v2);
  SetEvent(ghRefreshEvent);
  return 0;
}
// 12E96CF: using guessed type char gbShowColumnHeatmaps;

//----- (01252260) --------------------------------------------------------
int __cdecl OnVerifyImageSignature(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST24_4
  HMENU v4; // eax
  LRESULT v5; // edi
  int v6; // esi
  LPARAM lParam; // [esp+0h] [ebp-34h]
  LRESULT v9; // [esp+4h] [ebp-30h]
  int v10; // [esp+8h] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-14h]

  lParam = 0;
  memset(&v9, 0, 0x30u);
  v1 = 0;
  v2 = gbVerifySignatures != 0;
  gbVerifySignatures = gbVerifySignatures == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9CB2u, v3);
  if ( !gbVerifySignatures )
    return 0;
  AutoLoadStringArrFromId(ghWndTreeListView, 0x4A3u, gdwIDMapProcesListForSelectColumn, &gdwProcessListColumnCount);
  AutoLoadStringArrFromId(ghWndDllsListCtrl, 0x4A3u, gdwIdMapForDllsListColumn, &gdwDllsListColumnCount);
  v5 = SendMessageW(ghWndTreeListView, 0x1004u, 0, 0);
  v9 = 0;
  if ( v5 <= 0 )
    return 0;
  do
  {
    v10 = 0;
    lParam = 4;
    if ( SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam) )
    {
      v6 = v11;
      InterlockedIncrement((v11 + 36));
      _beginthread(VerifySignatureThreadProc, 0, v6);
    }
    ++v9;
  }
  while ( v9 < v5 );
  return 0;
}
// 12E96D7: using guessed type char gbVerifySignatures;

//----- (01252390) --------------------------------------------------------
int __cdecl sub_1252390(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST0C_4
  HMENU v3; // eax
  BOOL v4; // ST0C_4
  HMENU v5; // eax
  #1077 *v6; // esi
  #1077 *v7; // edi
  int v8; // eax
  LVITEMUSERDATA *i; // esi
  int v10; // eax

  if ( !sub_12817E0() )
    return 0;
  v1 = 0;
  gbVirusTotalCheck = gbVirusTotalCheck == 0;
  if ( gbVirusTotalCheck )
    v1 = 8;
  v2 = v1;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, 0x9CB3u, v2);
  v4 = gbVirusTotalCheck == 0;
  v5 = GetMenu(hWnd);
  EnableMenuItem(v5, 0x9F36u, v4);
  if ( gbVirusTotalCheck )
  {
    v6 = gpTreeListParamList;
    v7 = 0;
    AutoLoadStringArrFromId(ghWndTreeListView, 0x686u, gdwIDMapProcesListForSelectColumn, &gdwProcessListColumnCount);
    for ( ; v6; v6 = *(v6 + 364) )
    {
      v8 = *(v6 + 211);
      if ( *(v6 + 17) == g_dwProcessId )
        v7 = v6;
      if ( v8 && *(v8 + 4) == 1 )
        *(v8 + 4) = 6;
      if ( *(v6 + 198) )
        sub_1281C30(v6, 1, 0);
    }
    InvalidateRect(ghWndTreeListView, 0, 0);
    AutoLoadStringArrFromId(ghWndDllsListCtrl, 0x686u, gdwIdMapForDllsListColumn, &gdwDllsListColumnCount);
    if ( v7 && IsWindowVisible(ghWndDllsListCtrl) )
    {
      for ( i = gpUserDataInVerifySignature; i; i = i->Prev )
      {
        v10 = i->field_16C;
        if ( v10 && *(v10 + 4) == 1 )
          *(v10 + 4) = 6;
        if ( i->szPathName )
          sub_1281C30(i, ~(i->field_2C >> 1) & 1, 0);
      }
      InvalidateRect(ghWndDllsListCtrl, 0, 0);
    }
  }
  return 0;
}
// 12E96E0: using guessed type char gbVirusTotalCheck;

//----- (01252520) --------------------------------------------------------
int __cdecl sub_1252520(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST10_4
  HMENU v4; // eax
  #1077 *v5; // esi
  #1077 *i; // edi
  int v7; // eax
  LVITEMUSERDATA *j; // esi
  int v9; // eax
  unsigned int v10; // eax

  if ( !sub_12817E0() )
    return 0;
  v1 = 0;
  v2 = gbVirusTotalSubmitUnknown != 0;
  gbVirusTotalSubmitUnknown = gbVirusTotalSubmitUnknown == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9F36u, v3);
  if ( !gbVirusTotalSubmitUnknown )
    return 0;
  v5 = gpTreeListParamList;
  for ( i = 0; v5; v5 = *(v5 + 364) )
  {
    v7 = *(v5 + 211);
    if ( *(v5 + 17) == g_dwProcessId )
      i = v5;
    if ( v7 && *(v7 + 4) == 6 && *v7 )
      sub_1281C30(v5, 1, 1);
  }
  InvalidateRect(ghWndTreeListView, 0, 0);
  if ( i && IsWindowVisible(ghWndDllsListCtrl) )
  {
    for ( j = gpUserDataInVerifySignature; j; j = j->Prev )
    {
      v9 = j->field_16C;
      if ( v9 && *(v9 + 4) == 6 )
      {
        v10 = j->field_2C >> 1;
        if ( !(v10 & 1) )
          sub_1281C30(j, ~v10 & 1, 1);
      }
    }
    InvalidateRect(ghWndDllsListCtrl, 0, 0);
  }
  return 0;
}
// 12E96E1: using guessed type char gbVirusTotalSubmitUnknown;

//----- (01252640) --------------------------------------------------------
int OnCheckVirusTotalCom2()
{
  HWND v0; // esi
  char v1; // bl
  LRESULT v2; // eax
  int v3; // esi
  int v4; // eax
  LPARAM lParam; // [esp+8h] [ebp-34h]
  LRESULT v7; // [esp+Ch] [ebp-30h]
  int v8; // [esp+10h] [ebp-2Ch]
  int v9; // [esp+28h] [ebp-14h]

  lParam = 0;
  memset(&v7, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = 0;
  v2 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
  {
    v7 = v2;
    v8 = 0;
    lParam = 4;
    if ( SendMessageW(v0, 0x104Bu, 0, &lParam) )
    {
      v3 = v9;
      SetFocus(ghWndTreeListView);
      if ( v3 )
      {
        if ( sub_12817E0() )
        {
          AutoLoadStringArrFromId(
            ghWndTreeListView,
            0x686u,
            gdwIDMapProcesListForSelectColumn,
            &gdwProcessListColumnCount);
          v4 = *(v3 + 844);
          if ( v4 )
          {
            if ( *(v4 + 4) == 6 )
            {
              v1 = 1;
            }
            else if ( v4 && *(v4 + 4) == 1 )
            {
              *(v4 + 4) = 6;
            }
          }
          sub_1281C30(v3, 1, v1 != 0);
          InvalidateRect(ghWndTreeListView, 0, 0);
        }
      }
    }
  }
  return 0;
}

//----- (01252740) --------------------------------------------------------
int OnCheckVirusTotalCom()
{
  HWND v0; // esi
  char v1; // bl
  LRESULT v2; // eax
  int v3; // esi
  int v4; // eax
  LPARAM lParam; // [esp+8h] [ebp-34h]
  LRESULT v7; // [esp+Ch] [ebp-30h]
  int v8; // [esp+10h] [ebp-2Ch]
  int v9; // [esp+28h] [ebp-14h]

  lParam = 0;
  memset(&v7, 0, 0x30u);
  v0 = ghWndDllsListCtrl;
  v1 = 0;
  v2 = SendMessageW(ghWndDllsListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
  {
    v7 = v2;
    v8 = 0;
    lParam = 4;
    if ( SendMessageW(v0, 0x104Bu, 0, &lParam) )
    {
      v3 = v9;
      SetFocus(ghWndTreeListView);
      if ( v3 )
      {
        if ( sub_12817E0() )
        {
          AutoLoadStringArrFromId(ghWndDllsListCtrl, 0x686u, gdwIdMapForDllsListColumn, &gdwDllsListColumnCount);
          v4 = *(v3 + 364);
          if ( v4 )
          {
            if ( *(v4 + 4) == 6 )
            {
              v1 = 1;
            }
            else if ( v4 && *(v4 + 4) == 1 )
            {
              *(v4 + 4) = 6;
            }
          }
          sub_1281C30(v3, 1, v1 != 0);
          InvalidateRect(ghWndDllsListCtrl, 0, 0);
        }
      }
    }
  }
  return 0;
}

//----- (01252840) --------------------------------------------------------
int OnShowDetailsForalAllProcesses()
{
  DWORD v0; // eax

  CMainWnd::Reset(ghWndNewOwner, 1);
  CreateEventW(0, 0, 1, L"ProcessExplorerElevating");
  v0 = ExecuteProcess(gpszCommandLine, 5, 0);
  if ( v0 )
  {
    if ( v0 != ERROR_CANCELLED )
    {
      ErrMsgBox(L"Error elevating", ghWndNewOwner);
      return 0;
    }
  }
  else
  {
    DestroyWindow(ghWndNewOwner);
  }
  return 0;
}

//----- (012528B0) --------------------------------------------------------
int __cdecl OnAlwaysOnTop(HWND hWnd)
{
  MACRO_MF v1; // eax
  UINT v2; // ST18_4
  HMENU v3; // eax

  v1 = 0;
  gbAlwaysOntop = gbAlwaysOntop == 0;
  if ( gbAlwaysOntop )
    v1 = MF_CHECKED;
  v2 = v1;
  v3 = GetMenu(hWnd);
  CheckMenuItem(v3, IDS_PROCEXPLORERMENU_ALWAYS_ON_TOP, v2);
  if ( gbAlwaysOntop )
  {
    SetWindowPos(hWnd, HWND_MESSAGE|0x2, 0, 0, 0, 0, 3u);
    if ( ghSysinfoPropSheetDlg )
    {
      SetWindowPos(ghSysinfoPropSheetDlg, HWND_MESSAGE|0x2, 0, 0, 0, 0, 3u);
      return 0;
    }
  }
  else
  {
    if ( ghSysinfoPropSheetDlg )
      SetWindowPos(ghSysinfoPropSheetDlg, HWND_NOTOPMOST, 0, 0, 0, 0, 3u);
    SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 3u);
  }
  return 0;
}
// 12E96D2: using guessed type char gbAlwaysOntop;

//----- (01252960) --------------------------------------------------------
int __cdecl OnCpuHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_12579E0(gbTrayCPUHistory == 0) )
  {
    v1 = 0;
    gbTrayCPUHistory = gbTrayCPUHistory == 0;
    if ( gbTrayCPUHistory )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, IDS_PROCEXPLORERMENU_CPU_HISTORY, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C2: using guessed type char gbTrayCPUHistory;

//----- (012529C0) --------------------------------------------------------
int __cdecl OnIoHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU hMenu; // eax

  if ( !sub_12579E0(gbShowIoTray == 0) )
  {
    v1 = 0;
    gbShowIoTray = gbShowIoTray == 0;
    if ( gbShowIoTray )
      v1 = 8;
    v2 = v1;
    hMenu = GetMenu(hWnd);
    CheckMenuItem(hMenu, IDS_PROCEXPLORERMENU_IO_HISTORY, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C5: using guessed type char gbShowIoTray;

//----- (01252A20) --------------------------------------------------------
int __cdecl sub_1252A20(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_12579E0(gbShowNetTray == 0) )
  {
    v1 = 0;
    gbShowNetTray = gbShowNetTray == 0;
    if ( gbShowNetTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F2Bu, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C6: using guessed type char gbShowNetTray;

//----- (01252A80) --------------------------------------------------------
int __cdecl sub_1252A80(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_12579E0(gbShowDiskTray == 0) )
  {
    v1 = 0;
    gbShowDiskTray = gbShowDiskTray == 0;
    if ( gbShowDiskTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F2Au, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C7: using guessed type char gbShowDiskTray;

//----- (01252AE0) --------------------------------------------------------
int __cdecl sub_1252AE0(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_12579E0(gbShowGpuTray == 0) )
  {
    v1 = 0;
    gbShowGpuTray = gbShowGpuTray == 0;
    if ( gbShowGpuTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F2Cu, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C8: using guessed type char gbShowGpuTray;

//----- (01252B40) --------------------------------------------------------
#error "1252B43: call analysis failed (funcsize=23)"

//----- (01252B90) --------------------------------------------------------
int __cdecl OnCommitHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_12579E0(gbShowCommitTray == 0) )
  {
    v1 = 0;
    gbShowCommitTray = gbShowCommitTray == 0;
    if ( gbShowCommitTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F16u, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C3: using guessed type char gbShowCommitTray;

//----- (01252BF0) --------------------------------------------------------
int __cdecl OnPhysicalMemoryHistory(HWND hWnd)
{
  signed int v1; // eax
  UINT v2; // ST08_4
  HMENU v3; // eax

  if ( !sub_12579E0(gbShowPhysTray == 0) )
  {
    v1 = 0;
    gbShowPhysTray = gbShowPhysTray == 0;
    if ( gbShowPhysTray )
      v1 = 8;
    v2 = v1;
    v3 = GetMenu(hWnd);
    CheckMenuItem(v3, 0x9F17u, v2);
    HandleShellIconMsg();
  }
  return 0;
}
// 12E96C4: using guessed type char gbShowPhysTray;

//----- (01252C50) --------------------------------------------------------
signed int __usercall OnSelectColumnMRU@<eax>(double st7_0@<st0>, LPARAM ebx0@<ebx>, DWORD a3@<edi>, double a4@<st1>, double a5@<st3>, double a6@<st2>, double a7@<st4>, int a1, unsigned __int16 a2)
{
  int v9; // esi
  BOOL v11; // ST2C_4
  HMENU v12; // eax
  LRESULT v13; // eax
  char v14; // [esp+0h] [ebp-A0h]
  char v15; // [esp+8h] [ebp-98h]
  DWORD dwID; // [esp+10h] [ebp-90h]
  __int128 v17; // [esp+14h] [ebp-8Ch]
  __int128 v18; // [esp+24h] [ebp-7Ch]
  __int64 v19; // [esp+34h] [ebp-6Ch]
  char v20; // [esp+3Ch] [ebp-64h]
  struct tagRECT Rect; // [esp+8Ch] [ebp-14h]

  v9 = a2 - 40665;
  dwID = 0;
  _mm_storeu_si128(&v17, 0i64);
  _mm_storeu_si128(&v18, 0i64);
  v19 = 0i64;
  if ( v9 >= gdwNumColumnsets )
    return 1;
  SendMessageW(ghWndTreeListView, WM_SETREDRAW, 0, 0);
  SendMessageW(ghWndHandlesListCtrl, WM_SETREDRAW, 0, 0);
  SendMessageW(ghWndDllsListCtrl, WM_SETREDRAW, 0, 0);
  qmemcpy(gszColumnsetName, gstrMenuCulumnSet[v9], 1524u);
  sub_1257930(gszColumnsetName);
  InitListCtrl(
    ghWndTreeListView,
    gdwIDMapProcesListForSelectColumn,
    gwProcessListColumnWidths,
    gdwProcessListColumnCount);
  InitListCtrl(ghWndHandlesListCtrl, gdwHandlesListColumnMap, gdwHandlesListColumnWidths, gdwHandlesListColumnCount);
  InitListCtrl(ghWndDllsListCtrl, gdwIdMapForDllsListColumn, DllColumns, gdwDllsListColumnCount);
  GetClientRect(ghWndNewOwner, &Rect);
  HandleSize(ghWndNewOwner, 0, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
  InitTreeListSortableHeader(ghWndHandlesListCtrl, -1, gdwHandlesListSortColumnCount, HandleSortDirection);
  InitTreeListSortableHeader(ghWndDllsListCtrl, -1, gdwDllsListlSortColumnCount, DllSortDirection);
  LODWORD(v17) = 101;
  dwID = ghWndTreeListView;
  if ( gbShowProcessTree )
  {
    gbShowProcessTree = 0;
    gbProcessSortDirection = 0;
    HIDWORD(v17) = 0;
  }
  else
  {
    gbProcessSortDirection = gbProcessSortDirection == 0;
    HIDWORD(v17) = gdwProcessListSortColumnCount;
  }
  OnTreeListColumnClick(0x65, &dwID, a3, ebx0);
  SendMessageW(ghWndToolbar, TB_ENABLEBUTTON, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, gbShowProcessTree == 0);
  v11 = gbShowProcessTree != 0;
  v12 = GetMenu(ghWndNewOwner);
  EnableMenuItem(v12, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, v11);
  memset(&v20, 0, 0x50u);
  UpdateStatusBar(st7_0, a4, a6, a5, a7, 0, &v20, &v14, &v15);
  InitStatusBar(ghWndStatusBar);
  sub_123FAA0(0x66);
  sub_123FAA0(0x68);
  SendMessageW(ghWndTreeListView, WM_SETREDRAW, 1u, 0);
  SendMessageW(ghWndHandlesListCtrl, WM_SETREDRAW, 1u, 0);
  SendMessageW(ghWndDllsListCtrl, WM_SETREDRAW, 1u, 0);
  v13 = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
  SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, v13, 0);
  return 0;
}
// 1252C50: could not find valid save-restore pair for ebx
// 1252C50: could not find valid save-restore pair for edi
// 12E5538: using guessed type __int16 gszColumnsetName[260];
// 12E5742: using guessed type char gbShowProcessTree;
// 12E598C: using guessed type char gbProcessSortDirection;
// 12E5A5C: using guessed type char DllSortDirection;
// 12E5B28: using guessed type char HandleSortDirection;
// 12E5B2C: using guessed type int gdwNumColumnsets;

//----- (01252F00) --------------------------------------------------------
int sub_1252F00()
{
  gbUseGoogle = 1;
  return 0;
}
// 12E96DA: using guessed type char gbUseGoogle;

//----- (01252F10) --------------------------------------------------------
int sub_1252F10()
{
  gbUseGoogle = 0;
  return 0;
}
// 12E96DA: using guessed type char gbUseGoogle;

//----- (01252F20) --------------------------------------------------------
int __cdecl sub_1252F20(int a1, __int16 a2)
{
  HWND v2; // edi
  const WCHAR *v3; // esi
  LRESULT v4; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+8h] [ebp-8E8h]
  SHELLEXECUTEINFOW pExecInfo; // [esp+4Ch] [ebp-8A4h]
  LPARAM lParam; // [esp+88h] [ebp-868h]
  LRESULT v9; // [esp+8Ch] [ebp-864h]
  int v10; // [esp+90h] [ebp-860h]
  int v11; // [esp+A8h] [ebp-848h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+BCh] [ebp-834h]
  WCHAR CommandLine; // [esp+CCh] [ebp-824h]

  lParam = 0;
  memset(&v9, 0, 0x30u);
  v2 = ghWndTreeListView;
  v3 = 0;
  if ( a2 == -25504 )
    v2 = ghWndDllsListCtrl;
  if ( v2 == ghWndHandlesListCtrl )
    v2 = ghWndTreeListView;
  v4 = SendMessageW(v2, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v4 != -1 )
  {
    v9 = v4;
    v10 = 0;
    lParam = 4;
    if ( SendMessageW(v2, 0x104Bu, 0, &lParam) )
    {
      if ( v2 == ghWndDllsListCtrl )
      {
        if ( *(v11 + 44) & 8 )
        {
          MessageBoxW(
            ghWndTreeListView,
            L"Depends not supported on pagefile-backed sections",
            L"Process Explorer Error",
            0x10u);
          return 0;
        }
        v3 = *(v11 + 344);
        SetFocus(ghWndDllsListCtrl);
      }
      else
      {
        v3 = *(v11 + 792);
        if ( !v3 )
        {
          MessageBoxW(ghWndTreeListView, L"No process image file.", L"Process Explorer Error", 0x10u);
          return 0;
        }
        SetFocus(ghWndTreeListView);
      }
    }
  }
  if ( !*v3 )
  {
    MessageBoxW(ghWndTreeListView, L"No process or DLL is selected", L"Process Explorer Error", 0x10u);
    return 0;
  }
  if ( gszDependsFileName )
  {
    sub_12568E0(&CommandLine, L"depends \"%s\"", v3);
    memset(&StartupInfo, 0, 0x44u);
    StartupInfo.dwFlags = 1;
    StartupInfo.cb = 68;
    StartupInfo.wShowWindow = 5;
    _mm_storeu_si128(&ProcessInformation, 0i64);
    if ( CreateProcessW(&gszDependsFileName, &CommandLine, 0, 0, 0, 0x200u, 0, 0, &StartupInfo, &ProcessInformation) )
    {
      CloseHandle(ProcessInformation.hThread);
      CloseHandle(ProcessInformation.hProcess);
      return 0;
    }
  }
  else
  {
    memset(&pExecInfo, 0, 0x3Cu);
    pExecInfo.cbSize = 60;
    pExecInfo.lpFile = v3;
    pExecInfo.lpVerb = L"View Dependencies";
    pExecInfo.fMask = 0;
    pExecInfo.nShow = 5;
    ShellExecuteExW(&pExecInfo);
  }
  return 0;
}
// 12C1F14: using guessed type wchar_t aViewDependenci[18];

//----- (012531A0) --------------------------------------------------------
int sub_12531A0()
{
  HWND v0; // edi
  int v1; // esi
  LRESULT v2; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+8h] [ebp-49Ch]
  LPARAM lParam; // [esp+4Ch] [ebp-458h]
  LRESULT v6; // [esp+50h] [ebp-454h]
  int v7; // [esp+54h] [ebp-450h]
  int v8; // [esp+6Ch] [ebp-438h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+80h] [ebp-424h]
  WCHAR CommandLine; // [esp+90h] [ebp-414h]

  lParam = 0;
  memset(&v6, 0, 0x30u);
  v0 = ghWndTreeListView;
  v1 = 0;
  v2 = SendMessageW(ghWndTreeListView, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1
    && (v6 = v2, v7 = 0, lParam = 4, SendMessageW(v0, 0x104Bu, 0, &lParam))
    && (v1 = v8, SetFocus(ghWndTreeListView), v1) )
  {
    if ( MessageBoxW(
           ghWndTreeListView,
           L"WARNING: Debugging this process may result in loss of data.\nAre you sure you wish to attach the debugger?",
           L"Process Explorer Warning",
           0x31u) == 2 )
      return 0;
  }
  else
  {
    MessageBoxW(ghWndTreeListView, L"No process is selected", L"Process Explorer Error", 0x10u);
  }
  sub_1234BB0(&CommandLine, L"\"%s\" -p %d", gstrDefaultDebugger, *(v1 + 68));
  memset(&StartupInfo, 0, 0x44u);
  StartupInfo.dwFlags = 1;
  StartupInfo.cb = 68;
  StartupInfo.wShowWindow = 5;
  _mm_storeu_si128(&ProcessInformation, 0i64);
  if ( CreateProcessW(0, &CommandLine, 0, 0, 0, 0x200u, 0, 0, &StartupInfo, &ProcessInformation) )
  {
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);
  }
  return 0;
}

//----- (01253330) --------------------------------------------------------
int __cdecl sub_1253330(HWND hWnd)
{
  signed int v1; // eax
  bool v2; // zf
  UINT v3; // ST0C_4
  HMENU v4; // eax
  #1077 *i; // eax
  int v6; // ecx
  LRESULT v7; // ebx
  void *v8; // edi
  int v9; // esi
  LRESULT k; // edi
  int v11; // esi
  int v12; // eax
  LPARAM lParam; // [esp+Ch] [ebp-38h]
  int v15; // [esp+10h] [ebp-34h]
  int v16; // [esp+14h] [ebp-30h]
  int v17; // [esp+2Ch] [ebp-18h]
  void *j; // [esp+40h] [ebp-4h]

  SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
  v1 = 0;
  v2 = gbShowAllUsers != 0;
  gbShowAllUsers = gbShowAllUsers == 0;
  if ( !v2 )
    v1 = 8;
  v3 = v1;
  v4 = GetMenu(hWnd);
  CheckMenuItem(v4, 0x9C77u, v3);
  for ( i = gpTreeListParamList; i; i = *(i + 364) )
  {
    if ( gbShowAllUsers || (v6 = *(i + 10), v6 & 0x40) )
      *(i + 10) |= 2u;
    else
      *(i + 10) = v6 & 0xFFFFFFFD;
  }
  v7 = SendMessageW(ghWndTreeListView, 0x1004u, 0, 0);
  v8 = operator new[](4 * v7);
  v9 = 0;
  for ( j = v8; v9 < v7; ++v9 )
  {
    v15 = v9;
    v16 = 0;
    lParam = 4;
    SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam);
    *(v8 + v9) = v17;
  }
  SendMessageW(ghWndTreeListView, 0x1009u, 0, 0);
  for ( k = 0; k < v7; *(v11 + 1464) = v12 )
  {
    v11 = *(j + k);
    v12 = sub_1237F20(ghWndTreeListView, *(j + k++));
  }
  j_j__free(j);
  BYTE1(dword_12E53B4) = 1;
  SetEvent(ghRefreshEvent);
  return 0;
}
// 12E53B4: using guessed type int dword_12E53B4;
// 12E96D0: using guessed type char gbShowAllUsers;

//----- (01253490) --------------------------------------------------------
int __cdecl OnSaveColumnSet(HWND hWndParent)
{
  DialogBoxParamW(ghInstance, L"COLUMNSETSAVE", hWndParent, ColumnSetSaveDlgProc, 0);
  return 0;
}

//----- (012534C0) --------------------------------------------------------
int __cdecl OnOrganizeColumnset(HWND hWnd)
{
  if ( gdwNumColumnsets )
    DialogBoxParamW(ghInstance, L"COLUMNSETS", hWnd, ColumnSetDlgProc, 0);
  else
    MessageBoxW(
      hWnd,
      L"There are no column sets defined. Use View->Save Column Set to save a column set.",
      L"Process Explorer",
      0x30u);
  return 0;
}
// 12E5B2C: using guessed type int gdwNumColumnsets;

//----- (01253510) --------------------------------------------------------
LRESULT __cdecl HandleCommand(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam)
{
  return MSGHANDLER::HandleCommand(&gNormalWindowCmdHandler, hWnd, wParam, lParam);
}

//----- (01253530) --------------------------------------------------------
int __cdecl HandlePaint(HWND hWnd)
{
  HDC hdc; // eax
  PAINTSTRUCT ps; // [esp+4h] [ebp-44h]

  hdc = BeginPaint(hWnd, &ps);
  if ( gbShowLowerpane )
    DrawEdge(hdc, &gRectRedrawMainWnd, 5u, 0x80Au);
  EndPaint(hWnd, &ps);
  return 0;
}
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (01253590) --------------------------------------------------------
int __cdecl HandleSize(HWND hWndMain, int a2, int wParam, LPARAM size)
{
  int nStatusBarHeight; // edi
  HWND hWndRebar; // eax
  LONG nHeight; // ebx
  int bottom; // ST14_4
  int right; // ST10_4
  HWND hWndReBar; // eax
  RECT rcStatusBar; // [esp+Ch] [ebp-24h]
  RECT rcRebar; // [esp+1Ch] [ebp-14h]

  if ( wParam == SIZE_MINIMIZED )
  {
    if ( gbHideWhenMinimized )
    {
      MainWnd_Hide(ghWndNewOwner);
      return 0;
    }
  }
  else
  {
    GetWindowRect(ghWndStatusBar, &rcStatusBar);
    nStatusBarHeight = rcStatusBar.bottom - rcStatusBar.top;
    hWndRebar = GetParent(ghWndGraphCPUUsage);
    GetWindowRect(hWndRebar, &rcRebar);
    GetClientRect(hWndMain, &gRectMainWnd);
    nHeight = (size >> 16) - (rcRebar.bottom - rcRebar.top + gRectMainWnd.top);
    gRectMainWnd.top += rcRebar.bottom - rcRebar.top;
    gRectMainWnd.right = size;
    gRectMainWnd.bottom = nHeight;
    InvalidateRect(hWndMain, &gRectRedrawMainWnd, 0);
    gRectRedrawMainWnd.right = size;
    gRectRedrawMainWnd.top = ((gRectMainWnd.top + gRectMainWnd.bottom - nStatusBarHeight) * gdSavedDividerCopy);
    gRectRedrawMainWnd.bottom = gRectRedrawMainWnd.top + 7;
    MoveWindow(ghWndTreeListView, 0, gRectMainWnd.top, size, gRectRedrawMainWnd.top - gRectMainWnd.top, TRUE);
    MoveWindow(
      ghWndHandlesListCtrl,
      0,
      gRectRedrawMainWnd.bottom - 1,
      size,
      gRectMainWnd.bottom - gRectRedrawMainWnd.bottom - nStatusBarHeight + gRectMainWnd.top + 1,
      TRUE);
    MoveWindow(
      ghWndDllsListCtrl,
      0,
      gRectRedrawMainWnd.bottom - 1,
      size,
      gRectMainWnd.bottom - gRectRedrawMainWnd.bottom - nStatusBarHeight + gRectMainWnd.top + 1,
      TRUE);
    MoveWindow(ghWndStatusBar, 0, gRectMainWnd.top + gRectMainWnd.bottom - nStatusBarHeight, size, nStatusBarHeight, 1);
    bottom = gnToolbarHeight;
    right = gRectMainWnd.right;
    hWndReBar = GetDlgItem(hWndMain, IDW_REBAR);
    MoveWindow(hWndReBar, 0, 0, right, bottom, TRUE);
    InvalidateRgn(ghWndStatusBar, 0, 0);
    MoveWindow(ghWndRebar, 0, 0, gRectMainWnd.right - gRectMainWnd.left, 0, TRUE);
  }
  return 0;
}
// 12E96D1: using guessed type char gbHideWhenMinimized;

//----- (01253780) --------------------------------------------------------
int __cdecl HandleGetMinmaxInfo(int a1, int a2, int a3, MINMAXINFO *pInfo)
{
  pInfo->ptMinTrackSize.x = 200;
  pInfo->ptMinTrackSize.y = 200;
  return 0;
}

//----- (012537A0) --------------------------------------------------------
int __cdecl HandleLButtonDown(HWND hWnd, int a2, int a3, int a4)
{
  POINT v4; // ST04_8

  v4.y = a4 >> 16;
  v4.x = a4;
  if ( PtInRect(&gRectRedrawMainWnd, v4) )
  {
    SetCursor(ghCursorResizeVert);
    SetCapture(hWnd);
    DrawWindowEx(hWnd, (a4 >> 16) - 6);
    dword_12EA8FC = (a4 >> 16) - 6;
  }
  return 0;
}

//----- (012537F0) --------------------------------------------------------
int __cdecl HandleLButtonUp(HWND hWnd, int a2, int a3, int a4)
{
  signed int v4; // esi
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  v4 = a4 >> 16;
  if ( gbIsFinding )
  {
    FindProcessByWindow(hWnd);
    return 0;
  }
  if ( GetCapture() )
  {
    SetCursor(ghCursorResizeVert);
    ReleaseCapture();
    DrawWindowEx(hWnd, dword_12EA8FC);
    if ( v4 > gRectMainWnd.bottom - 30 )
      return OnShowLowerPane(hWnd);
    if ( v4 < gRectMainWnd.top + 40 )
      LOWORD(v4) = LOWORD(gRectMainWnd.top) + 40;
    gRectRedrawMainWnd.top = v4 - 3;
    gRectRedrawMainWnd.bottom = gRectRedrawMainWnd.top + 7;
    gdSavedDividerCopy = (v4 - 3) / (gRectMainWnd.top + gRectMainWnd.bottom);
    GetClientRect(ghWndNewOwner, &Rect);
    HandleSize(
      ghWndNewOwner,
      0,
      0,
      (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
    InvalidateRect(hWnd, &gRectRedrawMainWnd, 0);
  }
  return 0;
}
// 12EA38B: using guessed type char gbIsFinding;

//----- (01253940) --------------------------------------------------------
int __cdecl HandleMouseMove(HWND hWnd, UINT Flags, POINT pt)
{
  unsigned __int16 x; // si
  HWND hWndPoint; // edi
  HWND v5; // eax
  HCURSOR v6; // eax
  int result; // eax
  HCURSOR v8; // eax
  int v9; // esi
  POINT v10; // ST08_8
  struct tagPOINT Point; // [esp+8h] [ebp-8h]

  x = HIWORD(pt.y);
  if ( gbIsFinding )
  {
    Point.x = SLOWORD(pt.y);
    Point.y = SHIWORD(pt.y);
    ClientToScreen(hWnd, &Point);
    hWndPoint = WindowFromPoint(Point);
    if ( hWndPoint != ghWndPointLast )
    {
      if ( ghWndPointLast )
        DrawWindow(ghWndPointLast);
      v5 = hWndPoint;
      while ( v5 != ghWndNewOwner )
      {
        v5 = GetParent(v5);
        if ( !v5 )
        {
          if ( ghWndNewOwner )
          {
            ghWndPointLast = hWndPoint;
            DrawWindow(hWndPoint);
            v6 = LoadCursorW(ghInstance, 0xA);
            SetCursor(v6);
            return 0;
          }
          break;
        }
      }
      ghWndPointLast = 0;
    }
    v8 = LoadCursorW(ghInstance, 0xA);
    SetCursor(v8);
    result = 0;
  }
  else if ( GetCapture() )
  {
    if ( HIWORD(pt.y) > gRectMainWnd.bottom - 5 )
      x = LOWORD(gRectMainWnd.bottom) - 5;
    if ( x < gRectMainWnd.top + 40 )
      x = LOWORD(gRectMainWnd.top) + 40;
    DrawWindowEx(hWnd, dword_12EA8FC);
    v9 = (x - 3);
    DrawWindowEx(hWnd, v9);
    dword_12EA8FC = v9;
    result = 0;
  }
  else
  {
    v10.y = HIWORD(pt.y);
    v10.x = LOWORD(pt.y);
    if ( PtInRect(&gRectRedrawMainWnd, v10) )
      SetCursor(ghCursorResizeVert);
    result = 0;
  }
  return result;
}
// 12EA38B: using guessed type char gbIsFinding;

//----- (01253AA0) --------------------------------------------------------
BOOL __cdecl HandleMeasureItem(HWND hDlg, UINT uMsg, WPARAM wParam, MEASUREITEMSTRUCT *lpmis)
{
  HDC hdc; // ebx
  BOOL result; // eax
  int height; // edi
  TEXTMETRICW tm; // [esp+8h] [ebp-40h]

  if ( lpmis->CtlType == IDW_HANDLES_LISTCTRL || lpmis->CtlID == IDC_TREELIST )
  {
    hdc = GetDC(ghWndTreeListView);
    SelectObject(hdc, ghDefaultFont);
    result = GetTextMetricsW(hdc, &tm);
    if ( !result )
      return result;
    if ( lpmis->CtlID == IDC_TREELIST )
    {
      height = tm.tmHeight + 2;
      if ( height <= GetSystemMetrics(SM_CYSMICON) )
        height = GetSystemMetrics(SM_CYSMICON);
      lpmis->itemHeight = height;
    }
    else
    {
      lpmis->itemHeight = tm.tmHeight + 2;
    }
    ReleaseDC(ghWndTreeListView, hdc);
  }
  else if ( lpmis->CtlType == IDOK )
  {
    lpmis->itemWidth = 16;
    lpmis->itemHeight = 16;
  }
  return 1;
}

//----- (01253B70) --------------------------------------------------------
int __cdecl HandeNotify(HWND hWnd, int uMsg, HMENU wParam, NMLISTVIEW *pNMListView)
{
  int code; // eax
  int v5; // eax
  DWORD v7; // [esp+0h] [ebp-20h]
  struct tagPOINT Point; // [esp+4h] [ebp-1Ch]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h]

  code = pNMListView->hdr.code;
  if ( code > PE_LVN_GETDISPINFOW )
  {
    switch ( code )
    {
      case PE_LVN_BEGINLABELEDITW:
        // TTN_GETDISPINFOW
        return 1;
      case PE_LVN_KEYDOWN:
        return OnTreeListKeydown(wParam, pNMListView);
      case PE_LVN_COLUMNCLICK:
        return OnTreeListColumnClick(wParam, pNMListView, v7, Point.x);
      case PE_LVN_DELETEITEM:
        return CTreeList::DeleteItem(wParam, pNMListView);
      case PE_LVN_ITEMCHANGED:
        return CTreeList::OnItemChanged(wParam);
      case PE_NM_THEMECHANGED:
        if ( wParam == IDW_REBAR )
          // NM_THEMECHANGED
          GetToolbarButtonHeight();
        return 0;
      case PE_NM_RCLICK:
        GetCursorPos(&Point);
        return OnTreeListRClick(wParam, &pNMListView->hdr.hwndFrom, &Point);
      case PE_NM_DBLCLICK:
        return OnTreeListDblclks(wParam);
      case PE_NM_CLICK:
        return OnTreeListClick(wParam, pNMListView);
      default:
        return 0;
    }
  }
  else
  {
    if ( code == PE_LVN_GETDISPINFOW )
      return CTreeList::OnGetDispInfo(pNMListView, wParam, pNMListView);
    if ( code > PE_RBN_GETOBJECT )
    {
      switch ( code )
      {
        case PE_TBN_BEGINDRAG:
          // UDN_DELTAPOS
          if ( pNMListView->iItem == IDM_OTHER_FIND_WINDOW_PROCESS )
          {
            FindProcessByWindow(hWnd);
            return 0;
          }
          break;
        case PE_TTN_GETDISPINFOW:
          return OnTooltipGetDipsInfoW(wParam, pNMListView);
        case PE_LVN_ODFINDITEMW:
          return OnFindItem(wParam);
      }
    }
    else
    {
      if ( code == PE_RBN_GETOBJECT )
      {
        GetClientRect(ghWndNewOwner, &Rect);
        HandleSize(
          ghWndNewOwner,
          0,
          0,
          (LOWORD(Rect.right) - LOWORD(Rect.left)) | ((LOWORD(Rect.bottom) - LOWORD(Rect.top)) << 16));
        InvalidateRect(ghWndTreeListView, 0, 0);
        return 0;
      }
      if ( code > PE_NM_7D4 )
      {
        if ( code == PE_NM_7D5 )
          return OnTreeListNotify7D5(wParam, pNMListView);
        if ( code == PE_RBN_CHILDSIZE )
        {
          InvalidateRect(pNMListView->hdr.hwndFrom, 0, 0);
          return 0;
        }
      }
      else
      {
        if ( code == PE_NM_7D4 )
          return OnTreeListNotify7D4(wParam, pNMListView);
        v5 = code - PE_NM_7D1;
        // PE_NM_7D0
        if ( !v5 )
          return OnTreeListNotify7D1();
        if ( v5 == 1 )
          return OnTreeListNotify7D2();
      }
    }
  }
  return 0;
}

//----- (01253F40) --------------------------------------------------------
int __cdecl HandleCreate(HWND hWnd)
{
  HMODULE v1; // eax
  bool v2; // al
  HMENU hMainMenu; // edi
  HCURSOR v4; // eax
  HGDIOBJ v5; // eax
  int v6; // ST20_4
  HMENU v7; // eax
  HMENU hViewMenu; // eax
  HMENU v9; // eax
  signed int i; // esi
  int v11; // eax
  int nMenuLastColumnsetPosLast; // ST1C_4
  HMENU hMenuMain; // eax
  HMENU hMenuView; // eax
  HMENU v15; // eax
  HMENU hFileMenu; // eax
  HMENU hFileMenu_1; // eax
  HMENU hFileMenu_2; // eax
  HMENU hFileMenu_3; // eax
  HMENU (__stdcall *GetMenu)(HWND); // esi
  HMENU hMainMenu_1; // eax
  HMENU hMenuOpacity; // eax
  UINT v23; // eax
  UINT v24; // eax
  signed int v25; // eax
  UINT v26; // ST28_4
  HMENU v27; // eax
  signed int v28; // eax
  UINT v29; // ST28_4
  HMENU v30; // eax
  signed int v31; // eax
  UINT v32; // ST28_4
  HMENU v33; // eax
  signed int v34; // eax
  UINT v35; // ST28_4
  HMENU v36; // eax
  UINT v37; // eax
  UINT v38; // eax
  UINT v39; // eax
  UINT v40; // eax
  UINT v41; // eax
  UINT v42; // eax
  signed int v43; // eax
  UINT v44; // ST28_4
  HMENU v45; // eax
  float v46; // xmm0_4
  double v47; // xmm0_8
  float v48; // xmm0_4
  double v49; // xmm0_8
  UINT v50; // ST28_4
  HMENU v51; // eax
  UINT bRunAtLogon; // ST28_4
  HMENU v53; // eax
  UINT v54; // eax
  int dwPid; // ST04_4
  HANDLE hProcess; // eax
  WCHAR *pszText; // eax
  unsigned int nLen; // kr00_4
  HMENU hProcessMeu; // eax
  int dwNumberOfProcessors; // eax
  int j; // esi
  ProcessorInfo *v62; // ecx
  ProcessorInfo *v63; // edx
  HMODULE hMouPowrProfDLL; // eax
  HMODULE hMouPowrProfDLL1; // eax
  HMODULE hMouPowrProfDLL2; // eax
  HMODULE hUserDLL; // eax
  HMODULE hUserDLL1; // eax
  HMODULE hUserDLL2; // eax
  HMENU v70; // eax
  UINT v71; // ecx
  signed int v72; // eax
  UINT v73; // ST28_4
  HMENU v74; // eax
  void (__stdcall *RegCloseKey)(HKEY); // esi
  DWORD pszPath; // eax
  DWORD v77; // esi
  int v78; // ST24_4
  CTreeList *v79; // esi
  wchar_t *v80; // eax
  HWND hWndParent; // esi
  HINSTANCE hInst; // ST1C_4
  HWND hWndTreeList; // eax
  CTreeList *pTreeList; // eax
  CTreeList *pTreeList1; // esi
  void *hCursor1; // eax
  HWND v88; // eax
  HWND v89; // eax
  HWND v90; // eax
  LONG dwProcessColumnCount; // eax
  __int16 width; // ax
  int SmallIconHeight; // ST18_4
  int SmallIconWidth; // eax
  HIMAGELIST hImageList; // eax
  CTreeList *pTreeList3; // esi
  HICON hIcon1; // ST28_4
  _IMAGELIST *hImageList2; // eax
  struct _IMAGELIST *hImageList_1; // eax
  HWND hwndThis; // esi
  HWND hHandlesListCtrl; // ecx
  HWND hDllListCtrl; // ecx
  MACRO_MF v103; // eax
  UINT v104; // ST28_4
  HMENU v105; // eax
  HMENU v106; // eax
  HMENU v107; // eax
  LPARAM v108; // eax
  BOOL v109; // ST28_4
  HMENU v110; // eax
  HMENU v111; // eax
  double v112; // xmm0_8
  signed int v113; // eax
  UINT v114; // ST28_4
  HMENU v115; // eax
  signed int v116; // eax
  UINT v117; // ST28_4
  HMENU v118; // eax
  HWND hThisWnd; // ebx
  signed int v120; // eax
  UINT v121; // ST28_4
  HMENU v122; // eax
  HMENU v123; // eax
  HMENU v124; // eax
  HMODULE v125; // eax
  HMODULE v126; // eax
  FARPROC v127; // eax
  int dwOpacity; // ecx
  LONG dwExStyle; // eax
  UINT uMenuId; // ST24_4
  HMENU hWndThis_; // eax
  UINT uRefreshMenuId; // [esp-8h] [ebp-CE4h]
  const WCHAR *strMenuText; // [esp-4h] [ebp-CE0h]
  int v134; // [esp+0h] [ebp-CDCh]
  _DWORD *v135; // [esp+4h] [ebp-CD8h]
  LVITEMW treeListItem; // [esp+Ch] [ebp-CD0h]
  MENUITEMINFOW dllhndListItem; // [esp+40h] [ebp-C9Ch]
  DWORD Type; // [esp+74h] [ebp-C68h]
  DWORD64 dwSegCommitLimit; // [esp+78h] [ebp-C64h]
  DWORD64 dbRatio; // [esp+80h] [ebp-C5Ch]
  PWTS_SESSION_INFO ppSessionInfo; // [esp+88h] [ebp-C54h]
  DWORD pCount; // [esp+8Ch] [ebp-C50h]
  HCURSOR hCursor; // [esp+90h] [ebp-C4Ch]
  CTreeList *pTreeList2; // [esp+94h] [ebp-C48h]
  HKEY phkResult; // [esp+98h] [ebp-C44h]
  size_t cbData; // [esp+9Ch] [ebp-C40h]
  HWND hWndThis; // [esp+A0h] [ebp-C3Ch]
  WSADATA WSAData; // [esp+A4h] [ebp-C38h]
  LOGFONT LogFont; // [esp+234h] [ebp-AA8h]
  RECT rc; // [esp+290h] [ebp-A4Ch]
  RECT Rect; // [esp+2A0h] [ebp-A3Ch]
  TCHAR szUserName[260]; // [esp+2B0h] [ebp-A2Ch]
  TCHAR szBuffer[260]; // [esp+4B8h] [ebp-824h]
  TCHAR szPassword[260]; // [esp+6C0h] [ebp-61Ch]
  TCHAR szTitle[260]; // [esp+8C8h] [ebp-414h]
  TCHAR Data[260]; // [esp+AD0h] [ebp-20Ch]

  hWndThis = hWnd;
  _mm_storeu_si128(&Rect, 0i64);
  treeListItem.mask = LVS_ICON;
  memset(&treeListItem.iItem, 0, 0x30u);
  CoInitialize(0);
  WSAStartup(0x101u, &WSAData);
  GetLocaleInfoW(0x400u, LOCALE_SDECIMAL, &gszLocaleInfo, 16);
  InitializeCriticalSection(&gLockForSysInfoProperties);
  InitializeCriticalSection(&gLock2);
  InitializeCriticalSection(&gLock3);
  InitializeCriticalSection(&gStrListLock);
  LoadHiddenProcsFromRegistry();
  RetrieveProcessComments();
  v1 = LoadLibraryW(L"Advapi32.dll");
  *CreateRestrictedToken = GetProcAddress(v1, "CreateRestrictedToken");
  gbWintrustInited = LoadWintrust();
  v2 = GetProcessDEPStatus();
  ghWndNewOwner = hWnd;
  gbProcessDEPStatus = v2;
  hMainMenu = ::GetMenu(hWnd);
  v4 = LoadCursorW(0, IDC_WAIT);
  hCursor = SetCursor(v4);
  ghCursorArrow_1 = LoadCursorW(0, IDC_ARROW);
  ghCursorFind = LoadCursorW(ghInstance, 10);
  EnableMenuItem(hMainMenu, IDM_OTHER_HIDE_PROCESSES, *gpHiddenProcs == 0);
  v5 = GetStockObject(DEFAULT_GUI_FONT);
  GetObjectW(v5, 92, &LogFont);
  LogFont.lfUnderline = 1;
  ghDefaultGuiFontUnderline = CreateFontIndirectW(&LogFont);
  gMSGCommdlg_FindReplace = RegisterWindowMessageW(L"commdlg_FindReplace");
  DeleteMenu(hMainMenu, IDS_PROCEXPLORERMENU_LOAD_COLUMN_SET_TEST, 0);
  v6 = gnMenuLastColumnsetPosLast;
  v7 = ::GetMenu(ghWndNewOwner);
  hViewMenu = GetSubMenu(v7, MENUINDEX_VIEW);
  v9 = GetSubMenu(hViewMenu, v6);
  DeleteMenu(v9, 0, MF_BYPOSITION);
  // 在菜单View/Load Column Set项创建弹出下拉菜单，
  // 增加最近创建的各Column set项
  for ( i = 0; i < gdwNumColumnsets; ++i )
  {
    if ( i >= 10 )
    {
      tcscpy_s(szBuffer, _MAX_PATH, gstrMenuCulumnSet[i]);
    }
    else
    {
      if ( i == 9 )
        v11 = 0;
      else
        v11 = i + 1;
      stprintf(szBuffer, L"%s\tCtrl+%i", gstrMenuCulumnSet[i], v11);
    }
    nMenuLastColumnsetPosLast = gnMenuLastColumnsetPosLast;
    hMenuMain = ::GetMenu(ghWndNewOwner);
    hMenuView = GetSubMenu(hMenuMain, MENUINDEX_VIEW);
    v15 = GetSubMenu(hMenuView, nMenuLastColumnsetPosLast);
    AppendMenuW(v15, 0, i + IDM_OTHER_RECENT_COLUMNSET_BASE, szBuffer);
  }
  ghMenuPriority = LoadMenuW(ghInstance, L"PRIORITY");
  if ( *CreateRestrictedToken )
  {
    hFileMenu = GetSubMenu(hMainMenu, MENUINDEX_FILE);
    InsertMenuW(
      hFileMenu,
      1u,
      MF_BYPOSITION,
      IDS_PROCEXPLORERMENU_VERIFY_IMAGE_SIGNATURE|0x8,
      L"Run as &Limited User...");
    ++gnFileMenuPosLast;
  }
  if ( gdwOsType < 1 )
  {
    strMenuText = L"R&unas...";
    goto __InsertMenuItem;
  }
  // 不具备内建的系统管理员账号权限
  if ( !IsBuiltinAndAnministrative() )
  {
    strMenuText = L"R&un as Administrator...";
__InsertMenuItem:
    hFileMenu_1 = GetSubMenu(hMainMenu, MENUINDEX_FILE);
    InsertMenuW(hFileMenu_1, 1u, MF_BYPOSITION, IDS_DLLMENU_SEARCH_ONLINE|0x9, strMenuText);
    ++gnFileMenuPosLast;
  }
  InsertMenuW(
    hMainMenu,
    IDS_PROCEXPLORERMENU_PROCESS_SET_PRIORTY_NORMAL,
    MF_BYCOMMAND,
    IDM_PRIORITY_ABOVE_NORMAL,
    L"&Above Normal: 10");
  InsertMenuW(
    ghMenuPriority,
    IDS_PROCEXPLORERMENU_PROCESS_SET_PRIORTY_NORMAL,
    MF_BYCOMMAND,
    IDM_PRIORITY_ABOVE_NORMAL,
    L"&Above Normal: 10");
  InsertMenuW(hMainMenu, IDS_PRIORITYMENU_IDLE, MF_BYCOMMAND, IDM_PRIORITY_BELOW_NORMAL, L"&Below Normal: 6");
  InsertMenuW(
    ghMenuPriority,
    IDS_PROCEXPLORERMENU_PROCESS_SET_PRIORTY_IDLE,
    MF_BYCOMMAND,
    IDM_PRIORITY_BELOW_NORMAL,
    L"&Below Normal: 6");
  if ( gdwOsType < 1
    || (InsertMenuW(
          hMainMenu,
          IDS_PROCEXPLORERMENU_PROCESS_SET_PRIORTY_IDLE,
          MF_BYCOMMAND,
          IDM_PRIORITY_BACKGROUND_4,
          L"Back&ground: 4 (Low I/O and Memory Priority)"),
        InsertMenuW(
          ghMenuPriority,
          IDS_PROCEXPLORERMENU_PROCESS_SET_PRIORTY_IDLE,
          MF_BYCOMMAND,
          IDM_PRIORITY_BACKGROUND_4,
          L"Back&ground: 4 (Low I/O and Memory Priority)"),
        gdwOsType < 1)
    || IsBuiltinAndAnministrative() )
  {
    if ( ChangeWindowMessageFilter )
      // 从用户界面特权隔离 (UIPI) 消息过滤器，添加或删除一条消息
      ChangeWindowMessageFilter(PMT_MSG_7F2, 1);// MSGFLT_ADD =1,增加该消息的处理
    GetMenu = ::GetMenu;
  }
  else
  {
    hFileMenu_2 = GetSubMenu(hMainMenu, 0);
    InsertMenuW(hFileMenu_2, 3u, 0xC00u, 0, 0); // MF_OWNERDRAW|MF_BYPOSITION|MF_SEPARATOR
    ++gnFileMenuPosLast;
    hFileMenu_3 = GetSubMenu(hMainMenu, 0);
    InsertMenuW(hFileMenu_3, 4u, MF_BYPOSITION, 40722u, L"Show &Details for All Processes");
    GetMenu = ::GetMenu;
    hMainMenu_1 = ::GetMenu(hWndThis);
    UpdateSysIconInMenu(hMainMenu_1, IDM_OTHER_SHOW_DETAILS_FOR_ALL_PROCESSES);
    ++gnFileMenuPosLast;
  }
  // 更新Opacity菜单选项
  hMenuOpacity = LoadMenuW(ghInstance, L"OPACITY");
  InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_SHOW_LOWER_PANE, MF_POPUP, hMenuOpacity, L"Opacity");
  InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_SHOW_LOWER_PANE, MF_SEPARATOR, 0, 0);
  v23 = 0;
  if ( gbVerifySignatures )
    v23 = 8;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_VERIFY_IMAGE_SIGNATURE, v23);
  v24 = 0;
  if ( gbVirusTotalCheck )
    v24 = 8;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_CHECK_VIRUSTOTALCOM, v24);
  EnableMenuItem(hMainMenu, 0x9F36u, gbVirusTotalCheck == 0);
  if ( gbVirusTotalCheck )
    sub_12817E0();
  v25 = 0;
  if ( gbTrayCPUHistory )
    v25 = 8;
  v26 = v25;
  v27 = GetMenu(hWndThis);
  CheckMenuItem(v27, IDS_PROCEXPLORERMENU_CPU_HISTORY, v26);
  v28 = 0;
  if ( gbShowIoTray )
    v28 = 8;
  v29 = v28;
  v30 = GetMenu(hWndThis);
  CheckMenuItem(v30, IDS_PROCEXPLORERMENU_IO_HISTORY, v29);
  v31 = 0;
  if ( gbShowCommitTray )
    v31 = 8;
  v32 = v31;
  v33 = GetMenu(hWndThis);
  CheckMenuItem(v33, IDS_PROCEXPLORERMENU_COMMIT_HISTORY, v32);
  v34 = 0;
  if ( gbShowPhysTray )
    v34 = 8;
  v35 = v34;
  v36 = GetMenu(hWndThis);
  CheckMenuItem(v36, IDS_PROCEXPLORERMENU_PHYSICAL_MEMORY_HISTORY, v35);
  v37 = 0;
  if ( gbAllOneInstance )
    v37 = 8;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_ALLOW_ONE_INSTANCE, v37);
  v38 = 0;
  if ( gbHideWhenMinimized )
    v38 = 8;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_HIDE_WHEN_MINIMIZED, v38);
  v39 = 0;
  if ( gbShowColumnHeatmaps )
    v39 = 8;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_SHOW_COLUMN_HEATMAPS, v39);
  gbAlwaysOntop = gbAlwaysOntop == 0;
  OnAlwaysOnTop(ghWndNewOwner);
  v40 = 0;
  if ( gbShowCpuFractions )
    v40 = MF_CHECKED;
  CheckMenuItem(hMainMenu, IDM_OTHER_CPUFRACTIONS, v40);
  v41 = 0;
  if ( gbConfirmKill )
    v41 = 8;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_CONFIRM_KILL, v41);
  v42 = 0;
  if ( gbFormatIoBytes )
    v42 = 8;
  CheckMenuItem(hMainMenu, IDM_OTHER_FormatIoBytes, v42);
  v43 = 0;
  if ( gbShowNewProcesses )
    v43 = 8;
  v44 = v43;
  v45 = GetMenu(hWndThis);
  CheckMenuItem(v45, IDS_PROCEXPLORERMENU_SCROLL_TO_NEW_PROCESSES, v44);
  // 增加SystemInformation项在View视图中
  InsertMenuW(
    hMainMenu,
    IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE,
    MF_BYCOMMAND,
    IDS_TRAYMENU_SYSTEM_INFORMATION,
    L"System &Information...\tCtrl+I");
  // 初始化显卡信息
  if ( InitializeD3DStatistics(&dbRatio, &dwSegCommitLimit) )
  {
    gpGraphClassData[GraphIndex_GPUUsage] = InitProcessorScreenData(1, 1, 1);
    gpGraphClassData[GraphIndex_GPUUsage]->Index = 4;
    gpGraphClassData[GraphIndex_GPUUsage]->Color = 0x8080FF;
    *&gpGraphClassData[GraphIndex_GPUUsage]->dbTotalPageFile = gdbMaxValue;
    gpGraphClassData[3] = InitProcessorScreenData(1, 1, 0);
    gpGraphClassData[3]->Index = 5;
    gpGraphClassData[3]->Color = 0xAAAA;
    if ( dbRatio )
    {
      v46 = dbRatio;
      v47 = v46;
    }
    else
    {
      v47 = doubleOnePointZero;
    }
    *&gpGraphClassData[3]->dbTotalPageFile = v47;
    gpGraphClassData[4] = InitProcessorScreenData(1, 1, 0);
    gpGraphClassData[4]->Index = 6;
    gpGraphClassData[4]->Color = 0x4080FF;
    if ( dwSegCommitLimit )
    {
      v48 = dwSegCommitLimit;
      v49 = v48;
    }
    else
    {
      v49 = doubleOnePointZero;
    }
    *&gpGraphClassData[4]->dbTotalPageFile = v49;
  }
  // 在显示进程树菜单项之前增加一个Sperator项
  InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, MF_SEPARATOR, 0, 0);
  InsertMenuW(
    hMainMenu,
    IDS_PROCEXPLORERMENU_HIDE_WHEN_MINIMIZED,
    MF_BYCOMMAND,
    IDM_OTHER_REPLACE_TASK_MANAGER,
    L"Replace &Task Manager");
  v50 = TaskMgrIsDebugger() != 0 ? 8 : 0;
  v51 = GetMenu(hWndThis);
  CheckMenuItem(v51, IDM_OTHER_REPLACE_TASK_MANAGER, v50);
  if ( gdwOsType >= 1 && !IsBuiltinAndAnministrative() )
    UpdateSysIconInMenu(hMainMenu, IDM_OTHER_REPLACE_TASK_MANAGER);
  if ( TaskMgrIsDebugger() )
    ReplaceTaskMgr(hWndThis, 0);
  bRunAtLogon = MayRunAtLogon(v134, v135) != 0 ? 8 : 0;
  v53 = GetMenu(hWndThis);
  CheckMenuItem(v53, IDS_PROCEXPLORERMENU_RUN_AT_LOGON, bRunAtLogon);
  v54 = 0;
  if ( gbShowAllUsers )
    v54 = MF_CHECKED;
  CheckMenuItem(hMainMenu, IDS_PROCEXPLORERMENU_SHOW_PROCESSES_FROM_ALL_USERS, v54);
  InsertMenuW(
    hMainMenu,
    IDS_PROCEXPLORERMENU_DIFFERCENT_HILITE_DURATION,
    MF_BYCOMMAND,
    IDM_OTHER_CONFIGURE_SYMBOLS,
    L"Configure &Symbols...");
  DeleteMenu(hMainMenu, IDS_PROCEXPLORERMENU_HILITE_RELOCATED_DLLS, 0);
  InsertMenuW(
    hMainMenu,
    IDS_PROCEXPLORERMENU_DIFFERCENT_HILITE_DURATION,
    MF_BYCOMMAND,
    IDM_OTHER_CONFIGURE_COLORS,
    L"&Configure Colors...");
  if ( WTSEnumerateSessionsW && *SetMenuInfo && WTSEnumerateSessionsW(0, 0, 1u, &ppSessionInfo, &pCount) && pCount )
  {
    dllhndListItem.cbSize = 28;
    dllhndListItem.hbmpUnchecked = 0x80000010;
    dllhndListItem.dwItemData = 0x8000000;
    SetMenuInfo(hMainMenu, &dllhndListItem.hbmpChecked);
    ghMenuUsers = CreateMenu();
    InsertMenuW(hMainMenu, 5u, IDD_PROCSECURITY_CTRL_LISTVIEW1, ghMenuUsers, L"&Users");
    WTSFreeMemory(ppSessionInfo);
  }
  dwPid = GetCurrentProcessId();
  hProcess = GetCurrentProcess();
  QueryProcessUserInfo(hProcess, dwPid, 0, szUserName, _MAX_PATH, szPassword, _MAX_PATH, 0, 0, 0, 0);
  if ( !*szPassword || (pszText = L"\\", !*szUserName) )
    pszText = gpszTargetName;
  stprintf(&gszMainTitle, L"%s%s%s", szPassword, pszText, szUserName);
  GetWindowTextW(ghWndNewOwner, szTitle, _MAX_PATH);
  nLen = wcslen(szTitle);
  swprintf_s(&szTitle[2 * nLen], _MAX_PATH - nLen, L" [%s]", &gszMainTitle);
  SetWindowTextW(ghWndNewOwner, szTitle);
  gColors[0] = ColorOwn;
  gColors[1] = ColorServices;
  gColors[2] = ColorRelocatedDlls;
  gColors[3] = gColorJobs_0;
  gColors[4] = gColorNet;
  GetSidIndentityAuthInfo(&gstrSidIndentityInfo);
  if ( gSystemInfo.dwNumberOfProcessors > 1 )
  {
    hProcessMeu = GetSubMenu(hMainMenu, 3);
    InsertMenuW(hProcessMeu, 2u, MF_BYPOSITION, IDM_PROCESS_SET_AFFINITY, L"Set &Affinity...");
    CheckMenuItem(hMainMenu, (gbShowAllCpus != 0) + IDS_PROCESSORMENU_ONE_GRAPH_ALL_CPUS, MF_CHECKED);
    if ( *GetLogicalProcessorInformation )
    {
      cbData = 0;
      GetLogicalProcessorInformation(0, &cbData);
      if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
      {
        gLogicalProcessorInformation = malloc(cbData);
        GetLogicalProcessorInformation(gLogicalProcessorInformation, &cbData);
        gdwLogicalProcessorInformationCount = cbData / 0x18;
      }
    }
    else
    {
      gLogicalProcessorInformation = sub_1245420(&gdwLogicalProcessorInformationCount);
    }
    gpProcessorsInfo = malloc(4 * gSystemInfo.dwNumberOfProcessors);
    dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    for ( j = 0; j < gSystemInfo.dwNumberOfProcessors; ++j )
    {
      gpProcessorsInfo[j] = InitProcessorScreenData(dwNumberOfProcessors, 2, 0);
      gpProcessorsInfo[j]->m_ScreenData2 = j;
      sub_1243E70(
        gLogicalProcessorInformation,
        gdwLogicalProcessorInformationCount,
        j,
        &gpProcessorsInfo[j]->field_874,
        &gpProcessorsInfo[j]->m_Time.wSecond);
      gpProcessorsInfo[j]->ProcessorCount = 2;
      gpProcessorsInfo[j]->ID = 0;
      gpProcessorsInfo[j]->m_Buffer[0].m_Color = 0x3C943C;
      *&gpProcessorsInfo[j]->m_dbMaxValue = gdbMaxValue;
      gpProcessorsInfo[j]->m_Buffer[1].m_Color = 255;
      *&gpProcessorsInfo[j]->m_Buffer[0].m_dbMaxValue = gdbMaxValue;
      gpProcessorsInfo[j]->GPUGraphData = gpGraphClassData[GraphIndex_CPU];
      if ( j )
      {
        v62 = *gpProcessorsInfo;
        v63 = gpProcessorsInfo[j];
        *&v63->m_Time.wYear = *&(*gpProcessorsInfo)->m_Time.wYear;
        *&v63->m_Time.wDayOfWeek = *&v62->m_Time.wDayOfWeek;
      }
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    }
    GetMenu = ::GetMenu;
  }
  hMouPowrProfDLL = LoadLibraryW(L"Powrprof.dll");
  *SetSuspendState = GetProcAddress(hMouPowrProfDLL, "SetSuspendState");
  if ( *SetSuspendState )
  {
    hMouPowrProfDLL1 = LoadLibraryW(L"Powrprof.dll");
    *IsPwrHibernateAllowed = GetProcAddress(hMouPowrProfDLL1, "IsPwrHibernateAllowed");
    if ( IsPwrHibernateAllowed() )
      InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_RESTART, MF_BYCOMMAND, IDM_OTHER_HIBERNATE, L"&Hibernate");
    hMouPowrProfDLL2 = LoadLibraryW(L"Powrprof.dll");
    *IsPwrSuspendAllowed = GetProcAddress(hMouPowrProfDLL2, "IsPwrSuspendAllowed");
    if ( IsPwrSuspendAllowed() )
      InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_RESTART, MF_BYCOMMAND, IDM_OTHER_STAND_BY, L"Stand &By");
  }
  hUserDLL = LoadLibraryW(L"User32.dll");
  *LockWorkStation = GetProcAddress(hUserDLL, "LockWorkStation");
  if ( *LockWorkStation )
    InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_RESTART, MF_BYCOMMAND, IDM_OTHER_LOCK_WORKSTATION, L"Loc&k");
  hUserDLL1 = LoadLibraryW(L"User32.dll");
  *GetMonitorInfoA = GetProcAddress(hUserDLL1, "GetMonitorInfoA");
  hUserDLL2 = LoadLibraryW(L"User32.dll");
  *MonitorFromPoint = GetProcAddress(hUserDLL2, "MonitorFromPoint");
  v70 = LoadMenuW(ghInstance, L"DLLMENU");
  v71 = 0;
  ghMenuDllsMenu = v70;
  if ( gbHighlightRelocatedDlls )
    v71 = 8;
  CheckMenuItem(v70, IDS_PROCEXPLORERMENU_HILITE_RELOCATED_DLLS, v71);
  ghMenuHandlesMenu = LoadMenuW(ghInstance, L"HANDLEMENU");
  v72 = 0;
  if ( gbShowUnnamedHandles )
    v72 = 8;
  v73 = v72;
  v74 = GetMenu(hWndThis);
  CheckMenuItem(v74, IDS_PROCEXPLORERMENU_SHOW_UNNAMED_HANDLES_AND_MAPPINGS, v73);
  RegCloseKey = ::RegCloseKey;
  if ( RegOpenKeyW(HKEY_CLASSES_ROOT, L"exefile\\shell\\View Dependencies", &phkResult) )
  {
    gszDependsFileName = 0;
    // 从系统路径中获取有效的Depends.exe文件名
    pszPath = GetEnvironmentVariableW(L"PATH", 0, 0);
    v77 = pszPath;
    if ( pszPath )
    {
      pTreeList2 = malloc(2 * pszPath + 2);
      GetEnvironmentVariableW(L"PATH", pTreeList2, v77);
      v78 = v77;
      v79 = pTreeList2;
      if ( GetDependsFileName(L"depends.exe", pTreeList2, v78, &gszDependsFileName) )
      {
        InsertMenuW(
          hMainMenu,
          IDS_PROCEXPLORERMENU_PROCESS_TEMP,
          MF_BYCOMMAND,
          IDM_PROCESS_LAUNCH_DEPENDS,
          L"&Launch Depends...");
        InsertMenuW(ghMenuDllsMenu, 40111u, MF_BYCOMMAND, IDM_OTHER_LAUNCH_DEPENDS2, L"&Launch Depends...");
        gbLaunchDepends = 1;
      }
      else
      {
        gszDependsFileName = 0;
      }
      free(v79);
    }
    RegCloseKey = ::RegCloseKey;
  }
  else
  {
    gbLaunchDepends = 1;
    InsertMenuW(
      hMainMenu,
      IDS_PROCEXPLORERMENU_PROCESS_TEMP,
      MF_BYCOMMAND,
      IDM_OTHER_LAUNCH_DEPENDS,
      L"&Launch Depends...");
    InsertMenuW(ghMenuDllsMenu, 40111u, MF_BYCOMMAND, 40032u, L"&Launch Depends...");
    gszDependsFileName = 0;
    ::RegCloseKey(phkResult);
  }
  if ( !RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug", &phkResult) )
  {
    cbData = 520;
    if ( !RegQueryValueExW(phkResult, L"Debugger", 0, &Type, Data, &cbData) )
    {
      _wcslwr_s(gstrDefaultDebugger, _MAX_PATH);
      if ( *Data == '"' )
      {
        tcscpy_s(gstrDefaultDebugger, _MAX_PATH, &Data[2]);
        if ( wcschr(gstrDefaultDebugger, '"') )
        {
          v80 = wcschr(gstrDefaultDebugger, '"');
LABEL_110:
          *v80 = 0;
          goto LABEL_111;
        }
      }
      else
      {
        tcscpy_s(gstrDefaultDebugger, _MAX_PATH, Data);
        if ( wcschr(gstrDefaultDebugger, ' ') )
        {
          v80 = wcschr(gstrDefaultDebugger, ' ');
          goto LABEL_110;
        }
      }
    }
LABEL_111:
    RegCloseKey(phkResult);
  }
  if ( gstrDefaultDebugger[0] )
    InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_TEMP, MF_BYCOMMAND, IDM_OTHER_DEBUG_PROCESS, L"&Debug");
  DeleteMenu(hMainMenu, IDS_PROCEXPLORERMENU_PROCESS_TEMP, 0);
  hWndParent = hWndThis;
  // 创建工具条
  ghWndToolbar = CreateRebar(hWndThis, IDW_REBAR);
  if ( !ghWndToolbar )
    return -1;
  UpdateMenu(0, 3);
  GetWindowRect(ghWndToolbar, &Rect);
  gnToolbarHeight = Rect.bottom - Rect.top + 2;
  hInst = ghInstance;
  // rc.left = 0.000000
  _mm_storeu_si128(&rc, 0i64);
  // WS_CHILD | WS_BORDER | WS_TABSTOP | LVS_EDITLABELS
  hWndTreeList = CreateTreeListView(hWndParent, hInst, IDC_TREELIST, TREELIST_STYLE, &rc);
  ghWndTreeListView = hWndTreeList;
  if ( !hWndTreeList )
    return -1;
  InitTreeList(hWndTreeList, ghDefaultFont);
  pTreeList = GetTreeListCtrl(ghWndTreeListView);
  pTreeList1 = pTreeList;
  pTreeList2 = pTreeList;
  pTreeList->DisplayCallback = AutoComputerSomeGraphColor;
  CTreeList::RestoreScrollbars(pTreeList, 0);
  pTreeList1->m_HandCursor = LoadHandCursor;
  hCursor1 = LoadCursorW(ghInstance, IDC_CURSOR_SPLITTER);
  CTreeList::SetSplitterCursor(pTreeList1, hCursor1);
  sub_121BDA0(pTreeList1, 1);
  sub_121F210(pTreeList1, 0);
  sub_121F230(pTreeList1, 0);
  v88 = CTreeList::GetTooltipTreeList(pTreeList1);
  InitToolTips(v88);
  v89 = CTreeList::GetTooltipLeftHeader(pTreeList1);
  InitToolTips(v89);
  v90 = CTreeList::GetTooltipRightHeader(pTreeList1);
  InitToolTips(v90);
  dwProcessColumnCount = gdwProcessListColumnCount;
  if ( gdwIDMapProcesListForSelectColumn[0] != 3 )
  {
    memmove(&gdwIDMapProcesListForSelectColumn[1], gdwIDMapProcesListForSelectColumn, 4 * gdwProcessListColumnCount);
    gdwIDMapProcesListForSelectColumn[0] = 3;
    memmove(&gwProcessListColumnWidths[1], gwProcessListColumnWidths, 2 * gdwProcessListColumnCount);
    width = gwProcessImageColumnWidth;
    if ( !gwProcessImageColumnWidth )
      width = 200;
    gwProcessListColumnWidths[0] = width;
    dwProcessColumnCount = gdwProcessListColumnCount++ + 1;
  }
  if ( !InitListCtrl(
          ghWndTreeListView,
          gdwIDMapProcesListForSelectColumn,
          gwProcessListColumnWidths,
          dwProcessColumnCount) )
    return -1;
  SmallIconHeight = GetSystemMetrics(SM_CYSMICON);


  SmallIconWidth = GetSystemMetrics(SM_CXSMICON);
  hImageList = ImageList_Create(SmallIconWidth, SmallIconHeight, 0x21u, 256, 256);
  pTreeList3 = pTreeList2;
  CTreeList::SetImageList(pTreeList2, hImageList, 0);
  hIcon1 = LoadIconW(0, IDC_ARROW);
  hImageList2 = CTreeList::GetImageIcon(pTreeList3);
  ImageList_ReplaceIcon(hImageList2, -1, hIcon1);
  hImageList_1 = InitSortableImageList();
  CTreeList::SetSortImgList(pTreeList3, hImageList_1, 1, 0);
  if ( !gbShowProcessTree )
    InitTreeListSortableHeader(ghWndTreeListView, -1, gdwProcessListSortColumnCount, gbProcessSortDirection);
  hwndThis = hWndThis;
  // 创建句柄表列表框
  hHandlesListCtrl = CreateListCtrl(
                       hWndThis,
                       // WS_VISIBLE|WS_CHILD|WS_CLIPCHILDREN|LVS_EDITLABELS
                       0x40810605u,
                       gdwHandlesListColumnMap,
                       gdwHandlesListColumnWidths,
                       gdwHandlesListColumnCount,
                       IDW_HANDLES_LISTCTRL);
  ghWndHandlesListCtrl = hHandlesListCtrl;
  if ( !hHandlesListCtrl )
    return -1;
  InitTreeListSortableHeader(hHandlesListCtrl, -1, gdwHandlesListSortColumnCount, HandleSortDirection);
  // 创建DLL列表框
  hDllListCtrl = CreateListCtrl(
                   hwndThis,
                   0x40810605u,
                   gdwIdMapForDllsListColumn,
                   DllColumns,
                   gdwDllsListColumnCount,
                   IDW_DLL_LISTCTRL);
  ghWndDllsListCtrl = hDllListCtrl;
  if ( !hDllListCtrl )
    return -1;
  InitTreeListSortableHeader(hDllListCtrl, -1, gdwDllsListlSortColumnCount, DllSortDirection);
  // 创建状态栏
  ghWndStatusBar = CreateStatusWindowW(0x50000000, gpszTargetName, hwndThis, IDW_STATUSBAR);
  InitStatusBar(ghWndStatusBar);
  ghCursorResizeVert = LoadCursorW(ghInstance, IDC_CURSOR_RESIZE_VERT);
  if ( !ghCursorResizeVert )
    ghCursorResizeVert = LoadCursorW(0, IDC_ARROW);
  ghCursorSplitter = LoadCursorW(ghInstance, IDC_CURSOR_SPLITTER);
  if ( !ghCursorSplitter )
    ghCursorSplitter = LoadCursorW(0, IDC_ARROW);
  v103 = 0;
  if ( gbHighlightRelocatedDlls )
    v103 = MF_CHECKED;
  v104 = v103;
  v105 = ::GetMenu(hwndThis);
  CheckMenuItem(v105, IDS_PROCEXPLORERMENU_HILITE_RELOCATED_DLLS, v104);
  ShowWindow(ghWndTreeListView, SW_SHOW);
  if ( gbShowLowerpane )
  {
    if ( gbShowDllView )
    {
      v106 = ::GetMenu(hWndThis);
      CheckMenuItem(v106, IDS_PROCEXPLORERMENU_LOWER_PANE_VIEW_DLLS, MF_CHECKED);
      ShowWindow(ghWndDllsListCtrl, SW_SHOW);
    }
    else
    {
      v107 = ::GetMenu(hWndThis);
      CheckMenuItem(v107, IDS_PROCEXPLORERMENU_LOWER_PANE_VIEW_HANDLES, MF_CHECKED);
      ShowWindow(ghWndHandlesListCtrl, SW_SHOW);
    }
  }
  v108 = 1;
  if ( gbShowDllView )
    v108 = 4;
  SendMessageW(ghWndToolbar, TB_CHANGEBITMAP, IDM_OTHER_VIEW_HANDLES, v108);
  SendMessageW(ghWndToolbar, TBM_GETRANGEMIN, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, gbShowProcessTree == 0);
  v109 = gbShowProcessTree != 0;
  v110 = ::GetMenu(ghWndNewOwner);
  EnableMenuItem(v110, IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE, v109);
  v111 = ::GetMenu(ghWndNewOwner);
  EnableMenuItem(v111, IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS_TREE, 1u);
  ghSystemInfoSheetThreadEvent = CreateEventW(0, 0, 0, 0);
  GetClientRect(hWndThis, &gRectMainWnd);
  gRectRedrawMainWnd.left = 0;
  gRectMainWnd.top = gRectMainWnd.top - 1 + gnToolbarHeight;
  gRectMainWnd.bottom -= gRectMainWnd.top;
  gRectRedrawMainWnd.top = gRectMainWnd.top + ((gRectMainWnd.bottom - gRectMainWnd.top) * gdSavedDividerCopy);
  gRectRedrawMainWnd.bottom = gRectRedrawMainWnd.top + 7;
  gRectRedrawMainWnd.right = gRectMainWnd.right;
  if ( gbShowLowerpane )
    v112 = *&gdSavedDivider;
  else
    v112 = doubleOnePointZero;
  gdSavedDividerCopy = v112;
  gbShowLowerpane = gbShowLowerpane == 0;
  OnShowLowerPane(0);
  gShellIconMsg = RegisterWindowMessageW(L"TaskbarCreated");
  sub_122B950();
  CTreeList::Initialize(ghWndTreeListView, 1);
  SendMessageW(ghWndNewOwner, PMT_MSG_7E8, IDC_TREELIST, gbShowProcessTree);
  SetFocus(ghWndTreeListView);
  treeListItem.iItem = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, LVIS_SELECTED);
  treeListItem.iSubItem = 0;
  treeListItem.mask = LVIF_PARAM;
  SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &treeListItem);
  sub_12469D0(treeListItem.lParam);
  dllhndListItem.wID = 3;
  dllhndListItem.fState = 3;
  SendMessageW(ghWndDllsListCtrl, LVM_SETITEMSTATE, 0, &dllhndListItem);
  dllhndListItem.wID = 3;
  dllhndListItem.fState = 3;
  SendMessageW(ghWndHandlesListCtrl, LVM_SETITEMSTATE, 0, &dllhndListItem);
  if ( IsBuiltinAndAnministrative() && !CEventTrace::Start(&gEventTraceProperties, 1) )
  {
    InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_COMMIT_HISTORY, 0, 0x9F2Au, L"&Disk History");
    v113 = 0;
    if ( gbShowDiskTray )
      v113 = 8;
    v114 = v113;
    v115 = ::GetMenu(hWndThis);
    CheckMenuItem(v115, 0x9F2Au, v114);
    InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_COMMIT_HISTORY, 0, 0x9F2Bu, L"&Network History");
    v116 = 0;
    if ( gbShowNetTray )
      v116 = 8;
    v117 = v116;
    v118 = ::GetMenu(hWndThis);
    CheckMenuItem(v118, 0x9F2Bu, v117);
  }
  if ( gdwAdapterRuntingTime )
  {
    InsertMenuW(hMainMenu, IDS_PROCEXPLORERMENU_COMMIT_HISTORY, 0, 0x9F2Cu, L"&GPU History");
    hThisWnd = hWndThis;
    v120 = 0;
    if ( gbShowGpuTray )
      v120 = 8;
    v121 = v120;
    v122 = ::GetMenu(hWndThis);
    CheckMenuItem(v122, 0x9F2Cu, v121);
  }
  else
  {
    hThisWnd = hWndThis;
  }
  ghEventRefreshSearchResult = CreateEventW(0, 0, 0, 0);
  ghStartToResumeProcessEvent = CreateEventW(0, 0, 0, 0);
  ghEvent3 = CreateEventW(0, 1, 0, 0);
  ghRefreshEvent = CreateEventW(0, 0, 0, 0);
  ghEvent5 = CreateEventW(0, 1, 0, 0);
  ghEvent6 = CreateEventW(0, 0, 0, 0);
  ghBackupUpdateThreadHandle = _beginthreadex(0, 0, BackupUpdateThreadProc, 0, 0, 0);
  if ( gdwRefreshRateOfSearch > 2000 )
  {
    if ( gdwRefreshRateOfSearch == 5000 )
    {
      uRefreshMenuId = IDS_PROCEXPLORERMENU_FIVE_SECONDS;
      goto LABEL_166;
    }
    if ( gdwRefreshRateOfSearch == 10000 )
    {
      uRefreshMenuId = IDS_PROCEXPLORERMENU_TEN_SECONDS;
      goto LABEL_166;
    }
  }
  else
  {
    if ( gdwRefreshRateOfSearch == 2000 )
    {
      uRefreshMenuId = IDS_PROCEXPLORERMENU_TWO_SECONDS;
      goto LABEL_166;
    }
    if ( gdwRefreshRateOfSearch )
    {
      if ( gdwRefreshRateOfSearch == 500 )
      {
        uRefreshMenuId = IDS_PROCEXPLORERMENU_HALF_SECONDS;
        goto LABEL_166;
      }
      if ( gdwRefreshRateOfSearch == 1000 )
      {
        uRefreshMenuId = IDS_PROCEXPLORERMENU_ONE_SECONDS;
LABEL_166:
        v124 = ::GetMenu(ghWndNewOwner);
        CheckMenuRadioItem(
          v124,
          IDS_PROCEXPLORERMENU_PAUSED_SPACE,
          IDS_PROCEXPLORERMENU_HALF_SECONDS,
          uRefreshMenuId,
          0);
        goto LABEL_167;
      }
    }
    else
    {
      v123 = ::GetMenu(ghWndNewOwner);
      CheckMenuRadioItem(
        v123,
        IDS_PROCEXPLORERMENU_PAUSED_SPACE,
        IDS_PROCEXPLORERMENU_HALF_SECONDS,
        IDS_PROCEXPLORERMENU_PAUSED_SPACE,
        0);
      SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, L"Paused");
    }
  }
LABEL_167:
  InvalidateRect(ghWndToolbar, 0, 1);
  SetCursor(hCursor);
  if ( !gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
    DeleteMenu(hMainMenu, IDS_PROCEXPLORERMENU_IO_HISTORY, 0);
  HandleShellIconMsg();
  v125 = GetModuleHandle(L"Shlwapi.dll");
  SHAutoComplete = GetProcAddress(v125, "SHAutoComplete");
  v126 = LoadLibraryW(L"user32.dll");
  v127 = GetProcAddress(v126, "SetLayeredWindowAttributes");
  dwOpacity = *gdwOpacity;
  SetLayeredWindowAttributes = v127;
  if ( *gdwOpacity != 100 )
  {
    dwExStyle = GetWindowLongW(ghWndNewOwner, GWL_EXSTYLE);
    SetWindowLongW(ghWndNewOwner, GWL_EXSTYLE, dwExStyle | WS_EX_LAYERED);
    SetLayeredWindowAttributes(ghWndNewOwner, 0, 255 * *gdwOpacity / 100, 2);
    RedrawWindow(ghWndNewOwner, 0, 0, 0x485u);
    dwOpacity = *gdwOpacity;
  }
  uMenuId = (((0x66666667i64 * dwOpacity) >> 32) >> 2) + (((0x66666667i64 * dwOpacity) >> 32) >> 31) + 40093;
  hWndThis_ = ::GetMenu(hThisWnd);
  CheckMenuItem(hWndThis_, uMenuId, 8u);
  if ( gbHide1 )
    MainWnd_Hide(ghWndNewOwner);
  return 0;
}
// 128C720: using guessed type int (__stdcall *)(_DWORD);
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCDC0: using guessed type double gdbMaxValue;
// 12C08AC: using guessed type wchar_t aRUnAsAdministr[25];
// 12C0D80: using guessed type wchar_t aPaused[7];
// 12E4E54: using guessed type int gdwOsType;
// 12E5528: using guessed type __int64 gdSavedDivider;
// 12E5740: using guessed type __int16 gwProcessImageColumnWidth;
// 12E5742: using guessed type char gbShowProcessTree;
// 12E598C: using guessed type char gbProcessSortDirection;
// 12E5A5C: using guessed type char DllSortDirection;
// 12E5B28: using guessed type char HandleSortDirection;
// 12E5B2C: using guessed type int gdwNumColumnsets;
// 12E96C2: using guessed type char gbTrayCPUHistory;
// 12E96C3: using guessed type char gbShowCommitTray;
// 12E96C4: using guessed type char gbShowPhysTray;
// 12E96C5: using guessed type char gbShowIoTray;
// 12E96C6: using guessed type char gbShowNetTray;
// 12E96C7: using guessed type char gbShowDiskTray;
// 12E96C8: using guessed type char gbShowGpuTray;
// 12E96C9: using guessed type char gbShowCpuFractions;
// 12E96CA: using guessed type char gbShowUnnamedHandles;
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;
// 12E96CE: using guessed type char gbHighlightRelocatedDlls;
// 12E96CF: using guessed type char gbShowColumnHeatmaps;
// 12E96D0: using guessed type char gbShowAllUsers;
// 12E96D1: using guessed type char gbHideWhenMinimized;
// 12E96D2: using guessed type char gbAlwaysOntop;
// 12E96D3: using guessed type char gbAllOneInstance;
// 12E96D4: using guessed type char gbConfirmKill;
// 12E96D5: using guessed type char gbFormatIoBytes;
// 12E96D7: using guessed type char gbVerifySignatures;
// 12E96D8: using guessed type char gbShowAllCpus;
// 12E96DB: using guessed type char gbShowNewProcesses;
// 12E96E0: using guessed type char gbVirusTotalCheck;
// 12E9B08: using guessed type int ColorOwn;
// 12E9B0C: using guessed type int ColorServices;
// 12E9B10: using guessed type int ColorRelocatedDlls;
// 12E9B14: using guessed type int gColorJobs_0;
// 12E9B18: using guessed type int gColorNet;
// 12EA32C: using guessed type int gMSGCommdlg_FindReplace;
// 12EA388: using guessed type char gbHide1;
// 12EA390: using guessed type char gbProcessDEPStatus;
// 12EA391: using guessed type char gbWintrustInited;
// 12EA392: using guessed type char gbLaunchDepends;
// 12EA884: using guessed type int gShellIconMsg;
// 12EA8EC: using guessed type int (__stdcall *SetLayeredWindowAttributes)(_DWORD, _DWORD, _DWORD, _DWORD);
// 12EA8F4: using guessed type int (__stdcall *SHAutoComplete)(_DWORD, _DWORD);
// 12EA908: using guessed type int ghCursorSplitter;
// 12EF354: using guessed type int (__stdcall *WTSFreeMemory)(_DWORD);
// 12EF360: using guessed type int (__stdcall *ChangeWindowMessageFilter)(_DWORD, _DWORD);
// 1305720: using guessed type int gdwStatusBarCount;

//----- (012557D0) --------------------------------------------------------
int __cdecl HandleClose(HWND hWnd)
{
  if ( gbHideWhenMinimized )
    MainWnd_Hide(ghWndNewOwner);
  else
    HandleDestroy(hWnd);
  return 0;
}
// 12E96D1: using guessed type char gbHideWhenMinimized;

//----- (01255810) --------------------------------------------------------
int HandleEndSession()
{
  CMainWnd::Reset(ghWndNewOwner, 1);
  return 0;
}

//----- (01255830) --------------------------------------------------------
int __cdecl HandleDestroy(HWND hWnd)
{
  signed int v1; // esi
  HANDLE v2; // eax

  ShowWindow(hWnd, 0);
  CMainWnd::Reset(ghWndNewOwner, 1);
  v1 = 1;
  do
    RemoveShellIcon(hWnd, v1++);
  while ( v1 < 8 );
  SetEvent(ghEvent3);
  CEventTrace::Start(&gEventTraceProperties, 0);
  TerminateThread(ghBackupUpdateThreadHandle, 0);
  v2 = GetCurrentProcess();
  TerminateProcess(v2, 0);
  PostQuitMessage(0);
  return 0;
}

//----- (012558B0) --------------------------------------------------------
int __cdecl HandleDrawItem(int a1, int a2, int a3, int a4)
{
  if ( *a4 != 1 )
    return FindDlg_DrawItem(a4);
  DrawIconEx(*(a4 + 24), *(a4 + 28) - 15, *(a4 + 32), *(a4 + 44), 16, 16, 0, 0, 3u);
  return 0;
}

//----- (012558F0) --------------------------------------------------------
MACRO_BOOL __cdecl HandleSetFocus(HWND a1)
{
  MACRO_BOOL result; // eax

  gdwTickCountLast = GetTickCount();
  if ( ghWndFocus )
  {
    SetFocus(ghWndFocus);
    result = 1;
  }
  else if ( a1 == ghWndNewOwner )
  {
    SetFocus(ghWndTreeListView);
    result = TRUE;
  }
  else
  {
    result = FALSE;
  }
  return result;
}
// 12EA380: using guessed type int gdwTickCountLast;

//----- (01255940) --------------------------------------------------------
LRESULT __cdecl HandleContextMenu(HWND hWnd, UINT msg, HWND hWndContext, LPARAM pt)
{
  UINT nId; // edi
  int item; // eax
  HWND hWndMsg; // [esp+8h] [ebp-48h]
  POINT point; // [esp+34h] [ebp-1Ch]
  RECT rcItem; // [esp+3Ch] [ebp-14h]

  if ( hWndContext == ghWndTreeListView )
  {
    nId = IDC_TREELIST;
  }
  else if ( hWndContext == ghWndHandlesListCtrl )
  {
    nId = IDW_HANDLES_LISTCTRL;
  }
  else
  {
    if ( hWndContext != ghWndDllsListCtrl )
      return DefWindowProcW(hWnd, msg, hWndContext, pt);
    nId = IDW_DLL_LISTCTRL;
  }
  hWndMsg = hWnd;
  point.x = pt;
  point.y = SHIWORD(pt);
  if ( pt != -1 )
    return 0;
  item = SendMessageW(hWndContext, LVM_GETNEXTITEM, pt, LVIS_SELECTED);
  if ( item != -1 )
  {
    rcItem.left = 0;
    SendMessageW(hWndContext, LVM_GETITEMRECT, item, &rcItem);
    point.y = rcItem.bottom;
    point.x = rcItem.left + 10;
    ClientToScreen(hWndContext, &point);
  }
  return OnTreeListRClick(nId, &hWndMsg, &point);
}

//----- (01255A40) --------------------------------------------------------
int __cdecl OnMessage7EF(int a1, int a2, int a3, void *wParam)
{
  RemoveTreeListItemParam(wParam);
  return 0;
}

//----- (01255A60) --------------------------------------------------------
int __cdecl sub_1255A60(int a1, int a2, int a3, const wchar_t **a4)
{
  #1077 *v4; // esi
  char v5; // cl
  #1077 *v6; // ebx
  const wchar_t *v7; // eax
  wchar_t *v8; // eax
  const wchar_t *v9; // eax
  LVITEMUSERDATA *v10; // esi
  char v11; // bl
  const wchar_t *v12; // eax
  char v14; // [esp+Bh] [ebp-1h]

  v4 = gpTreeListParamList;
  v5 = 0;
  v6 = 0;
  v14 = 0;
  if ( !gpTreeListParamList )
    return 0;
  do
  {
    v7 = *(v4 + 198);
    if ( *(v4 + 17) == g_dwProcessId )
      v6 = v4;
    if ( v7 )
    {
      if ( _wcsicmp(v7, a4[1]) || _wcsicmp(L"system", *a4) && _wcsicmp(*(v4 + 22), *a4) )
      {
        v5 = v14;
      }
      else
      {
        v8 = _wcsdup(a4[2]);
        v5 = 1;
        *(v4 + 207) = v8;
        v14 = 1;
      }
    }
    v4 = *(v4 + 364);
  }
  while ( v4 );
  if ( v5 )
  {
    if ( ColumnIDIsIllegal(1, ghWndTreeListView, 1656, 0) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      sub_123FAA0(0x65);
    }
    else if ( IsIllegalID(ghWndTreeListView, 1656) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
    }
  }
  if ( v6 )
  {
    if ( IsWindowVisible(ghWndDllsListCtrl) )
    {
      if ( !_wcsicmp(L"system", *a4) || (v9 = *(v6 + 22)) != 0 && !_wcsicmp(v9, *a4) )
      {
        v10 = gpUserDataInVerifySignature;
        v11 = 0;
        if ( gpUserDataInVerifySignature )
        {
          do
          {
            v12 = v10->szPathName;
            if ( v12 && !_wcsicmp(v12, a4[1]) )
            {
              v10->field_15C = _wcsdup(a4[2]);
              v11 = 1;
            }
            v10 = v10->Prev;
          }
          while ( v10 );
          if ( v11 )
          {
            InvalidateRect(ghWndDllsListCtrl, 0, 0);
            sub_123FAA0(0x68);
          }
        }
      }
    }
  }
  return 0;
}

//----- (01255C10) --------------------------------------------------------
int __cdecl sub_1255C10(int a1, int a2, int a3, HWND hWnd)
{
  InvalidateRect(hWnd, 0, 0);
  return 0;
}

//----- (01255C30) --------------------------------------------------------
HWND __stdcall GetFocus_0()
{
  ghWndFocus = GetFocus();
  return 1;
}

//----- (01255C50) --------------------------------------------------------
int __cdecl sub_1255C50(int a1, int a2, int a3, #1077 *TreeListItemData)
{
  if ( *(TreeListItemData + 1) )
  {
    if ( *(TreeListItemData + 89) )
      free(*(TreeListItemData + 89));
    *(TreeListItemData + 89) = _wcsdup(*(TreeListItemData + 90));
    if ( IsIllegalID(ghWndDllsListCtrl, IDD_PAGE_MEMORY_PAGING_LISTS_STANDBY_PRORITY_5_NAME) )
      InvalidateRect(ghWndDllsListCtrl, 0, 0);
  }
  else
  {
    if ( *(TreeListItemData + 209) )
      free(*(TreeListItemData + 209));
    *(TreeListItemData + 209) = _wcsdup(*(TreeListItemData + 210));
    if ( ColumnIDIsIllegal(1, ghWndTreeListView, 1187, 0) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      sub_123FAA0(0x65);
      return 0;
    }
    if ( IsIllegalID(ghWndTreeListView, 1187) )
    {
      InvalidateRect(ghWndTreeListView, 0, 0);
      return 0;
    }
  }
  return 0;
}

//----- (01255D40) --------------------------------------------------------
#1077 *__cdecl sub_1255D40(int a1, int a2, int a3, int a4)
{
  LRESULT v4; // esi
  #1077 *v5; // ebx

  v4 = -1;
  if ( !gbShowNewProcesses )
  {
    v4 = SendMessageW(ghWndTreeListView, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
    if ( !SendMessageW(ghWndTreeListView, LVM_ISITEMVISIBLE, v4, 0) )
      v4 = -1;
  }
  v5 = sub_1237BC0(ghWndTreeListView, a4);
  if ( v4 != -1 )
    SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, v4, 0);
  return v5;
}
// 12E96DB: using guessed type char gbShowNewProcesses;

//----- (01255DC0) --------------------------------------------------------
int __cdecl HandleInitMenuPopup(int a1, int a2, HMENU hMenu)
{
  UINT nIndex; // esi
  unsigned int iUser; // esi
  int idx; // ebx
  HMENU hMenuUsers; // esi
  UINT_PTR hMenuUsers1; // ST0C_4
  UINT nPos; // esi
  MENUINFO mi; // [esp+0h] [ebp-244h]
  DWORD pdwBytesReturned; // [esp+1Ch] [ebp-228h]
  UINT uPosition; // [esp+20h] [ebp-224h]
  LPTSTR szDomainName; // [esp+24h] [ebp-220h]
  unsigned int Index; // [esp+28h] [ebp-21Ch]
  LPTSTR szUserName; // [esp+2Ch] [ebp-218h]
  int nCount; // [esp+30h] [ebp-214h]
  _WTS_SESSION_INFO *ppSessionInfo; // [esp+34h] [ebp-210h]
  __int16 NewItem[260]; // [esp+38h] [ebp-20Ch]

  if ( hMenu != ghMenuUsers )
    return FALSE;
  nCount = GetMenuItemCount(ghMenuUsers);
  nIndex = nCount - 1;
  if ( nCount )
  {
    do
      DeleteMenu(ghMenuUsers, nIndex--, MF_BYPOSITION);
    while ( nIndex != -1 );
  }
  if ( WTSEnumerateSessionsW(NULL, NULL, 1u, &ppSessionInfo, &nCount) )
  {
    iUser = 0;
    uPosition = 0;
    Index = 0;
    if ( nCount )
    {
      idx = 0;
      do
      {
        if ( WTSQuerySessionInformationW(
               NULL,
               ppSessionInfo[idx].SessionId,
               WTSUserName,
               &szUserName,
               &pdwBytesReturned) )
        {
          if ( WTSQuerySessionInformationW(
                 NULL,
                 ppSessionInfo[idx].SessionId,
                 WTSDomainName,
                 &szDomainName,
                 &pdwBytesReturned) )
          {
            if ( *szUserName )
            {
              stprintf(NewItem, L"%d: %s\\%s", ppSessionInfo[idx].SessionId, szDomainName, szUserName);
              hMenuUsers = LoadMenuW(ghInstance, L"USERS");
              mi.cbSize = 28;
              mi.fMask = 0x80000018;            // MIM_APPLYTOSUBMENUS|MIM_MENUDATA|MIM_STYLE
              mi.dwStyle = MNS_NOTIFYBYPOS;
              mi.dwMenuData = ppSessionInfo[idx].SessionId;
              SetMenuInfo(hMenuUsers, &mi);
              switch ( ppSessionInfo[idx].State )
              {
                case WTSActive:
                case WTSShadow:
                  break;
                case WTSConnected:
                  EnableMenuItem(hMenuUsers, IDM_POPUP_USERS_CONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDM_POPUP_USERS_LOGOFF, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDM_POPUP_USERS_SEND_MESSAGE, MF_GRAYED);
                  break;
                case WTSDisconnected:
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_DISCONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_SEND_MESSAGE, MF_GRAYED);
                  break;
                default:
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_CONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_SEND_MESSAGE, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_LOGOFF, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_DISCONNECT, MF_GRAYED);
                  EnableMenuItem(hMenuUsers, IDS_USERSMENU_REMOTE_CONTROL, MF_GRAYED);
                  break;
              }
              hMenuUsers1 = hMenuUsers;
              nPos = uPosition;
              InsertMenuW(ghMenuUsers, uPosition, 0x410u, hMenuUsers1, NewItem);
              uPosition = nPos + 1;
              iUser = Index;
            }
            WTSFreeMemory(szDomainName);
          }
          WTSFreeMemory(szUserName);
        }
        ++iUser;
        ++idx;
        Index = iUser;
      }
      while ( iUser < nCount );
    }
    WTSFreeMemory(ppSessionInfo);
  }
  return FALSE;
}
// 12EF354: using guessed type int (__stdcall *WTSFreeMemory)(_DWORD);

//----- (01256050) --------------------------------------------------------
LRESULT __cdecl HandleMenuCommand(HWND hWnd, int uMsg, WPARAM nPos, LPARAM hMenu)
{
  WPARAM nMenuId; // eax
  WPARAM wMenuId; // esi
  LRESULT result; // eax
  DWORD res; // eax
  CComBSTR *v8; // eax
  const WCHAR *bstrPassword; // eax
  char v10; // bl
  DWORD v11; // eax
  CREDUI_INFO ReduiInfo; // [esp+Ch] [ebp-458h]
  tagMENUINFO mii; // [esp+20h] [ebp-444h]
  WCHAR *pszUserName; // [esp+3Ch] [ebp-428h]
  BSTR *bstrError; // [esp+40h] [ebp-424h]
  BOOL fSave; // [esp+44h] [ebp-420h]
  DWORD pSessionId; // [esp+48h] [ebp-41Ch]
  DWORD nSize; // [esp+4Ch] [ebp-418h]
  TCHAR Buffer[260]; // [esp+50h] [ebp-414h]
  TCHAR szPassword[260]; // [esp+258h] [ebp-20Ch]

  *szPassword = 0;
  memset(&szPassword[2], 0, 0x206u);
  nMenuId = GetMenuItemID(hMenu, nPos);
  wMenuId = nMenuId;
  if ( nMenuId != IDS_USERSMENU_DISCONNECT
    && nMenuId != IDS_USERSMENU_LOGOFF
    && nMenuId != IDS_USERSMENU_SEND_MESSAGE
    && nMenuId != IDS_USERSMENU_PROPERTIES
    && nMenuId != IDS_USERSMENU_CONNECT
    && nMenuId != IDS_USERSMENU_REMOTE_CONTROL )
  {
    return MSGHANDLER::HandleCommand(&gNormalWindowCmdHandler, hWnd, nMenuId, 0);
  }
  mii.cbSize = 0x1C;
  mii.fMask = MF_CHECKED;
  GetMenuInfo(hMenu, &mii);
  switch ( wMenuId )
  {
    case IDS_USERSMENU_DISCONNECT:
      if ( WTSDisconnectSession(0, mii.dwMenuData, 0) )
        goto LABEL_32;
      ErrMsgBox(L"Error disconnecting session", ghWndNewOwner);
      return 0;
    case IDS_USERSMENU_LOGOFF:
      if ( WTSLogoffSession(0, mii.dwMenuData, 0) )
        goto LABEL_32;
      ErrMsgBox(L"Error logging off session", ghWndNewOwner);
      return 0;
    case IDS_USERSMENU_SEND_MESSAGE:
      DialogBoxParamW(ghInstance, L"SENDMESSAGE", ghWndNewOwner, SendMessageDlgProc, mii.dwMenuData);
      goto LABEL_32;
    case IDS_USERSMENU_PROPERTIES:
      DialogBoxParamW(ghInstance, L"TSINFO", ghWndNewOwner, TsInfoDlgProc, mii.dwMenuData);
      goto LABEL_32;
    case IDS_USERSMENU_CONNECT:
      // BOOL WTSQuerySessionInformation(
      //   _In_  HANDLE         hServer,
      //   _In_  DWORD          SessionId,
      //   _In_  WTS_INFO_CLASS WTSInfoClass,
      //   _Out_ LPTSTR         *ppBuffer,
      //   _Out_ DWORD          *pBytesReturned
      // );
      if ( WTSQuerySessionInformationW(NULL, mii.dwMenuData, WTSUserName, &pszUserName, &nSize) )
      {
        ReduiInfo.hwndParent = hWnd;
        fSave = 0;
        ReduiInfo.cbSize = 20;
        ReduiInfo.pszMessageText = L"Enter the selected user's password";
        ReduiInfo.pszCaptionText = L"Process Explorer Connect Password";
        ReduiInfo.hbmBanner = 0;
        do
        {
          res = CredUIPromptForCredentialsW(
                  &ReduiInfo,
                  gpszTargetName,
                  NULL,
                  ERROR_LOGON_FAILURE,
                  pszUserName,
                  nSize,
                  szPassword,
                  _MAX_PATH,
                  &fSave,
                  0x140082u);
          if ( !res )
          {
            v8 = *bstr_t::EqualAssign(&bstrError, szPassword);
            if ( v8 )
              bstrPassword = v8->bstr;
            else
              bstrPassword = 0;
            v10 = WinStationConnectW(STATUS_SUCCESS, mii.dwMenuData, 0xFFFFFFFF, bstrPassword, 1u);
            bstr_t::Data_t::Free(&bstrError);
            if ( v10 )
              goto LABEL_32;
            res = GetLastError();
          }
        }
        while ( res == ERROR_LOGON_FAILURE );
      }
      else
      {
        res = GetLastError();
      }
      if ( !res )
        goto LABEL_32;
      SetLastError(res);
      ErrMsgBox(L"Error connecting to session", ghWndNewOwner);
      result = 0;
      break;
    case IDS_USERSMENU_REMOTE_CONTROL:
      v11 = GetCurrentProcessId();
      ProcessIdToSessionId(v11, &pSessionId);
      if ( WTSGetActiveConsoleSessionId() == pSessionId )
      {
        ErrMsgBox(L"Remote control is not supported from a console session", ghWndNewOwner);
        result = 0;
      }
      else
      {
        nSize = 260;
        GetComputerNameW(Buffer, &nSize);
        if ( WinStationShadow(0, Buffer, mii.dwMenuData, 112, 2) )
        {
LABEL_32:
          result = 0;
        }
        else
        {
          ErrMsgBox(L"Error starting remote control", ghWndNewOwner);
          result = 0;
        }
      }
      break;
    default:
      goto LABEL_32;
  }
  return result;
}
// 12C0F50: using guessed type wchar_t aEnterTheSelect[35];
// 12C0F98: using guessed type wchar_t aProcessExplore_5[34];
// 12C10F8: using guessed type wchar_t aSendmessage[12];
// 12EF334: using guessed type int (__stdcall *WTSDisconnectSession)(_DWORD, _DWORD, _DWORD);
// 12EF33C: using guessed type int (__stdcall *WinStationShadow)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF34C: using guessed type int (__stdcall *WTSLogoffSession)(_DWORD, _DWORD, _DWORD);

//----- (01256470) --------------------------------------------------------
signed int __cdecl HandleCopyData(int a1, int a2, int hwnd, PCOPYDATASTRUCT lParam)
{
  #1077 *pTreeListParamList; // esi
  signed int ret; // esi
  CStringData *v6; // edi
  CStringData *szImageName; // [esp+8h] [ebp-34h]
  WINDOWPLACEMENT wndpl; // [esp+Ch] [ebp-30h]

  pTreeListParamList = gpTreeListParamList;
  ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(
    &szImageName,
    lParam->lpData,
    lParam->cbData);
  if ( pTreeListParamList )
  {
    while ( _wcsicmp(*(pTreeListParamList + 15), szImageName) )
    {
      pTreeListParamList = *(pTreeListParamList + 364);
      if ( !pTreeListParamList )
        goto LABEL_4;
    }
    StartProcessPropSheet(pTreeListParamList);
    if ( !IsWindowVisible(ghWndNewOwner) )
    {
      wndpl.length = 44;
      GetWindowPlacement(ghWndNewOwner, &wndpl);
      ShowWindow(ghWndNewOwner, 4 * (wndpl.showCmd == SW_SHOWMINIMIZED) + SW_SHOW);
      SetForegroundWindow(ghWndNewOwner);
      SetFocus(ghWndNewOwner);
      gbProcessExplorerShow = TRUE;
      gbProcessExplorerHide = FALSE;
    }
    ret = 2;
  }
  else
  {
LABEL_4:
    ret = 1;
  }
  v6 = szImageName - 1;
  if ( _InterlockedDecrement(&szImageName[-1].nRefs) <= 0 )
    (v6->pStringMgr->vtptr->Free)(v6);
  return ret;
}
// 12EA389: using guessed type char gbProcessExplorerHide;
// 12EA393: using guessed type char gbProcessExplorerShow;

//----- (01256570) --------------------------------------------------------
int __cdecl sub_1256570(int a1, int a2, int a3, int a4)
{
  CTreeList *v4; // eax
  HICON v5; // ST08_4
  _IMAGELIST *v6; // eax

  v4 = GetTreeListCtrl(ghWndTreeListView);
  if ( *(a4 + 52) )
  {
    v5 = *(a4 + 52);
    v6 = CTreeList::GetImageIcon(v4);
    *(a4 + 64) = ImageList_ReplaceIcon(v6, -1, v5);
  }
  else
  {
    *(a4 + 64) = 0;
  }
  return 0;
}

//----- (012565C0) --------------------------------------------------------
int __cdecl OnMessage7E8(int a1, int a2, HWND uId)
{
  HWND hListCtrl; // esi
  LRESULT item; // edi

  if ( uId == IDC_TREELIST )
  {
    hListCtrl = ghWndTreeListView;
  }
  else if ( uId == IDW_HANDLES_LISTCTRL )
  {
    hListCtrl = ghWndHandlesListCtrl;
  }
  else if ( (uId + 0xFFFFFF9A) == 2 )           // uId=104 //IDW_DLLS_LISTCTRL
  {
    hListCtrl = ghWndDllsListCtrl;
  }
  else
  {
    hListCtrl = uId;
  }
  item = -1;
  if ( !gbShowNewProcesses )
  {
    item = SendMessageW(hListCtrl, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
    if ( !SendMessageW(hListCtrl, LVM_ISITEMVISIBLE, item, 0) )
      item = -1;
  }
  if ( uId == IDC_TREELIST )
    sub_1276020(gpTreeListParamList);
  sub_123FAA0(uId);
  if ( item != -1 )
    SendMessageW(hListCtrl, LVM_ENSUREVISIBLE, item, 0);
  return 0;
}
// 12E96DB: using guessed type char gbShowNewProcesses;

//----- (01256660) --------------------------------------------------------
int __cdecl sub_1256660(HWND hWnd, int a2, int a3, int a4)
{
  HMENU v4; // eax
  HMENU v5; // eax
  int v6; // ST14_4
  HMENU v7; // edi
  HMENU v8; // eax
  HMENU v9; // eax
  HMENU v10; // eax
  HMODULE v12; // eax
  void (*v13)(void); // eax
  struct tagPOINT Point; // [esp+4h] [ebp-38h]
  WINDOWPLACEMENT wndpl; // [esp+Ch] [ebp-30h]

  if ( a4 == 123 )
    goto LABEL_4;
  if ( a4 != 513 )
  {
    if ( a4 != 517 )
      return 0;
LABEL_4:
    GetCursorPos(&Point);
    SetForegroundWindow(hWnd);
    v4 = LoadMenuW(ghInstance, L"TRAYMENU");
    v5 = GetSubMenu(v4, 0);
    v6 = gnFileMenuPosLast;
    v7 = v5;
    v8 = GetMenu(hWnd);
    v9 = GetSubMenu(v8, 0);
    v10 = GetSubMenu(v9, v6);
    InsertMenuW(v7, 0, 0x410u, v10, L"S&hutdown");
    TrackPopupMenu(v7, 0, Point.x, Point.y, 0, hWnd, 0);
    return 0;
  }
  v12 = GetModuleHandle(L"user32.dll");
  v13 = GetProcAddress(v12, "EndMenu");
  if ( v13 )
    v13();
  else
    SendMessageW(hWnd, 0x1Fu, 0, 0);
  wndpl.length = 44;
  GetWindowPlacement(ghWndNewOwner, &wndpl);
  if ( !IsWindowVisible(ghWndNewOwner) || wndpl.showCmd == 2 )
  {
LABEL_14:
    gbProcessExplorerShow = 1;
    OnShowProcessExplorer();
    return 0;
  }
  if ( sub_1257A60(ghWndTreeListView) )
  {
    if ( gbHideWhenMinimized )
    {
      MainWnd_Hide(ghWndNewOwner);
      return 0;
    }
    goto LABEL_14;
  }
  SetForegroundWindow(ghWndNewOwner);
  return 0;
}
// 12E96D1: using guessed type char gbHideWhenMinimized;
// 12EA393: using guessed type char gbProcessExplorerShow;

//----- (012567F0) --------------------------------------------------------
LRESULT __cdecl HandleSysCommand(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  if ( !gbHideWhenMinimized || wParam != 61472 )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  gbProcessExplorerHide = 1;
  MainWnd_Hide(hWnd);
  return 0;
}
// 12E96D1: using guessed type char gbHideWhenMinimized;
// 12EA389: using guessed type char gbProcessExplorerHide;

//----- (01256830) --------------------------------------------------------
int __cdecl sub_1256830(int a1, int a2, WPARAM wParam, WPARAM nItem)
{
  HWND *v4; // eax
  int result; // eax
  RECT Rect; // [esp+0h] [ebp-14h]

  if ( wParam == -2 )
  {
    v4 = GetTreeListCtrl(ghWndTreeListView);
    sub_121EA60(v4, nItem);
    result = 0;
  }
  else
  {
    if ( nItem == -1 )
    {
      SendMessageW(ghWndTreeListView, 0x1015u, wParam, wParam);
    }
    else
    {
      GetListItemRect(ghWndTreeListView, wParam, nItem, &Rect);
      Rect.right += Rect.left;
      Rect.bottom += Rect.top;
      InvalidateRect(ghWndTreeListView, &Rect, 0);
    }
    result = 0;
  }
  return result;
}

//----- (012568E0) --------------------------------------------------------
int sub_12568E0(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x410u, Format, ArgList);
}

//----- (01256900) --------------------------------------------------------
// CStringT::CStringT(PXCHAR psz,UINT nLength)
CStringData **__thiscall ATL::CStringT<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(CString *res, LPCSTR psz, int nLength)
{
  CString *str; // esi
  CAtlStringMgr *v4; // ecx
  int nLen; // eax
  int nDataLength; // edi

  str = res;
  // CString str;
  v4 = ATL::CAtlStringMgr::GetInstance();
  if ( !v4 )
    AtlThrow(E_FAIL);
  // CString::Attach(psz)
  str->m_pszData = ((v4->vtptr->GetNilString)() + 16);
  // 初始化
  if ( nLength > 0 )
  {
    // CString::operator=(PXCHAR psz)
    if ( !psz )
      goto __Error;
    // StringTraits::GetBaseTypeLength( psz )
    nLen = MultiByteToWideChar(CP_THREAD_ACP, 0, psz, nLength, 0, 0);
    nDataLength = nLen;
    // PXSTR PrepareWrite(_In_ int nLength)
    if ( nLen < 0 )
      AtlThrow(E_INVALIDARG);
    // CStringData* GetData()
    if ( ((str->m_pszData[-1].nAllocLength - nLen) | (1 - str->m_pszData[-1].nRefs)) < 0 )
      ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(&str->m_pszData, nLen);
    MultiByteToWideChar(CP_THREAD_ACP, 0, psz, nLength, str->m_pszData, nDataLength);
    if ( nDataLength > str->m_pszData[-1].nAllocLength )
__Error:
      AtlThrow(E_INVALIDARG);
    str->m_pszData[-1].nDataLength = nDataLength;
    *(&str->m_pszData->pStringMgr + nDataLength) = 0;
  }
  return str;
}

//----- (012569F0) --------------------------------------------------------
HBRUSH __stdcall ChooseColorDlgProc(HWND hDlg, UINT a2, WPARAM hdc, LPARAM hWnd)
{
  COLORREF v4; // esi
  HBRUSH result; // eax
  COLORREF v6; // esi
  BOOL v7; // ST08_4
  BOOL v8; // ST08_4
  BOOL v9; // ST08_4
  BOOL v10; // ST08_4
  BOOL v11; // ST08_4
  BOOL v12; // ST08_4
  BOOL v13; // ST08_4
  BOOL v14; // ST08_4
  BOOL v15; // ST08_4
  BOOL v16; // ST08_4
  UINT v17; // eax
  UINT v18; // eax
  UINT v19; // eax
  UINT v20; // eax
  UINT v21; // eax
  UINT v22; // eax
  UINT v23; // eax
  UINT v24; // eax
  UINT v25; // eax
  UINT v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // eax
  HWND v35; // eax
  HWND v36; // eax
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax

  if ( a2 == WM_INITDIALOG )
  {
    gColorOwnProcesses = ColorOwn;
    gColorServices = ColorServices;
    gColorRelocatedDlls = ColorRelocatedDlls;
    gColorJobs = gColorJobs_0;
    gColorNetProcesses = gColorNet;
    gColorNewObjects = gColorNewProc;
    gColorDeleteObects = gColorDeleteObjects;
    gColorPackedImages = ColorPacked;
    gColorGraphBackground = gColorGraphBackground;
    gColorImmersiveProcess = ColorImmersive;
    gColorThreadId = gColorSuspend;
    gColorKernelTime = gColorProtected;
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX2, gbHighlightDelProc != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX1, gbHighlightNewProc != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX3, gbHighlightOwnProcesses != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX4, gbHighlightServices != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX7, gbHighlightRelocatedDlls != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX6, gbHighlightPacked != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX5, gbHighlightSuspend != 0);
    CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX11, gbHighlightProtected != 0);
    v27 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX10);
    EnableWindow(v27, 0);
    if ( gdwOsType >= 1 && IsBuiltinAndAnministrative() )
    {
      v28 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX11);
      EnableWindow(v28, 1);
      v29 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_PROTECTED_PROCESS);
      EnableWindow(v29, 1);
      v30 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_CHANGE13);
      EnableWindow(v30, 1);
    }
    if ( *IsProcessInJob )
    {
      v31 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX8);
      EnableWindow(v31, 1);
      v32 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_CHANGE9);
      EnableWindow(v32, 1);
      CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX8, gbHighlightJobs != 0);
    }
    v33 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_JOBS);
    EnableWindow(v33, 1);
    if ( IsImmersiveProcess )
    {
      v34 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX10);
      EnableWindow(v34, 1);
      v35 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_CHANGE11);
      EnableWindow(v35, 1);
      CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX10, gbHighlightImmersive != 0);
    }
    v36 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_IMMERSIVE_PROCESS);
    EnableWindow(v36, 1);
    if ( gbDotNetProcess )
    {
      v37 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX9);
      EnableWindow(v37, 1);
      v38 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_BUTTON_CHANGE10);
      EnableWindow(v38, 1);
      CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX9, gbHighlightNetProcess != 0);
    }
    v39 = GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_NET_PROCESSES);
    EnableWindow(v39, 1);
    result = 1;
  }
  else
  {
    if ( a2 != WM_COMMAND )
    {
      if ( a2 == WM_CTLCOLORSTATIC )
      {
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_OWN_PROCESSES) )
        {
          SetBkColor(hdc, gColorOwnProcesses);
          v4 = gColorOwnProcesses;
          if ( ghbrOwnProcesses )
            DeleteObject(ghbrOwnProcesses);
          result = CreateSolidBrush(v4);
          ghbrOwnProcesses = result;
          return result;
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_IMMERSIVE_PROCESS) )
        {
          SetBkColor(hdc, gColorImmersiveProcess);
          v6 = gColorImmersiveProcess;
          if ( ghbrImmersiveProcess )
            DeleteObject(ghbrImmersiveProcess);
          result = CreateSolidBrush(v6);
          ghbrImmersiveProcess = result;
          return result;
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_SERVICES) )
        {
          SetBkColor(hdc, gColorServices);
          return CreateBrush(gColorServices, &ghbrServices);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_GRAPH_BACKGROUND) )
        {
          SetTextColor(hdc, 255 - gColorGraphBackground);
          SetBkColor(hdc, gColorGraphBackground);
          return CreateBrush(gColorGraphBackground, &ghbrGraphBackground);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_RELOCATED_DLLS) )
        {
          SetBkColor(hdc, gColorRelocatedDlls);
          return CreateBrush(gColorRelocatedDlls, &ghbrRelocatedDlls);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_PACKED_IMAGES) )
        {
          SetBkColor(hdc, gColorPackedImages);
          return CreateBrush(gColorPackedImages, &ghbrPackedImage);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_SUSPENDED_PROCESSES) )
        {
          SetBkColor(hdc, gColorThreadId);
          return CreateBrush(gColorThreadId, &ghbrThreadId);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_JOBS) )
        {
          SetBkColor(hdc, gColorJobs);
          return CreateBrush(gColorJobs, &ghbrJobs);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_NET_PROCESSES) )
        {
          SetBkColor(hdc, gColorNetProcesses);
          return CreateBrush(gColorNetProcesses, &ghbrNetProcesses);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_NEW_OBJECTS) )
        {
          SetBkColor(hdc, gColorNewObjects);
          return CreateBrush(gColorNewObjects, &ghbrNewObjects);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_DELETED_OBJECTS) )
        {
          SetBkColor(hdc, gColorDeleteObects);
          return CreateBrush(gColorDeleteObects, &ghbrDeletedObjects);
        }
        if ( hWnd == GetDlgItem(hDlg, IDD_CHOOSECOLORS_STATIC_PROTECTED_PROCESS) && IsWindowEnabled(hWnd) )
        {
          SetBkColor(hdc, gColorKernelTime);
          return CreateBrush(gColorKernelTime, &ghbrDeletedObjects);
        }
      }
      return 0;
    }
    if ( !(hdc >> 16) )
    {
      switch ( hdc )
      {
        case IDD_CHOOSECOLORS_STATIC_OWN_PROCESSES:
          v7 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX3) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX3, v7);
          break;
        case IDD_CHOOSECOLORS_STATIC_SERVICES:
          v8 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX4) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX4, v8);
          break;
        case IDD_CHOOSECOLORS_STATIC_RELOCATED_DLLS:
          v10 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX7) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX7, v10);
          break;
        case IDD_CHOOSECOLORS_STATIC_JOBS:
          v11 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX8) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX8, v11);
          break;
        case IDD_CHOOSECOLORS_STATIC_NET_PROCESSES:
          v12 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX9) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX9, v12);
          break;
        case IDD_CHOOSECOLORS_STATIC_DELETED_OBJECTS:
          v15 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX2) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX2, v15);
          break;
        case IDD_CHOOSECOLORS_STATIC_NEW_OBJECTS:
          v14 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX1) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX1, v14);
          break;
        case IDD_CHOOSECOLORS_STATIC_PACKED_IMAGES:
          v9 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX6) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX6, v9);
          break;
        case IDD_CHOOSECOLORS_STATIC_SUSPENDED_PROCESSES:
          v13 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX5) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX5, v13);
          break;
        case IDC_ABOUTDLG_STATIC_HOMEPAGE:
          v16 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX11) != 1;
          CheckDlgButton(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX11, v16);
          break;
        default:
          break;
      }
    }
    if ( hdc <= IDD_CHOOSECOLORS_BUTTON_CHANGE4 )
    {
      switch ( hdc )
      {
        case IDD_CHOOSECOLORS_BUTTON_CHANGE4:
          return SelectColor(hDlg, &gColorOwnProcesses);
        case IDD_CHOOSECOLORS_BUTTON_OK:
          gColorJobs_0 = gColorJobs;
          DeleteObject(ghbrJobs);
          v17 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX8);
          ColorRelocatedDlls = gColorRelocatedDlls;
          gbHighlightJobs = v17 == 1;
          DeleteObject(ghbrRelocatedDlls);
          v18 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX7);
          ColorOwn = gColorOwnProcesses;
          gbHighlightRelocatedDlls = v18 == 1;
          DeleteObject(ghbrOwnProcesses);
          v19 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX3);
          ColorServices = gColorServices;
          gbHighlightOwnProcesses = v19 == 1;
          DeleteObject(ghbrServices);
          v20 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX4);
          gColorNet = gColorNetProcesses;
          gbHighlightServices = v20 == 1;
          DeleteObject(ghbrNetProcesses);
          v21 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX9);
          gColorSuspend = gColorThreadId;
          gbHighlightNetProcess = v21 == 1;
          DeleteObject(ghbrThreadId);
          v22 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX5);
          gColorNewProc = gColorNewObjects;
          gbHighlightSuspend = v22 == 1;
          DeleteObject(ghbrNewObjects);
          v23 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX1);
          gColorDeleteObjects = gColorDeleteObects;
          gbHighlightNewProc = v23 == 1;
          DeleteObject(ghbrDeletedObjects);
          v24 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX2);
          ColorPacked = gColorPackedImages;
          gbHighlightDelProc = v24 == 1;
          DeleteObject(ghbrPackedImage);
          gbHighlightPacked = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX6) == 1;
          gColorGraphBackground = gColorGraphBackground;
          DeleteObject(ghbrGraphBackground);
          v25 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX10);
          ColorImmersive = gColorImmersiveProcess;
          gbHighlightImmersive = v25 == 1;
          DeleteObject(ghbrImmersiveProcess);
          v26 = IsDlgButtonChecked(hDlg, IDD_CHOOSECOLORS_CHECKBOX_CHECKBOX11);
          gColorProtected = gColorKernelTime;
          gbHighlightProtected = v26 == 1;
          DeleteObject(ho);
          SetEvent(ghRefreshEvent);
          break;
        case IDD_COLUMNSETSAVE_BUTTON_CANCEL:
          break;
        default:
          return 0;
      }
      EndDialog(hDlg, 0);
      return 0;
    }
    switch ( hdc )
    {
      case IDD_CHOOSECOLORS_BUTTON_CHANGE5:
        result = SelectColor(hDlg, &gColorServices);
        break;
      case IDD_CHOOSECOLORS_BUTTON_CHANGE8:
        result = SelectColor(hDlg, &gColorRelocatedDlls);
        break;
      case IDD_CHOOSECOLORS_BUTTON_CHANGE9:
        result = SelectColor(hDlg, &gColorJobs);
        break;
      case IDC_SYSTEMINFOGPU_STATIC_STATIC8:
        result = SelectColor(hDlg, &gColorDeleteObects);
        break;
      case IDC_SYSTEMINFOGPU_STATIC_STATIC9:
        result = SelectColor(hDlg, &gColorNetProcesses);
        break;
      case IDD_CHOOSECOLORS_BUTTON_CHANGE2:
        result = SelectColor(hDlg, &gColorNewObjects);
        break;
      case IDD_CHOOSECOLORS_BUTTON_CHANGE7:
        result = SelectColor(hDlg, &gColorPackedImages);
        break;
      case IDD_PROCPERFETW_GROUPBOX_DISK_IO:
        SelectColor(hDlg, &gColorGraphBackground);
        result = 1;
        break;
      case IDD_DLLCOLUMNS_CHECKBOX_WS_SHARED_BYTES:
        result = SelectColor(hDlg, &gColorImmersiveProcess);
        break;
      case IDD_PROCTHREADS_STATIC_THREAD_ID:
        result = SelectColor(hDlg, &gColorThreadId);
        break;
      case IDD_PROCTHREADS_STATIC_KERNEL_TIME:
        result = SelectColor(hDlg, &gColorKernelTime);
        break;
      case IDD_CHOOSECOLORS_BUTTON_DEFAULTS:
        gColorOwnProcesses = 0xFFD0D0;
        gColorServices = 0xD0D0FF;
        gColorRelocatedDlls = 0xA0FFFF;
        gColorJobs = 0x6CD0;
        gColorNetProcesses = 0xA0FFFF;
        gColorImmersiveProcess = 0xEAEA00;
        gColorNewObjects = 0x46FF46;
        gColorDeleteObects = 0x4646FF;
        gColorPackedImages = 0xFF0080;
        gColorThreadId = 0x808080;
        gColorKernelTime = 0x8000FF;
        gColorGraphBackground = GetSysColor(COLOR_BTNFACE);
        InvalidateRect(hDlg, 0, 0);
        result = 1;
        break;
      default:
        return 0;
    }
  }
  return result;
}
// 12E4E54: using guessed type int gdwOsType;
// 12E96B8: using guessed type char gbHighlightJobs;
// 12E96B9: using guessed type char gbHighlightServices;
// 12E96BA: using guessed type char gbHighlightOwnProcesses;
// 12E96BB: using guessed type char gbHighlightNetProcess;
// 12E96BC: using guessed type char gbHighlightNewProc;
// 12E96BD: using guessed type char gbHighlightDelProc;
// 12E96BE: using guessed type char gbHighlightPacked;
// 12E96BF: using guessed type char gbHighlightImmersive;
// 12E96C0: using guessed type char gbHighlightSuspend;
// 12E96C1: using guessed type char gbHighlightProtected;
// 12E96CE: using guessed type char gbHighlightRelocatedDlls;
// 12E9B08: using guessed type int ColorOwn;
// 12E9B0C: using guessed type int ColorServices;
// 12E9B10: using guessed type int ColorRelocatedDlls;
// 12E9B14: using guessed type int gColorJobs_0;
// 12E9B18: using guessed type int gColorNet;
// 12E9B1C: using guessed type int gColorNewProc;
// 12E9B20: using guessed type int gColorDeleteObjects;
// 12E9B24: using guessed type int ColorPacked;
// 12E9B2C: using guessed type int ColorImmersive;
// 12E9B30: using guessed type int gColorSuspend;
// 12E9B34: using guessed type int gColorProtected;
// 12EA098: using guessed type char gbDotNetProcess;
// 12FBA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);

//----- (012574D0) --------------------------------------------------------
int __userpurge SelectColumnForStatusBarPageWndProc@<eax>(double a1@<st0>, double a2@<st1>, double st4_0@<st3>, double st5_0@<st2>, double st3_0@<st4>, HWND hDlg, int a3, int a4, int a5)
{
  __int16 v9; // ax
  char v11; // [esp+8h] [ebp-64h]
  char v12; // [esp+10h] [ebp-5Ch]
  char v13; // [esp+18h] [ebp-54h]

  if ( a3 == 78 )
  {
    if ( *(a5 + 8) == -202 )
    {
      gdwStatusBarColumns = 0;
      if ( IsDlgButtonChecked(hDlg, 1107) == 1 )
        gdwStatusBarColumns |= 1u;
      if ( IsDlgButtonChecked(hDlg, 1114) == 1 )
        gdwStatusBarColumns |= 2u;
      if ( IsDlgButtonChecked(hDlg, 1109) == 1 )
        gdwStatusBarColumns |= 4u;
      if ( IsDlgButtonChecked(hDlg, 1115) == 1 )
        gdwStatusBarColumns |= 8u;
      if ( IsDlgButtonChecked(hDlg, 1108) == 1 )
        gdwStatusBarColumns |= 0x10u;
      if ( IsDlgButtonChecked(hDlg, 1111) == 1 )
        gdwStatusBarColumns |= 0x20u;
      if ( IsDlgButtonChecked(hDlg, 1112) == 1 )
        gdwStatusBarColumns |= 0x40u;
      if ( IsDlgButtonChecked(hDlg, 1116) == 1 )
        gdwStatusBarColumns |= 0x80u;
      if ( IsDlgButtonChecked(hDlg, 1110) == 1 )
        gdwStatusBarColumns |= 0x100u;
      if ( IsDlgButtonChecked(hDlg, 1117) == 1 )
        gdwStatusBarColumns |= 0x200u;
      if ( IsDlgButtonChecked(hDlg, 1113) == 1 )
        gdwStatusBarColumns |= 0x400u;
      if ( IsDlgButtonChecked(hDlg, 1118) == 1 )
        gdwStatusBarColumns |= 0x800u;
      if ( IsDlgButtonChecked(hDlg, 1325) == 1 )
        gdwStatusBarColumns |= 0x1000u;
      if ( IsDlgButtonChecked(hDlg, 1119) == 1 )
        gdwStatusBarColumns |= 0x2000u;
      if ( IsDlgButtonChecked(hDlg, 1120) == 1 )
        gdwStatusBarColumns |= 0x4000u;
      memset(&v13, 0, 0x50u);
      UpdateStatusBar(a1, a2, st5_0, st4_0, st3_0, 0, &v13, &v12, &v11);
      InitStatusBar(ghWndStatusBar);
      SetEvent(ghEventRefreshSearchResult);
      return 1;
    }
    return 0;
  }
  if ( a3 != 272 )
    return 0;
  v9 = gdwStatusBarColumns;
  if ( gdwStatusBarColumns & 1 )
  {
    CheckDlgButton(hDlg, 1107, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 2 )
  {
    CheckDlgButton(hDlg, 1114, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 4 )
  {
    CheckDlgButton(hDlg, 1109, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 8 )
  {
    CheckDlgButton(hDlg, 1115, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x10 )
  {
    CheckDlgButton(hDlg, 1108, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x20 )
  {
    CheckDlgButton(hDlg, 1111, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x40 )
  {
    CheckDlgButton(hDlg, 1112, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( (v9 & 0x80u) != 0 )
  {
    CheckDlgButton(hDlg, 1116, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x100 )
  {
    CheckDlgButton(hDlg, 1110, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x200 )
  {
    CheckDlgButton(hDlg, 1117, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x400 )
  {
    CheckDlgButton(hDlg, 1113, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x800 )
  {
    CheckDlgButton(hDlg, 1118, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x1000 )
  {
    CheckDlgButton(hDlg, 1325, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x2000 )
  {
    CheckDlgButton(hDlg, 1119, 1u);
    v9 = gdwStatusBarColumns;
  }
  if ( v9 & 0x4000 )
    CheckDlgButton(hDlg, 1120, 1u);
  return 1;
}
// 12E598C: using guessed type char gbProcessSortDirection;
// 12E5990: using guessed type int gdwStatusBarColumns;

//----- (01257810) --------------------------------------------------------
BOOL __stdcall DiffDurationDlgProc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  BOOL result; // eax
  HWND v5; // eax
  HWND v6; // eax
  WCHAR String; // [esp+4h] [ebp-204h]
  __int16 v8; // [esp+8h] [ebp-200h]

  if ( a2 == 272 )
  {
    VLogEntry(&String, L"%d", gdwHighlightDuration / 1000);
    SetDlgItemTextW(hDlg, 1105, &String);
    v5 = GetDlgItem(hDlg, 1105);
    SendMessageW(v5, 0xC5u, 1u, 0);
    v6 = GetDlgItem(hDlg, 1022);
    SendMessageW(v6, 0x465u, 0, 9);
    result = 1;
  }
  else
  {
    if ( a2 == 273 )
    {
      if ( a3 == 1 )
      {
        GetDlgItemTextW(hDlg, 1105, &String, 2);
        v8 = 0;
        gdwHighlightDuration = 1000 * _wtoi(&String);
      }
      else if ( a3 != 2 )
      {
        return 0;
      }
      EndDialog(hDlg, 0);
    }
    result = 0;
  }
  return result;
}
// 12E5534: using guessed type int gdwHighlightDuration;

//----- (01257930) --------------------------------------------------------
void __cdecl sub_1257930(int a1)
{
  int v1; // eax
  signed __int16 v2; // ax

  if ( *(a1 + 720) != 3 )
  {
    memmove((a1 + 724), (a1 + 720), 4 * *(a1 + 524));
    v1 = *(a1 + 524);
    *(a1 + 720) = 3;
    memmove((a1 + 530), (a1 + 528), 2 * v1);
    v2 = *(a1 + 520);
    if ( !v2 )
      v2 = 200;
    ++*(a1 + 524);
    *(a1 + 528) = v2;
  }
}

//----- (012579B0) --------------------------------------------------------
HBRUSH __cdecl CreateBrush(COLORREF color, HBRUSH *phbrush)
{
  HBRUSH result; // eax

  if ( *phbrush )
    DeleteObject(*phbrush);
  result = CreateSolidBrush(color);
  *phbrush = result;
  return result;
}

//----- (012579E0) --------------------------------------------------------
char __cdecl sub_12579E0(char a1)
{
  if ( a1
    || !gbHideWhenMinimized
    || gbShowPhysTray
     + gbShowIoTray
     + gbTrayCPUHistory
     + gbShowCommitTray
     + gbShowNetTray
     + gbShowGpuTray
     + gbShowDiskTray != 1 )
  {
    return 0;
  }
  MessageBoxW(
    ghWndTreeListView,
    L"Because the Hide When Minimized option is selected, you must maintain at least one tray icon so that you can activat"
     "e Process Explorer when it is minimized.",
    L"Process Explorer Error",
    0x10u);
  return 1;
}
// 12E96C2: using guessed type char gbTrayCPUHistory;
// 12E96C3: using guessed type char gbShowCommitTray;
// 12E96C4: using guessed type char gbShowPhysTray;
// 12E96C5: using guessed type char gbShowIoTray;
// 12E96C6: using guessed type char gbShowNetTray;
// 12E96C7: using guessed type char gbShowDiskTray;
// 12E96C8: using guessed type char gbShowGpuTray;
// 12E96D1: using guessed type char gbHideWhenMinimized;

//----- (01257A60) --------------------------------------------------------
BOOL __cdecl sub_1257A60(HWND hWnd)
{
  POINT v1; // ST00_8
  struct tagRECT Rect; // [esp+4h] [ebp-14h]

  if ( !IsWindow(hWnd) )
    return 0;
  GetWindowRect(hWnd, &Rect);
  v1.y = Rect.top + (Rect.bottom - Rect.top) / 2;
  v1.x = Rect.left + (Rect.right - Rect.left) / 2;
  return WindowFromPoint(v1) == hWnd;
}

//----- (01257AE0) --------------------------------------------------------
int __cdecl SelectColor(HWND hWnd, COLORREF *pColor)
{
  struct tagCHOOSECOLORW ChooseColor; // [esp+8h] [ebp-24h] typedef struct tagCHOOSECOLOR {
                                      //                      DWORD lStructSize;
                                      //                      HWND hwndOwner;
                                      //                      HINSTANCE hInstance;
                                      //                      COLORREF rgbResult;
                                      //                      COLORREF* lpCustColors;
                                      //                      DWORD Flags;
                                      //                      LPARAM lCustData;
                                      //                      LPCCHOOKPROC lpfnHook;
                                      //                      LPCTSTR lpTemplateName;
                                      //                    } CHOOSECOLOR, *LPCHOOSECOLOR;

  ChooseColor.hInstance = ghInstance;
  ChooseColor.rgbResult = *pColor;
  ChooseColor.lStructSize = 36;
  ChooseColor.hwndOwner = hWnd;
  ChooseColor.lpCustColors = gColors;
  ChooseColor.lCustData = 0;
  ChooseColor.Flags = 1;
  if ( ChooseColorW(&ChooseColor) )
  {
    *pColor = ChooseColor.rgbResult;
    InvalidateRect(ghWndTreeListView, 0, 1);
    InvalidateRect(ghWndDllsListCtrl, 0, 1);
    InvalidateRect(ghWndHandlesListCtrl, 0, 1);
    InvalidateRect(hWnd, 0, 1);
  }
  return 0;
}

//----- (01257B70) --------------------------------------------------------
int __userpurge BackupUpdateThreadProc@<eax>(void *pInfo)
{
  CHAR *v1; // ebx
  char v2; // bl
  DWORD dwTimeout; // ecx
  DWORD i; // esi
  float v5; // xmm1_4
  float v6; // xmm1_4
  float v7; // xmm1_4
  float v8; // xmm1_4
  float v9; // xmm1_4
  DWORD v10; // ecx
  char v12; // [esp+2h] [ebp-76h]
  char v13; // [esp+3h] [ebp-75h]
  struct _MEMORYSTATUSEX Buffer; // [esp+4h] [ebp-74h]
  struct _MEMORYSTATUS mbi; // [esp+44h] [ebp-34h]
  HANDLE Handles[4]; // [esp+64h] [ebp-14h]

  Handles[0] = ghEventRefreshSearchResult;
  Handles[1] = ghRefreshEvent;
  Handles[2] = ghStartToResumeProcessEvent;
  Handles[3] = ghEvent3;
  if ( gbDotNetProcess )
    CoInitialize(0);
  v2 = dword_12E5390;
  v12 = dword_12E5390;
  SetErrorMode(1u);
  dwTimeout = INFINITE;
  if ( gdwRefreshRateOfSearch )
    dwTimeout = gdwRefreshRateOfSearch;
  for ( i = WaitForMultipleObjects(4u, Handles, 0, dwTimeout); i != 3; i = WaitForMultipleObjects(4u, Handles, 0, v10) )
  {
    // ghStartToResumeProcessEvent
    if ( i == 2 )
    {
      dword_12E10B8 = -1;
      gdwProcessIdSearching = -1;
      gdwProcessIdOfSystemHandleInformation = -1;
    }
    if ( gdwRefreshRateOfSearch || i != WAIT_TIMEOUT )
    {
      if ( ghSysinfoPropSheetDlg )
        PostMessageW(ghSysinfoPropSheetDlg, WM_TIMER, 0, 0);
      ++gnCounter;
      if ( v2 )
        CEventTrace::Start(&gEventTraceProperties, 1);
      if ( i != 2 )
      {
        v1 = GetTickCount();
        if ( &v1[-gdwTickLastUpdateGraph] > 10000 )
        {
          sub_1234400(&gptrIOGraphData__3UCSimpleGraphData__A);
          sub_1234400(&gptrNetGraphData);
          sub_1234400(&gptrDiskGraphData);
          gdwTickLastUpdateGraph = v1;
        }
        if ( *GlobalMemoryStatusEx )
        {
          Buffer.dwLength = 64;
          GlobalMemoryStatusEx(&Buffer);
          v5 = Buffer.ullTotalPageFile;
          v6 = v5 * 0.0009765625;
          if ( v6 > *&gpGraphClassData[0]->dbTotalPageFile )
            *&gpGraphClassData[0]->dbTotalPageFile = v6;
          v7 = Buffer.ullTotalPhys;
          v8 = v7 * 0.0009765625;
        }
        else
        {
          mbi.dwLength = 32;
          GlobalMemoryStatus(&mbi);
          v9 = mbi.dwTotalPageFile * 0.0009765625;
          if ( v9 > *&gpGraphClassData[0]->dbTotalPageFile )
            *&gpGraphClassData[0]->dbTotalPageFile = v9;
          v8 = mbi.dwTotalPhys * 0.0009765625;
        }
        if ( v8 > *&gpGraphClassData[5]->dbTotalPageFile )
          *&gpGraphClassData[5]->dbTotalPageFile = v8;
      }
      LOWORD(v1) = 0;
      v13 = 0;
      if ( i != 2 )
      {
        v13 = CTreeList::Initialize(ghWndTreeListView, i == 1);
        PulseEvent(ghEvent5);
        PostMessageW(ghWndGraphCPUUsage, 0x400u, 0, 0);
        PostMessageW(ghWndGraphMemory, 0x400u, 0, 0);
        PostMessageW(ghWndGraphPhysicalMemory, 0x400u, 0, 0);
        if ( ghWndIOGraphCtrl )
          PostMessageW(ghWndIOGraphCtrl, 0x400u, 0, 0);
        if ( ghWndNetworkGraphCtrl )
          PostMessageW(ghWndNetworkGraphCtrl, 0x400u, 0, 0);
        if ( ghWndDiskGraphCtrl )
          PostMessageW(ghWndDiskGraphCtrl, 0x400u, 0, 0);
        if ( ghWndGPUGraphCtrl )
          PostMessageW(ghWndGPUGraphCtrl, 0x400u, 0, 0);
      }
      if ( !gbProcessExplorerHide )
      {
        if ( g_dwProcessId == -1 )
        {
          dword_12E10B8 = -2;
          gdwProcessIdOfSystemHandleInformation = -1;
          gdwProcessIdSearching = -2;
          if ( gbShowDllView )
            SendMessageW(ghWndDllsListCtrl, LVM_DELETEALLITEMS, 0, 0);
          else
            SendMessageW(ghWndHandlesListCtrl, LVM_DELETEALLITEMS, 0, 0);
        }
        else if ( gbShowDllView )
        {
          BYTE1(v1) = SearchDlls(v1, ghWndDllsListCtrl, g_dwProcessId, 0);
        }
        else
        {
          LOBYTE(v1) = SearchHandles(0, ghWndHandlesListCtrl, g_dwProcessId, 0);
        }
      }
      ++gnCounter;
      if ( v13 )
        PostMessageW(ghWndNewOwner, PMT_MSG_7E8, IDC_TREELIST, gbShowProcessTree);
      if ( v1 )
        PostMessageW(ghWndNewOwner, PMT_MSG_7E8, IDW_HANDLES_LISTCTRL, 0);
      if ( BYTE1(v1) )
        PostMessageW(ghWndNewOwner, PMT_MSG_7E8, IDW_DLL_LISTCTRL, 0);
      v2 = v12;
    }
    v10 = -1;
    if ( gdwRefreshRateOfSearch )
      v10 = gdwRefreshRateOfSearch;
  }
  return 0;
}
// 12E10B8: using guessed type int dword_12E10B8;
// 12E10BC: using guessed type int gdwProcessIdSearching;
// 12E10C0: using guessed type int gdwProcessIdOfSystemHandleInformation;
// 12E5390: using guessed type int dword_12E5390;
// 12E5742: using guessed type char gbShowProcessTree;
// 12E96CC: using guessed type char gbShowDllView;
// 12EA098: using guessed type char gbDotNetProcess;
// 12EA11C: using guessed type int gnCounter;
// 12EA389: using guessed type char gbProcessExplorerHide;
// 12EA90C: using guessed type int gdwTickLastUpdateGraph;

//----- (01257F60) --------------------------------------------------------
BOOL __stdcall RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wID, LPARAM hData)
{
  wchar_t *v4; // eax
  int nID; // eax
  int v7; // eax
  HANDLE v8; // eax
  HANDLE v9; // esi
  HANDLE v10; // ST28_4
  DWORD v11; // ecx
  HINSTANCE nRet; // eax
  HWND v13; // eax
  LONG v14; // eax
  unsigned int v15; // esi
  LRESULT hEditCtrl; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+Ch] [ebp-6F8h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-6B4h]
  struct tagOFNW ofn; // [esp+60h] [ebp-6A4h]
  COMBOBOXEXITEMW item; // [esp+B8h] [ebp-64Ch]
  HANDLE TokenHandle; // [esp+E0h] [ebp-624h]
  HKEY phkResult; // [esp+E4h] [ebp-620h]
  DWORD cbData; // [esp+E8h] [ebp-61Ch]
  DWORD dwErrCode; // [esp+ECh] [ebp-618h]
  wchar_t szText[260]; // [esp+F0h] [ebp-614h]
  __int16 Dst[260]; // [esp+2F8h] [ebp-40Ch]
  WCHAR szFileName[256]; // [esp+500h] [ebp-204h]

  szFileName[0] = 0;
  memset(&szFileName[1], 0, 0x1FEu);
  dwErrCode = 65;
  if ( uMsg == WM_INITDIALOG )
  {
    SetPropW(hDlg, L"Runas", hData);
    if ( hData == 40121 )
    {
      SetWindowTextW(hDlg, L"Runas");
      SetDlgItemTextW(hDlg, IDD_RUNDLG_STATIC_RUN, L"Runas:");
      SetDlgItemTextW(
        hDlg,
        IDD_RUNDLG_STATIC_PROGAME_NAME_TYPE,
        L"Select the program to run and then you will be prompted for alternate credentials.");
    }
    else if ( hData == 40122 )
    {
      SetWindowTextW(hDlg, L"Run as Limited User");
      SetDlgItemTextW(
        hDlg,
        IDD_RUNDLG_STATIC_PROGAME_NAME_TYPE,
        L"Select the program to run with standard user privileges.");
    }
    v13 = GetDlgItem(hDlg, IDD_RUNDLG_CTRL_COMBOBOXEX);
    ghComboBoxRunDlg = v13;
    v14 = GetWindowLongW(v13, GWL_STYLE);
    SetWindowLongW(ghComboBoxRunDlg, GWL_STYLE, v14 | CBS_AUTOHSCROLL);
    item.iItem = -1;
    item.mask = 1;
    if ( gszRunAsCommandLine[0] )
    {
      item.pszText = gszRunAsCommandLine;
      SendMessageW(ghComboBoxRunDlg, CBEM_INSERTITEMW, 0, &item);
    }
    SendMessageW(ghComboBoxRunDlg, CB_LIMITTEXT, _MAX_PATH, 0);
    if ( !RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU", &phkResult) )
    {
      cbData = 512;
      RegQueryValueExW(phkResult, L"MRUList", 0, 0, szFileName, &cbData);
      v15 = 0;
      if ( wcslen(szFileName) )
      {
        do
        {
          LOWORD(dwErrCode) = szFileName[v15];
          cbData = 520;
          if ( !RegQueryValueExW(phkResult, &dwErrCode, 0, 0, szText, &cbData) )
          {
            if ( wcsrchr(szText, '\\') )
              *wcsrchr(szText, '\\') = 0;
            item.pszText = szText;
            SendMessageW(ghComboBoxRunDlg, CBEM_INSERTITEMW, 0, &item);
          }
          ++v15;
        }
        while ( v15 < wcslen(szFileName) );
      }
      RegCloseKey(phkResult);
    }
    SetFocus(ghComboBoxRunDlg);
    if ( SHAutoComplete )
    {
      hEditCtrl = SendMessageW(ghComboBoxRunDlg, CBEM_GETEDITCONTROL, 0, 0);
      SHAutoComplete(hEditCtrl, 1);
    }
    SendMessageW(ghComboBoxRunDlg, CB_SETCURSEL, 0, 0);
    SendMessageW(ghComboBoxRunDlg, CB_SETEDITSEL, 0, -1);
    SetFocus(ghComboBoxRunDlg);
    return 1;
  }
  if ( uMsg != WM_COMMAND )
    return 0;
  if ( wID == 1 )
  {
    GetDlgItemTextW(hDlg, IDD_RUNDLG_CTRL_COMBOBOXEX, gszRunAsCommandLine, 260);
    nID = GetPropW(hDlg, L"Runas") - 40061;
    if ( nID )
    {
      v7 = nID - 0x3C;
      if ( v7 )
      {
        if ( v7 == 1 )
        {
          v8 = GetCurrentProcess();
          OpenProcessToken(v8, 0xF01FFu, &TokenHandle);
          v9 = sub_1246DB0(TokenHandle);
          if ( !v9 )
          {
            ErrMsgBox(L"Unable to execute process", ghWndNewOwner);
            return 0;
          }
          memset(&StartupInfo, 0, 0x44u);
          StartupInfo.cb = 68;
          StartupInfo.dwFlags = 1;
          StartupInfo.wShowWindow = 5;
          v10 = TokenHandle;
          _mm_storeu_si128(&ProcessInformation, 0i64);
          CloseHandle(v10);
          if ( !CreateProcessAsUserW(
                  v9,
                  0,
                  gszRunAsCommandLine,
                  0,
                  0,
                  0,
                  0x10u,
                  0,
                  0,
                  &StartupInfo,
                  &ProcessInformation) )
          {
            ErrMsgBox(L"Unable to execute process", ghWndNewOwner);
            CloseHandle(v9);
            return 0;
          }
          sub_1243300(gszRunAsCommandLine);
          EndDialog(hDlg, 0);
          CloseHandle(v9);
          return 0;
        }
        v11 = dwErrCode;
        goto LABEL_23;
      }
      nRet = ShellExecuteW(hDlg, L"runas", gszRunAsCommandLine, 0, 0, 1);
    }
    else
    {
      nRet = ShellExecuteW(hDlg, L"open", gszRunAsCommandLine, 0, 0, 1);
    }
    v11 = nRet;
LABEL_23:
    switch ( v11 )
    {
      case 0u:
      case 8u:
        v11 = 8;
        break;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 6u:
      case 7u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
        break;
      case 5u:
        v11 = 5;
        break;
      case 0x1Au:
        v11 = 32;
        break;
      case 0x20u:
        v11 = 2;
        break;
      default:
        sub_1243300(gszRunAsCommandLine);
        goto LABEL_30;
    }
    SetLastError(v11);
    ErrMsgBox(L"Unable to execute process", ghWndNewOwner);
    SetFocus(ghComboBoxRunDlg);
    return 0;
  }
  if ( wID != 2 )
  {
    if ( wID == 4 )
    {
      memset(&ofn, 0, 0x58u);
      ofn.lStructSize = 76;
      ofn.hwndOwner = hDlg;
      ofn.hInstance = ghInstance;
      ofn.nMaxFile = 256;
      ofn.Flags = 0x200004;
      ofn.lpstrTitle = L"Specify executable...";
      ofn.lpstrDefExt = L"*.exe";
      ofn.nFilterIndex = 1;
      ofn.lpstrFilter = L"Executables";
      GetDlgItemTextW(hDlg, IDD_RUNDLG_CTRL_COMBOBOXEX, gszRunAsCommandLine, 260);
      if ( wcschr(gszRunAsCommandLine, 0x5Cu) )
      {
        tcscpy_s(Dst, _MAX_PATH, gszRunAsCommandLine);
        v4 = wcschr(Dst, '\\');
        tcscpy_s(gszRunAsCommandLine, _MAX_PATH, v4 + 1);
        wcschr(Dst, '\\')[1] = 0;
        ofn.lpstrInitialDir = Dst;
      }
      ofn.lpstrFile = gszRunAsCommandLine;
      if ( GetOpenFileNameW(&ofn) )
      {
        SetDlgItemTextW(hDlg, IDD_RUNDLG_CTRL_COMBOBOXEX, gszRunAsCommandLine);
        return 0;
      }
    }
    return 0;
  }
LABEL_30:
  EndDialog(hDlg, 0);
  return 0;
}
// 12C19EC: using guessed type wchar_t aSpecifyExecuta[22];
// 12C1A18: using guessed type wchar_t aExe_0[6];
// 12C1A28: using guessed type wchar_t aExecutables[12];
// 12C1A6C: using guessed type wchar_t aRunas_0[6];
// 12EA8F4: using guessed type int (__stdcall *SHAutoComplete)(_DWORD, _DWORD);

//----- (012585F0) --------------------------------------------------------
int __stdcall SendMessageDlgProc(HWND hDlg, int a2, int a3, int a4)
{
  HWND v4; // eax
  HWND v5; // eax
  unsigned int v6; // kr00_4
  WCHAR *v7; // edx
  WCHAR v8; // ax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v13; // eax
  int Pid; // ST14_4
  HANDLE Tid; // eax
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // eax
  int v19; // [esp+Ch] [ebp-82Ch]
  WCHAR *v20; // [esp+10h] [ebp-828h]
  char ArgList[520]; // [esp+14h] [ebp-824h]
  __int16 Dst[260]; // [esp+21Ch] [ebp-61Ch]
  WCHAR v23[260]; // [esp+424h] [ebp-414h]
  __int16 String[260]; // [esp+62Ch] [ebp-20Ch]

  if ( a2 != WM_INITDIALOG )
  {
    if ( a2 != WM_COMMAND )
      return 0;
    if ( a3 == 1 )
    {
      v4 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE);
      GetWindowTextW(v4, String, 260);
      v5 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE_TITLE);
      GetWindowTextW(v5, v23, 260);
      v6 = wcslen(String);
      v7 = v23;
      v20 = &v23[1];
      do
      {
        v8 = *v7;
        ++v7;
      }
      while ( v8 );
      if ( !WTSSendMessageW(0, dword_12EA914, v23, 2 * (v7 - v20), String, 2 * v6, 0, 0, &v19, 0) )
        ErrMsgBox(L"Error sending message", ghWndNewOwner);
    }
    else if ( a3 != IDD_SENDMESSAGE_BUTTON_CANCEL )
    {
LABEL_11:
      if ( a3 >> 16 == 768 )
      {
        v9 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE);
        GetWindowTextW(v9, String, 260);
        v10 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE_TITLE);
        GetWindowTextW(v10, v23, 260);
        if ( String[0] && v23[0] )
        {
          v11 = GetDlgItem(hDlg, IDD_SENDMESSAGE_BUTTON_OK);
          EnableWindow(v11, IDD_SENDMESSAGE_BUTTON_OK);
          return 0;
        }
        v13 = GetDlgItem(hDlg, IDD_SENDMESSAGE_BUTTON_OK);
        EnableWindow(v13, 0);
      }
      return 0;
    }
    EndDialog(hDlg, 0);
    goto LABEL_11;
  }
  dword_12EA914 = a4;
  Pid = GetCurrentProcessId();
  Tid = GetCurrentProcess();
  QueryProcessUserInfo(Tid, Pid, 0, Dst, _MAX_PATH, ArgList, _MAX_PATH, 0, 0, 0, 0);
  stprintf(String, L"Message from %s\\%s", ArgList, Dst);
  v16 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE_TITLE);
  SetWindowTextW(v16, String);
  v17 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE);
  SetWindowTextW(v17, gpszTargetName);
  v18 = GetDlgItem(hDlg, IDD_SENDMESSAGE_EDITTEXT_MESSAGE_TITLE);
  SetFocus(v18);
  return 1;
}
// 12EF350: using guessed type int (__stdcall *WTSSendMessageW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (01258860) --------------------------------------------------------
BOOL __stdcall SymbolConfigDlgProc(HWND hDlg, UINT uMsg, WPARAM wID, LPARAM a4)
{
  HANDLE v4; // esi
  BOOL v5; // eax
  BOOL v6; // ST0C_4
  HWND v7; // eax
  BOOL result; // eax
  HWND v9; // eax
  HWND v10; // eax
  struct tagOFNW ofn; // [esp+8h] [ebp-4B4h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+60h] [ebp-45Ch]
  __int16 szFileName[260]; // [esp+2B0h] [ebp-20Ch]

  if ( uMsg == WM_INITDIALOG )
  {
    SetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT1, gstrDbgHelpPath);
    SetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT2, gszSymbolPath);
    if ( SHAutoComplete )
    {
      v9 = GetDlgItem(hDlg, 1088);
      SHAutoComplete(v9, 1);
    }
    v10 = GetDlgItem(hDlg, 1088);
    SetFocus(v10);
    result = 1;
  }
  else
  {
    if ( uMsg == WM_COMMAND )
    {
      if ( wID > 0x442 )
      {
        if ( wID == IDD_SYMBOLCONFIG_BUTTON_BUTTON )
        {
          GetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT2, szFileName, _MAX_PATH);
          if ( BrowseSymbolPath(hDlg, szFileName) )
            SetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT2, szFileName);
        }
      }
      else
      {
        switch ( wID )
        {
          case IDD_SYMBOLCONFIG_BUTTON_EDIT3:
            GetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT1, szFileName, _MAX_PATH);
            memset(&ofn, 0, 0x58u);
            ofn.hInstance = ghInstance;
            ofn.lpstrFile = szFileName;
            *&ofn.nFileOffset = 0;
            ofn.lpfnHook = 0;
            ofn.lStructSize = 76;
            ofn.hwndOwner = hDlg;
            ofn.lpstrCustomFilter = 0;
            ofn.nMaxCustFilter = 0;
            ofn.nFilterIndex = 1;
            ofn.nMaxFile = 256;
            ofn.lpstrFileTitle = 0;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = 0;
            ofn.Flags = 0x200000;
            ofn.lpstrTitle = L"Specify dbghelp.dll...";
            ofn.lpstrDefExt = L"*.dll";
            ofn.lpstrFilter = L"Dbghelp DLL (dbghelp.dll)";
            if ( GetOpenFileNameW(&ofn) )
              SetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT1, szFileName);
            break;
          case IDC_SYSTEMINFOGPUNODES_BUTTON_OK:
            GetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT1, szFileName, _MAX_PATH);
            if ( LoadDbgHelp(szFileName) )
            {
              GetDlgItemTextW(hDlg, IDD_SYMBOLCONFIG_EDITTEXT_EDIT2, gszSymbolPath, _MAX_PATH);
              tcscpy_s(gstrDbgHelpPath, _MAX_PATH, szFileName);
              SetEnvironmentVariableW(L"_NT_SYMBOL_PATH", gszSymbolPath);
              dword_12DE0DC = 1;
              sub_12592A0(hDlg);
              EndDialog(hDlg, 0);
            }
            else
            {
              MessageBoxW(
                hDlg,
                L"The DLL you specified is not a valid version of the Debugging Tools Help File.",
                L"Process Explorer Error",
                0x10u);
            }
            break;
          case IDD_CHOOSECOLORS_BUTTON_CANCEL1:
            EndDialog(hDlg, 0);
            break;
        }
      }
      if ( wID >> 16 == 768 )
      {
        GetDlgItemTextW(hDlg, IDD_PROCTHREADS_STATIC_NA11, szFileName, 260);
        v4 = FindFirstFileW(szFileName, &FindFileData);
        v5 = v4 != -1 && !(FindFileData.dwFileAttributes & 0x10);
        v6 = v5;
        v7 = GetDlgItem(hDlg, 1);
        EnableWindow(v7, v6);
        if ( v4 )
          FindClose(v4);
      }
    }
    result = 0;
  }
  return result;
}
// 12C1578: using guessed type wchar_t aSpecifyDbghelp[23];
// 12C15A8: using guessed type wchar_t aDll_2[6];
// 12C15B4: using guessed type wchar_t aDbghelpDllDbgh[26];
// 12DE0DC: using guessed type int dword_12DE0DC;
// 12EA8F4: using guessed type int (__stdcall *SHAutoComplete)(_DWORD, _DWORD);

//----- (01258B70) --------------------------------------------------------
bool __cdecl BrowseSymbolPath(HWND hWndOwner, LPTSTR pszPath)
{
  void *pBuffer; // esi
  bool result; // al
  const ITEMIDLIST *pidlist; // eax
  ITEMIDLIST *v5; // edi
  struct _browseinfoW bi; // [esp+4h] [ebp-28h]
  LPITEMIDLIST ppidl; // [esp+24h] [ebp-8h]
  IMalloc *pMalloc; // [esp+28h] [ebp-4h]

  SHGetMalloc(&pMalloc);
  pBuffer = pMalloc->lpVtbl->Alloc(pMalloc, _MAX_PATH);
  if ( !pBuffer )
    return 0;
  if ( SHGetSpecialFolderLocation(hWndOwner, CSIDL_DESKTOP, &ppidl) >= 0 )
  {
    bi.pidlRoot = ppidl;
    bi.hwndOwner = hWndOwner;
    bi.pszDisplayName = pszPath;
    bi.lpszTitle = L"Browse for Symbols Directory";
    bi.ulFlags = 0x11;                          // BIF_RETURNONLYFSDIRS |BIF_EDITBOX
    bi.lpfn = 0;
    bi.lParam = 0;
    pidlist = SHBrowseForFolderW(&bi);
    v5 = pidlist;
    if ( pidlist )
    {
      SHGetPathFromIDListW(pidlist, pszPath);
      pMalloc->lpVtbl->Free(pMalloc, v5);
      pMalloc->lpVtbl->Free(pMalloc, ppidl);
      pMalloc->lpVtbl->Free(pMalloc, pBuffer);
      result = TRUE;
    }
    else
    {
      pMalloc->lpVtbl->Free(pMalloc, ppidl);
      pMalloc->lpVtbl->Free(pMalloc, pBuffer);
      result = FALSE;
    }
  }
  else
  {
    pMalloc->lpVtbl->Free(pMalloc, pBuffer);
    result = FALSE;
  }
  return result;
}
// 12C14DC: using guessed type wchar_t aBrowseForSymbo[29];

//----- (01258C50) --------------------------------------------------------
BOOL StartSystemInfoSheetThreadProc()
{
  HICON hIcon; // edi
  BOOL ret; // eax
  MSG msg; // [esp+8h] [ebp-20h]
  HACCEL hAccTable; // [esp+24h] [ebp-4h]

  ghSysinfoPropSheetDlg = CreateDialogParamW(ghInstance, L"SYSINFOPROPSHEET", 0, SysInfoPropWndProc, 0);
  hIcon = LoadIconW(ghInstance, 101);
  SendMessageW(ghSysinfoPropSheetDlg, WM_SETICON, 0, hIcon);
  SendMessageW(ghSysinfoPropSheetDlg, WM_SETICON, 1u, hIcon);
  SetEvent(ghSystemInfoSheetThreadEvent);
  hAccTable = LoadAcceleratorsW(ghInstance, L"PROCPROPERTIES");
  // 进入消息循环
  for ( ret = GetMessageW(&msg, 0, 0, 0); ret; ret = GetMessageW(&msg, 0, 0, 0) )
  {
    if ( !TranslateAcceleratorW(ghSysinfoPropSheetDlg, hAccTable, &msg)
      && !IsDialogMessageW(ghSysinfoPropSheetDlg, &msg) )
    {
      TranslateMessage(&msg);
      DispatchMessageW(&msg);
    }
  }
  return ret;
}

//----- (01258D50) --------------------------------------------------------
const wchar_t *__cdecl sub_1258D50(int a1)
{
  const wchar_t *result; // eax

  switch ( a1 )
  {
    case 1:
      result = L"16";
      break;
    case 2:
      result = L"256";
      break;
    case 4:
      result = L"65536";
      break;
    case 8:
    case 24:
      result = L"2^24";
      break;
    case 16:
      result = L"2^15";
      break;
    case 32:
      result = L"2^32";
      break;
    default:
      result = L"<?>";
      break;
  }
  return result;
}
// 12C0E34: using guessed type wchar_t a16[3];
// 12C0E3C: using guessed type wchar_t a256[4];
// 12C0E44: using guessed type wchar_t a65536[6];
// 12C0E50: using guessed type wchar_t a224[5];
// 12C0E5C: using guessed type wchar_t a215[5];
// 12C0E68: using guessed type wchar_t a232[5];
// 12C0E74: using guessed type wchar_t asc_12C0E74[4];

//----- (01258DE0) --------------------------------------------------------
BOOL __stdcall TsInfoDlgProc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  WCHAR *v5; // eax
  LPTSTR v6; // eax
  const wchar_t *v7; // eax
  _DWORD *v8; // ecx
  LPTSTR v9; // [esp+4h] [ebp-22Ch]
  LPCWSTR lpString; // [esp+8h] [ebp-228h]
  LPTSTR v11; // [esp+Ch] [ebp-224h]
  char ArgList[4]; // [esp+10h] [ebp-220h]
  LPTSTR v13; // [esp+14h] [ebp-21Ch]
  LPTSTR v14; // [esp+18h] [ebp-218h]
  LPTSTR ppBuffer; // [esp+1Ch] [ebp-214h]
  DWORD pdwBytesReturned; // [esp+20h] [ebp-210h]
  WCHAR String; // [esp+24h] [ebp-20Ch]

  if ( a2 == WM_DRAWITEM )
  {
    FindDlg_DrawItem(a4);
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 273 && a3 - 1 <= 1 )
    {
      EndDialog(hDlg, 0);
      return 0;
    }
    return 0;
  }
  SessionID = a4;
  stprintf(&String, L"%d", a4);
  SetDlgItemTextW(hDlg, 108, &String);
  ppBuffer = 0;
  WTSQuerySessionInformationW(0, SessionID, WTSClientProtocolType, &ppBuffer, &pdwBytesReturned);
  if ( WTSQuerySessionInformationW(0, SessionID, 5u, &v9, &pdwBytesReturned) )
  {
    if ( WTSQuerySessionInformationW(0, SessionID, WTSDomainName, ArgList, &pdwBytesReturned) )
    {
      stprintf(&String, L"%s\\%s", *ArgList, v9);
      SetDlgItemTextW(hDlg, 106, &String);
      WTSFreeMemory(*ArgList);
    }
    WTSFreeMemory(v9);
  }
  if ( WTSQuerySessionInformationW(0, SessionID, WTSConnectState, &v14, &pdwBytesReturned) )
  {
    if ( *v14 >= 0xAu )
    {
      stprintf(&String, L"Unknown (%d)", *v14);
      v5 = &String;
    }
    else
    {
      v5 = &aActive[32 * *v14];
    }
    SetDlgItemTextW(hDlg, IDC_SESSION_PROPERTIES_STATIC_STATE, v5);
    WTSFreeMemory(v14);
  }
  v6 = ppBuffer;
  if ( ppBuffer )
  {
    if ( *ppBuffer )
    {
      if ( WTSQuerySessionInformationW(0, SessionID, 0xAu, &lpString, &pdwBytesReturned) )
      {
        SetDlgItemTextW(hDlg, 110, lpString);
        WTSFreeMemory(lpString);
      }
      if ( WTSQuerySessionInformationW(0, SessionID, 0xEu, &v13, &pdwBytesReturned) && *(v13 + 1) )
      {
        stprintf(&String, L"%d.%d.%d.%d", v13[6], v13[7], v13[8], v13[9]);
        SetDlgItemTextW(hDlg, 111, &String);
        WTSFreeMemory(v13);
      }
      if ( WTSQuerySessionInformationW(0, SessionID, 0xFu, &v11, &pdwBytesReturned) )
      {
        v7 = sub_1258D50(*(v11 + 2));
        stprintf(&String, L"%dx%d by %s colors", *v8, v8[1], v7);
        SetDlgItemTextW(hDlg, 112, &String);
        WTSFreeMemory(v11);
      }
      v6 = ppBuffer;
    }
    if ( v6 )
      WTSFreeMemory(v6);
  }
  return 1;
}
// 12DE130: using guessed type wchar_t aActive[7];
// 12EF354: using guessed type int (__stdcall *WTSFreeMemory)(_DWORD);

//----- (012590F0) --------------------------------------------------------
BOOL __cdecl HandleShellIconMsg()
{
  signed int nIndex; // esi
  BOOL result; // eax
  MACRO_NIM uID; // esi

  nIndex = 1;
  do
    result = RemoveShellIcon(ghWndNewOwner, nIndex++);
  while ( nIndex < GraphIndex_PhysicalMemory );
  uID = 1;
  if ( gbShowPhysTray )
  {
    guIdOfPhysTrayIcon = 1;
    result = AddShellIcon(ghWndNewOwner, 1, gpGraphClassData[5], gpszTargetName);
    uID = NIM_DELETE;
  }
  else
  {
    guIdOfPhysTrayIcon = 0;
  }
  if ( gbShowIoTray )
  {
    guIdOfIoTrayIcon = uID;
    result = AddShellIcon(ghWndNewOwner, uID++, gptrIOGraphData__3UCSimpleGraphData__A.GraphData, gpszTargetName);
  }
  else
  {
    guIdOfIoTrayIcon = 0;
  }
  if ( gbShowDiskTray )
  {
    guIdOfDiskTrayIcon = uID;
    result = AddShellIcon(ghWndNewOwner, uID++, gptrDiskGraphData.GraphData, gpszTargetName);
  }
  else
  {
    guIdOfDiskTrayIcon = 0;
  }
  if ( gbShowGpuTray && (result = gpGraphClassData[GraphIndex_GPUUsage]) != 0 )
  {
    guIdOfGpuTrayIcon = uID;
    result = AddShellIcon(ghWndNewOwner, uID++, gpGraphClassData[2], gpszTargetName);
  }
  else
  {
    guIdOfGpuTrayIcon = 0;
  }
  if ( gbShowNetTray )
  {
    guIdOfNetTrayIcon = uID;
    result = AddShellIcon(ghWndNewOwner, uID++, gptrNetGraphData.GraphData, gpszTargetName);
  }
  else
  {
    guIdOfNetTrayIcon = 0;
  }
  if ( gbShowCommitTray )
  {
    guIdOfCommitTrayIcon = uID;
    result = AddShellIcon(ghWndNewOwner, uID++, gpGraphClassData[0], gpszTargetName);
  }
  else
  {
    guIdOfCommitTrayIcon = 0;
  }
  if ( gbTrayCPUHistory )
  {
    guIdOfCpuTrayIcon = uID;
    result = AddShellIcon(ghWndNewOwner, uID, gpGraphClassData[1], gpszTargetName);
  }
  else
  {
    guIdOfCpuTrayIcon = 0;
  }
  return result;
}
// 12E96C2: using guessed type char gbTrayCPUHistory;
// 12E96C3: using guessed type char gbShowCommitTray;
// 12E96C4: using guessed type char gbShowPhysTray;
// 12E96C5: using guessed type char gbShowIoTray;
// 12E96C6: using guessed type char gbShowNetTray;
// 12E96C7: using guessed type char gbShowDiskTray;
// 12E96C8: using guessed type char gbShowGpuTray;
// 12EA3BC: using guessed type int guIdOfCpuTrayIcon;

//----- (012592A0) --------------------------------------------------------
void __cdecl sub_12592A0(int a1)
{
  DWORD v1; // esi
  _DWORD *v2; // ebx
  DWORD dwHandle; // [esp+4h] [ebp-4h]

  dwHandle = 0;
  if ( !_wcsnicmp(L"srv*", gszSymbolPath, 4u) )
  {
    v1 = GetFileVersionInfoSizeW(gstrDbgHelpPath, &dwHandle);
    v2 = malloc(v1);
    if ( GetFileVersionInfoW(gstrDbgHelpPath, 0, v1, v2) && v2[12] < 0x60000u )
    {
      if ( a1 )
        DialogBoxParamW(ghInstance, L"SYMBOLDBGHELPGWARNING", 0, AboutOrSymbolConfigWarningProc, 0);
      else
        DialogBoxParamW(ghInstance, L"SYMBOLCONFIGWARNING", 0, AboutOrSymbolConfigWarningProc, 0);
    }
    free(v2);
  }
  if ( !gbSymbolWarningShown && (!*SymInitialize || !gszSymbolPath[0]) )
  {
    DialogBoxParamW(ghInstance, L"SYMBOLCONFIGWARNING", 0, AboutOrSymbolConfigWarningProc, 0);
    gbSymbolWarningShown = 1;
    CMainWnd::Reset(ghWndNewOwner, 1);
  }
}
// 12E98FC: using guessed type char gbSymbolWarningShown;

//----- (01259380) --------------------------------------------------------
int __cdecl FindProcessByWindow(HWND hWnd)
{
  int result; // eax
  HWND v2; // eax
  unsigned int count; // edi
  WPARAM row; // esi
  DWORD dwPid; // ecx
  #1077 *v6; // eax
  LVITEMW item; // [esp+8h] [ebp-244h]
  DWORD dwProcessId; // [esp+3Ch] [ebp-210h]
  wchar_t Dst; // [esp+40h] [ebp-20Ch]

  if ( gbIsFinding )
  {
    SetCursor(ghCursorFind);
    ReleaseCapture();
    gbIsFinding = 0;
    SendMessageW(ghWndToolbar, TB_PRESSBUTTON, IDM_OTHER_FIND_WINDOW_PROCESS, 0);
    SetWindowPos(hWnd, -(gbAlwaysOntop != 0), 0, 0, 0, 0, 3u);
    if ( ghWndPointLast )
    {
      DrawWindow(ghWndPointLast);
      if ( !HungWindowFromGhostWindow || (v2 = HungWindowFromGhostWindow(ghWndPointLast)) == 0 )
        v2 = ghWndPointLast;
      GetWindowThreadProcessId(v2, &dwProcessId);
      count = SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
      row = 0;
      if ( count )
      {
        while ( 1 )
        {
          item.mask = LVCF_TEXT;
          item.iItem = row;
          item.iSubItem = 0;
          SendMessageW(ghWndTreeListView, LVM_GETITEMW, 0, &item);
          dwPid = dwProcessId;
          if ( *&item.lParam->szText[0xE] == dwProcessId )
            break;
          if ( ++row >= count )
            goto __nofound;
        }
        item.mask = LVCF_SUBITEM;
        item.stateMask = LVIS_SELECTED;
        item.state = LVIS_SELECTED;
        SendMessageW(ghWndTreeListView, LVM_SETITEMW, 0, &item);
        SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, row, 0);
        SetFocus(ghWndTreeListView);
      }
      dwPid = dwProcessId;
__nofound:
      if ( row == count )
      {
        v6 = gpTreeListParamList;
        if ( gpTreeListParamList )
        {
          while ( *(v6 + 17) != dwPid )
          {
            v6 = *(v6 + 364);
            if ( !v6 )
              goto LABEL_17;
          }
          stprintf(
            &Dst,
            L"The owning process is %s (process ID %d), which is not currently visible in the process list.",
            *(v6 + 15),
            *(v6 + 17));
          MessageBoxW(ghWndTreeListView, &Dst, L"Process Explorer Error", 0x40u);
        }
        else
        {
LABEL_17:
          MessageBoxW(
            ghWndTreeListView,
            L"Unable to find the window's owning process in the current process list",
            L"Process Explorer Error",
            0x10u);
        }
      }
    }
    result = 0;
  }
  else
  {
    SetWindowPos(hWnd, 1, 0, 0, 0, 0, 3u);
    SetWindowPos(hWnd, 1, 0, 0, 0, 0, 3u);
    ghCursorFind = SetCursor(ghCursorFind);
    SetCapture(hWnd);
    gbIsFinding = 1;
    result = 0;
    ghWndPointLast = 0;
  }
  return result;
}
// 12E96D2: using guessed type char gbAlwaysOntop;
// 12EA38B: using guessed type char gbIsFinding;
// 12EF380: using guessed type int (__stdcall *HungWindowFromGhostWindow)(_DWORD);

//----- (012595D0) --------------------------------------------------------
LRESULT __stdcall PEMainWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  if ( Msg == gShellIconMsg )
    HandleShellIconMsg();
  return MSGHANDLER::HandleMessage(&gNormalWindowMsgHandler, hWnd, Msg, wParam, lParam);
}
// 12EA884: using guessed type int gShellIconMsg;

//----- (01259600) --------------------------------------------------------
BOOL __cdecl DumpProcessToFile(HANDLE hFile, HANDLE Process, char a3)
{
  HMODULE hModule; // eax
  signed int dwDefaultType; // eax
  MINIDUMP_TYPE type; // ST0C_4
  DWORD dwPid; // eax

  hModule = LoadLibraryW(L"Dbghelp.dll");
  if ( GetProcAddress(hModule, "EnumDirTreeW") )
  {
    dwDefaultType = 0x1105;
    if ( a3 )
      dwDefaultType = 0x1907;
  }
  else
  {
    dwDefaultType = 0x105;
    if ( a3 )
      dwDefaultType = 0x107;
  }
  type = dwDefaultType;
  dwPid = GetProcessId(Process);
  return MiniDumpWriteDump(Process, dwPid, hFile, type, 0, 0, 0);
}

//----- (01259660) --------------------------------------------------------
int __cdecl sub_1259660(int a1, int a2, wchar_t *Dst)
{
  return swprintf_s(Dst, 0x400u, L"%d.%d.%d.%d", a2 >> 16, a2, a1 >> 16, a1);
}

//----- (01259690) --------------------------------------------------------
_DWORD *__thiscall sub_1259690(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = sub_1275470(this);
  *(result + 6) = 0;
  if ( result != -16 )
  {
    result[4] = *a2;
    _mm_storeu_si128((result + 6), _mm_loadu_si128((a2 + 8)));
    _mm_storeu_si128((result + 10), _mm_loadu_si128((a2 + 24)));
    _mm_storeu_si128((result + 14), _mm_loadu_si128((a2 + 40)));
  }
  return result;
}

//----- (012596D0) --------------------------------------------------------
int __thiscall map::_Insert_at(CSysProcItem *this, int a2, char a3, int a4, int a5, CSysProcItem *a6)
{
  CSysProcItem *v6; // edi
  CSysProcItem *v7; // eax
  CSysProcItem *v8; // eax
  CSysProcItem *v9; // ecx
  CSysProcItem *v10; // esi
  CSysProcItem *v11; // edx
  CSysProcItem *v12; // edx
  CSysProcItem **v13; // ecx
  CSysProcItem *v14; // edx
  CSysProcItem *v15; // esi
  CSysProcItem *v16; // ecx
  CSysProcItem *v17; // ecx
  CSysProcItem *v18; // edx
  CSysProcItem *v19; // ecx
  CSysProcItem *v20; // ecx
  CSysProcItem *v21; // ecx
  int result; // eax

  v6 = this;
  v7 = this->_Parent;
  if ( v7 >= 0xAAAAAA9 )
  {
    j__free(a6);
    std::_Xlength_error("map/set<T> too long");
  }
  this->_Parent = (v7 + 1);
  a6->_Parent = a4;
  if ( a4 == this->_Left )
  {
    this->_Left->_Parent = a6;
    this->_Left->_Left = a6;
    this->_Left->_Right = a6;
  }
  else if ( a3 )
  {
    *a4 = a6;
    if ( a4 == this->_Left->_Left )
      this->_Left->_Left = a6;
  }
  else
  {
    *(a4 + 8) = a6;
    if ( a4 == this->_Left->_Right )
      this->_Left->_Right = a6;
  }
  v8 = a6;
  while ( !v8->_Parent->_Color )
  {
    v9 = v8->_Parent;
    v10 = v9->_Parent;
    v11 = v10->_Left;
    if ( v9 == v10->_Left )
    {
      v11 = v10->_Right;
      if ( v11->_Color )
      {
        if ( v8 == v9->_Right )
        {
          v8 = v8->_Parent;
          v12 = v9->_Right;
          v9->_Right = v12->_Left;
          if ( !v12->_Left->_Isnil )
            v12->_Left->_Parent = v9;
          v12->_Parent = v9->_Parent;
          if ( v9 == v6->_Left->_Parent )
          {
            v6->_Left->_Parent = v12;
          }
          else
          {
            v13 = &v9->_Parent->_Left;
            if ( v8 == *v13 )
              *v13 = v12;
            else
              v13[2] = v12;
          }
          v12->_Left = v8;
          v8->_Parent = v12;
        }
        v8->_Parent->_Color = 1;
        v8->_Parent->_Parent->_Color = 0;
        v14 = v8->_Parent->_Parent;
        v15 = v14->_Left;
        v14->_Left = v14->_Left->_Right;
        v16 = v15->_Right;
        if ( !v16->_Isnil )
          v16->_Parent = v14;
        v15->_Parent = v14->_Parent;
        if ( v14 == v6->_Left->_Parent )
        {
          v6->_Left->_Parent = v15;
          v15->_Right = v14;
        }
        else
        {
          v17 = v14->_Parent;
          if ( v14 == v17->_Right )
            v17->_Right = v15;
          else
            v17->_Left = v15;
          v15->_Right = v14;
        }
LABEL_48:
        v14->_Parent = v15;
        continue;
      }
    }
    else if ( v11->_Color )
    {
      if ( v8 == v9->_Left )
      {
        v8 = v8->_Parent;
        v18 = v9->_Left;
        v9->_Left = v9->_Left->_Right;
        v19 = v18->_Right;
        if ( !v19->_Isnil )
          v19->_Parent = v8;
        v18->_Parent = v8->_Parent;
        if ( v8 == v6->_Left->_Parent )
        {
          v6->_Left->_Parent = v18;
        }
        else
        {
          v20 = v8->_Parent;
          if ( v8 == v20->_Right )
            v20->_Right = v18;
          else
            v20->_Left = v18;
        }
        v18->_Right = v8;
        v8->_Parent = v18;
      }
      v8->_Parent->_Color = 1;
      v8->_Parent->_Parent->_Color = 0;
      v14 = v8->_Parent->_Parent;
      v15 = v14->_Right;
      v14->_Right = v15->_Left;
      if ( !v15->_Left->_Isnil )
        v15->_Left->_Parent = v14;
      v15->_Parent = v14->_Parent;
      if ( v14 == v6->_Left->_Parent )
      {
        v6->_Left->_Parent = v15;
      }
      else
      {
        v21 = v14->_Parent;
        if ( v14 == v21->_Left )
          v21->_Left = v15;
        else
          v21->_Right = v15;
      }
      v15->_Left = v14;
      goto LABEL_48;
    }
    v9->_Color = 1;
    v11->_Color = 1;
    v8->_Parent->_Parent->_Color = 0;
    v8 = v8->_Parent->_Parent;
  }
  v6->_Left->_Parent->_Color = 1;
  result = a2;
  *a2 = a6;
  return result;
}

//----- (012598E0) --------------------------------------------------------
_DWORD *__thiscall sub_12598E0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, int a6)
{
  _DWORD *v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // ebx
  int v9; // eax
  _DWORD *v10; // eax
  int *v11; // ecx
  int *v12; // esi
  int *v13; // edx
  _DWORD *v14; // edx
  _DWORD *v15; // ecx
  _DWORD *v16; // edx
  _DWORD *v17; // esi
  int v18; // ecx
  _DWORD *v19; // ecx
  int v20; // edx
  int v21; // ecx
  _DWORD *v22; // ecx
  _DWORD *v23; // ecx
  _DWORD *result; // eax

  v6 = this;
  if ( this[1] >= 0x38E38E2u )
    std::_Xlength_error("map/set<T> too long");
  v7 = sub_1259690(this, a5);
  ++v6[1];
  v8 = v7;
  v7[1] = a4;
  if ( a4 == *v6 )
  {
    *(*v6 + 4) = v7;
    **v6 = v7;
    v9 = *v6;
LABEL_8:
    *(v9 + 8) = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    a4[2] = v7;
    v9 = *v6;
    if ( a4 != *(*v6 + 8) )
      goto LABEL_9;
    goto LABEL_8;
  }
  *a4 = v7;
  if ( a4 == **v6 )
    **v6 = v7;
LABEL_9:
  v10 = v8;
  while ( !*(v10[1] + 12) )
  {
    v11 = v10[1];
    v12 = v11[1];
    v13 = *v12;
    if ( v11 == *v12 )
    {
      v13 = v12[2];
      if ( *(v13 + 12) )
      {
        if ( v10 == v11[2] )
        {
          v10 = v10[1];
          v14 = v11[2];
          v11[2] = *v14;
          if ( !*(*v14 + 13) )
            *(*v14 + 4) = v11;
          v14[1] = v11[1];
          if ( v11 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v14;
          }
          else
          {
            v15 = v11[1];
            if ( v10 == *v15 )
              *v15 = v14;
            else
              v15[2] = v14;
          }
          *v14 = v10;
          v10[1] = v14;
        }
        *(v10[1] + 12) = 1;
        *(*(v10[1] + 4) + 12) = 0;
        v16 = *(v10[1] + 4);
        v17 = *v16;
        *v16 = *(*v16 + 8);
        v18 = v17[2];
        if ( !*(v18 + 13) )
          *(v18 + 4) = v16;
        v17[1] = v16[1];
        if ( v16 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v17;
          v17[2] = v16;
        }
        else
        {
          v19 = v16[1];
          if ( v16 == v19[2] )
            v19[2] = v17;
          else
            *v19 = v17;
          v17[2] = v16;
        }
LABEL_48:
        v16[1] = v17;
        continue;
      }
    }
    else if ( *(v13 + 12) )
    {
      if ( v10 == *v11 )
      {
        v10 = v10[1];
        v20 = *v11;
        *v11 = *(*v11 + 8);
        v21 = *(v20 + 8);
        if ( !*(v21 + 13) )
          *(v21 + 4) = v10;
        *(v20 + 4) = v10[1];
        if ( v10 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v20;
        }
        else
        {
          v22 = v10[1];
          if ( v10 == v22[2] )
            v22[2] = v20;
          else
            *v22 = v20;
        }
        *(v20 + 8) = v10;
        v10[1] = v20;
      }
      *(v10[1] + 12) = 1;
      *(*(v10[1] + 4) + 12) = 0;
      v16 = *(v10[1] + 4);
      v17 = v16[2];
      v16[2] = *v17;
      if ( !*(*v17 + 13) )
        *(*v17 + 4) = v16;
      v17[1] = v16[1];
      if ( v16 == *(*v6 + 4) )
      {
        *(*v6 + 4) = v17;
      }
      else
      {
        v23 = v16[1];
        if ( v16 == *v23 )
          *v23 = v17;
        else
          v23[2] = v17;
      }
      *v17 = v16;
      goto LABEL_48;
    }
    *(v11 + 12) = 1;
    *(v13 + 12) = 1;
    *(*(v10[1] + 4) + 12) = 0;
    v10 = *(v10[1] + 4);
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (01259AF0) --------------------------------------------------------
CMapNode *__thiscall std::_Tree<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Insert_at<std::pair<unsigned long const,void *> &,std::_Tree_node<std::pair<unsigned long const,void *>,void *> *>(CMap *this, CMapNode *a2, int flags, int dwPid, void *pnode)
{
  CMapNode *parent; // ecx
  bool ret; // dl
  DWORD *dwPid_1; // ebx
  CSysProcItem *v8; // edi
  CSysProcItem *pItem; // eax
  unsigned int v10; // ecx
  CMapNode *v11; // esi
  CMapNode **v12; // eax
  CMapNode *v13; // ecx
  CMapNode *result; // eax
  int v15; // [esp+0h] [ebp-2Ch]
  CMapNode *v16; // [esp+10h] [ebp-1Ch]
  CSysProcItem *v17; // [esp+14h] [ebp-18h]
  int v18; // [esp+18h] [ebp-14h]
  int *v19; // [esp+1Ch] [ebp-10h]
  int v20; // [esp+28h] [ebp-4h]

  v19 = &v15;
  v17 = this;
  parent = this->_Header;
  ret = 1;
  dwPid_1 = dwPid;
  v8 = parent;
  v20 = 0;
  v16 = parent;
  pItem = parent->_Parent;
  LOBYTE(v18) = 1;
  if ( !pItem->_Isnil )
  {
    v10 = *dwPid;
    do
    {
      v8 = pItem;
      if ( flags )
        ret = pItem->dwPid >= v10;
      else
        ret = v10 < pItem->dwPid;
      LOBYTE(v18) = ret;
      if ( ret )
        pItem = pItem->_Left;
      else
        pItem = pItem->_Right;
    }
    while ( !pItem->_Isnil );
    parent = v16;
  }
  v11 = v8;
  flags = v8;
  if ( ret )
  {
    if ( v8 == parent->_Left )
    {
      v12 = map::_Insert_at(v17, &flags, 1, v8, dwPid, pnode);
LABEL_14:
      v13 = *v12;
      result = a2;
      a2->_Left = v13;
      LOBYTE(a2->_Parent) = 1;
      return result;
    }
    sub_1211450(&flags);
    v11 = flags;
  }
  if ( v11->_KeyValue.Key < *dwPid_1 )
  {
    v12 = map::_Insert_at(v17, &flags, v18, v8, dwPid_1, pnode);
    goto LABEL_14;
  }
  j__free(pnode);
  result = a2;
  a2->_Left = v11;
  LOBYTE(a2->_Parent) = 0;
  return result;
}

//----- (01259C10) --------------------------------------------------------
int __thiscall sub_1259C10(_DWORD *this, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // ebx
  _DWORD *v6; // ecx
  bool v7; // dl
  _DWORD *v8; // edi
  _DWORD *v9; // esi
  int *v10; // eax
  unsigned int v11; // ecx
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  int result; // eax
  int v16; // [esp+0h] [ebp-2Ch]
  _DWORD *v17; // [esp+10h] [ebp-1Ch]
  _DWORD *v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int *v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+28h] [ebp-4h]

  v20 = &v16;
  v5 = this;
  v17 = this;
  v6 = *this;
  v7 = 1;
  v8 = a4;
  v9 = v6;
  v21 = 0;
  v18 = v6;
  v10 = v6[1];
  LOBYTE(v19) = 1;
  if ( !*(v10 + 13) )
  {
    v11 = *a4;
    do
    {
      v9 = v10;
      if ( a3 )
        v7 = v10[4] >= v11;
      else
        v7 = v11 < v10[4];
      LOBYTE(v19) = v7;
      if ( v7 )
        v10 = *v10;
      else
        v10 = v10[2];
    }
    while ( !*(v10 + 13) );
    v6 = v18;
    v5 = v17;
  }
  v12 = v9;
  a3 = v9;
  if ( v7 )
  {
    if ( v9 == *v6 )
    {
      v13 = sub_12598E0(v5, &a3, 1, v9, a4, a5);
LABEL_14:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v12 = a3;
  }
  if ( v12[4] < *v8 )
  {
    v13 = sub_12598E0(v5, &a4, v19, v9, v8, a5);
    goto LABEL_14;
  }
  *a2 = v12;
  result = a2;
  *(a2 + 4) = 0;
  return result;
}

//----- (01259D20) --------------------------------------------------------
int sub_1259D20(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0xAu, Format, ArgList);
}

//----- (01259D40) --------------------------------------------------------
int LogEntry(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x1000u, Format, ArgList);
}

//----- (01259D60) --------------------------------------------------------
int sub_1259D60(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x105u, Format, ArgList);
}

//----- (01259D80) --------------------------------------------------------
int sub_1259D80(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x20u, Format, ArgList);
}

//----- (01259DA0) --------------------------------------------------------
int FormatULong64(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x32u, Format, ArgList);
}

//----- (01259DC0) --------------------------------------------------------
int sub_1259DC0(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x40u, Format, ArgList);
}

//----- (01259DE0) --------------------------------------------------------
int FormatString(wchar_t *Dst, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+10h] [ebp+10h]

  va_start(ArgList, Format);
  return vswprintf_s(Dst, 0x41u, Format, ArgList);
}

//----- (01259E00) --------------------------------------------------------
int *__thiscall sub_1259E00(_DWORD *this, LPCWSTR lpWideCharStr)
{
  int *v2; // esi
  CAtlStringMgr *v3; // ecx
  HMODULE v4; // eax

  v2 = this;
  v3 = ATL::CAtlStringMgr::GetInstance();
  if ( !v3 )
    AtlThrow(0x80004005);
  *v2 = (v3->vtptr->GetNilString)() + 16;
  if ( !lpWideCharStr || lpWideCharStr & 0xFFFF0000 )
  {
    sub_1259FE0(v2, lpWideCharStr);
  }
  else
  {
    v4 = AtlGetStringResourceImage(lpWideCharStr, 0);
    if ( v4 )
      sub_125F660(v2, v4, lpWideCharStr);
  }
  return v2;
}

//----- (01259EA0) --------------------------------------------------------
CString *__thiscall sub_1259EA0(int *this, LPCSTR lpMultiByteStr)
{
  CString *v2; // esi
  CAtlStringMgr *v3; // ecx

  v2 = this;
  v3 = ATL::CAtlStringMgr::GetInstance();
  if ( !v3 )
    AtlThrow(-2147467259);
  v2->m_pszData = ((v3->vtptr->GetNilString)() + 16);
  AsciiToUNICODE(v2, lpMultiByteStr);
  return v2;
}

//----- (01259F20) --------------------------------------------------------
void __thiscall sub_1259F20(void **this)
{
  void **v1; // eax
  _DWORD *v2; // ebx
  void *v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  void **v6; // [esp+4h] [ebp-4h]

  v1 = this;
  v6 = this;
  v2 = *this;
  if ( *this )
  {
    v3 = this[1];
    v4 = 0;
    if ( v3 )
    {
      do
      {
        v5 = v2[v4];
        if ( v5 )
          (*(*v5 + 8))(v2[v4]);
        ++v4;
      }
      while ( v4 < v3 );
      v1 = v6;
    }
    free(*v1);
  }
}

//----- (01259F70) --------------------------------------------------------
void __thiscall sub_1259F70(void **this)
{
  void **v1; // esi

  v1 = this;
  j__free(*this);
  *v1 = 0;
}

//----- (01259FB0) --------------------------------------------------------
void __thiscall sub_1259FB0(int **this)
{
  void **v1; // esi
  CSysProcItem *a2; // [esp+4h] [ebp-4h]

  v1 = this;
  sub_1275510(this, &a2, **this, *this);
  j__free(*v1);
}

//----- (01259FE0) --------------------------------------------------------
int *__thiscall sub_1259FE0(int *this, LPCWSTR lpWideCharStr)
{
  int *v2; // edi
  int v3; // esi
  int *result; // eax

  v2 = this;
  if ( lpWideCharStr && (v3 = WideCharToMultiByte(3u, 0, lpWideCharStr, -1, 0, 0, 0, 0) - 1, v3 > 0) )
  {
    if ( ((*(*v2 - 8) - v3) | (1 - *(*v2 - 4))) < 0 )
      sub_1262330(v2, v3);
    WideCharToMultiByte(3u, 0, lpWideCharStr, -1, *v2, v3, 0, 0);
    if ( v3 > *(*v2 - 8) )
      AtlThrow(-2147024809);
    *(*v2 - 12) = v3;
    *(v3 + *v2) = 0;
    result = v2;
  }
  else
  {
    sub_125B8D0(v2);
    result = v2;
  }
  return result;
}

//----- (0125A070) --------------------------------------------------------
HANDLESANDDLLSLISTUSERPARAM *__cdecl sub_125A070(HWND hWnd, char a2, int a3, int a4, int a5, int a6, int a7, u_long hostlong, int a9, int port, int a11, int a12, int a13, int a14)
{
  const __m128i *v14; // esi
  const __m128i *v15; // edi
  int v16; // esi
  int *v17; // edx
  _DWORD *v18; // ecx
  unsigned int v19; // edi
  bool v20; // cf
  LRESULT v21; // eax
  signed int v22; // eax
  unsigned int *v23; // edi
  const wchar_t *v24; // eax
  HANDLESANDDLLSLISTUSERPARAM *result; // eax
  int v26; // eax
  int v27; // edi
  _BYTE *v28; // edi
  char v29; // dl
  char v30; // al
  int v31; // ecx
  _DWORD *v32; // edx
  _DWORD *v33; // ecx
  unsigned int v34; // edi
  unsigned int v35; // kr00_4
  HWND v36; // ebx
  char v37; // [esp-890h] [ebp-13B0h]
  char v38; // [esp+Ch] [ebp-B14h]
  int v39; // [esp+10h] [ebp-B10h]
  int v40; // [esp+1Ch] [ebp-B04h]
  char v41; // [esp+30h] [ebp-AF0h]
  int v42; // [esp+34h] [ebp-AECh]
  int v43; // [esp+38h] [ebp-AE8h]
  __int128 v44; // [esp+3Ch] [ebp-AE4h]
  int v45; // [esp+254h] [ebp-8CCh]
  u_long v46; // [esp+460h] [ebp-6C0h]
  __int128 v47; // [esp+464h] [ebp-6BCh]
  int v48; // [esp+67Ch] [ebp-4A4h]
  int v49; // [esp+888h] [ebp-298h]
  unsigned int *v50; // [esp+88Ch] [ebp-294h]
  int v51; // [esp+890h] [ebp-290h]
  wchar_t *v52; // [esp+894h] [ebp-28Ch]
  LPARAM v53; // [esp+89Ch] [ebp-284h]
  int v54; // [esp+8A4h] [ebp-27Ch]
  const wchar_t *v55; // [esp+8B0h] [ebp-270h]
  LPARAM lParam; // [esp+8D0h] [ebp-250h]
  WPARAM wParam; // [esp+8D4h] [ebp-24Ch]
  int v58; // [esp+8D8h] [ebp-248h]
  int v59; // [esp+8F0h] [ebp-230h]
  const __m128i *v60; // [esp+904h] [ebp-21Ch]
  _BYTE *v61; // [esp+908h] [ebp-218h]
  unsigned int *v62; // [esp+90Ch] [ebp-214h]
  int v63; // [esp+910h] [ebp-210h]
  HWND v64; // [esp+914h] [ebp-20Ch]
  int v65; // [esp+918h] [ebp-208h]
  __int16 Dst[256]; // [esp+91Ch] [ebp-204h]

  v14 = a9;
  v65 = a4;
  v15 = a6;
  v62 = a12;
  v61 = a14;
  v64 = hWnd;
  v60 = a6;
  v63 = a9;
  lParam = 4;
  wParam = 0;
  v58 = 0;
  if ( !SendMessageW(hWnd, 0x104Bu, 0, &lParam) )
  {
LABEL_15:
    memset(&v38, 0, 0x890u);
    v39 = 5;
    v41 = 1;
    v22 = 2;
    v42 = a3;
    if ( a2 )
      v22 = 0;
    v40 = v22;
    v49 = v65;
    v43 = a5;
    if ( v15 )
      _mm_storeu_si128(&v44, _mm_loadu_si128(v15));
    v45 = a7;
    v46 = hostlong;
    if ( v14 )
      _mm_storeu_si128(&v47, _mm_loadu_si128(v14));
    v23 = v62;
    v48 = port;
    if ( gdwOsType >= 1 && !a13 && v62 )
    {
      if ( *v62 )
      {
        v24 = sub_127EFB0(*v62);
        v52 = _wcsdup(v24);
      }
    }
    v50 = v23;
    v51 = a13;
    qmemcpy(&v37, &v38, 0x890u);
    return sub_1237DD0(v64, v37);
  }
  while ( 1 )
  {
    if ( (v16 = v59, a3) && a3 != 1 || *(v59 + 44) == a5 )
    {
      if ( a3 == 2 || a3 == 3 )
      {
        v17 = v15;
        v18 = (v59 + 48);
        v19 = 12;
        while ( *v18 == *v17 )
        {
          ++v18;
          ++v17;
          v20 = v19 < 4;
          v19 -= 4;
          if ( v20 )
            goto LABEL_10;
        }
        goto LABEL_13;
      }
LABEL_10:
      if ( !*(v59 + 36) && *(v59 + 40) == a3 && *(v59 + 584) == a7 )
        break;
    }
LABEL_13:
    ++wParam;
    v21 = SendMessageW(v64, 0x104Bu, 0, &lParam);
    v15 = v60;
    if ( !v21 )
    {
      v14 = v63;
      goto LABEL_15;
    }
  }
  if ( a3 == 1 || a3 == 3 )
  {
LABEL_31:
    v26 = v65;
    goto LABEL_32;
  }
  if ( a3 )
  {
    if ( a3 != 2 )
      goto LABEL_41;
    v32 = v63;
    v33 = (v59 + 1112);
    v34 = 12;
    while ( *v33 == *v32 )
    {
      ++v33;
      ++v32;
      v20 = v34 < 4;
      v34 -= 4;
      if ( v20 )
        goto LABEL_41;
    }
    goto LABEL_31;
  }
  if ( *(v59 + 1108) != hostlong )
    goto LABEL_31;
LABEL_41:
  v26 = v65;
  if ( *(v59 + 2172) != v65 )
  {
    v27 = port;
LABEL_43:
    *(v59 + 2172) = v26;
    *(v16 + 1108) = hostlong;
    *(v16 + 1648) = v27;
    if ( a3 )
    {
      v54 = 2;
      v55 = L"*:*";
      SendMessageW(v64, 0x1074u, wParam, &v53);
    }
    else
    {
      sub_12444B0(0, 1, 0, hostlong, v63, Dst, 0x100u);
      v35 = wcslen(Dst);
      sub_1244670(1, v27, proto[0], &Dst[v35], 256 - v35);
      v36 = v64;
      v55 = Dst;
      v54 = 2;
      SendMessageW(v64, 0x1074u, wParam, &v53);
      v54 = 3;
      v55 = off_12DD238[v65];
      SendMessageW(v36, 0x1074u, wParam, &v53);
    }
    v28 = v61;
    *v61 = 1;
    goto LABEL_34;
  }
LABEL_32:
  v27 = port;
  if ( *(v59 + 1648) != port )
    goto LABEL_43;
  v28 = v61;
LABEL_34:
  v29 = *(v16 + 24);
  v30 = 0;
  if ( v29 )
  {
    v31 = *(v16 + 28);
    if ( v31 < gdwHighlightDuration )
    {
      *(v16 + 16) = 2;
      result = 0;
      *(v16 + 20) = v31;
      *(v16 + 36) = 1;
      return result;
    }
    if ( v29 )
    {
      v30 = 1;
      *(v16 + 24) = 0;
    }
  }
  *(v16 + 16) = 0;
  if ( v30 )
    *v28 = 1;
  result = 0;
  *(v16 + 36) = 1;
  return result;
}
// 12BE250: using guessed type wchar_t asc_12BE250[4];
// 12DD238: using guessed type wchar_t *off_12DD238[13];
// 12E4E54: using guessed type int gdwOsType;
// 12E5534: using guessed type int gdwHighlightDuration;
// 125A070: using guessed type wchar_t Dst[256];

//----- (0125A4A0) --------------------------------------------------------
int __thiscall sub_125A4A0(int *this, __int16 a2)
{
  int *v2; // edi
  int v3; // ebx
  int v4; // esi
  int result; // eax

  v2 = this;
  v3 = *(*this - 12);
  v4 = v3 + 1;
  if ( v3 + 1 < 0 )
    goto LABEL_9;
  if ( ((*(*this - 8) - v4) | (1 - *(*this - 4))) < 0 )
    ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2(this, v3 + 1);
  *(*v2 + 2 * v3) = a2;
  if ( v4 > *(*v2 - 8) )
LABEL_9:
    AtlThrow(-2147024809);
  *(*v2 - 12) = v4;
  result = *v2;
  *(*v2 + 2 * v4) = 0;
  return result;
}

//----- (0125A500) --------------------------------------------------------
int __cdecl sub_125A500(int a1)
{
  int v1; // eax
  int v2; // ecx
  signed int v3; // edx
  _DWORD *v4; // eax
  unsigned int v5; // esi
  int v6; // kr00_4
  int result; // eax

  if ( GetVersion() <= 4u )
    v1 = a1 + 136;
  else
    v1 = a1 + 184;
  v2 = *(a1 + 4);
  if ( !v2 )
    goto LABEL_14;
  v3 = 0;
  v4 = (v1 + 48);
  v5 = 0;
  do
  {
    v6 = *v4 + v5;
    v3 = (*v4 + __PAIR__(v3, v5)) >> 32;
    v5 += *v4;
    v4 += 16;
    --v2;
  }
  while ( v2 );
  if ( v3 >= 0 && (v3 > 0 || v6) )
    result = v6;
  else
LABEL_14:
    result = 0;
  return result;
}

//----- (0125A580) --------------------------------------------------------
int __stdcall sub_125A580(int a1, int a2, DWORD pSIRequested, PSECURITY_DESCRIPTOR pSID, int a5, int a6, int a7, int a8)
{
  DWORD v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // eax
  HANDLE v12; // edi
  int result; // eax
  DWORD v14; // eax
  bool v15; // zf
  DWORD nLengthNeeded; // [esp+8h] [ebp-4h]

  v8 = pSIRequested;
  v9 = *(pSIRequested + 8);
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        pSIRequested = 1;
        v11 = 0x80000;
      }
      else
      {
        v11 = a8;
      }
    }
    else
    {
      pSIRequested = 8;
      v11 = 0x1000000;
    }
  }
  else
  {
    pSIRequested = 4;
    v11 = 0x40000;
  }
  v12 = DuplicateProcessHandle(*v8, *(v8 + 4), v11);
  if ( v12 )
  {
    if ( SetUserObjectSecurity(v12, &pSIRequested, pSID) )
    {
      v14 = pSIRequested | 3;
      v15 = *(v8 + 8) == 2;
      pSIRequested |= 3u;
      if ( v15 )
        pSIRequested = v14 | 4;
      **(v8 + 20) = GetUserObjectSecurity(v12, &pSIRequested, *(v8 + 16), 0x2000u, &nLengthNeeded);
    }
    else
    {
      MessageBoxW(0, L"Unable to modify the object's Security Information.", L"WinObj", 0x10u);
    }
    CloseHandle(v12);
    *a8 = 1;
    result = 0;
  }
  else
  {
    MessageBoxW(0, L"Unable to modify the object's Security Information.", L"WinObj", 0x10u);
    *a8 = 1;
    result = 0;
  }
  return result;
}

//----- (0125A670) --------------------------------------------------------
HBRUSH __stdcall DllInfoPropWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM dwNewLong)
{
  int v4; // edi
  CResize *v5; // eax
  CResize *v6; // eax
  HWND v7; // eax
  ResizeInfo *v8; // eax
  HWND v9; // eax
  ResizeInfo *v10; // eax
  wchar_t *v11; // eax
  const WCHAR *v12; // eax
  const WCHAR *v13; // ecx
  BOOL v14; // ST10_4
  HWND v15; // eax
  BOOL v16; // ST10_4
  HWND v17; // eax
  HICON v18; // ST10_4
  HWND v19; // eax
  HICON v20; // ST10_4
  HWND v21; // eax
  const WCHAR *v22; // ST10_4
  HWND v23; // eax
  HWND v24; // eax
  _WORD *v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  _WORD *v28; // eax
  int v29; // ST10_4
  HWND v30; // eax
  const WCHAR *v31; // ecx
  wchar_t *v32; // eax
  int v34; // eax
  HWND v35; // eax
  const WCHAR *v36; // eax
  int v37; // eax
  char v38; // cl
  HWND v39; // eax
  int v40; // ST10_4
  HWND v41; // eax
  HWND v42; // eax
  WPARAM v43; // [esp-8h] [ebp-E38h]
  int v44; // [esp-4h] [ebp-E34h]
  CResize *hdc; // [esp+1Ch] [ebp-E14h]
  WCHAR String; // [esp+20h] [ebp-E10h]
  WCHAR v47; // [esp+820h] [ebp-610h]
  WCHAR v48; // [esp+A20h] [ebp-410h]
  WCHAR Dest; // [esp+C20h] [ebp-210h]
  int v50; // [esp+E2Ch] [ebp-4h]

  v4 = GetWindowLongW(hWnd, -21);
  switch ( uMsg )
  {
    case 0x110u:
      v5 = operator new(0x40u);
      v50 = 0;
      if ( v5 )
        v6 = CResize::CResize(v5, hWnd);
      else
        v6 = 0;
      hdc = v6;
      v50 = -1;
      v6->m_WidthScale = 85;
      v6->m_HeightScale = 100;
      v7 = GetDlgItem(hWnd, 1015);
      if ( v7 )
      {
        v8 = CResize::InitResizeBuffer(hdc, v7, 1);
        *&v8->d1.left = 0i64;
        *&v8->d1.right = doubleOnePointZero;
      }
      v9 = GetDlgItem(hWnd, 1656);
      if ( v9 )
      {
        v10 = CResize::InitResizeBuffer(hdc, v9, 1);
        *&v10->d1.left = 0i64;
        *&v10->d1.right = doubleOnePointZero;
      }
      SetWindowLongW(hWnd, -21, dwNewLong);
      if ( wcsrchr(*(dwNewLong + 344), 0x5Cu) )
        v11 = wcsrchr(*(dwNewLong + 344), 0x5Cu) + 1;
      else
        v11 = *(dwNewLong + 344);
      FormatTex(&String, L"%s Properties", v11);
      SetWindowTextW(hWnd, &String);
      if ( *(dwNewLong + 44) & 4 )
        SetDlgItemTextW(hWnd, 106, L"Path (Image is probably packed):");
      v12 = L"Data";
      if ( !(*(dwNewLong + 44) & 2) )
        v12 = L"Image";
      SetDlgItemTextW(hWnd, 1323, v12);
      SetDlgItemTextW(hWnd, 1015, *(dwNewLong + 344));
      v13 = L"n/a";
      if ( *(dwNewLong + 348) )
        v13 = *(dwNewLong + 348);
      SetDlgItemTextW(hWnd, 1656, v13);
      v14 = *(dwNewLong + 344) != 0;
      v15 = GetDlgItem(hWnd, 1307);
      EnableWindow(v15, v14);
      v16 = *(dwNewLong + 348) != 0;
      v17 = GetDlgItem(hWnd, 1306);
      EnableWindow(v17, v16);
      v18 = LoadIconW(ghInstance, 0x9A);
      v19 = GetParent(hWnd);
      SendMessageW(v19, 0x80u, 1u, v18);
      v20 = LoadIconW(ghInstance, 0x9A);
      v21 = GetParent(hWnd);
      SendMessageW(v21, 0x80u, 0, v20);
      if ( *(dwNewLong + 336) )
        SetDlgItemTextW(hWnd, 1183, *(dwNewLong + 336));
      else
        SetDlgItemTextW(hWnd, 1183, L"n/a");
      if ( *(dwNewLong + 340) )
      {
        v22 = VerifySignatureOK(dwNewLong, gbVerifySignatures);
        SetDlgItemTextW(hWnd, 3, v22);
      }
      else
      {
        SetDlgItemTextW(hWnd, 3, L"n/a");
      }
      v23 = GetDlgItem(hWnd, 1195);
      ShowWindow(v23, 0);
      if ( gbWintrustInited )
      {
        if ( *(dwNewLong + 352) || (v25 = *(dwNewLong + 340)) == 0 || *v25 == 91 )
        {
          v26 = GetDlgItem(hWnd, 1005);
          EnableWindow(v26, 0);
        }
      }
      else
      {
        v24 = GetDlgItem(hWnd, 1005);
        ShowWindow(v24, 0);
      }
      v27 = GetDlgItem(hWnd, 1672);
      SetWindowSubclass(v27, pfnSubclass, 0, 0);
      sub_1281A50(*(dwNewLong + 364), &Dest);
      SetDlgItemTextW(hWnd, 1672, &Dest);
      v28 = *(dwNewLong + 344);
      if ( v28 && *v28 != 91 )
      {
        v29 = sub_1281C10(*(dwNewLong + 364));
        v30 = GetDlgItem(hWnd, 1671);
        EnableWindow(v30, v29);
      }
      v31 = L"n/a";
      if ( *(dwNewLong + 206) )
        v31 = (dwNewLong + 206);
      SetDlgItemTextW(hWnd, 25, v31);
      FormatTex(&String, L"0x%X", *(dwNewLong + 36));
      SetDlgItemTextW(hWnd, 1321, &String);
      FormatTex(&String, L"0x%X bytes", *(dwNewLong + 56));
      SetDlgItemTextW(hWnd, 1322, &String);
      if ( *(dwNewLong + 72) )
        v32 = _wctime32((dwNewLong + 72));
      else
        v32 = L"n/a";
      SetDlgItemTextW(hWnd, 30, v32);
      SetTimer(hWnd, 0, 0x3E8u, 0);
      ResizeTab(hWnd);
      ShowWindow(hWnd, 1);
      return 1;
    case 0x111u:
      if ( wParam > 1307 )
      {
        if ( wParam > 40001 )
        {
          if ( wParam - 40092 > 1 )
            return 0;
          v43 = wParam;
        }
        else
        {
          if ( wParam != 40001 )
          {
            if ( wParam == 1671 )
            {
              if ( !sub_12817E0() )
                return 1;
              v37 = *(v4 + 364);
              v38 = 0;
              if ( v37 )
              {
                v38 = 1;
                *(v37 + 4) = 6;
              }
              sub_1281C30(v4, ~(*(v4 + 44) >> 1) & 1, v38 != 0);
              v39 = GetDlgItem(hWnd, 1671);
              EnableWindow(v39, 0);
              sub_1281A50(*(v4 + 364), &v48);
              v40 = sub_1281C10(*(v4 + 364));
              v41 = GetDlgItem(hWnd, 1671);
              EnableWindow(v41, v40);
              SetDlgItemTextW(hWnd, 1672, &v48);
              PostMessageW(ghWndNewOwner, 0x7F9u, 0, *(v4 + 364));
              return 1;
            }
            return 0;
          }
          v43 = 40014;
        }
        v42 = GetParent(hWnd);
        PostMessageW(v42, 0x111u, v43, 0);
        return 0;
      }
      if ( wParam == 1307 )
      {
        sub_122B780(hWnd, *(v4 + 344));
        return 1;
      }
      if ( wParam > 1005 )
      {
        if ( wParam == 1306 )
        {
          sub_122B780(hWnd, *(v4 + 348));
          return 1;
        }
        return 0;
      }
      if ( wParam != 1005 )
      {
        if ( wParam != 1 )
        {
          if ( wParam == 2 )
            return 1;
          return 0;
        }
        return 1;
      }
      v36 = VerifySignatureOK(v4, 1);
      SetDlgItemTextW(hWnd, 3, v36);
      v44 = 0;
      v35 = GetDlgItem(hWnd, 1005);
LABEL_44:
      EnableWindow(v35, v44);
      return 1;
    case 0x113u:
      GetDlgItemTextW(hWnd, 1672, &v47, 256);
      sub_1281A50(*(v4 + 364), &Dest);
      v34 = wcscmp(&v47, &Dest);
      if ( v34 )
        v34 = -(v34 < 0) | 1;
      if ( !v34 )
        return 1;
      SetDlgItemTextW(hWnd, 1672, &Dest);
      v44 = sub_1281C10(*(v4 + 364));
      v35 = GetDlgItem(hWnd, 1671);
      goto LABEL_44;
    case 0x138u:
      if ( dwNewLong != GetDlgItem(hWnd, 1672) || !sub_1281820(*(v4 + 364)) )
        return 0;
      if ( sub_1282910(*(v4 + 364)) )
        SetTextColor(wParam, 0xFFu);
      else
        SetTextColor(wParam, 0xFF0000u);
      SelectObject(wParam, ghDefaultGuiFontUnderline);
      return GetSysColorBrush(20);
    default:
      return 0;
  }
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BE220: using guessed type wchar_t aData_0[5];
// 12E96D7: using guessed type char gbVerifySignatures;
// 12EA391: using guessed type char gbWintrustInited;

//----- (0125ADD0) --------------------------------------------------------
BOOL __stdcall DllPropDlgProc(HWND hDlg, UINT a2, WPARAM wParam, CPropSheetDlg *pPropSheetDlg)
{
  LONG v4; // eax
  LVITEMUSERDATA **v5; // ebx
  HWND *v7; // esi
  signed int v8; // ebx
  LRESULT v9; // eax
  LVITEMUSERDATA *v10; // esi
  HWND v11; // eax
  int v12; // ecx
  HWND v13; // esi
  HWND *v14; // esi
  HWND v15; // ecx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  WPARAM v17; // eax
  LRESULT v18; // eax
  WPARAM v19; // ecx
  _DWORD *i; // eax
  CResize *v21; // eax
  HWND v22; // ebx
  bool v23; // zf
  #1077 *v24; // eax
  wchar_t *v25; // eax
  HWND v26; // eax
  int v27; // eax
  WPARAM v28; // ecx
  HCURSOR v29; // eax
  TCITEMW item; // [esp+10h] [ebp-260h]
  struct tagPOINT Point; // [esp+2Ch] [ebp-244h]
  HWND v32; // [esp+34h] [ebp-23Ch]
  NMHDR nmHdr; // [esp+38h] [ebp-238h]
  HWND hWnd; // [esp+44h] [ebp-22Ch]
  struct tagRECT Rect; // [esp+48h] [ebp-228h]
  WCHAR String; // [esp+58h] [ebp-218h]
  int v37; // [esp+26Ch] [ebp-4h]

  v32 = hDlg;
  hWnd = GetDlgItem(hDlg, IDW_STATIC);
  v4 = GetWindowLongW(hDlg, GWL_USERDATA);
  v5 = v4;
  if ( a2 > WM_NOTIFY )
  {
    if ( a2 == WM_INITDIALOG )
    {
      v21 = operator new(0x40u);
      v32 = v21;
      v37 = 0;
      if ( v21 )
        CResize::CResize(v21, hDlg);
      SetWindowLongW(hDlg, GWL_USERDATA, pPropSheetDlg);
      v22 = hWnd;
      item.mask = 3;
      item.iImage = -1;
      item.pszText = L"Image";
      ::SendMessageW(hWnd, TCM_INSERTITEMW, 0, &item);
      tcscpy_s(pPropSheetDlg->PageData[1].TemplateName, 256u, L"PROCSTRINGS");
      pPropSheetDlg->PageData[1].TabId = 13;
      pPropSheetDlg->PageData[1].PageWndProc = ProcStringsWndProc;
      item.pszText = L"Strings";
      ::SendMessageW(v22, TCM_INSERTITEMW, 1u, &item);
      v23 = wcsrchr(*(pPropSheetDlg->TreeListItemData + 86), '\\') == 0;
      v24 = pPropSheetDlg->TreeListItemData;
      if ( v23 )
        v25 = *(v24 + 86);
      else
        v25 = wcsrchr(*(v24 + 86), '\\') + 1;
      stprintf(&String, L"%s Properties", v25);
      SetWindowTextW(hDlg, &String);
      v26 = CreateDialogParamW(ghInstance2, L"DLLINFO", hDlg, DllInfoPropWndProc, pPropSheetDlg->TreeListItemData);
      pPropSheetDlg->PageData[0].hWnd = v26;
      pPropSheetDlg->PageData[0].TabId = 1;
      ShowWindow(v26, 5);
      SetForegroundWindow(hDlg);
      v27 = pPropSheetDlg->PageData[0].TabId;
      v28 = 0;
      if ( v27 )
      {
        while ( gdwDefaultDllPropPage != v27 )
        {
          v27 = *(&pPropSheetDlg->TabIndex + 131 * (++v28 + 1));
          if ( !v27 )
            goto LABEL_47;
        }
      }
      else
      {
LABEL_47:
        v28 = 0;
      }
      ::SendMessageW(v22, TCM_SETCURSEL, v28, 0);
      nmHdr.idFrom = IDW_STATIC;
      nmHdr.code = -0x227u;
      ::SendMessageW(hDlg, WM_NOTIFY, 0, &nmHdr);
      if ( gWindowPlacement[3].rcNormalPosition.right == gWindowPlacement[3].rcNormalPosition.left )
      {
        GetCursorPos(&Point);
        SetPropSheetRect(hDlg, Point.x - 385, Point.y - 408);
      }
      else
      {
        sub_126DC50(hDlg, pPropSheetDlg->TreeListItemData);
      }
      ShowWindow(hDlg, 5);
      InterlockedDecrement(&gnLock);
      v29 = LoadCursorW(0, 0x7F00);
      SetCursor(v29);
      return 1;
    }
    if ( a2 == 273 )
    {
      if ( wParam > 40092 )
      {
        if ( wParam != 40093 )
          return 0;
        v18 = ::SendMessageW(hWnd, TCM_GETCURSEL, 0, 0);
        v19 = v18 - 1;
        if ( !v18 )
        {
          v19 = 0;
          for ( i = v5 + 263; *i; ++v19 )
            i += 131;
        }
        SendMessageW = ::SendMessageW;
        ::SendMessageW(hWnd, TCM_SETCURSEL, v19, 0);
      }
      else
      {
        if ( wParam != 40092 )
        {
          if ( wParam > 0 && (wParam <= 2 || wParam == 40014) )
          {
            v14 = (v4 + 8);
            v15 = 32;
            hWnd = 32;
            while ( 1 )
            {
              if ( *v14 )
              {
                ::SendMessageW(*v14, WM_COMMAND, wParam, 0);
                DestroyWindow(*v14);
                v15 = hWnd;
              }
              v14 += 131;
              v15 = (v15 - 1);
              hWnd = v15;
              if ( !v15 )
              {
                sub_1238600(v5[1]);
                free(v5);
                GetWindowPlacement(v32, &gWindowPlacement[3]);
                DestroyWindow(v32);
                _endthread();
              }
            }
          }
          return 0;
        }
        SendMessageW = ::SendMessageW;
        v17 = ::SendMessageW(hWnd, TCM_GETCURSEL, 0, 0) + 1;
        if ( !v5[131 * v17 + 132] )
          v17 = 0;
        ::SendMessageW(hWnd, TCM_SETCURSEL, v17, 0);
      }
      nmHdr.idFrom = 1110;
      nmHdr.code = -551;
      SendMessageW(hDlg, WM_NOTIFY, 0, &nmHdr);
    }
    return 0;
  }
  if ( a2 == WM_NOTIFY )
  {
    if ( pPropSheetDlg->TreeListItemData == IDW_STATIC && pPropSheetDlg->PageData[0].hWnd == -0x227u )
    {
      v9 = ::SendMessageW(hWnd, TCM_GETCURSEL, 0, 0);
      v10 = v9;
      v11 = &v5[131 * v9];
      gdwDefaultDllPropPage = *(v11 + 131);
      v12 = 131 * *v5;
      hWnd = v11;
      ShowWindow(v5[v12 + 2], 0);
      *v5 = v10;
      v13 = hWnd;
      if ( !*(hWnd + 2) )
        *(hWnd + 2) = CreateDialogParamW(ghInstance2, hWnd + 6, hDlg, *(hWnd + 132), v5[1]);
      ShowWindow(*(v13 + 2), 5);
      return 0;
    }
    return 0;
  }
  if ( a2 != 5 )
  {
    if ( a2 == 36 )
    {
      pPropSheetDlg->PageData[0].hWnd = 2 * gScreenWidth;
      return 0;
    }
    return 0;
  }
  v7 = (v4 + 8);
  v8 = 32;
  do
  {
    if ( *v7 )
    {
      GetWindowRect(hWnd, &Rect);
      ::SendMessageW(hWnd, TCM_ADJUSTRECT, 0, &Rect);
      MapWindowPoints(0, hDlg, &Rect, 2u);
      MoveWindow(*v7, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 1);
    }
    v7 += 131;
    --v8;
  }
  while ( v8 );
  return 0;
}
// 128A009: using guessed type int _endthread(void);
// 12C65E8: using guessed type wchar_t aStrings[8];
// 12E4E28: using guessed type int gScreenWidth;
// 12E96EC: using guessed type int gdwDefaultDllPropPage;

//----- (0125B330) --------------------------------------------------------
MACRO_BOOL CDriver::Load()
{
  TCHAR szFileName[260]; // [esp+0h] [ebp-414h]
  TCHAR szPathName[260]; // [esp+208h] [ebp-20Ch]

  if ( !CDriver::Open(L"PROCEXP152", &theDriver) )
  {
    GetSystemDirectoryW(szFileName, _MAX_PATH);
    stprintf(szPathName, L"%s\\Drivers\\%s", szFileName, L"PROCEXP152.SYS");
    if ( !CDriver::LoadFromResource(EDriverID_WIN32, szPathName) )
    {
      stprintf(szFileName, L"%%TEMP%%\\%s", L"PROCEXP152.SYS");
      ExpandEnvironmentStringsW(szFileName, szPathName, _MAX_PATH);
      if ( !CDriver::LoadFromResource(EDriverID_WIN32, szPathName) )
      {
        GetCurrentDirectoryW(_MAX_PATH, szFileName);
        // 这不是BUG吗？
        stprintf(szPathName, L"%s\\s", szFileName, L"PROCEXP152.SYS");
        if ( !CDriver::LoadFromResource(EDriverID_WIN32, szPathName) )
          return FALSE;
      }
    }
    if ( !CDriver::OpenEx(L"PROCEXP152", szPathName, &theDriver) )
    {
      DeleteFileW(szPathName);
      return FALSE;
    }
    DeleteFileW(szPathName);
  }
  return TRUE;
}
// 12C2E08: using guessed type wchar_t aProcexp152Sys[15];

//----- (0125B490) --------------------------------------------------------
HCURSOR __cdecl sub_125B490(HWND hWnd, CPropSheetDlg *pPropSheet)
{
  #1077 *hWindow; // ST14_4
  HCURSOR result; // eax
  SYSTEM_PROCESS_INFORMATION *SystemProcInfo; // edi
  HANDLE dwProcessId; // ecx
  HCURSOR hcursor; // eax
  void *v7; // eax
  HANDLE Handle; // eax
  void *ModuleInfo; // eax
  DWORD v10; // esi
  void *pModuleInfo; // eax
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  void *ThreadHandle; // esi
  #1077 *v16; // ST10_4
  HANDLESANDDLLSLISTUSERPARAM *pParam; // edi
  HCURSOR hArrowCursor; // eax
  unsigned int idx; // esi
  int v20; // eax
  int v21; // eax
  HANDLESANDDLLSLISTUSERPARAM *v22; // eax
  DWORD ThreadId; // [esp+8h] [ebp-4ECh]
  LVITEMW item; // [esp+Ch] [ebp-4E8h]
  int v25; // [esp+40h] [ebp-4B4h]
  int v26; // [esp+44h] [ebp-4B0h]
  DWORD ExitCode; // [esp+48h] [ebp-4ACh]
  HWND hwnd; // [esp+4Ch] [ebp-4A8h]
  char ArgList[4]; // [esp+50h] [ebp-4A4h]
  DWORD pdwSizeReturned; // [esp+54h] [ebp-4A0h]
  SYSTEM_PROCESS_INFORMATION *pSystemProcessInfo; // [esp+58h] [ebp-49Ch]
  char v32; // [esp+5Fh] [ebp-495h]
  __int16 v33[22]; // [esp+60h] [ebp-494h]
  int v34; // [esp+8Ch] [ebp-468h]
  __int16 szText[302]; // [esp+94h] [ebp-460h]
  __int16 Dst[256]; // [esp+2F0h] [ebp-204h]

  hwnd = hWnd;
  *ArgList = 0;
  pSystemProcessInfo = 0;
  v32 = 0;
  SendMessageW(hWnd, LVM_DELETEALLITEMS, 0, 0);
  hWindow = pPropSheet->TreeListItemData;
  v34 = 0;
  result = SendMessageW(hWindow, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
  item.iItem = result;
  if ( result != -1 )
  {
    if ( !LOBYTE(pPropSheet->PageData[0].TemplateName[4]) )
    {
      GetAllProcesses(&pSystemProcessInfo, 0);
      SystemProcInfo = pSystemProcessInfo;
      dwProcessId = *(pPropSheet->TabIndex + 0x44);
      if ( pSystemProcessInfo->UniqueProcessId != dwProcessId )
      {
        while ( SystemProcInfo->NextEntryOffset )
        {
          SystemProcInfo = (SystemProcInfo + SystemProcInfo->NextEntryOffset);
          if ( SystemProcInfo->UniqueProcessId == dwProcessId )
            goto LABEL_8;
        }
        SystemProcInfo = 0;
      }
LABEL_8:
      hcursor = LoadCursorW(0, IDC_WAIT);
      SetCursor(hcursor);
      *pPropSheet->PageData[0].TemplateName = OpenProcess(0x80000000, 0, *(pPropSheet->TabIndex + 68));
      if ( *SymInitialize )
      {
        EnterCriticalSection(&gStrListLock);
        v32 = 1;
        SymSetOptions(0x10027u);
        v7 = *pPropSheet->PageData[0].TemplateName;
        if ( v7 )
          LOBYTE(pPropSheet->PageData[0].TemplateName[4]) = SymInitialize(v7, 0, 1);
        if ( !LOBYTE(pPropSheet->PageData[0].TemplateName[4]) )
        {
          if ( *pPropSheet->PageData[0].TemplateName )
            CloseHandle(*pPropSheet->PageData[0].TemplateName);
          Handle = GetCurrentProcess();
          *pPropSheet->PageData[0].TemplateName = Handle;
          LOBYTE(pPropSheet->PageData[0].TemplateName[4]) = SymInitialize(Handle, 0, 1);
        }
      }
      pdwSizeReturned = 1000;
      ModuleInfo = malloc(1000u);
      pPropSheet->PageData[0].hWnd = ModuleInfo;
      if ( NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, 1000u, &pdwSizeReturned) )
      {
        do
        {
          free(pPropSheet->PageData[0].hWnd);
          pdwSizeReturned += 1000;
          v10 = pdwSizeReturned;
          pModuleInfo = malloc(pdwSizeReturned);
          pPropSheet->PageData[0].hWnd = pModuleInfo;
        }
        while ( NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, v10, &pdwSizeReturned) );
      }
      v12 = pPropSheet->TabIndex;
      *&pPropSheet->PageData[0].TemplateName[2] = 0;
      if ( !(*(v12 + 40) & 0x10) )
      {
        v13 = RtlCreateQueryDebugBuffer(0, 0);
        *&pPropSheet->PageData[0].TemplateName[2] = v13;
        if ( v13 )
        {
          v14 = SystemProcInfo->UniqueProcessId;
          v26 = v13;
          v25 = v14;
          ThreadHandle = _beginthreadex(0, 0, QueryDBGInfoThreadProc, &v25, 0, &ThreadId);
          if ( WaitForSingleObject(ThreadHandle, 4000u) == WAIT_TIMEOUT )
            TerminateThread(ThreadHandle, 1u);
          GetExitCodeThread(ThreadHandle, &ExitCode);
          if ( ExitCode )
          {
            RtlDestroyQueryDebugBuffer(*&pPropSheet->PageData[0].TemplateName[2]);
            *&pPropSheet->PageData[0].TemplateName[2] = 0;
          }
          CloseHandle(ThreadHandle);
        }
      }
    }
    item.iSubItem = 0;
    v16 = pPropSheet->TreeListItemData;
    item.mask = LVCF_TEXT;
    SendMessageW(v16, LVM_GETITEMW, 0, &item);
    pParam = item.lParam;
    hArrowCursor = LoadCursorW(0, IDC_WAIT);
    idx = 0;
    pSystemProcessInfo = SetCursor(hArrowCursor);
    if ( *&pParam[0xB].szText[0x3A] & 0xFFFFFFFC )
    {
      do
      {
        v20 = *(*&pParam[0xB].szText[0x38] + 4 * idx);
        if ( v20 && v20 != -1 )
        {
          sub_125DD60(
            1,
            v20,
            v33,
            *pPropSheet->PageData[0].TemplateName,
            0,
            0,
            *&pPropSheet->PageData[0].TemplateName[2],
            pPropSheet->PageData[0].hWnd);
          v21 = wcscmp(szText, L"0x0");
          if ( v21 )
            v21 = -(v21 < 0) | 1;
          if ( v21 )
          {
            item.mask = 5;
            item.iItem = 0x7FFFFFFF;
            item.iSubItem = 0;
            item.stateMask = 0;
            item.state = 0;
            VLogEntry(Dst, L"%d", *ArgList);
            item.iImage = 0;
            item.pszText = Dst;
            v22 = (*ArgList + 1);
            *ArgList = v22;
            item.lParam = v22;
            result = SendMessageW(hwnd, LVM_INSERTITEMW, 0, &item);
            if ( result == -1 )
              return result;
            item.iItem = result;
            item.pszText = szText;
            item.mask = 1;
            item.iSubItem = 1;
            SendMessageW(hwnd, LVM_SETITEMW, 0, &item);
          }
        }
        ++idx;
      }
      while ( idx < *&pParam[0xB].szText[0x3A] >> 2 );
    }
    if ( v32 )
      LeaveCriticalSection(&gStrListLock);
    result = SetCursor(pSystemProcessInfo);
  }
  return result;
}
// 12C5208: using guessed type wchar_t a0x0[4];
// 12EF25C: using guessed type int (__stdcall *RtlCreateQueryDebugBuffer)(_DWORD, _DWORD);
// 12EF264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);

//----- (0125B8D0) --------------------------------------------------------
_BYTE *__thiscall sub_125B8D0(_DWORD *this)
{
  _DWORD *v1; // esi
  _BYTE *result; // eax
  volatile signed __int32 *v3; // edx
  volatile signed __int32 v4; // edi

  v1 = this;
  result = *this;
  v3 = (*this - 16);
  v4 = *v3;
  if ( *(*this - 12) )
  {
    if ( *(v3 + 3) >= 0 )
    {
      if ( _InterlockedDecrement(v3 + 3) <= 0 )
        (*(**v3 + 4))(v3);
      result = ((*(*v4 + 12))(v4) + 16);
      *v1 = result;
    }
    else
    {
      if ( *(result - 2) < 0 )
        AtlThrow(-2147024809);
      *(result - 3) = 0;
      result = *this;
      **this = 0;
    }
  }
  return result;
}

//----- (0125B930) --------------------------------------------------------
void __cdecl sub_125B930(HANDLE hProcess, LPCVOID lpBaseAddress, int a3, int a4, int a5)
{
  BOOL (__stdcall *v5)(HANDLE, LPCVOID, LPVOID, SIZE_T, SIZE_T *); // edi
  SIZE_T v6; // edi
  void *v7; // esi
  SIZE_T v8; // ST0C_4
  SIZE_T v9; // edi
  SIZE_T v10; // ST0C_4
  signed int v11; // esi
  wchar_t *v12; // esi
  size_t v13; // edi
  char *v14; // esi
  size_t v15; // edi
  void *v16; // eax
  volatile signed __int32 *v17; // esi
  SIZE_T NumberOfBytesRead; // [esp+18h] [ebp-80514h]
  void *v19; // [esp+1Ch] [ebp-80510h]
  char Buffer; // [esp+20h] [ebp-8050Ch]
  LPCVOID v21; // [esp+30h] [ebp-804FCh]
  char v22; // [esp+270h] [ebp-802BCh]
  unsigned __int16 v23; // [esp+294h] [ebp-80298h]
  LPCVOID v24; // [esp+298h] [ebp-80294h]
  unsigned __int16 v25; // [esp+2B0h] [ebp-8027Ch]
  LPCVOID v26; // [esp+2B4h] [ebp-80278h]
  LPCVOID v27; // [esp+2B8h] [ebp-80274h]
  wchar_t Src; // [esp+518h] [ebp-80014h]
  int v29; // [esp+80518h] [ebp-14h]
  int v30; // [esp+80528h] [ebp-4h]

  v5 = ReadProcessMemory;
  v19 = a4;
  if ( ReadProcessMemory(hProcess, lpBaseAddress, &Buffer, 0x250u, &NumberOfBytesRead)
    && ReadProcessMemory(hProcess, v21, &v22, 0x2A8u, &NumberOfBytesRead)
    && v26 )
  {
    if ( a3 )
    {
      v6 = v25;
      v7 = malloc(v25 + 2);
      v8 = v6;
      v5 = ReadProcessMemory;
      if ( !ReadProcessMemory(hProcess, v26, v7, v8, &NumberOfBytesRead) )
      {
LABEL_6:
        j__free(v7);
        return;
      }
      *(v7 + (v25 >> 1)) = 0;
      *a3 = v7;
      j__free(0);
    }
    if ( v19 )
    {
      v9 = v23;
      v7 = malloc(v23 + 2);
      v10 = v9;
      v5 = ReadProcessMemory;
      if ( !ReadProcessMemory(hProcess, v24, v7, v10, &NumberOfBytesRead) )
        goto LABEL_6;
      *(v7 + (v23 >> 1)) = 0;
      *v19 = v7;
      j__free(0);
    }
    if ( a5 )
    {
      v11 = 0x80000;
      while ( !v5(hProcess, v27, &Src, v11, &NumberOfBytesRead) )
      {
        v11 -= 4096;
        if ( v11 <= 0 )
          return;
      }
      if ( v11 > 0 )
      {
        v29 = 0;
        sub_122B3A0(&v19);
        v12 = &Src;
        v30 = 0;
        if ( Src )
        {
          do
          {
            if ( *v12 == 61 )
            {
              do
                ++v12;
              while ( *v12 );
            }
            else
            {
              v13 = wcslen(v12);
              sub_122DB80(&v19, v12, v13);
              sub_125A4A0(&v19, 0);
              v12 += v13;
            }
            ++v12;
          }
          while ( *v12 );
        }
        v14 = v19;
        v15 = 2 * *(v19 - 3) + 2;
        v16 = malloc(v15);
        *a5 = v16;
        memmove_0(v16, v14, v15);
        v17 = (v14 - 16);
        v30 = -1;
        if ( _InterlockedDecrement(v17 + 3) <= 0 )
          (*(**v17 + 4))(v17);
      }
    }
  }
}

//----- (0125BBC0) --------------------------------------------------------
int __stdcall SortInFindDlgCallback(int Data1, int Data2, int col)
{
  int ret; // eax
  int res; // ecx

  if ( col )
  {
    if ( col == 1 )
    {
      res = *(Data1 + 0xA8) - *(Data2 + 0xA8);
      goto LABEL_9;
    }
    if ( col == 2 )
      ret = _wcsicmp((Data1 + 0x28), (Data2 + 0x28));
    else
      ret = _wcsicmp(*(Data1 + 0xB4), *(Data2 + 0xB4));
  }
  else
  {
    ret = _wcsicmp(*(Data1 + 0x24), *(Data2 + 0x24));
  }
  res = ret;
LABEL_9:
  if ( !gbFINDDLGLISTAscending )
    res = -res;
  return res;
}
// 12DE8B0: using guessed type char gbFINDDLGLISTAscending;

//----- (0125BC30) --------------------------------------------------------
HANDLE __stdcall Real_FindExecutableImageExW(const WCHAR *a1, const WCHAR *a2, WCHAR *a3)
{
  return FindExecutableImageExW(a1, a2, a3, 0, 0);
}

//----- (0125BC50) --------------------------------------------------------
HANDLE __stdcall Proxy_FindExecutableImageExW(LPCWSTR a1, LPCWSTR a2, int a3)
{
  int *v3; // esi
  int *v4; // eax
  HANDLE v5; // eax
  int v6; // edi
  HANDLE v7; // ebx
  int v8; // edx
  int v10; // [esp+10h] [ebp-124h]
  int v11; // [esp+14h] [ebp-120h]
  CHAR MultiByteStr; // [esp+18h] [ebp-11Ch]
  LPWSTR lpWideCharStr; // [esp+120h] [ebp-14h]
  int v14; // [esp+130h] [ebp-4h]

  lpWideCharStr = a3;
  v14 = 0;
  v3 = sub_1259E00(&v11, a2);
  LOBYTE(v14) = 1;
  v4 = sub_1259E00(&v10, a1);
  LOBYTE(v14) = 2;
  v5 = FindExecutableImage(*v4, *v3, &MultiByteStr);
  v6 = v10 - 16;
  LOBYTE(v14) = 1;
  v7 = v5;
  if ( _InterlockedDecrement((v10 - 16 + 12)) <= 0 )
    (*(**v6 + 4))(v6);
  v8 = v11 - 16;
  LOBYTE(v14) = 0;
  if ( _InterlockedDecrement((v11 - 16 + 12)) <= 0 )
    (*(**v8 + 4))(v8);
  MultiByteToWideChar(0, 0, &MultiByteStr, 261, lpWideCharStr, 261);
  return v7;
}

//----- (0125BD50) --------------------------------------------------------
int __userpurge SearchThreadProc@<eax>(signed int a1@<ebx>, _BYTE *pbCancelFindInFindDlg)
{
  HWND v2; // eax

  SearchDlls(a1, ghWndListCtrlInFindDialog, 0, pbCancelFindInFindDlg);
  SearchHandles(a1, ghWndListCtrlInFindDialog, 0, pbCancelFindInFindDlg);
  v2 = GetParent(ghWndListCtrlInFindDialog);
  PostMessageW(v2, FDM_ENDSORT, 0, 0);
  return 0;
}

//----- (0125BDA0) --------------------------------------------------------
HWND __cdecl sub_125BDA0(HWND hWndParent)
{
  HWND v1; // eax
  HWND result; // eax

  v1 = FindWindowExW(hWndParent, 0, 0, L"OK");
  if ( v1 )
    ShowWindow(v1, 0);
  result = FindWindowExW(hWndParent, 0, 0, L"Cancel");
  if ( result )
    result = SetWindowTextW(result, L"&OK");
  return result;
}

//----- (0125BDF0) --------------------------------------------------------
int *__thiscall sub_125BDF0(int *this, int a2)
{
  volatile signed __int32 *v2; // esi
  int v3; // ebx
  int (__thiscall ***v4)(_DWORD, int, signed int); // eax
  int v5; // edi
  int v6; // eax
  int v7; // ebx
  int *result; // eax
  int *v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+1Ch] [ebp+8h]

  v9 = this;
  v2 = (*this - 16);
  v3 = *(v2 + 1);
  v10 = *(v2 + 1);
  v4 = (*(**v2 + 16))();
  v5 = a2;
  v6 = (**v4)(v4, a2, 1);
  v11 = v6;
  if ( !v6 )
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  if ( v3 < v5 )
    v5 = v3;
  v7 = v6 + 16;
  memcpy_s((v6 + 16), v5 + 1, (v2 + 4), v5 + 1);
  *(v11 + 4) = v10;
  if ( _InterlockedDecrement(v2 + 3) <= 0 )
    (*(**v2 + 4))(v2);
  result = v9;
  *v9 = v7;
  return result;
}

//----- (0125BE70) --------------------------------------------------------
HLOCAL __cdecl sub_125BE70(wchar_t *Dst, size_t SizeInWords)
{
  int v2; // ecx
  DWORD v3; // eax
  WCHAR Buffer[2]; // [esp+0h] [ebp-4h]

  *Buffer = v2;
  v3 = GetLastError();
  FormatMessageW(0x1100u, 0, v3, 0x400u, Buffer, 0, 0);
  swprintf_s(Dst, SizeInWords, L"%s", *Buffer);
  return LocalFree(*Buffer);
}

//----- (0125BEC0) --------------------------------------------------------
int __cdecl sub_125BEC0(int a1, int a2, wchar_t *Dst, size_t SizeInWords)
{
  return swprintf_s(Dst, SizeInWords, L"%d.%d.%d.%d", a2 >> 16, a2, a1 >> 16, a1);
}

//----- (0125BEF0) --------------------------------------------------------
unsigned int __cdecl sub_125BEF0(int a1, int InBuffer)
{
  int v2; // esi
  FARPROC pfnGetProcessMitigationPolicy; // eax
  HMODULE v4; // eax
  unsigned int result; // eax
  int v6; // [esp+4h] [ebp-10h]
  DWORD BytesReturned; // [esp+8h] [ebp-Ch]
  int v8; // [esp+Ch] [ebp-8h]
  int OutBuffer; // [esp+10h] [ebp-4h]

  v2 = InBuffer;
  LOBYTE(OutBuffer) = -1;
  if ( !InBuffer )
    return OutBuffer;
  if ( gdwOsType >= 3 )
  {
    pfnGetProcessMitigationPolicy = GetProcessMitigationPolicy;
    if ( !GetProcessMitigationPolicy )
    {
      v4 = GetModuleHandle(L"KERNEL32.DLL");
      pfnGetProcessMitigationPolicy = GetProcAddress(v4, "GetProcessMitigationPolicy");
      GetProcessMitigationPolicy = pfnGetProcessMitigationPolicy;
      if ( !pfnGetProcessMitigationPolicy )
      {
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return OutBuffer;
      }
    }
    if ( (pfnGetProcessMitigationPolicy)(v2, 0, &v6, 8) )
    {
      result = 0;
      if ( v6 & 1 )
        result = 1;
      if ( v6 & 2 )
        result |= 4u;
      if ( BytesReturned )
        result |= 8u;
      return result;
    }
    return OutBuffer;
  }
  if ( gdwOsType < 2 )
  {
    if ( gdwOsType < 1 )
    {
      DeviceIoControl(theDriver, 0x83350034, &InBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0);
      return OutBuffer;
    }
    if ( NtQueryInformationProcess(InBuffer, ProcessExecuteFlags, &OutBuffer, 4u, 0) )
      return OutBuffer;
    result = OutBuffer & 0xFFFFFF0B;
    OutBuffer &= 0xFFFFFF0B;
    if ( OutBuffer & 2 )
      result &= 0xFFFFFFF6;
  }
  else
  {
    if ( !sub_125F580(InBuffer, &v8, &BytesReturned) )
      return OutBuffer;
    result = 0;
    if ( v8 & 1 )
      result = 1;
    if ( v8 & 2 )
      result |= 4u;
    if ( BytesReturned )
      result |= 8u;
  }
  return result;
}
// 12E4E54: using guessed type int gdwOsType;
// 12FBC04: using guessed type int GetProcessMitigationPolicy;

//----- (0125C020) --------------------------------------------------------
int __stdcall BackQueryObjectThreadProc(void *pTheadParam)
{
  ULONG nLength; // [esp+4h] [ebp-4h]

  // 等待前台触发这个查询事件
  while ( !WaitForSingleObject(theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent, INFINITE) )
  {
    nLength = theQueryObjectThread.m_pObjectNameInfo->Name.Length + 8;
    // LONG (__stdcall *NtQueryObject)( HANDLE   Handle,OBJECT_INFORMATION_CLASS ObjectInformationClass,PVOID                    ObjectInformation,ULONG  ObjectInformationLength,PULONG   ReturnLength)
    theQueryObjectThread.m_uQueryObjectResult = NtQueryObject(
                                                  theQueryObjectThread.m_hObjectHandleToQuery,
                                                  ObjectNameInformation,
                                                  theQueryObjectThread.m_pObjectNameInfo,
                                                  nLength,
                                                  &nLength);
    // 重置该事件
    SetEvent(theQueryObjectThread.m_hBackQueryObjectEvent);
  }
  return 0;
}

//----- (0125C090) --------------------------------------------------------
int __stdcall sub_125C090(DWORD nLengthNeeded)
{
  DWORD v1; // edi
  DWORD v2; // edx
  signed int v3; // eax
  signed int v4; // esi
  HANDLE v5; // ebx
  BOOL v6; // esi
  int result; // eax

  v1 = nLengthNeeded;
  v2 = 0;
  v3 = 1;
  v4 = 32;
  do
  {
    if ( *(nLengthNeeded + 4) & v3 )
    {
      switch ( v3 )
      {
        case 1:
          v2 |= 0xE0000u;
          break;
        case 4:
        case 16:
          v2 |= 0x60000u;
          break;
        case 8:
          v2 |= 0x1000000u;
          break;
        default:
          break;
      }
    }
    v3 = __ROL4__(v3, 1);
    --v4;
  }
  while ( v4 );
  v5 = DuplicateProcessHandle(*(*nLengthNeeded + 36), *(*nLengthNeeded + 44), v2);
  if ( v5 )
  {
    GetKernelObjectSecurity(v5, *(v1 + 4), 0, 0, &nLengthNeeded);
    **(v1 + 8) = LocalAlloc(0x40u, nLengthNeeded);
    v6 = GetKernelObjectSecurity(v5, *(v1 + 4), **(v1 + 8), nLengthNeeded, &nLengthNeeded);
    CloseHandle(v5);
    if ( v6 )
    {
      result = 0;
      *(v1 + 12) = 0;
    }
    else
    {
      *(v1 + 12) = GetLastError();
      result = 0;
    }
  }
  else
  {
    *(v1 + 12) = 6;
    result = 0;
  }
  return result;
}

//----- (0125C190) --------------------------------------------------------
LPVOID __cdecl GetImageDescription(LPCVOID pBlock, int a2, unsigned __int16 a3, int a4)
{
  BOOL v4; // eax
  BOOL v5; // ecx
  LPVOID result; // eax
  unsigned int puLen; // [esp+10h] [ebp-228h]
  LPVOID lodescription; // [esp+14h] [ebp-224h]
  BOOL v9; // [esp+18h] [ebp-220h]
  WCHAR SubBlock; // [esp+1Ch] [ebp-21Ch]
  CPPEH_RECORD ms_exc; // [esp+220h] [ebp-18h]

  v9 = 0;
  VLogEntry(&SubBlock, L"\\StringFileInfo\\%04X%04X\\%s", a2, a3, a4);
  ms_exc.registration.TryLevel = 0;
  v4 = VerQueryValueW(pBlock, &SubBlock, &lodescription, &puLen);
  v5 = v4;
  v9 = v4;
  ms_exc.registration.TryLevel = -2;
  result = lodescription;
  if ( !v5 )
    result = 0;
  return result;
}

//----- (0125C270) --------------------------------------------------------
__int16 *__cdecl sub_125C270(int a1, rsize_t SizeInWords)
{
  __int16 *v2; // ecx
  __int16 v3; // ax
  int v4; // edi
  __int16 *v5; // ecx
  __int16 v6; // ax
  wchar_t *v7; // esi

  if ( !*GetLongPathNameW )
    return *a1;
  v2 = *a1;
  do
  {
    v3 = *v2;
    ++v2;
  }
  while ( v3 );
  if ( SizeInWords <= ((v2 - *a1 - 2) >> 1) + 1 )
  {
    v5 = *a1;
    do
    {
      v6 = *v5;
      ++v5;
    }
    while ( v6 );
    v4 = ((v5 - *a1 - 2) >> 1) + 1;
  }
  else
  {
    v4 = SizeInWords;
  }
  v7 = malloc(2 * v4);
  tcscpy_s(v7, v4, *a1);
  GetLongPathNameW(v7, *a1, SizeInWords);
  j__free(v7);
  return *a1;
}

//----- (0125C350) --------------------------------------------------------
void __cdecl sub_125C350(LPCWSTR *a1)
{
  DWORD v1; // eax
  DWORD v2; // ebx
  WCHAR *v3; // ST1C_4

  if ( *GetLongPathNameW )
  {
    v1 = GetLongPathNameW(*a1, 0, 0);
    v2 = v1;
    if ( v1 )
    {
      v3 = malloc(2 * v1 + 2);
      GetLongPathNameW(*a1, v3, v2 + 1);
      free(*a1);
      *a1 = v3;
      j__free(0);
    }
  }
}

//----- (0125C3E0) --------------------------------------------------------
int __stdcall QueryDBGInfoThreadProc(FILETIME *a1)
{
  return RtlQueryProcessDebugInformation(a1->dwLowDateTime, 1, a1->dwHighDateTime);
}
// 12EF260: using guessed type int (__stdcall *RtlQueryProcessDebugInformation)(_DWORD, _DWORD, _DWORD);

//----- (0125C400) --------------------------------------------------------
char __cdecl sub_125C400(int *a1, LVITEMUSERDATA *pUserData)
{
  int v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v6; // edi
  int *v7; // esi
  int v8; // eax
  unsigned int v9; // ecx
  bool v10; // cf
  bool v11; // zf
  int v12; // eax
  int v13; // esi
  int v14; // edi
  int v15; // ecx
  bool v16; // bl
  bool v17; // dl
  int v18; // [esp+8h] [ebp-Ch]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]
  unsigned int v21; // [esp+1Ch] [ebp+8h]

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v20 = 0;
  v18 = 0;
  v19 = 0;
  if ( !a1 )
    return 0;
  v6 = *a1;
  if ( *a1 )
  {
    v7 = a1 + 1;
    do
    {
      v8 = *v7;
      v21 = *v7 & 0xFFFFF000;
      v2 = v20;
      if ( v21 >= pUserData->field_24 )
      {
        v9 = pUserData->field_24 + pUserData->field_38;
        v10 = v21 < v9;
        v11 = v21 == v9;
        v2 = v20;
        if ( v10 || v11 )
        {
          v2 = v20++ + 1;
          if ( v8 & 0x100 )
          {
            ++v18;
            if ( (*v7 & 0xE0u) > 0x20 )
              ++v19;
          }
          else
          {
            ++v4;
          }
        }
      }
      ++v7;
      --v6;
    }
    while ( v6 );
    v3 = v19;
  }
  v12 = v2 * gSystemInfo.dwPageSize;
  v13 = v18 * gSystemInfo.dwPageSize;
  v14 = v3 * gSystemInfo.dwPageSize;
  v15 = v4 * gSystemInfo.dwPageSize;
  v11 = v12 == pUserData->dwPageSize;
  pUserData->dwPageSize = v12;
  v16 = !v11;
  v11 = v15 == pUserData->dwPageSize2;
  pUserData->dwPageSize2 = v15;
  v17 = !v11;
  v11 = v13 == pUserData->dwPageSize3;
  pUserData->dwPageSize3 = v13;
  LOBYTE(v12) = v14 != pUserData->dwPageSize4;
  pUserData->dwPageSize4 = v14;
  return v16 | v17 | !v11 | v12;
}

//----- (0125C4F0) --------------------------------------------------------
char __cdecl sub_125C4F0(LPVOID lpInBuffer, int a2, int a3, int a4)
{
  char v4; // bl
  HANDLE v6; // eax
  BOOL (__stdcall *v7)(HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPOVERLAPPED); // esi
  int v8; // eax
  char v9; // [esp+8h] [ebp-78h]
  int v10; // [esp+18h] [ebp-68h]
  struct _OVERLAPPED Overlapped; // [esp+20h] [ebp-60h]
  DWORD InBuffer; // [esp+34h] [ebp-4Ch]
  int v13; // [esp+38h] [ebp-48h]
  char v14; // [esp+3Ch] [ebp-44h]
  HANDLE v15; // [esp+40h] [ebp-40h]
  _DWORD *v16; // [esp+44h] [ebp-3Ch]
  _DWORD *v17; // [esp+48h] [ebp-38h]
  DWORD BytesReturned; // [esp+4Ch] [ebp-34h]
  int OutBuffer; // [esp+50h] [ebp-30h]
  _DWORD *v20; // [esp+54h] [ebp-2Ch]
  HANDLE TargetHandle; // [esp+58h] [ebp-28h]
  LPVOID lpOutBuffer; // [esp+5Ch] [ebp-24h]
  char v23; // [esp+60h] [ebp-20h]
  unsigned __int16 v24; // [esp+6Ch] [ebp-14h]
  int v25; // [esp+6Eh] [ebp-12h]

  v17 = a2;
  v4 = 0;
  v20 = a3;
  v16 = a4;
  if ( !lpInBuffer )
  {
    if ( dword_12E10D4 != -1 )
    {
      CloseHandle(hSourceProcessHandle);
      dword_12E10D4 = -1;
    }
    return 0;
  }
  if ( dword_12E10D4 != *(lpInBuffer + 1) )
  {
    if ( dword_12E10D4 != -1 )
    {
      dword_12E10D4 = -1;
      CloseHandle(hSourceProcessHandle);
    }
    hSourceProcessHandle = OpenProcess(0x40u, 0, *(lpInBuffer + 1));
    if ( !hSourceProcessHandle )
      return 0;
    dword_12E10D4 = *(lpInBuffer + 1);
  }
  v6 = GetCurrentProcess();
  if ( !DuplicateHandle(hSourceProcessHandle, *(lpInBuffer + 2), v6, &TargetHandle, 0, 0, 0) )
    return 0;
  lpOutBuffer = malloc(0x408u);
  InBuffer = GetCurrentProcessId();
  v13 = *lpInBuffer;
  v15 = TargetHandle;
  v14 = 0;
  if ( DeviceIoControl(theDriver, 0x83350048, &InBuffer, 0x10u, lpOutBuffer, 0x408u, &BytesReturned, 0)
    && (!_wcsicmp(lpOutBuffer + 2, L"\\Device\\Tcp") || !_wcsicmp(lpOutBuffer + 2, L"\\Device\\Udp")) )
  {
    if ( GetVersion() >= 5u )
    {
      v7 = DeviceIoControl;
    }
    else
    {
      v7 = DeviceIoControl;
      DeviceIoControl(theDriver, 0x83350020, lpInBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0);
    }
    if ( GetVersion() >= 5u || OutBuffer == 1 || OutBuffer == 2 )
    {
      Overlapped.hEvent = 0;
      _mm_storeu_si128(&Overlapped, 0i64);
      Overlapped.hEvent = CreateEventW(0, 0, 0, 0);
      v10 = 3;
      if ( v7(TargetHandle, 0x210012u, &v9, 0x18u, &v23, 0x1Au, 0, &Overlapped) )
      {
        v8 = _wcsicmp(lpOutBuffer + 2, L"\\Device\\Tcp");
        v4 = 1;
        *v17 = v8 != 0;
        *v16 = v24;
        *v20 = v25;
      }
      else
      {
        v4 = 0;
      }
      CloseHandle(Overlapped.hEvent);
    }
  }
  free(lpOutBuffer);
  CloseHandle(TargetHandle);
  return v4;
}
// 12E10D4: using guessed type int dword_12E10D4;

//----- (0125C750) --------------------------------------------------------
void __cdecl sub_125C750(wchar_t *szType, int a2, wchar_t *szTargetName, rsize_t SizeInWords, _DWORD *a5)
{
  rsize_t v5; // esi
  int v6; // eax
  HANDLE v7; // eax
  size_t v8; // esi
  void *v9; // eax
  BOOL v10; // eax
  HANDLE v11; // esi
  size_t v12; // esi
  const wchar_t **v13; // eax
  ULONG v14; // ST20_4
  const wchar_t **v15; // esi
  LONG v16; // eax
  HANDLE v17; // edi
  int v18; // ebx
  HANDLE v19; // eax
  void *v20; // ebx
  size_t v21; // esi
  void *v22; // eax
  int v23; // ecx
  bool v24; // zf
  wchar_t *v25; // ebx
  HANDLE v26; // ebx
  OBJECT_NAME_INFORMATION *pObjectName; // edi
  HANDLE v28; // eax
  int v29; // eax
  HANDLE v30; // ebx
  int pBuffer; // [esp+Ch] [ebp-10C0h]
  int v32; // [esp+1Ch] [ebp-10B0h]
  int v33; // [esp+24h] [ebp-10A8h]
  int v34; // [esp+2Ch] [ebp-10A0h]
  int v35; // [esp+30h] [ebp-109Ch]
  enum _SID_NAME_USE peUse; // [esp+40h] [ebp-108Ch]
  DWORD ThreadId; // [esp+44h] [ebp-1088h]
  DWORD cchReferencedDomainName; // [esp+48h] [ebp-1084h]
  DWORD cchName; // [esp+4Ch] [ebp-1080h]
  int InBuffer; // [esp+50h] [ebp-107Ch]
  int v41; // [esp+54h] [ebp-1078h]
  bool v42; // [esp+58h] [ebp-1074h]
  int v43; // [esp+5Ch] [ebp-1070h]
  _DWORD *v44; // [esp+60h] [ebp-106Ch]
  DWORD ReturnLength; // [esp+64h] [ebp-1068h]
  HANDLE hObject; // [esp+68h] [ebp-1064h]
  size_t pulRet; // [esp+6Ch] [ebp-1060h]
  wchar_t *Dst; // [esp+70h] [ebp-105Ch]
  DWORD BytesReturned; // [esp+74h] [ebp-1058h]
  char TokenInformation; // [esp+78h] [ebp-1054h]
  int v51; // [esp+80h] [ebp-104Ch]
  int v52[11]; // [esp+84h] [ebp-1048h]
  void *Sid[512]; // [esp+B0h] [ebp-101Ch]
  __int16 Name[260]; // [esp+8B0h] [ebp-81Ch]
  __int16 ReferencedDomainName[260]; // [esp+AB8h] [ebp-614h]
  wchar_t v56[260]; // [esp+CC0h] [ebp-40Ch]
  wchar_t v57[256]; // [esp+EC8h] [ebp-204h]

  v5 = SizeInWords;
  Dst = szTargetName;
  v44 = a5;
  tcscpy_s(szTargetName, SizeInWords, gpszTargetName);
  if ( a5 )
    *v44 = 0;
  if ( !*szType )
    goto LABEL_55;
  v6 = wcscmp(szType, L"<Unknown type>");
  if ( v6 )
    v6 = -(v6 < 0) | 1;
  if ( !v6 )
  {
LABEL_55:
    v7 = DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 0);
    hObject = v7;
    if ( v7 )
    {
      NtQueryObject(v7, 2u, 0, 0, &pulRet);
      v12 = pulRet;
      v13 = malloc(pulRet);
      v14 = v12;
      v15 = v13;
      v16 = NtQueryObject(hObject, 2u, v13, v14, 0);
      if ( v16 )
        sub_1259DC0(szType, L"<Unknown type: %X>", v16);
      else
        wcsncpy_s(szType, 0x40u, v15[1], *v15 >> 1);
      free(v15);
      CloseHandle(hObject);
LABEL_17:
      v5 = SizeInWords;
      goto LABEL_18;
    }
    if ( theDriver != -1 )
    {
      v8 = 2 * SizeInWords + 8;
      v9 = malloc(v8);
      InBuffer = *(a2 + 4);
      v41 = *a2;
      v43 = *(a2 + 8);
      hObject = v9;
      v10 = DeviceIoControl(theDriver, 0x8335004C, &InBuffer, 16u, v9, v8, &BytesReturned, 0);
      v11 = hObject;
      if ( v10 )
        tcscpy_s(szType, 0x40u, hObject + 2);
      free(v11);
      goto LABEL_17;
    }
    sub_1259DC0(szType, L"<Unknown type>");
  }
LABEL_18:
  if ( _wcsicmp(szType, L"process") && _wcsicmp(szType, L"thread") )
  {
    if ( _wcsicmp(szType, L"token") )
    {
      if ( _wcsicmp(szType, L"EtwRegistration") )
      {
        if ( theDriver == INVALID_HANDLE_VALUE )
        {
          v26 = DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 0);
          if ( v26 )
          {
            pulRet = 1024;
            pObjectName = malloc(1024u);
            _mm_storel_epi64(pObjectName, 0i64);
            pObjectName->Name.Length = pulRet - 8;
            if ( !theQueryObjectThread.m_hBackQueryObjectThreadHandle )
              theQueryObjectThread.m_hBackQueryObjectThreadHandle = _beginthreadex(
                                                                      0,
                                                                      0,
                                                                      BackQueryObjectThreadProc,
                                                                      0,
                                                                      0,
                                                                      &ThreadId);
            v28 = theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent;
            if ( !theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent )
            {
              theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent = CreateEventW(
                                                                            theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent,
                                                                            theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent,
                                                                            theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent,
                                                                            theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent);
              theQueryObjectThread.m_hBackQueryObjectEvent = CreateEventW(0, 0, 0, 0);
              v28 = theQueryObjectThread.m_hBackQueryObjectThreadQueryOKEvent;
            }
            theQueryObjectThread.m_pObjectNameInfo = pObjectName;
            theQueryObjectThread.m_hObjectHandleToQuery = v26;
            SetEvent(v28);
            if ( WaitForSingleObject(theQueryObjectThread.m_hBackQueryObjectEvent, 1000u) == 258 )
            {
              TerminateThread(theQueryObjectThread.m_hBackQueryObjectThreadHandle, 1u);
              CloseHandle(theQueryObjectThread.m_hBackQueryObjectThreadHandle);
              theQueryObjectThread.m_hBackQueryObjectThreadHandle = 0;
              free(pObjectName);
              CloseHandle(v26);
            }
            else
            {
              if ( !theQueryObjectThread.m_uQueryObjectResult )
                sub_1275230(Dst, SizeInWords, pObjectName);
              free(pObjectName);
              CloseHandle(v26);
            }
          }
        }
        else
        {
          v21 = 2 * v5 + 8;
          v22 = malloc(v21);
          InBuffer = *(a2 + 4);
          v23 = *a2;
          BytesReturned = v22;
          v41 = v23;
          v24 = _wcsicmp(szType, L"file") == 0;
          v25 = BytesReturned;
          v43 = *(a2 + 8);
          v42 = v24;
          if ( DeviceIoControl_0(0x83350048, &InBuffer, 0x10u, BytesReturned, v21) )
          {
            tcscpy_s(Dst, SizeInWords, v25 + 2);
            if ( v44 )
              *v44 = *v25;
          }
          free(v25);
        }
      }
      else
      {
        v19 = DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 0);
        v20 = v19;
        if ( v19 )
        {
          CloseHandle(v19);
          CloseHandle(v20);
        }
      }
    }
    else
    {
      v17 = DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), 8u);
      if ( v17 )
      {
        v52[0] = 0;
        v51 = 0;
        ReturnLength = 56;
        GetTokenInformation(v17, TokenStatistics, &TokenInformation, 0x38u, &ReturnLength);
        v18 = v51;
        BytesReturned = v52[0];
        ReturnLength = 2048;
        if ( GetTokenInformation(v17, TokenUser, Sid, 0x800u, &ReturnLength) )
        {
          cchName = 260;
          cchReferencedDomainName = 260;
          if ( LookupAccountSidW(
                 gpszTargetName,
                 Sid[0],
                 Name,
                 &cchName,
                 ReferencedDomainName,
                 &cchReferencedDomainName,
                 &peUse) )
          {
            swprintf_s(Dst, SizeInWords, L"%s\\%s:%x", ReferencedDomainName, Name, v18, BytesReturned);
          }
        }
        CloseHandle(v17);
      }
    }
  }
  else
  {
    v29 = _wcsicmp(szType, L"process");
    v30 = DuplicateProcessHandle(*(a2 + 4), *(a2 + 8), v29 != 0 ? 64 : 1024);
    if ( v30 )
    {
      if ( _wcsicmp(szType, L"Process") )
      {
        if ( !NtQueryInformationThread(v30, 0, &v33, 28, &pulRet) )
        {
          sub_1278310(v34, 0, v57, 0x100u);
          swprintf_s(Dst, v5, L"%s(%d): %d", v57, v34, v35);
        }
      }
      else if ( !NtQueryInformationProcess(v30, 0, &pBuffer, 0x18u, &pulRet) )
      {
        sub_1278310(v32, 0, v57, 0x100u);
        swprintf_s(Dst, v5, L"%s(%d)", v57, v32);
        CloseHandle(v30);
        return;
      }
      CloseHandle(v30);
    }
    else if ( theDriver != -1 )
    {
      sub_125BE70(v56, 0x104u);
      swprintf_s(Dst, v5, L"<%s>", v56);
    }
  }
}
// 12EF23C: using guessed type int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0125CE20) --------------------------------------------------------
int __cdecl sub_125CE20(DWORD BytesReturned, LPVOID lpOutBuffer)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  DWORD v4; // eax
  unsigned __int64 v5; // rax
  double v6; // xmm0_8

  v2 = BytesReturned;
  v3 = lpOutBuffer;
  *BytesReturned = 0;
  v2[1] = 0;
  *v3 = 0;
  v3[1] = 0;
  if ( dword_13050E8 || !dword_12DE0DC )
  {
    v4 = dword_13050EC;
  }
  else
  {
    dword_13050E8 = sub_12607B0(v3, "MmMaximumNonPagedPoolInBytes");
    v4 = sub_12607B0(v3, "MmSizeOfPagedPoolInBytes");
    dword_13050EC = v4;
    dword_12DE0DC = 0;
  }
  if ( v4 )
    DeviceIoControl(theDriver, 0x83350044, &dword_13050EC, 4u, v3, 8u, &BytesReturned, 0);
  if ( dword_13050E8 )
  {
    LODWORD(v5) = DeviceIoControl(theDriver, 0x83350044, &dword_13050E8, 4u, v2, 8u, &BytesReturned, 0);
    v2[1] = 0;
    v3[1] = 0;
  }
  else
  {
    *v2 = 0x200000;
    v2[1] = 0;
    v6 = *&gpGraphClassData[5]->dbTotalPageFile;
    v5 = v6 << 10;
    if ( is_mul_ok(0x400u, v6) && v5 < 0x200000 )
      *v2 = v5;
    v2[1] = 0;
    v3[1] = 0;
  }
  return v5;
}
// 12DE0DC: using guessed type int dword_12DE0DC;
// 13050E8: using guessed type int dword_13050E8;
// 13050EC: using guessed type int dword_13050EC;

//----- (0125CF30) --------------------------------------------------------
char __cdecl sub_125CF30(HANDLE hProcess, int a2)
{
  SIZE_T v3; // ebx
  wchar_t *v4; // esi
  char v5; // bl
  wchar_t *v6; // eax
  int pBuffer; // [esp+4h] [ebp-520h]
  LPCVOID lpBaseAddress; // [esp+8h] [ebp-51Ch]
  ULONG pulRet; // [esp+1Ch] [ebp-508h]
  wchar_t **v10; // [esp+20h] [ebp-504h]
  SIZE_T NumberOfBytesRead; // [esp+24h] [ebp-500h]
  char Buffer; // [esp+28h] [ebp-4FCh]
  LPCVOID v13; // [esp+38h] [ebp-4ECh]
  char v14; // [esp+278h] [ebp-2ACh]
  unsigned __int16 v15; // [esp+2B0h] [ebp-274h]
  LPCVOID v16; // [esp+2B4h] [ebp-270h]

  v10 = a2;
  if ( NtQueryInformationProcess(hProcess, 0, &pBuffer, 0x18u, &pulRet) || !lpBaseAddress )
    return 0;
  if ( !ReadProcessMemory(hProcess, lpBaseAddress, &Buffer, 0x250u, &NumberOfBytesRead)
    || !ReadProcessMemory(hProcess, v13, &v14, 0x2A8u, &NumberOfBytesRead)
    || !v16 )
  {
    return 0;
  }
  v3 = v15;
  v4 = malloc(v15 + 2);
  if ( ReadProcessMemory(hProcess, v16, v4, v3, &NumberOfBytesRead) )
  {
    v4[v3 >> 1] = 0;
    v6 = _wcsdup(v4);
    v5 = 1;
    *v10 = v6;
  }
  else
  {
    v5 = 0;
  }
  j__free(v4);
  return v5;
}

//----- (0125D050) --------------------------------------------------------
HICON __cdecl sub_125D050(LPCWSTR pszPath, int a2)
{
  SHFILEINFOW psfi; // [esp+0h] [ebp-2B8h]

  psfi.hIcon = 0;
  if ( !pszPath )
    return 0;
  SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, a2 | 0x100);
  return psfi.hIcon;
}

//----- (0125D0C0) --------------------------------------------------------
char __cdecl sub_125D0C0(HANDLE hProcess, LPARAM lParam)
{
  wchar_t *v2; // ebx
  unsigned int v3; // kr00_4
  wchar_t *v4; // esi
  const WCHAR *v5; // ecx
  const wchar_t *v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // ebx
  int v9; // edx
  wchar_t v10; // cx
  wchar_t *v11; // eax
  wchar_t *v12; // eax
  wchar_t *v13; // esi
  wchar_t i; // ax
  char v15; // cl
  int v16; // eax
  DWORD v17; // eax
  WCHAR *v18; // eax
  wchar_t *v19; // ecx
  wchar_t *v20; // ecx
  HWND v21; // eax
  HWND v22; // esi
  char v23; // al
  wchar_t *v24; // ebx
  wchar_t *v26; // eax
  wchar_t *v27; // esi
  LPWSTR FilePart; // [esp+Ch] [ebp-2A0h]
  char hObject; // [esp+13h] [ebp-299h]
  wchar_t *Src; // [esp+14h] [ebp-298h]
  DWORD nBufferLength; // [esp+18h] [ebp-294h]
  char v32; // [esp+1Fh] [ebp-28Dh]
  WCHAR ClassName; // [esp+20h] [ebp-28Ch]
  wchar_t Dst; // [esp+228h] [ebp-84h]

  Src = 0;
  v32 = 0;
  if ( *(lParam + 792) )
    return 0;
  if ( !sub_1260A90(hProcess, *(lParam + 68), &Src, lParam) )
  {
    if ( *(lParam + 68) <= 8u )
    {
      v27 = Src;
    }
    else
    {
      v26 = malloc(0x208u);
      v27 = v26;
      if ( hProcess )
      {
        sub_125BE70(v26 + 1, 0x103u);
        *v27 = 91;
        if ( wcschr(v27, 0xDu) )
          *wcschr(v27, 0xDu) = 0;
        wcscat_s(v27, 0x104u, L"]");
      }
      else
      {
        swprintf_s(v26, 0x104u, L"[Error opening process]");
      }
      *(lParam + 792) = _wcsdup(v27);
    }
    if ( v27 )
      free(v27);
    return 0;
  }
  v2 = Src;
  if ( GetImageVersionInfo(Src, (lParam + 654), 0x41u, lParam + 784, (lParam + 788)) && GetLastError() != 1813 )
  {
    v3 = wcslen(v2);
    v4 = malloc(2 * (v3 + 260));
    tcscpy_s(v4, v3 + 260, Src);
    sub_125BE70(v4 + 1, v3 + 259);
    *v4 = 91;
    if ( wcschr(v4, 0xDu) )
      *wcschr(v4, 0xDu) = 0;
    wcscat_s(v4, v3 + 260, L"]");
    *(lParam + 792) = v4;
  }
  else
  {
    nBufferLength = _wcsdup(v2);
    sub_125C350(&nBufferLength);
    v5 = nBufferLength;
    *(lParam + 792) = nBufferLength;
    if ( OpenExeFromFile(v5, (lParam + 640), &hObject, (lParam + 650)) )
      *(lParam + 40) |= 0x100u;
    else
      *(lParam + 40) &= 0xFFFFFEFF;
    if ( !_wcsicmp(*(lParam + 60), L"rundll32.exe") && (v6 = *(lParam + 800)) != 0 && wcschr(v6, 0x2Cu) )
    {
      v7 = _wcsdup(*(lParam + 800));
      v8 = v7;
      v9 = (v7 + 1);
      do
      {
        v10 = *v7;
        ++v7;
      }
      while ( v10 );
      _wcsupr_s(v8, ((v7 - v9) >> 1) + 1);
      if ( wcsstr(v8, L"SHELL32.DLL") && wcsstr(v8, L"CONTROL_RUNDLL ") )
      {
        v11 = wcsstr(v8, L"CONTROL_RUNDLL");
        v12 = wcschr(v11, 0x20u);
        v13 = v12;
        for ( i = *v12; i; ++v13 )
        {
          if ( i != 32 )
            break;
          i = v13[1];
        }
        if ( *v13 == 34 )
        {
          ++v13;
          if ( wcschr(v13, 0x22u) )
            *wcschr(v13, 0x22u) = 0;
        }
      }
      else
      {
        v13 = wcschr(v8, 0x2Cu);
        v15 = 0;
        for ( *v13 = 0; v13 != v8; --v13 )
        {
          if ( v15 )
          {
            if ( *v13 == 34 )
              break;
          }
          else
          {
            v16 = *v13;
            if ( v16 == 32 )
              goto LABEL_33;
            if ( v16 == 34 )
            {
              v15 = 1;
              *v13 = 0;
            }
          }
        }
        if ( *v13 == 32 )
LABEL_33:
          ++v13;
        if ( *v13 == 34 )
          ++v13;
        if ( !*v13 )
          ++v13;
      }
      v17 = SearchPathW(0, v13, 0, 0, 0, 0);
      nBufferLength = v17;
      if ( v17 )
      {
        v18 = malloc(2 * v17);
        *(lParam + 860) = v18;
        SearchPathW(0, v13, 0, nBufferLength, v18, &FilePart);
        _wcslwr_s(*(lParam + 860), nBufferLength);
        GetImageVersionInfo(*(lParam + 860), &Dst, 0x40u, lParam + 856, (lParam + 852));
      }
      free(v8);
    }
    else if ( _wcsicmp(*(lParam + 60), L"svchost.exe") || (v19 = *(lParam + 800)) == 0 )
    {
      if ( !_wcsicmp(*(lParam + 60), L"dllhost.exe") )
      {
        v20 = *(lParam + 800);
        if ( v20 )
          sub_1243F80(v20, lParam + 848, lParam + 860, lParam + 856, lParam + 852);
      }
    }
    else
    {
      sub_1244730(v19, lParam + 864);
    }
    if ( !_wcsicmp(*(lParam + 60), L"mmc.exe") && *(lParam + 40) >= 0 )
    {
      v21 = GetDesktopWindow();
      v22 = GetWindow(v21, 5u);
      nBufferLength = 0;
      while ( 1 )
      {
        GetWindowThreadProcessId(v22, &nBufferLength);
        ClassName = 0;
        GetClassNameW(v22, &ClassName, 260);
        if ( nBufferLength == *(lParam + 68) && !wcsncmp(&ClassName, L"MMCMainFrame", 0x104u) )
        {
          SendMessageTimeoutW(v22, 0x7Fu, 0, 0, 0, 0xC8u, (lParam + 52));
          SendMessageTimeoutW(v22, 0x7Fu, 1u, 0, 0, 0xC8u, (lParam + 56));
          v23 = 1;
          v32 = 1;
        }
        else
        {
          v22 = GetWindow(v22, 2u);
          v23 = v32;
        }
        if ( !v22 )
          break;
        if ( v23 )
          goto LABEL_59;
      }
      if ( v23 )
        goto LABEL_59;
    }
  }
  v24 = Src;
  *(lParam + 52) = sub_125D050(Src, 1);
  SendMessageW(ghWndNewOwner, 0x7F3u, 0, lParam);
  *(lParam + 56) = sub_125D050(v24, 0);
LABEL_59:
  if ( Src )
    free(Src);
  return 1;
}

//----- (0125D670) --------------------------------------------------------
int __cdecl VerifySignatureOK(#1077 *TreeListItemData, char a2)
{
  wchar_t *v2; // eax
  StrNode **v3; // ecx
  const unsigned __int16 *v4; // ebx
  char *v5; // edx
  wchar_t **v6; // esi
  StrNode *v7; // eax
  StrNode *v8; // esi
  HCURSOR v9; // eax
  CRYPT_PROVIDER_SGNR *v10; // eax
  CRYPT_PROVIDER_SGNR *v11; // esi
  wchar_t *v12; // esi
  int v13; // ecx
  wchar_t v14; // ax
  size_t v15; // esi
  wchar_t *v16; // ebx
  wchar_t *v17; // eax
  unsigned int v18; // esi
  unsigned int v19; // ecx
  size_t v20; // esi
  wchar_t *v21; // eax
  wchar_t *v22; // eax
  HCURSOR hCursor; // [esp+Ch] [ebp-8C0h]
  wchar_t *v25; // [esp+10h] [ebp-8BCh]
  unsigned int v26; // [esp+14h] [ebp-8B8h]
  wchar_t *str1; // [esp+18h] [ebp-8B4h]
  char *v28; // [esp+1Ch] [ebp-8B0h]
  wchar_t **v29; // [esp+20h] [ebp-8ACh]
  StrNode **v30; // [esp+24h] [ebp-8A8h]
  wchar_t *v31[32]; // [esp+28h] [ebp-8A4h]
  __int16 szErrorMsg[1040]; // [esp+A8h] [ebp-824h]

  if ( *(TreeListItemData + 1) == 1 )
  {
    v2 = *(TreeListItemData + 86);
    v3 = (TreeListItemData + 352);
    v4 = *(TreeListItemData + 85);
    v5 = TreeListItemData + 356;
    v6 = (TreeListItemData + 360);
  }
  else
  {
    v2 = *(TreeListItemData + 198);
    v3 = (TreeListItemData + 832);
    v4 = *(TreeListItemData + 197);
    v5 = TreeListItemData + 836;
    v6 = (TreeListItemData + 840);
  }
  v29 = v6;
  v28 = v5;
  str1 = v2;
  v30 = v3;
  if ( !v2 || *v2 == 91 )
    return 0;
  if ( !*v3 )
  {
    if ( a2 )
    {
      v7 = StrInList(v2);
      v8 = v7;
      if ( v7 )
      {
        *v29 = _wcsdup(v7->strText2);
        *v30 = v8->pPrev;
      }
      else
      {
        *v29 = _wcsdup(L"Verifying...");
        SendMessageW(ghWndNewOwner, PMT_MSG_7F0, 0, TreeListItemData);
        v9 = LoadCursorW(0, IDC_WAIT);
        hCursor = SetCursor(v9);
        v26 = 32;
        v10 = sub_1219BB0(str1, 0, 0, 0, 0, &v26, v31, 0, 0, 0, 0, 0, -1);
        v11 = v10;
        if ( v10 )
        {
          SetLastError(v10);
          if ( v11 == CERT_E_EXPIRED )
            tcscpy_s(szErrorMsg, 0x410u, L"Certificate expired");
          else
            sub_125BE70(szErrorMsg, 0x410u);
          if ( wcschr(szErrorMsg, 0x2Eu) )
            *wcschr(szErrorMsg, 0x2Eu) = 0;
          if ( v4 )
            v19 = wcslen(v4);
          else
            v19 = 1;
          v20 = wcslen(szErrorMsg) + v19 + 32;
          v21 = malloc(2 * v20);
          v25 = v21;
          *v30 = 2;
          if ( v4 )
            swprintf_s(v21, v20, L"(%s) %s", szErrorMsg, v4);
          else
            swprintf_s(v21, v20, L"(%s)", szErrorMsg);
          v16 = v25;
        }
        else
        {
          v12 = v31[0];
          *v30 = 1;
          v13 = (v12 + 1);
          do
          {
            v14 = *v12;
            ++v12;
          }
          while ( v14 );
          v15 = ((v12 - v13) >> 1) + 64;
          v16 = malloc(2 * v15);
          swprintf_s(v16, v15, L"(Verified) %s", v31[0]);
          v17 = _wcsdup(v31[0]);
          v18 = 0;
          *v28 = v17;
          if ( v26 )
          {
            do
              free(v31[v18++]);
            while ( v18 < v26 );
          }
        }
        SetCursor(hCursor);
        v22 = _wcsdup(v16);
        *v29 = v22;
        InsertNodeToTail(str1, *v30, v22);
        free(v16);
      }
    }
    else
    {
      *v6 = _wcsdup(v4);
    }
    SendMessageW(ghWndNewOwner, 0x7F0u, 0, TreeListItemData);
  }
  return *v28;
}

//----- (0125D9D0) --------------------------------------------------------
_DWORD *__cdecl sub_125D9D0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
    result = *a1;
  return result;
}

//----- (0125D9E0) --------------------------------------------------------
_DWORD *__cdecl GetTopSystemHandleInfo(PSYSTEM_HANDLE_INFORMATION SystemHandleInfo, int NumberOfHandles, PSYSTEM_HANDLE_TABLE_ENTRY_INFO HandleTableEntry)
{
  _DWORD *result; // eax
  PSYSTEM_HANDLE_TABLE_ENTRY_INFO v4; // ecx

  if ( gbServiceNotImplemented )
  {
    // _SYSTEM_HANDLE_INFORMATION_EX
    result = &HandleTableEntry->UniqueProcessId;
    *&HandleTableEntry->UniqueProcessId = SystemHandleInfo + 0x1C * NumberOfHandles + 8;
  }
  else
  {
    // SYSTEM_HANDLE_INFORMATION
    v4 = (SystemHandleInfo + 0x10 * NumberOfHandles);
    gTopSystemHandleInfo.CreatorBackTraceIndex = v4->HandleValue;
    gTopSystemHandleInfo.GrantedAccess = *&v4[1].UniqueProcessId;
    LOBYTE(gTopSystemHandleInfo.HandleAttributes) = BYTE1(v4->Object);
    gTopSystemHandleInfo.HandleValue = HIWORD(v4->Object);
    gTopSystemHandleInfo.Object = v4->GrantedAccess;
    gTopSystemHandleInfo.ObjectTypeIndex = LOBYTE(v4->Object);
    gTopSystemHandleInfo.UniqueProcessId = *&v4->ObjectTypeIndex;
    result = &HandleTableEntry->UniqueProcessId;
    *&HandleTableEntry->UniqueProcessId = &gTopSystemHandleInfo;
  }
  return result;
}
// 12EABA5: using guessed type char gbServiceNotImplemented;

//----- (0125DA60) --------------------------------------------------------
struct _FILETIME __cdecl GetAllProcesses(_SYSTEM_PROCESS_INFORMATION **ppBuffer, size_t *pdwSizeReturned)
{
  DWORD dwSize; // esi
  _SYSTEM_PROCESS_INFORMATION *v3; // eax
  struct _FILETIME SystemTimeAsFileTime; // [esp+8h] [ebp-Ch]
  DWORD v6; // [esp+10h] [ebp-4h]

  dwSize = &v6;
  if ( pdwSizeReturned )
    dwSize = pdwSizeReturned;
  if ( !*ppBuffer )
  {
    *dwSize = 1000;
    *ppBuffer = malloc(1000u);
  }
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  if ( NtQuerySystemInformation(SystemProcessInformation, *ppBuffer, *dwSize, &pdwSizeReturned) )
  {
    do
    {
      free(*ppBuffer);
      *dwSize += 10000;
      v3 = malloc(*dwSize);
      *ppBuffer = v3;
    }
    while ( NtQuerySystemInformation(SystemProcessInformation, v3, *dwSize, &pdwSizeReturned) );
  }
  return SystemTimeAsFileTime;
}

//----- (0125DAF0) --------------------------------------------------------
DWORD __cdecl LoadSystemInfo(_SYSTEM_PROCESS_INFORMATION **pSystemProcessInfo, int *pcbSize, SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *pSysProcessorPerfInfo, _SYSTEM_INTERRUPT_INFORMATION *pInterruptInfo, SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION *pProcessorCycleTimeInfo, void *pInfo, int InfoSize)
{
  struct _FILETIME TimeRefresh; // rax
  DWORD dwLowDateTime; // ebx
  SYSTEM_PERFORMANCE_INFORMATION *pProcessorCycleTimeInfo1; // edi
  SYSTEM_PROCESS_INFORMATION *pSysProcessInfo; // esi
  CMapNode *NewNode; // eax
  ULONG i; // eax
  CMapNode *pNewNode; // eax
  int v14; // eax
  _DWORD *v15; // ecx
  CSysProcItem **v16; // eax
  int v17; // edx
  CSysProcItem *v18; // ST0C_4
  CMapPair resultPair; // [esp+10h] [ebp-2Ch]
  CMapPair pair; // [esp+18h] [ebp-24h]
  CMap theMap; // [esp+20h] [ebp-1Ch]
  DWORD SizeReturned; // [esp+28h] [ebp-14h]
  DWORD dwHighDateTime; // [esp+2Ch] [ebp-10h]
  int v25; // [esp+38h] [ebp-4h]

  TimeRefresh = GetAllProcesses(pSystemProcessInfo, pcbSize);
  dwHighDateTime = TimeRefresh.dwHighDateTime;
  dwLowDateTime = TimeRefresh.dwLowDateTime;
  if ( pSysProcessorPerfInfo )
    NtQuerySystemInformation(
      SystemProcessorPerformanceInformation,
      pSysProcessorPerfInfo,
      sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * gSystemInfo.dwNumberOfProcessors,
      &SizeReturned);
  if ( pInterruptInfo )
    NtQuerySystemInformation(
      SystemInterruptInformation,
      pInterruptInfo,
      sizeof(SYSTEM_INTERRUPT_INFORMATION) * gSystemInfo.dwNumberOfProcessors,
      &SizeReturned);
  pProcessorCycleTimeInfo1 = pProcessorCycleTimeInfo;
  if ( pProcessorCycleTimeInfo )
    NtQuerySystemInformation(
      SystemProcessorCycleTimeInformation,
      pProcessorCycleTimeInfo,
      8 * gSystemInfo.dwNumberOfProcessors,
      &SizeReturned);
  if ( GetProcessorSystemCycleTime && pProcessorCycleTimeInfo1 )
  {
    theMap._Size = 0;
    theMap._Header = std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Buynode<std::pair<unsigned long,void *>>();
    pSysProcessInfo = gpSysProcessInfo1;
    v25 = 0;
    if ( gpSysProcessInfo1 )
    {
      pair.Key = gpSysProcessInfo1->UniqueProcessId;
      pair.Value = gpSysProcessInfo1;
      NewNode = CMapNode::NewNode(&theMap, &pair);
      std::_Tree<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Insert_at<std::pair<unsigned long const,void *> &,std::_Tree_node<std::pair<unsigned long const,void *>,void *> *>(
        &theMap,
        &resultPair,
        0,
        &NewNode->_KeyValue,
        NewNode);
      for ( i = pSysProcessInfo->NextEntryOffset; pSysProcessInfo->NextEntryOffset; i = pSysProcessInfo->NextEntryOffset )
      {
        pSysProcessInfo = (pSysProcessInfo + i);
        pair.Value = pSysProcessInfo;
        pair.Key = pSysProcessInfo->UniqueProcessId;
        pNewNode = CMapNode::NewNode(&theMap, &pair);
        std::_Tree<std::_Tmap_traits<unsigned long,void *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const,void *>>,0>>::_Insert_at<std::pair<unsigned long const,void *> &,std::_Tree_node<std::pair<unsigned long const,void *>,void *> *>(
          &theMap,
          &resultPair,
          0,
          &pNewNode->_KeyValue,
          pNewNode);
      }
    }
    v14 = sub_125E4B0(&theMap, *pSystemProcessInfo, pProcessorCycleTimeInfo1, InfoSize);
    v15 = pInfo;
    *pInfo = v14;
    v16 = theMap._Header;
    v18 = theMap._Header;
    v15[1] = v17;
    sub_1275510(&theMap, &pSysProcessorPerfInfo, *v16, v18);
    j__free(theMap._Header);
  }
  return dwLowDateTime;
}

//----- (0125DC80) --------------------------------------------------------
void GetAllServicesName()
{
  DWORD v0; // esi
  DWORD cbSized; // [esp+0h] [ebp-8h]
  DWORD dwHandle; // [esp+4h] [ebp-4h]

  if ( *EnumServicesStatusExW )
  {
    EnterCriticalSection(&gEnumServiceLock);
    dwHandle = 0;
    if ( !EnumServicesStatusExW(
            ghSCManager,
            SC_ENUM_PROCESS_INFO,
            SERVICE_WIN32,
            SERVICE_ACTIVE,
            gstrServiceNameBuffer,
            gdwServiceNameBufferAllocSize,
            &cbSized,
            &gdwServiceNameBufferRealSize,
            &dwHandle,
            0) )
    {
      do
      {
        if ( GetLastError() != ERROR_MORE_DATA )
          break;
        dwHandle = 0;
        if ( gstrServiceNameBuffer )
          free(gstrServiceNameBuffer);
        gdwServiceNameBufferAllocSize += 16384;
        v0 = gdwServiceNameBufferAllocSize;
        gstrServiceNameBuffer = malloc(gdwServiceNameBufferAllocSize);
      }
      while ( !EnumServicesStatusExW(
                 ghSCManager,
                 SC_ENUM_PROCESS_INFO,
                 SERVICE_WIN32,
                 SERVICE_ACTIVE,
                 gstrServiceNameBuffer,
                 v0,
                 &cbSized,
                 &gdwServiceNameBufferRealSize,
                 &dwHandle,
                 0) );
    }
    LeaveCriticalSection(&gEnumServiceLock);
  }
}

//----- (0125DD60) --------------------------------------------------------
void __cdecl sub_125DD60(char a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int *a8)
{
  int v8; // esi
  unsigned int v9; // edx
  wchar_t *v10; // edi
  int v11; // ebx
  signed int v12; // eax
  const CHAR *v13; // ecx
  unsigned int v14; // ebx
  int v15; // esi
  int v16; // eax
  const CHAR *v17; // ebx
  const wchar_t **v18; // eax
  wchar_t *v19; // eax
  volatile signed __int32 *v20; // edx
  _DWORD *v21; // eax
  void *v22; // esi
  int v23; // ebx
  LPCSTR v24; // ebx
  const CHAR *v25; // ecx
  int v26; // eax
  void *v27; // ebx
  int v28; // edx
  unsigned int v29; // ebx
  int v30; // esi
  char *v31; // eax
  LPCSTR v32; // eax
  int v33; // eax
  void *v34; // esi
  const wchar_t **v35; // eax
  bool v36; // bl
  bool v37; // zf
  int v38; // ebx
  CString *v39; // eax
  const wchar_t **v40; // eax
  const wchar_t **v41; // eax
  wchar_t *v42; // eax
  DWORD v43; // ST18_4
  int v44; // eax
  int v45; // esi
  __int16 *v46; // ecx
  __int16 v47; // ax
  int v48; // ecx
  wchar_t v49; // ax
  __int16 v50; // ax
  int v51; // ecx
  wchar_t v52; // ax
  int v53; // [esp+10h] [ebp-1278h]
  unsigned __int64 Displacement; // [esp+14h] [ebp-1274h]
  int v55; // [esp+1Ch] [ebp-126Ch]
  int v56; // [esp+20h] [ebp-1268h]
  int v57; // [esp+24h] [ebp-1264h]
  int v58; // [esp+28h] [ebp-1260h]
  int v59; // [esp+2Ch] [ebp-125Ch]
  int v60; // [esp+30h] [ebp-1258h]
  int str; // [esp+34h] [ebp-1254h]
  int v62; // [esp+38h] [ebp-1250h]
  unsigned int *v63; // [esp+3Ch] [ebp-124Ch]
  int v64; // [esp+40h] [ebp-1248h]
  int v65; // [esp+44h] [ebp-1244h]
  LPCSTR lpMultiByteStr; // [esp+48h] [ebp-1240h]
  unsigned int *v67; // [esp+4Ch] [ebp-123Ch]
  DWORD64 Address; // [esp+50h] [ebp-1238h]
  wchar_t v69; // [esp+58h] [ebp-1230h]
  struct _SYMBOL_INFOW Symbol; // [esp+858h] [ebp-A30h]
  WCHAR Buffer; // [esp+C58h] [ebp-630h]
  WCHAR Src; // [esp+E60h] [ebp-428h]
  WCHAR Dst; // [esp+106Ch] [ebp-21Ch]
  int v74; // [esp+1284h] [ebp-4h]

  HIDWORD(Displacement) = a6;
  Address = __PAIR__(a4, a2);
  v65 = a3;
  v58 = a5;
  v57 = a7;
  v63 = a8;
  if ( !a2 )
  {
    v8 = sub_125E420(*(a3 + 44));
    if ( !v8 )
      v8 = a5;
    LODWORD(Address) = v8;
  }
  EnterCriticalSection(&gStrListLock);
  GetSystemDirectoryW(&Buffer, 0x104u);
  v9 = Address;
  v10 = (a3 + 52);
  while ( 1 )
  {
    v11 = v57;
    v12 = -1;
    v67 = -1;
    *v10 = 0;
    if ( !v11 )
      goto LABEL_74;
    v64 = -1;
    v13 = *(v11 + 48);
    v14 = 0;
    lpMultiByteStr = v13;
    if ( !*v13 )
      goto LABEL_74;
    v15 = (v13 + 12);
    do
    {
      if ( v9 > *v15 )
      {
        if ( v9 >= *v15 + *(v15 + 4) )
        {
          v12 = v67;
        }
        else
        {
          v16 = *(v15 + 18) + 20;
          v64 = *v15;
          stprintf(v10, L"%S", v15 + v16);
          v9 = Address;
          v12 = v14;
          v67 = v14;
        }
      }
      ++v14;
      v15 += 284;
    }
    while ( v14 < *lpMultiByteStr );
    if ( v12 == -1 )
    {
LABEL_74:
      v29 = 0;
      v64 = -1;
      if ( !*v63 )
        goto LABEL_52;
      v30 = (v63 + 3);
      do
      {
        if ( v9 > *v30 )
        {
          if ( v9 >= *v30 + *(v30 + 4) )
          {
            v12 = v67;
          }
          else
          {
            v64 = *v30;
            lpMultiByteStr = (v30 + 20);
            v31 = strrchr((v30 + 20), 92);
            if ( v31 )
              v32 = v31 + 1;
            else
              v32 = lpMultiByteStr;
            stprintf(v10, L"%S", v32);
            v9 = Address;
            v12 = v29;
            v67 = v29;
          }
        }
        ++v29;
        v30 += 284;
      }
      while ( v29 < *v63 );
      if ( v12 == -1 )
      {
LABEL_52:
        v27 = HIDWORD(Address);
        goto LABEL_53;
      }
      v33 = 71 * v12;
      v34 = 0;
      v67 = &v63[v33];
      lpMultiByteStr = &v63[v33 + 8];
      v35 = sub_1259EA0(&v55, lpMultiByteStr);
      v36 = _wcsnicmp(*v35, L"\\SystemRoot\\", 0xCu) == 0;
      sub_122B3E0(&v55);
      v37 = v36 == 0;
      v38 = v67;
      if ( v37 )
      {
        if ( *(v67 + 33) == 58 )
        {
          v40 = CString::LoadString(lpMultiByteStr);
          tcscpy_s(&Dst, 0x105u, *v40);
          sub_122B3E0(&v60);
        }
        else
        {
          if ( *(v67 + 37) != 58 )
          {
            sub_1259D60(&Dst, L"%s\\drivers\\%s", &Buffer, v10);
            v34 = pfnFindExecutableImageExW(&Dst, &Buffer, &Src);
            if ( v34 )
            {
              if ( !_wcsicmp(&Src, &Dst) )
                goto LABEL_46;
              CloseHandle(v34);
            }
            sub_1259D60(&Src, L"%s\\drivers\\%s", &Buffer, v10);
            v34 = pfnFindExecutableImageExW(&Src, &Buffer, &Dst);
            goto LABEL_46;
          }
          v41 = CString::LoadString(v67 + 36);
          tcscpy_s(&Dst, 0x105u, *v41);
          sub_122B3E0(&v56);
        }
      }
      else
      {
        v39 = sub_1259EA0(&v53, v67 + 44);
        sub_1259D60(&Src, L"%%SystemRoot%%\\%s", v39->m_pszData);
        sub_122B3E0(&v53);
        ExpandEnvironmentStringsW(&Src, &Dst, 0x105u);
      }
LABEL_46:
      v42 = _wcsdup(&Dst);
      *(v65 + 572) = v42;
      if ( Hook_SymLoadModuleExW && a1 )
      {
        v43 = *(v38 + 16);
        v44 = *(v38 + 12);
        v27 = HIDWORD(Address);
        Hook_SymLoadModuleExW(HIDWORD(Address), v34, &Dst, 0, v44, v43);
      }
      else
      {
        v27 = HIDWORD(Address);
      }
      if ( v34 )
        CloseHandle(v34);
      goto LABEL_53;
    }
    if ( !a1 )
      goto LABEL_52;
    lpMultiByteStr += 284 * v12;
    v17 = lpMultiByteStr + 32;
    v18 = CString::LoadString(lpMultiByteStr + 32);
    v19 = _wcsdup(*v18);
    v20 = (str - 16);
    *(v65 + 572) = v19;
    if ( _InterlockedDecrement(v20 + 3) <= 0 )
      (*(**v20 + 4))(v20);
    if ( !Hook_SymLoadModuleExW )
      goto LABEL_52;
    v21 = CString::LoadString(v17);
    v74 = 0;
    v22 = pfnFindExecutableImageExW(*v21, 0, &Dst);
    v23 = v59 - 16;
    v74 = -1;
    if ( _InterlockedDecrement((v59 - 16 + 12)) <= 0 )
      (*(**v23 + 4))(v23);
    v24 = lpMultiByteStr;
    v25 = *CString::LoadString(lpMultiByteStr + 32);
    v26 = *(v24 + 3);
    v27 = HIDWORD(Address);
    v74 = 1;
    Hook_SymLoadModuleExW(HIDWORD(Address), v22, v25, 0, v26, 0);
    v28 = v62 - 16;
    v74 = -1;
    if ( _InterlockedDecrement((v62 - 16 + 12)) <= 0 )
      (*(**v28 + 4))(v28);
    if ( v22 )
      CloseHandle(v22);
LABEL_53:
    v45 = Address;
    Symbol.SizeOfStruct = 88;
    Symbol.MaxNameLen = 469;
    if ( a1 )
    {
      if ( *SymFromAddrW && SymFromAddrW(v27, Address, &Displacement, &Symbol) )
        break;
    }
    if ( *v10 )
    {
      FormatTex(&v69, L"+0x%x", v45 - v64);
      goto LABEL_70;
    }
    if ( v45 == v58 )
    {
      FormatTex(&v69, L"0x%x", v45);
LABEL_70:
      wcscat_s(v10, 0x104u, &v69);
      goto LABEL_71;
    }
    v9 = v58;
    LODWORD(Address) = v58;
  }
  v46 = (a3 + 52);
  LOBYTE(Symbol.Name[Symbol.NameLen]) = 0;
  if ( Displacement )
  {
    do
    {
      v47 = *v46;
      ++v46;
    }
    while ( v47 );
    v48 = (v46 - a3 - 54) >> 1;
    do
    {
      v49 = *v10;
      ++v10;
    }
    while ( v49 );
    _snwprintf_s((v65 + 2 * ((v10 - a3 - 54) >> 1) + 52), 260 - v48, 0xFFFFFFFF, L"!%s+0x%x", Symbol.Name, Displacement);
  }
  else
  {
    do
    {
      v50 = *v46;
      ++v46;
    }
    while ( v50 );
    v51 = (v46 - a3 - 54) >> 1;
    do
    {
      v52 = *v10;
      ++v10;
    }
    while ( v52 );
    _snwprintf_s((v65 + 2 * ((v10 - a3 - 54) >> 1) + 52), 260 - v51, 0xFFFFFFFF, L"!%s", Symbol.Name);
  }
LABEL_71:
  LeaveCriticalSection(&gStrListLock);
}
// 12C2BE0: using guessed type wchar_t a0xX_0[5];
// 12EF2DC: using guessed type int (__stdcall *pfnFindExecutableImageExW)(_DWORD, _DWORD, _DWORD);

//----- (0125E420) --------------------------------------------------------
int __cdecl sub_125E420(HANDLE hObject)
{
  HANDLE v1; // esi
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  HANDLE v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]

  v10 = hObject;
  v12 = 0;
  v9 = 0;
  v3 = 24;
  v4 = 0;
  v6 = 0;
  v5 = 0;
  v7 = 0;
  v8 = 0;
  if ( NtOpenThread(&hObject, 64, &v3, &v9) )
    return v12;
  v1 = hObject;
  if ( hObject )
  {
    NtQueryInformationThread(hObject, 9, &v12, 4, &v11);
    CloseHandle(v1);
  }
  return v12;
}
// 12EF23C: using guessed type int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF254: using guessed type int (__stdcall *NtOpenThread)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0125E4B0) --------------------------------------------------------
int __cdecl sub_125E4B0(CMap *map, _SYSTEM_PROCESS_INFORMATION *SystemProcessInfo, SYSTEM_PERFORMANCE_INFORMATION *perfinfo, unsigned int InfoSize)
{
  CMap Map_1; // rcx
  _SYSTEM_PROCESS_INFORMATION *SystemProcessInfo_1; // esi
  unsigned int v6; // edx
  DWORD dwNumberOfProcessors; // edi
  DWORD offset; // edx
  __m128i v9; // xmm1
  __m128i v10; // xmm2
  ULONG64 *pProcessorCycleTimes; // eax
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128i v14; // xmm1
  signed __int64 v15; // kr08_8
  unsigned int v16; // eax
  unsigned int v17; // edi
  int v18; // kr18_4
  unsigned __int8 v19; // cf
  unsigned __int64 v20; // kr28_8
  unsigned int CycleTime; // kr04_4
  CMapNode *_Left; // ebx
  CMapNode *found; // ecx
  DWORD uID; // edx
  CMapNode *_Parent; // eax
  CMapNode **v26; // eax
  CMapNode *v27; // eax
  _SYSTEM_PROCESS_INFORMATION *v28; // edx
  CMap *Map; // esi
  CMapNode *v30; // eax
  FILETIME v31; // rdi
  _SYSTEM_PROCESS_INFORMATION *pProcessInfo; // edx
  int CycleTime_1; // ecx
  CMapNode *v34; // ecx
  CMapNode *j; // ecx
  CMapNode *i; // ecx
  unsigned int v37; // edx
  __m128i v38; // xmm1
  __m128i v39; // xmm2
  LARGE_INTEGER *IoWriteTransferCount; // eax
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm1
  signed __int64 v44; // kr38_8
  unsigned __int64 v45; // rcx
  int v46; // eax
  unsigned int v47; // edi
  unsigned int v48; // eax
  unsigned __int64 v49; // kr40_8
  unsigned __int64 v50; // kr48_8
  unsigned int v51; // edi
  unsigned __int64 v52; // rax
  ULONG puBufferLength; // [esp+0h] [ebp-83Ch]
  CMapNode *v55; // [esp+4h] [ebp-838h]
  CMapNode *v56; // [esp+8h] [ebp-834h]
  DWORD dwNumberOfProcessors_1; // [esp+Ch] [ebp-830h]
  _DWORD a2[7]; // [esp+10h] [ebp-82Ch]
  CMapNode *pMap; // [esp+2Ch] [ebp-810h]
  __int64 v60; // [esp+30h] [ebp-80Ch]
  ULONG64 ProcessorCycleTimes[256]; // [esp+38h] [ebp-804h]

  Map_1 = map;
  SystemProcessInfo_1 = SystemProcessInfo;
  *&a2[3] = 0i64;
  v6 = 0;
  dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
  pMap = map;
  a2[2] = InfoSize;
  v60 = 0i64;
  while ( 1 )
  {
    if ( !SystemProcessInfo_1->UniqueProcessId && !SystemProcessInfo_1->CycleTime )
    {
      puBufferLength = 8 * dwNumberOfProcessors;
      QueryIdleProcessorCycleTime(&puBufferLength, ProcessorCycleTimes);
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
      offset = 0;
      if ( gSystemInfo.dwNumberOfProcessors && gSystemInfo.dwNumberOfProcessors >= 4 )
      {
        v9 = 0i64;
        v10 = 0i64;
        pProcessorCycleTimes = &ProcessorCycleTimes[2];
        do
        {
          v12 = _mm_loadu_si128(pProcessorCycleTimes - 1);
          offset += 4;
          pProcessorCycleTimes += 4;
          // Adds the 2 signed or unsigned 64-bit integers in a to the 2 signed or unsigned 64-bit integers in b.
          // r0 := a0 + b0
          // r1 := a1 + b1
          v9 = _mm_add_epi64(v9, v12);
          v10 = _mm_add_epi64(v10, _mm_loadu_si128(pProcessorCycleTimes - 2));
        }
        while ( offset < gSystemInfo.dwNumberOfProcessors - (gSystemInfo.dwNumberOfProcessors & 3) );
        v13 = _mm_add_epi64(v9, v10);
        // //返回一个__m128i的寄存器，r=srl(_A, _Imm * 8),   _Imm must be an immediate,    
        // //shifting in zeros 
        v14 = _mm_add_epi64(v13, _mm_srli_si128(v13, 8));
        // //返回一个32bit整数，r=_A0 
        Map_1._Header = _mm_cvtsi128_si32(v14);
        v15 = *&Map_1 + __PAIR__(_mm_cvtsi128_si32(_mm_srli_si128(v14, 4)), HIDWORD(v60));
        Map_1._Size = HIDWORD(v15);
        v60 = __PAIR__(v15, HIDWORD(v15));
      }
      *&a2[3] = 0i64;
      *&a2[5] = 0i64;
      if ( offset >= gSystemInfo.dwNumberOfProcessors )
      {
        v6 = HIDWORD(v60);
      }
      else
      {
        Map_1 = __PAIR__(a2[6], a2[3]);
        if ( gSystemInfo.dwNumberOfProcessors - offset < 2 )
        {
          a2[6] = a2[5];
          v16 = a2[4];
        }
        else
        {
          dwNumberOfProcessors_1 = gSystemInfo.dwNumberOfProcessors - 1;
          a2[6] = a2[5];
          v16 = a2[4];
          v17 = a2[5];
          do
          {
            v16 = (__PAIR__(HIDWORD(ProcessorCycleTimes[offset]), ProcessorCycleTimes[offset])
                 + __PAIR__(v16, Map_1._Header)) >> 32;
            Map_1._Header = (Map_1._Header + LODWORD(ProcessorCycleTimes[offset]));
            v18 = LODWORD(ProcessorCycleTimes[offset + 1]) + v17;
            Map_1._Size = (__PAIR__(HIDWORD(ProcessorCycleTimes[offset + 1]), ProcessorCycleTimes[offset + 1])
                         + __PAIR__(Map_1._Size, v17)) >> 32;
            v17 += LODWORD(ProcessorCycleTimes[offset + 1]);
            offset += 2;
          }
          while ( offset < dwNumberOfProcessors_1 );
          a2[6] = v18;
          dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
        }
        if ( offset < dwNumberOfProcessors )
        {
          v19 = __CFADD__(ProcessorCycleTimes[offset], HIDWORD(v60));
          HIDWORD(v60) += LODWORD(ProcessorCycleTimes[offset]);
          LODWORD(v60) = HIDWORD(ProcessorCycleTimes[offset]) + v19 + v60;
          dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
        }
        v20 = __PAIR__(v16, a2[6]) + *&Map_1 + __PAIR__(v60, HIDWORD(v60));
        Map_1._Size = v20 >> 32;
        v6 = v20;
      }
      Map_1._Header = pMap;
    }
    CycleTime = SystemProcessInfo_1->CycleTime;
    HIDWORD(v60) = LODWORD(SystemProcessInfo_1->CycleTime) + v6;
    Map_1._Size = (__PAIR__(Map_1._Size, CycleTime) + __PAIR__(HIDWORD(SystemProcessInfo_1->CycleTime), v6)) >> 32;
    v6 += CycleTime;
    LODWORD(v60) = Map_1._Size;
    if ( Map_1._Header )
    {
      _Left = Map_1._Header->_Left;
      found = _Left;
      uID = SystemProcessInfo_1->UniqueProcessId;
      _Parent = _Left->_Parent;
      while ( !_Parent->_isnil )
      {
        if ( _Parent->_KeyValue.Key >= uID )
        {
          found = _Parent;
          _Parent = _Parent->_Left;
        }
        else
        {
          _Parent = _Parent->_Right;
        }
      }
      if ( found == _Left || uID < found->_KeyValue.Key )
      {
        v56 = _Left;
        v26 = &v56;
      }
      else
      {
        v55 = found;
        v26 = &v55;
      }
      v27 = *v26;
      if ( v27 != _Left )
      {
        v28 = v27->_KeyValue.Value;
        if ( v28->CreateTime.LowPart == SystemProcessInfo_1->CreateTime.LowPart )
        {
          Map_1._Header = pMap;
          if ( v28->CreateTime.HighPart != SystemProcessInfo_1->CreateTime.HighPart )
          {
LABEL_35:
            v6 = HIDWORD(v60);
            Map_1._Size = v60;
            goto __next;
          }
          sub_12755B0(pMap, &a2[1], v27);
          dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
        }
      }
      Map_1._Header = pMap;
      goto LABEL_35;
    }
__next:
    if ( !SystemProcessInfo_1->NextEntryOffset )
      break;
    SystemProcessInfo_1 = (SystemProcessInfo_1 + SystemProcessInfo_1->NextEntryOffset);
  }
  Map = pMap;
  if ( pMap )
  {
    v30 = pMap->_Left->_Left;
    if ( v30 != pMap->_Left )
    {
      v31.dwLowDateTime = a2[2];
      do
      {
        pProcessInfo = v30->_KeyValue.Value;
        CycleTime_1 = pProcessInfo->CycleTime;
        v19 = __CFADD__(CycleTime_1, *v31.dwLowDateTime);
        *v31.dwLowDateTime += CycleTime_1;
        *(v31.dwLowDateTime + 4) += HIDWORD(pProcessInfo->CycleTime) + v19;
        if ( !v30->_isnil )
        {
          v34 = v30->_Right;
          if ( v34->_isnil )
          {
            for ( i = v30->_Parent; !i->_isnil; i = i->_Parent )
            {
              if ( v30 != i->_Right )
                break;
              v30 = i;
            }
            v30 = i;
          }
          else
          {
            v30 = v30->_Right;
            for ( j = v34->_Left; !j->_isnil; j = j->_Left )
              v30 = j;
          }
        }
      }
      while ( v30 != Map->_Header );
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    }
  }
  v37 = 0;
  if ( dwNumberOfProcessors && dwNumberOfProcessors >= 4 )
  {
    v38 = 0i64;
    v39 = 0i64;
    IoWriteTransferCount = &perfinfo->IoWriteTransferCount;
    do
    {
      *v41.m128i_i8 = IoWriteTransferCount[-2];
      IoWriteTransferCount += 4;
      v41.m128i_i64[1] = IoWriteTransferCount[-5].QuadPart;
      v37 += 4;
      v38 = _mm_add_epi64(v38, v41);
      *v41.m128i_i8 = IoWriteTransferCount[-4];
      v41.m128i_i64[1] = IoWriteTransferCount[-3].QuadPart;
      v39 = _mm_add_epi64(v39, v41);
    }
    while ( v37 < dwNumberOfProcessors - (dwNumberOfProcessors & 3) );
    v42 = _mm_add_epi64(v38, v39);
    v43 = _mm_add_epi64(v42, _mm_srli_si128(v42, 8));
    Map_1._Header = _mm_cvtsi128_si32(v43);
    v44 = *&Map_1 + __PAIR__(_mm_cvtsi128_si32(_mm_srli_si128(v43, 4)), HIDWORD(v60));
    v60 = __PAIR__(v44, HIDWORD(v44));
  }
  *a2 = 0i64;
  *&a2[3] = 0i64;
  if ( v37 >= dwNumberOfProcessors )
  {
    LODWORD(v52) = HIDWORD(v60);
  }
  else
  {
    v45 = __PAIR__(a2[4], a2[0]);
    if ( dwNumberOfProcessors - v37 < 2 )
    {
      a2[6] = a2[3];
      v48 = a2[1];
    }
    else
    {
      v46 = dwNumberOfProcessors - 1;
      v47 = a2[3];
      a2[2] = v46;
      v48 = a2[1];
      do
      {
        v49 = *(&perfinfo->liIdleTime.QuadPart + v37) + __PAIR__(v48, v45);
        v48 = v49 >> 32;
        LODWORD(v45) = v49;
        v50 = *(&perfinfo->IoReadTransferCount.QuadPart + v37) + __PAIR__(HIDWORD(v45), v47);
        HIDWORD(v45) = v50 >> 32;
        v47 = v50;
        v37 += 2;
      }
      while ( v37 < a2[2] );
      a2[6] = v50;
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
    }
    if ( v37 >= dwNumberOfProcessors )
    {
      v51 = v60;
    }
    else
    {
      v51 = (*(&perfinfo->liIdleTime.QuadPart + v37) + __PAIR__(v60, HIDWORD(v60))) >> 32;
      HIDWORD(v60) += *(&perfinfo->liIdleTime.LowPart + 2 * v37);
    }
    v52 = __PAIR__(v48, a2[6]) + v45 + __PAIR__(v51, HIDWORD(v60));
  }
  return v52;
}

//----- (0125E920) --------------------------------------------------------
signed int sub_125E920()
{
  HANDLE JobHandle; // edi
  SYSTEM_HANDLE_INFORMATION *pSystemHandleInfo; // eax
  ULONG NumberOfHandles; // esi
  int iNDEXOfHandles; // esi
  signed int result; // eax
  SYSTEM_HANDLE_INFORMATION *v5; // eax
  ULONG v6; // esi
  int v7; // esi
  _SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleTableEntry; // [esp+4h] [ebp-808h]

  if ( *CreateJobObjectW )
  {
    // Windows提供了一个作业(job)内核对象,它允许你将进程组合在一起并创建一个"沙箱"来限制进程能够做什么.最好将作业对象想象成一个进程容器.但是,即使作业中只包含一个进程,也是非常有用的,因为这样可以对进程施加平时不能施加的限制.
    JobHandle = CreateJobObjectW(0, 0);
    if ( JobHandle )
    {
      GetAllProcesses(&gpSysProcessInfo, &gdwSysProcessInfoSize);
      GetSystemHandlesInfo(0);
      pSystemHandleInfo = gpSystemHandleInformation2;
      if ( gpSystemHandleInformation2 )
        NumberOfHandles = gpSystemHandleInformation2->NumberOfHandles;
      else
        NumberOfHandles = 0;
      iNDEXOfHandles = NumberOfHandles - 1;
      if ( iNDEXOfHandles >= 0 )
      {
        while ( 1 )
        {
          GetTopSystemHandleInfo(pSystemHandleInfo, iNDEXOfHandles, &HandleTableEntry);
          if ( *(*&HandleTableEntry.UniqueProcessId + 4) == GetCurrentProcessId()
            && *(*&HandleTableEntry.UniqueProcessId + 8) == JobHandle )
          {
            break;
          }
          if ( --iNDEXOfHandles < 0 )
            goto LABEL_12;
          pSystemHandleInfo = gpSystemHandleInformation2;
        }
        *&HandleTableEntry.ObjectTypeIndex = 0;
        sub_125C750(
          &word_12F05D8[64 * *(*&HandleTableEntry.UniqueProcessId + 18)],
          *&HandleTableEntry.UniqueProcessId,
          &HandleTableEntry.ObjectTypeIndex,
          0x400u,
          0);
      }
LABEL_12:
      CloseHandle(JobHandle);
    }
    result = 1;
  }
  else
  {
    // 获取所有进程信息
    GetAllProcesses(&gpSysProcessInfo, &gdwSysProcessInfoSize);
    GetSystemHandlesInfo(0);
    v5 = gpSystemHandleInformation2;
    if ( gpSystemHandleInformation2 )
      v6 = gpSystemHandleInformation2->NumberOfHandles;
    else
      v6 = 0;
    v7 = v6 - 1;
    if ( v7 >= 0 )
    {
      while ( 1 )
      {
        GetTopSystemHandleInfo(v5, v7, &HandleTableEntry);
        if ( !word_12F05D8[64 * *(*&HandleTableEntry.UniqueProcessId + 18)] )
        {
          *&HandleTableEntry.ObjectTypeIndex = 0;
          sub_125C750(
            &word_12F05D8[64 * *(*&HandleTableEntry.UniqueProcessId + 18)],
            *&HandleTableEntry.UniqueProcessId,
            &HandleTableEntry.ObjectTypeIndex,
            0x400u,
            0);
        }
        if ( --v7 < 0 )
          break;
        v5 = gpSystemHandleInformation2;
      }
    }
    result = 1;
  }
  return result;
}

//----- (0125EAA0) --------------------------------------------------------
LPVOID __cdecl GetDescInfo(LPCVOID VerInfo, int a2)
{
  LPVOID result; // eax
  unsigned int puLen; // [esp+8h] [ebp-Ch]
  __int16 translate; // [esp+Ch] [ebp-8h]
  LANGANDCODEPAGE *lpTranslate; // [esp+10h] [ebp-4h]

  translate = 1024;
  lpTranslate = &translate;
  VerQueryValueW(VerInfo, L"\\VarFileInfo\\Translation", &lpTranslate, &puLen);
  result = GetImageDescription(VerInfo, lpTranslate->wLanguage, lpTranslate->wCodePage, a2);
  if ( !result )
  {
    result = GetImageDescription(VerInfo, lpTranslate->wLanguage, 0x4E4u, a2);
    if ( !result )
      result = GetImageDescription(VerInfo, DS_DEFAULT_LOCALE, 0x4E4u, a2);
  }
  return result;
}

//----- (0125EB20) --------------------------------------------------------
DWORD __cdecl sub_125EB20(void *a1, PVOID *a2, DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, DWORD *a7)
{
  DWORD result; // eax
  unsigned int v8; // ecx
  int v9; // eax

  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  while ( 1 )
  {
    if ( QueryWorkingSet(a1, *a2, *a3) )
    {
      if ( !*a2 )
        goto LABEL_7;
      if ( *a3 >= 4 * **a2 )
        break;
    }
    if ( *a2 )
      free(*a2);
LABEL_7:
    result = GetLastError();
    if ( result != 24 )
    {
      *a2 = 0;
      *a3 = 0;
      return result;
    }
    *a3 += 0x4000;
    *a2 = malloc(*a3);
  }
  v8 = 0;
  if ( **a2 )
  {
    do
    {
      v9 = *(*a2 + v8 + 1);
      ++*a4;
      if ( v9 & 0x100 )
      {
        ++*a6;
        if ( (v9 & 0xE0u) > 0x20 )
          ++*a7;
      }
      else
      {
        ++*a5;
      }
      ++v8;
    }
    while ( v8 < **a2 );
  }
  *a4 *= gSystemInfo.dwPageSize;
  *a5 *= gSystemInfo.dwPageSize;
  *a6 *= gSystemInfo.dwPageSize;
  result = gSystemInfo.dwPageSize * *a7;
  *a7 = result;
  return result;
}

//----- (0125EC30) --------------------------------------------------------
BOOL __stdcall SystemInfoGPUnodesDlgProc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  int v4; // ebx
  int v5; // esi
  HWND v6; // eax
  int v7; // ST24_4
  int v8; // ST20_4
  int v9; // ST1C_4
  HWND v10; // eax
  HICON v11; // eax
  HWND v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  signed int v16; // esi
  HWND v17; // eax
  ProcessorInfo *v18; // eax
  int v19; // esi
  unsigned int v20; // edx
  int v21; // ecx
  LONG v22; // eax
  LONG v23; // ecx
  int v24; // ebx
  int v25; // esi
  HWND v26; // esi
  CResize *v27; // eax
  CResize *v28; // esi
  char *v29; // eax
  HWND v30; // eax
  ResizeInfo *v31; // eax
  HMENU v32; // ST2C_4
  HWND v33; // eax
  double v34; // xmm0_8
  double *v35; // eax
  int v37; // ecx
  int v38; // esi
  int v39; // ebx
  int v40; // esi
  int v41; // ebx
  HWND v42; // eax
  HWND v43; // eax
  int v44; // ebx
  int v45; // esi
  HWND v46; // eax
  double v47; // [esp+10h] [ebp-94h]
  LRESULT wParam; // [esp+14h] [ebp-90h]
  double v49; // [esp+18h] [ebp-8Ch]
  int v50; // [esp+1Ch] [ebp-88h]
  double v51; // [esp+20h] [ebp-84h]
  int v52; // [esp+24h] [ebp-80h]
  double v53; // [esp+28h] [ebp-7Ch]
  double v54; // [esp+28h] [ebp-7Ch]
  int v55; // [esp+2Ch] [ebp-78h]
  int v56; // [esp+30h] [ebp-74h]
  int nWidth; // [esp+34h] [ebp-70h]
  int v58; // [esp+38h] [ebp-6Ch]
  double v59; // [esp+3Ch] [ebp-68h]
  signed int ArgList; // [esp+40h] [ebp-64h]
  LONG ArgLista; // [esp+40h] [ebp-64h]
  struct tagPOINT Point; // [esp+44h] [ebp-60h]
  int v63; // [esp+4Ch] [ebp-58h]
  HMENU hMenu; // [esp+50h] [ebp-54h]
  struct tagRECT v65; // [esp+54h] [ebp-50h]
  struct tagRECT Rect; // [esp+64h] [ebp-40h]
  WCHAR String; // [esp+74h] [ebp-30h]
  int v68; // [esp+A0h] [ebp-4h]

  if ( a2 > 0x113 )
  {
    if ( a2 > 0x138 )
    {
      if ( a2 == 1124 )
      {
        v43 = GetDlgItem(hDlg, 2501);
        ShowWindow(v43, 0);
        v44 = 1;
        if ( gdwAdapterRuntingTime + 1 > 1 )
        {
          v45 = 2503;
          do
          {
            v46 = GetDlgItem(hDlg, v45);
            ShowWindow(v46, 5);
            ++v44;
            v45 += 2;
          }
          while ( v44 < gdwAdapterRuntingTime + 1 );
        }
      }
    }
    else if ( a2 == 312 || a2 == 307 || a2 == 310 )
    {
      return sub_1246710(hDlg, a3);
    }
    return 0;
  }
  if ( a2 == 275 )
  {
    v40 = 0;
    if ( gdwAdapterRuntingTime > 0 )
    {
      v41 = 2502;
      do
      {
        v42 = GetDlgItem(hDlg, v41);
        SendMessageW(v42, 0x400u, 0, 0);
        ++v40;
        v41 += 2;
      }
      while ( v40 < gdwAdapterRuntingTime );
    }
    return 0;
  }
  if ( a2 > 0x110 )
  {
    if ( a2 == 273 )
    {
      if ( a3 == 1 )
      {
        v37 = 0;
        v38 = 0;
        hMenu = 0;
        if ( gdwAdapterRuntingTime > 0 )
        {
          v39 = 2503;
          do
          {
            if ( IsDlgButtonChecked(hDlg, v39) == 1 )
            {
              v37 = (1 << v38) | hMenu;
              hMenu = ((1 << v38) | hMenu);
            }
            else
            {
              v37 = hMenu;
            }
            ++v38;
            v39 += 2;
          }
          while ( v38 < gdwAdapterRuntingTime );
        }
        if ( v37 != gdwGpuNodeUsageMask )
        {
          gdwGpuNodeUsageMask = v37;
          gpGraphClassData[2][20].field_18 = 0;
          gpGraphClassData[2][20].field_1C = 0;
        }
        EndDialog(hDlg, 0);
      }
      else if ( a3 == 2 )
      {
        EndDialog(hDlg, 0);
      }
    }
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 5 )
    {
      v4 = 0;
      if ( gdwAdapterRuntingTime > 0 )
      {
        v5 = 2503;
        do
        {
          v6 = GetDlgItem(hDlg, v5 - 1);
          GetWindowRect(v6, &Rect);
          Point.x = Rect.left;
          Point.y = Rect.bottom + 2;
          ScreenToClient(hDlg, &Point);
          v7 = Rect.right - Rect.left;
          v8 = Point.y;
          v9 = Point.x;
          v10 = GetDlgItem(hDlg, v5);
          SetWindowPos(v10, 0, v9, v8, v7, 14, 0);
          ++v4;
          v5 += 2;
        }
        while ( v4 < gdwAdapterRuntingTime );
      }
    }
    else if ( a2 == 36 )
    {
      *(a4 + 8) = 2 * gScreenWidth;
    }
    return 0;
  }
  v11 = LoadIconW(ghInstance, 0x65);
  SendMessageW(hDlg, 0x80u, 0, v11);
  v12 = GetDlgItem(hDlg, 2501);
  GetWindowRect(v12, &v65);
  v13 = gdwAdapterRuntingTime;
  v56 = gdwAdapterRuntingTime;
  if ( gdwAdapterRuntingTime > 8 )
  {
    v13 = 8 * (gdwAdapterRuntingTime / 8 > 16) + 8;
    v56 = 8 * (gdwAdapterRuntingTime / 8 > 16) + 8;
  }
  v14 = (v13 + gdwAdapterRuntingTime - 1) / v13;
  v58 = v14;
  v15 = v13 * v14 - gdwAdapterRuntingTime;
  if ( v15 )
  {
    v13 += v15 / -2;
    v56 = v13;
    v58 = (v13 + gdwAdapterRuntingTime - 1) / v13;
  }
  v16 = 4;
  if ( gdwAdapterRuntingTime > 16 )
    v16 = 3;
  ArgList = v16;
  if ( gdwAdapterRuntingTime > 32 )
    ArgList = --v16;
  nWidth = (v65.right - v16 * (v13 - 1) - v65.left) / v13;
  v52 = (v65.bottom - v16 * (v58 - 1) - v65.top) / v58;
  v17 = GetDlgItem(hDlg, 2501);
  GetWindowRect(v17, &v65);
  MapWindowPoints(0, hDlg, &v65, 2u);
  if ( !dword_12FBA1C )
  {
    v18 = InitProcessorScreenData(gdwAdapterRuntingTime, 1, 0);
    v19 = 0;
    dword_12FBA1C = v18;
    if ( gdwAdapterRuntingTime > 0 )
    {
      v20 = 0;
      while ( 1 )
      {
        v18[v20 / 0x898].m_ScreenData2 = v19;
        *(v20 + dword_12FBA1C + 28) = 1;
        *(v20 + dword_12FBA1C + 32) = 4;
        *(v20 + dword_12FBA1C + 48) = 8421631;
        *(v20 + dword_12FBA1C + 40) = gdbMaxValue;
        *(v20 + dword_12FBA1C + 2172) = gpGraphClassData[2];
        if ( v19 )
        {
          v21 = dword_12FBA1C;
          *(v20 + dword_12FBA1C + 2148) = *(dword_12FBA1C + 2148);
          *(v20 + dword_12FBA1C + 2152) = *(v21 + 2152);
        }
        ++v19;
        v20 += 2200;
        if ( v19 >= gdwAdapterRuntingTime )
          break;
        v18 = dword_12FBA1C;
      }
    }
    v16 = ArgList;
  }
  Rect.bottom = v65.left;
  wParam = SendMessageW(hDlg, 0x31u, 0, 0);
  v22 = 0;
  ArgLista = 0;
  if ( gdwAdapterRuntingTime > 0 )
  {
    v63 = 0;
    v50 = v16 + nWidth;
    v23 = v65.left;
    hMenu = 2503;
    do
    {
      v24 = 0;
      Point.y = v22 + 1;
      v55 = (v22 + 1) % v56;
      if ( !v55 )
        v24 = v65.right - v23 - nWidth;
      v25 = MulDiv(14, gLogPixelsY, 96);
      CreateWindowExW(
        0,
        L"Static",
        0,
        0x40000000u,
        v65.left,
        v65.top,
        v24 + nWidth,
        v52 - v25 - 1,
        hDlg,
        (hMenu - 1),
        ghInstance,
        0);
      CreateGraphWindowInDlg(hDlg, hMenu - 1, v63 + dword_12FBA1C);
      v26 = CreateWindowExW(
              0,
              L"Button",
              0,
              0x40010003u,
              v65.left,
              v52 + v65.top - v25,
              nWidth,
              v25,
              hDlg,
              hMenu,
              ghInstance,
              0);
      wsprintf(&String, L"Engine %d", ArgLista);
      SetWindowTextW(v26, &String);
      SendMessageW(v26, 0x30u, wParam, 1);
      EnableWindow(v26, 1);
      ShowWindow(v26, 5);
      if ( (1 << ArgLista) & gdwGpuNodeUsageMask )
        CheckDlgButton(hDlg, hMenu, 1u);
      v23 = v50 + v65.left;
      v65.left += v50;
      if ( !v55 )
      {
        v23 = Rect.bottom;
        v65.left = Rect.bottom;
        v65.top += v52 + 2;
      }
      v22 = Point.y;
      v63 += 2200;
      ArgLista = Point.y;
      hMenu = (hMenu + 2);
    }
    while ( Point.y < gdwAdapterRuntingTime );
    v13 = v56;
  }
  v27 = operator new(0x40u);
  v28 = v27;
  Point.y = v27;
  v68 = 0;
  if ( v27 )
  {
    v27->m_hTheme = 0;
    LOBYTE(v68) = 1;
    v27->vtptr = &CResizer::`vftable';
    v27->m_hWnd = 0;
    v27->m_WidthScale = 50;
    v27->m_HeightScale = 67;
    v27->m_Buffer = 0;
    v27->m_BufCount = 0;
    v27->m_FixedBorder = 1;
    if ( hDlg )
      CResize::HookWindow(v27, hDlg);
  }
  else
  {
    v28 = 0;
  }
  v68 = -1;
  *&Point = 0.0;
  *&Rect.right = 0i64;
  v63 = 0;
  if ( gdwAdapterRuntingTime > 0 )
  {
    v29 = 2502;
    hMenu = 2502;
    v47 = 1.0 / v13;
    v49 = 1.0 / v58;
    do
    {
      v30 = GetDlgItem(hDlg, v29);
      v59 = v49 + *&Rect.right;
      v53 = v49 + *&Rect.right;
      if ( v49 + *&Rect.right >= 0.99999 )
        v53 = doubleOnePointZero;
      v31 = CResize::InitResizeBuffer(v28, v30, 1);
      v32 = hMenu;
      *&v31->d21.left = *&Rect.right;
      *&v31->d21.right = v53;
      v33 = GetDlgItem(hDlg, v32);
      v34 = v47 + *&Point;
      v51 = v47 + *&Point;
      v54 = v47 + *&Point;
      if ( v47 + *&Point >= 0.99999 )
        v54 = doubleOnePointZero;
      if ( v33 )
      {
        v35 = CResize::InitResizeBuffer(v28, v33, 1);
        *v35 = *&Point;
        v35[1] = v54;
        v34 = v51;
      }
      *&Point = v34;
      if ( !(++v63 % v13) )
      {
        *&Point = 0.0;
        *&Rect.right = v59;
      }
      v29 = hMenu + 2;
      hMenu = (hMenu + 2);
    }
    while ( v63 < gdwAdapterRuntingTime );
  }
  SendMessageW(hDlg, 0x464u, 0, 0);
  SetTimer(hDlg, 0, 0x3E8u, 0);
  return 1;
}
// 12BC888: using guessed type void *CResizer::`vftable';
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E4E28: using guessed type int gScreenWidth;
// 12E96DC: using guessed type int gdwGpuNodeUsageMask;
// 12FBA1C: using guessed type int dword_12FBA1C;

//----- (0125F3E0) --------------------------------------------------------
signed int __cdecl sub_125F3E0(int ThreadId, int a2, int a3)
{
  void *v3; // esi
  signed int result; // eax
  int v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h]

  v5 = ThreadId;
  v6 = a2;
  v7 = a3;
  v3 = _beginthreadex(0, 0, sub_125C090, &v5, 0, &ThreadId);
  if ( WaitForSingleObject(v3, 0x1388u) == 258 )
  {
    TerminateThread(v3, 1u);
    CloseHandle(v3);
    result = 32;
  }
  else
  {
    CloseHandle(v3);
    result = v8;
  }
  return result;
}

//----- (0125F460) --------------------------------------------------------
char __cdecl FindSystemHandleInfo(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *a1)
{
  struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO *v1; // ecx
  struct _SYSTEM_HANDLE_INFORMATION *pSystemHandleInformation; // eax
  unsigned int i; // esi
  PSYSTEM_HANDLE_TABLE_ENTRY_INFO pTableEntryInfo; // [esp+0h] [ebp-4h]

  pTableEntryInfo = v1;
  pSystemHandleInformation = gpSystemHandleInformation2;
  if ( !gpSystemHandleInformation2 )
    return 0;
  for ( i = 0; pSystemHandleInformation && i < pSystemHandleInformation->NumberOfHandles; ++i )
  {
    GetTopSystemHandleInfo(pSystemHandleInformation, i, &pTableEntryInfo);
    if ( *&pTableEntryInfo->ObjectTypeIndex == a1[1].HandleValue
      && pTableEntryInfo->Object == *&a1[1].CreatorBackTraceIndex
      && *&pTableEntryInfo->UniqueProcessId == a1[1].GrantedAccess )
    {
      return 1;
    }
    pSystemHandleInformation = gpSystemHandleInformation2;
  }
  return 0;
}

//----- (0125F4D0) --------------------------------------------------------
int __cdecl sub_125F4D0(int a1, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, PSECURITY_DESCRIPTOR pSecurityDescriptor, int a5)
{
  SECURITY_INFORMATION v5; // esi
  DWORD v6; // eax
  HANDLE v7; // eax
  void *v8; // ebx
  signed int v10; // edi
  int v11; // esi
  bool v12; // al

  v5 = SecurityInformation;
  switch ( SecurityInformation )
  {
    case 1u:
      v6 = 0x80000;
      break;
    case 4u:
      v6 = 0x40000;
      break;
    case 8u:
      v6 = 0x1000000;
      break;
    default:
      v6 = SecurityInformation;
      break;
  }
  v7 = DuplicateProcessHandle(*(a1 + 36), *(a1 + 44), v6);
  v8 = v7;
  if ( !v7 || !SetKernelObjectSecurity(v7, v5, SecurityDescriptor) )
    return 5;
  v10 = 5;
  if ( pSecurityDescriptor )
  {
    v11 = v5 | 3;
    if ( v11 == 1 )
      v11 = 5;
    v12 = GetKernelObjectSecurity(v8, v11, pSecurityDescriptor, 0x2000u, &SecurityInformation);
    *a5 = v12;
  }
  CloseHandle(v8);
  if ( !a5 )
    return 0;
  if ( *a5 )
    v10 = 0;
  return v10;
}

//----- (0125F580) --------------------------------------------------------
int __stdcall sub_125F580(int a1, int a2, int a3)
{
  FARPROC v3; // eax
  HMODULE v4; // eax

  v3 = dword_12FBC08;
  if ( dword_12FBC08 )
    return (v3)(a1, a2, a3);
  v4 = GetModuleHandle(L"KERNEL32.DLL");
  v3 = GetProcAddress(v4, "GetProcessDEPPolicy");
  dword_12FBC08 = v3;
  if ( v3 )
    return (v3)(a1, a2, a3);
  SetLastError(0x78u);
  return 0;
}
// 12FBC08: using guessed type int dword_12FBC08;

//----- (0125F5C0) --------------------------------------------------------
int __stdcall sub_125F5C0(int a1, int a2, int a3, int a4)
{
  FARPROC v4; // eax
  HMODULE v5; // eax

  v4 = GetProcessMitigationPolicy;
  if ( GetProcessMitigationPolicy )
    return (v4)(a1, a2, a3, a4);
  v5 = GetModuleHandle(L"KERNEL32.DLL");
  v4 = GetProcAddress(v5, "GetProcessMitigationPolicy");
  GetProcessMitigationPolicy = v4;
  if ( v4 )
    return (v4)(a1, a2, a3, a4);
  SetLastError(0x78u);
  return 0;
}
// 12FBC04: using guessed type int GetProcessMitigationPolicy;

//----- (0125F600) --------------------------------------------------------
char __cdecl sub_125F600(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax
  int v5; // ecx

  v4 = a1;
  if ( !a1 )
    return 0;
  while ( 1 )
  {
    if ( v4[10] == a2 && v4[146] == a4 )
    {
      v5 = v4[11];
      if ( v5 == a3 || v5 == 16777343 && !a3 )
        break;
      if ( !v5 && a3 == 16777343 )
        break;
    }
    v4 = v4[547];
    if ( !v4 )
      return 0;
  }
  return 1;
}

//----- (0125F660) --------------------------------------------------------
int __thiscall sub_125F660(int *this, HMODULE hModule, int a3)
{
  int *v3; // edi
  HRSRC v4; // eax
  unsigned __int16 *v5; // eax
  unsigned __int16 *v6; // ebx
  int v7; // eax
  int v8; // esi
  int result; // eax

  v3 = this;
  v4 = FindResourceW(hModule, ((a3 >> 4) + 1), 6);
  if ( !v4 )
    return 0;
  v5 = AtlGetStringResourceImage(hModule, v4, a3);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = WideCharToMultiByte(3u, 0, v5 + 1, *v5, 0, 0, 0, 0);
  v8 = v7;
  if ( v7 < 0 )
    goto LABEL_12;
  if ( ((*(*v3 - 8) - v7) | (1 - *(*v3 - 4))) < 0 )
    sub_1262330(v3, v7);
  WideCharToMultiByte(3u, 0, v6 + 1, *v6, *v3, v8, 0, 0);
  if ( v8 > *(*v3 - 8) )
LABEL_12:
    AtlThrow(-2147024809);
  *(*v3 - 12) = v8;
  result = 1;
  *(v8 + *v3) = 0;
  return result;
}

//----- (0125F720) --------------------------------------------------------
char LoadSystemCalls()
{
  HMODULE v0; // eax
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  HMODULE v5; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  HMODULE v8; // eax
  HMODULE v9; // eax
  HMODULE v10; // eax
  HMODULE v11; // eax
  HMODULE v12; // eax
  HMODULE v13; // eax
  HMODULE v14; // eax
  HMODULE v15; // eax
  HMODULE v16; // eax
  HMODULE v17; // eax
  HMODULE v18; // eax
  HMODULE v19; // eax
  HMODULE v20; // eax
  HMODULE v21; // eax
  HMODULE v22; // eax
  HMODULE v23; // eax
  HMODULE v24; // eax
  HMODULE v25; // eax
  HMODULE v26; // eax
  HMODULE v27; // eax
  HMODULE v28; // eax
  HMODULE v29; // eax
  HMODULE v30; // eax
  HMODULE v31; // eax
  HMODULE v32; // eax
  HMODULE v33; // eax
  HMODULE v34; // eax
  HMODULE v35; // eax
  HMODULE v36; // eax
  HMODULE v37; // eax
  HMODULE v38; // eax
  HMODULE v39; // eax
  HMODULE v40; // eax
  HMODULE v41; // eax
  HMODULE v42; // eax
  HMODULE v43; // eax
  HMODULE v44; // eax
  HMODULE v45; // eax
  HMODULE v46; // eax
  HMODULE v47; // eax
  HMODULE v48; // eax
  HMODULE v49; // eax
  HMODULE v50; // eax
  HMODULE v51; // eax
  HMODULE v52; // eax
  HMODULE v53; // eax
  HMODULE v54; // eax
  HMODULE v55; // eax
  HMODULE v56; // eax
  HMODULE hDbgHelpModule; // eax
  HMODULE v58; // eax
  HMODULE v59; // eax
  FARPROC v60; // eax
  HANDLE (__stdcall *v61)(LPCWSTR, LPCWSTR, int); // ecx
  HMODULE v62; // eax
  HMODULE v63; // eax
  HMODULE v64; // eax
  HMODULE v65; // eax
  HMODULE v66; // eax
  HMODULE v67; // eax
  HMODULE v68; // eax
  HMODULE v69; // eax
  HMODULE v70; // eax
  HMODULE v71; // eax
  HMODULE v72; // eax
  HMODULE v73; // eax
  HMODULE v74; // eax
  HMODULE v75; // eax
  HKEY phkResult; // [esp+8h] [ebp-218h]
  DWORD cbData; // [esp+Ch] [ebp-214h]
  HMODULE hModule; // [esp+10h] [ebp-210h]
  __int16 Text[260]; // [esp+14h] [ebp-20Ch]

  sub_12601B0();
  v0 = GetModuleHandle(L"ntdll.dll");
  NtQuerySystemInformation = GetProcAddress(v0, "NtQuerySystemInformation");
  if ( !NtQuerySystemInformation )
  {
    stprintf(
      Text,
      L"Not able to run on this version of Windows:\nMissing function: %s",
      L"Ntdll!NtQuerySystemInformation");
__ErrorRpt:
    MessageBoxW(0, Text, L"Process Explorer", 0x10u);
    return 0;
  }
  v2 = GetModuleHandle(L"ntdll.dll");
  NtQuerySymbolicLinkObject = GetProcAddress(v2, "NtQuerySymbolicLinkObject");
  if ( !NtQuerySymbolicLinkObject )
  {
    stprintf(
      Text,
      L"Not able to run on this version of Windows:\nMissing function: %s",
      L"Ntdll!NtQuerySymbolicLinkObject");
    goto __ErrorRpt;
  }
  v3 = GetModuleHandle(L"ntdll.dll");
  NtQueryDirectoryObject = GetProcAddress(v3, "NtQueryDirectoryObject");
  if ( !NtQueryDirectoryObject )
  {
    stprintf(
      Text,
      L"Not able to run on this version of Windows:\nMissing function: %s",
      L"Ntdll!NtQueryDirectoryObject");
    goto __ErrorRpt;
  }
  v4 = GetModuleHandle(L"ntdll.dll");
  NtOpenSymbolicLinkObject = GetProcAddress(v4, "NtOpenSymbolicLinkObject");
  if ( !NtOpenSymbolicLinkObject )
    return ErrMsxBox(L"Ntdll!NtOpenSymbolicLinkObject");
  v5 = GetModuleHandle(L"ntdll.dll");
  NtOpenDirectoryObject = GetProcAddress(v5, "NtOpenDirectoryObject");
  if ( !NtOpenDirectoryObject )
    return ErrMsxBox(L"Ntdll!NtOpenDirectoryObject");
  v6 = GetModuleHandle(L"ntdll.dll");
  NtQueryObject = GetProcAddress(v6, "NtQueryObject");
  if ( !NtQueryObject )
    return ErrMsxBox(L"Ntdll!NtQueryObject");
  v7 = GetModuleHandle(L"ntdll.dll");
  NtQueryInformationProcess = GetProcAddress(v7, "NtQueryInformationProcess");
  if ( !NtQueryInformationProcess )
    return ErrMsxBox(L"Ntdll!NtQueryInformationProcess");
  v8 = GetModuleHandle(L"ntdll.dll");
  NtSetInformationProcess = GetProcAddress(v8, "NtSetInformationProcess");
  if ( !NtSetInformationProcess )
    return ErrMsxBox(L"Ntdll!NtSetInformationProcess");
  v9 = GetModuleHandle(L"ntdll.dll");
  NtQuerySemaphore = GetProcAddress(v9, "NtQuerySemaphore");
  if ( !NtQuerySemaphore )
    return ErrMsxBox(L"Ntdll!NtQuerySemaphore");
  v10 = GetModuleHandle(L"ntdll.dll");
  NtOpenSymbolicLinkObject = GetProcAddress(v10, "NtOpenSymbolicLinkObject");
  if ( !NtOpenSymbolicLinkObject )
    return ErrMsxBox(L"Ntdll!NtOpenSymbolicLinkObject");
  v11 = GetModuleHandle(L"ntdll.dll");
  NtQuerySection = GetProcAddress(v11, "NtQuerySection");
  if ( !NtQuerySection )
    return ErrMsxBox(L"Ntdll!NtQuerySection");
  v12 = GetModuleHandle(L"ntdll.dll");
  NtQueryEvent = GetProcAddress(v12, "NtQueryEvent");
  if ( !NtQueryEvent )
    return ErrMsxBox(L"Ntdll!NtQueryEvent");
  v13 = GetModuleHandle(L"ntdll.dll");
  NtQueryMutant = GetProcAddress(v13, "NtQueryMutant");
  if ( !NtQueryMutant )
    return ErrMsxBox(L"Ntdll!NtQueryMutant");
  v14 = GetModuleHandle(L"ntdll.dll");
  NtResumeThread = GetProcAddress(v14, "NtResumeThread");
  if ( !NtResumeThread )
    return ErrMsxBox(L"Ntdll!NtResumeThread");
  v15 = GetModuleHandle(L"ntdll.dll");
  NtSuspendThread = GetProcAddress(v15, "NtSuspendThread");
  if ( !NtSuspendThread )
    return ErrMsxBox(L"Ntdll!NtSuspendThread");
  v16 = GetModuleHandle(L"ntdll.dll");
  NtOpenThread = GetProcAddress(v16, "NtOpenThread");
  if ( !NtOpenThread )
    return ErrMsxBox(L"Ntdll!NtOpenThread");
  v17 = GetModuleHandle(L"ntdll.dll");
  NtQueryInformationThread = GetProcAddress(v17, "NtQueryInformationThread");
  if ( !NtQueryInformationThread )
    return ErrMsxBox(L"Ntdll!NtQueryInformationThread");
  v18 = GetModuleHandle(L"ntdll.dll");
  NtQueryVirtualMemory = GetProcAddress(v18, "NtQueryVirtualMemory");
  if ( !NtQueryVirtualMemory )
    return ErrMsxBox(L"Ntdll!NtQueryVirtualMemory");
  v19 = GetModuleHandle(L"ntdll.dll");
  RtlCreateQueryDebugBuffer = GetProcAddress(v19, "RtlCreateQueryDebugBuffer");
  if ( !RtlCreateQueryDebugBuffer )
    return ErrMsxBox(L"Ntdll!RtlCreateQueryDebugBuffer");
  v20 = GetModuleHandle(L"ntdll.dll");
  RtlQueryProcessDebugInformation = GetProcAddress(v20, "RtlQueryProcessDebugInformation");
  if ( !RtlQueryProcessDebugInformation )
    return ErrMsxBox(L"Ntdll!RtlQueryProcessDebugInformation");
  v21 = GetModuleHandle(L"ntdll.dll");
  RtlDestroyQueryDebugBuffer = GetProcAddress(v21, "RtlDestroyQueryDebugBuffer");
  if ( !RtlDestroyQueryDebugBuffer )
    return ErrMsxBox(L"Ntdll!RtlDestroyQueryDebugBuffer");
  v22 = GetModuleHandle(L"ntdll.dll");
  RtlTimeToTimeFields = GetProcAddress(v22, "RtlTimeToTimeFields");
  if ( !RtlTimeToTimeFields )
    return ErrMsxBox(L"Ntdll!RtlTimeToTimeFields");
  v23 = LoadLibraryW(L"aclui.dll");
  *CreateSecurityPage = GetProcAddress(v23, "CreateSecurityPage");
  if ( *CreateSecurityPage )
    goto LABEL_70;
  v24 = LoadLibraryW(L"acledit.dll");
  SedDiscretionaryAclEditor = GetProcAddress(v24, "SedDiscretionaryAclEditor");
  if ( !SedDiscretionaryAclEditor )
    return ErrMsxBox(L"Acledit!SedDiscretionaryAclEditor");
  v25 = GetModuleHandle(L"acledit.dll");
  SedSystemAclEditor = GetProcAddress(v25, "SedSystemAclEditor");
  if ( !SedSystemAclEditor )
    return ErrMsxBox(L"Acledit!SedSystemAclEditor");
  v26 = GetModuleHandle(L"acledit.dll");
  SedTakeOwnership = GetProcAddress(v26, "SedTakeOwnership");
  if ( !SedTakeOwnership )
    return ErrMsxBox(L"Acledit!SedTakeOwnership");
LABEL_70:
  v27 = LoadLibraryW(L"shcore.dll");
  GetProcessDpiAwareness = GetProcAddress(v27, "GetProcessDpiAwareness");
  v28 = LoadLibraryW(L"iphlpapi.dll");
  *GetTcpTable = GetProcAddress(v28, "GetTcpTable");
  v29 = LoadLibraryW(L"iphlpapi.dll");
  *GetUdpTable = GetProcAddress(v29, "GetUdpTable");
  v30 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetTcpExTableFromStack = GetProcAddress(v30, "AllocateAndGetTcpExTableFromStack");
  v31 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetUdpExTableFromStack = GetProcAddress(v31, "AllocateAndGetUdpExTableFromStack");
  v32 = LoadLibraryW(L"iphlpapi.dll");
  *GetExtendedTcpTable = GetProcAddress(v32, "GetExtendedTcpTable");
  v33 = LoadLibraryW(L"iphlpapi.dll");
  *GetExtendedUdpTable = GetProcAddress(v33, "GetExtendedUdpTable");
  v34 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetTcpExTable2FromStack = GetProcAddress(v34, "AllocateAndGetTcpExTable2FromStack");
  v35 = LoadLibraryW(L"iphlpapi.dll");
  AllocateAndGetUdpExTable2FromStack = GetProcAddress(v35, "AllocateAndGetUdpExTable2FromStack");
  v36 = LoadLibraryW(L"user32.dll");
  *GetGuiResources = GetProcAddress(v36, "GetGuiResources");
  v37 = LoadLibraryW(L"psapi.dll");
  *QueryWorkingSet = GetProcAddress(v37, "QueryWorkingSet");
  v38 = LoadLibraryW(L"psapi.dll");
  *GetMappedFileNameW = GetProcAddress(v38, "GetMappedFileNameW");
  v39 = LoadLibraryW(L"psapi.dll");
  *EnumProcessModulesEx = GetProcAddress(v39, "EnumProcessModulesEx");
  v40 = LoadLibraryW(L"kernel32.dll");
  *GlobalMemoryStatusEx = GetProcAddress(v40, "GlobalMemoryStatusEx");
  v41 = LoadLibraryW(L"user32.dll");
  *IsHungAppWindow = GetProcAddress(v41, "IsHungAppWindow");
  v42 = LoadLibraryW(L"user32.dll");
  HungWindowFromGhostWindow = GetProcAddress(v42, "HungWindowFromGhostWindow");
  v43 = LoadLibraryW(L"kernel32.dll");
  *GetLogicalProcessorInformation = GetProcAddress(v43, "GetLogicalProcessorInformation");
  v44 = LoadLibraryW(L"kernel32.dll");
  GetLogicalProcessorInformationEx = GetProcAddress(v44, "GetLogicalProcessorInformationEx");
  v45 = LoadLibraryW(L"kernel32.dll");
  SetThreadGroupAffinity = GetProcAddress(v45, "SetThreadGroupAffinity");
  v46 = LoadLibraryW(L"wtsapi32.dll");
  WTSEnumerateSessionsW = GetProcAddress(v46, "WTSEnumerateSessionsW");
  v47 = LoadLibraryW(L"wtsapi32.dll");
  WTSDisconnectSession = GetProcAddress(v47, "WTSDisconnectSession");
  v48 = LoadLibraryW(L"winsta.dll");
  WinStationConnectW = GetProcAddress(v48, "WinStationConnectW");
  v49 = LoadLibraryW(L"winsta.dll");
  WinStationShadow = GetProcAddress(v49, "WinStationShadow");
  v50 = LoadLibraryW(L"wtsapi32.dll");
  WTSLogoffSession = GetProcAddress(v50, "WTSLogoffSession");
  v51 = LoadLibraryW(L"wtsapi32.dll");
  WTSSendMessageW = GetProcAddress(v51, "WTSSendMessageW");
  v52 = LoadLibraryW(L"wtsapi32.dll");
  WTSFreeMemory = GetProcAddress(v52, "WTSFreeMemory");
  v53 = LoadLibraryW(L"wtsapi32.dll");
  WTSQuerySessionInformationW = GetProcAddress(v53, "WTSQuerySessionInformationW");
  v54 = LoadLibraryW(L"kernel32.dll");
  *WTSGetActiveConsoleSessionId = GetProcAddress(v54, "WTSGetActiveConsoleSessionId");
  v55 = LoadLibraryW(L"user32.dll");
  *SetMenuInfo = GetProcAddress(v55, "SetMenuInfo");
  v56 = LoadLibraryW(L"user32.dll");
  *GetMenuInfo = GetProcAddress(v56, "GetMenuInfo");
  hDbgHelpModule = LoadLibraryW(gstrDbgHelpPath);
  hModule = hDbgHelpModule;
  if ( !hDbgHelpModule )
  {
    if ( RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\DebuggingTools", &phkResult) )
      goto LABEL_71;
    cbData = 520;
    RegQueryValueExW(phkResult, L"Windbg", 0, 0, gstrDbgHelpPath, &cbData);
    wcscat_s(gstrDbgHelpPath, 0x104u, L"DbgHelp.dll");
    hDbgHelpModule = LoadLibraryW(gstrDbgHelpPath);
    hModule = hDbgHelpModule;
    if ( !hDbgHelpModule )
    {
      tcscpy_s(gstrDbgHelpPath, 0x104u, L"C:\\Debuggers\\dbghelp.dll");
      hDbgHelpModule = LoadLibraryW(gstrDbgHelpPath);
      hModule = hDbgHelpModule;
      if ( !hDbgHelpModule )
      {
        ExpandEnvironmentStringsW(
          L"%ProgramFiles%\\Debugging Tools for Windows (x86)\\dbghelp.dll",
          gstrDbgHelpPath,
          0x104u);
        hDbgHelpModule = LoadLibraryW(gstrDbgHelpPath);
        hModule = hDbgHelpModule;
        if ( !hDbgHelpModule )
        {
          GetCurrentDirectoryW(0x104u, gstrDbgHelpPath);
          wcscat_s(gstrDbgHelpPath, 0x104u, L"\\dbghelp.dll");
          hDbgHelpModule = LoadLibraryW(gstrDbgHelpPath);
          hModule = hDbgHelpModule;
          if ( !hDbgHelpModule )
          {
LABEL_71:
            hDbgHelpModule = LoadLibraryW(L"dbghelp.dll");
            hModule = hDbgHelpModule;
            if ( !hDbgHelpModule )
            {
              hDbgHelpModule = LoadLibraryW(L"imagehlp.dll");
              hModule = hDbgHelpModule;
            }
          }
        }
      }
    }
  }
  GetModuleFileNameW(hDbgHelpModule, gstrDbgHelpPath, 0x104u);
  LoadDbgHelp(gstrDbgHelpPath);
  if ( !*ImageNtHeader )
  {
    v58 = LoadLibraryW(L"imagehlp.dll");
    *ImageNtHeader = GetProcAddress(v58, "ImageNtHeader");
  }
  *FindExecutableImageExW = GetProcAddress(hModule, "FindExecutableImageExW");
  if ( *FindExecutableImageExW )
  {
    pfnFindExecutableImageExW = Real_FindExecutableImageExW;
  }
  else
  {
    v59 = LoadLibraryW(L"imagehlp.dll");
    v60 = GetProcAddress(v59, "FindExecutableImage");
    v61 = 0;
    *FindExecutableImage = v60;
    if ( v60 )
      v61 = Proxy_FindExecutableImageExW;
    pfnFindExecutableImageExW = v61;
  }
  v62 = GetModuleHandle(L"ntdll.dll");
  NtSuspendProcess = GetProcAddress(v62, "NtSuspendProcess");
  v63 = GetModuleHandle(L"ntdll.dll");
  NtResumeProcess = GetProcAddress(v63, "NtResumeProcess");
  v64 = GetModuleHandle(L"kernel32.dll");
  QueryProcessCycleTime = GetProcAddress(v64, "QueryProcessCycleTime");
  v65 = GetModuleHandle(L"kernel32.dll");
  QueryIdleProcessorCycleTime = GetProcAddress(v65, "QueryIdleProcessorCycleTime");
  v66 = GetModuleHandle(L"kernel32.dll");
  QueryThreadCycleTime = GetProcAddress(v66, "QueryThreadCycleTime");
  v67 = GetModuleHandle(L"Shell32.dll");
  SHGetStockIconInfo = GetProcAddress(v67, "SHGetStockIconInfo");
  v68 = GetModuleHandle(L"kernel32.dll");
  *CreateJobObjectW = GetProcAddress(v68, "CreateJobObjectW");
  v69 = GetModuleHandle(L"user32.dll");
  ChangeWindowMessageFilter = GetProcAddress(v69, "ChangeWindowMessageFilter");
  v70 = LoadLibraryW(L"advapi32.dll");
  I_QueryTagInformation = GetProcAddress(v70, "I_QueryTagInformation");
  v71 = LoadLibraryW(L"wow64cpu");
  CpuGetContext = GetProcAddress(v71, "CpuGetContext");
  v72 = LoadLibraryW(L"kernel32.dll");
  GetProcessorSystemCycleTime = GetProcAddress(v72, "GetProcessorSystemCycleTime");
  v73 = LoadLibraryW(L"kernel32.dll");
  GetThreadIdealProcessorEx = GetProcAddress(v73, "GetThreadIdealProcessorEx");
  v74 = LoadLibraryW(L"user32.dll");
  IsImmersiveProcess = GetProcAddress(v74, "IsImmersiveProcess");
  v75 = LoadLibraryW(L"kernel32.dll");
  GetPackageFullName = GetProcAddress(v75, "GetPackageFullName");
  return 1;
}
// 12C3420: using guessed type wchar_t aNtdllNtquerysy[31];
// 12C3480: using guessed type wchar_t aNtdllNtquerysy_0[32];
// 12C34D8: using guessed type wchar_t aNtdllNtquerydi[29];
// 12C3530: using guessed type wchar_t aNtdllNtopensym[31];
// 12C3588: using guessed type wchar_t aNtdllNtopendir[28];
// 12C35D0: using guessed type wchar_t aNtdllNtqueryob[20];
// 12C3618: using guessed type wchar_t aNtdllNtqueryin[32];
// 12C3670: using guessed type wchar_t aNtdllNtsetinfo[30];
// 12C36C0: using guessed type wchar_t aNtdllNtqueryse[23];
// 12C3700: using guessed type wchar_t aNtdllNtqueryse_0[21];
// 12C373C: using guessed type wchar_t aNtdllNtqueryev[19];
// 12C3774: using guessed type wchar_t aNtdllNtquerymu[20];
// 12C37AC: using guessed type wchar_t aNtdllNtresumet[21];
// 12C37E8: using guessed type wchar_t aNtdllNtsuspend[22];
// 12C3824: using guessed type wchar_t aNtdllNtopenthr[19];
// 12C3868: using guessed type wchar_t aNtdllNtqueryin_0[31];
// 12C38C0: using guessed type wchar_t aNtdllNtqueryvi[27];
// 12C3918: using guessed type wchar_t aNtdllRtlcreate[32];
// 12C3978: using guessed type wchar_t aNtdllRtlqueryp[38];
// 12C39E0: using guessed type wchar_t aNtdllRtldestro[33];
// 12C3A38: using guessed type wchar_t aNtdllRtltimeto[26];
// 12C3AC8: using guessed type wchar_t aAcleditSeddisc[34];
// 12C3B20: using guessed type wchar_t aAcleditSedsyst[27];
// 12C3B6C: using guessed type wchar_t aAcleditSedtake[25];
// 12EB1C8: using guessed type int (__stdcall *NtSetInformationProcess)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EB204: using guessed type int (__stdcall *I_QueryTagInformation)(_DWORD, _DWORD, _DWORD);
// 12EF210: using guessed type int (__stdcall *NtOpenSymbolicLinkObject)(_DWORD, _DWORD, _DWORD);
// 12EF214: using guessed type int NtOpenDirectoryObject;
// 12EF21C: using guessed type int (__stdcall *NtQuerySymbolicLinkObject)(_DWORD, _DWORD, _DWORD);
// 12EF220: using guessed type int RtlTimeToTimeFields;
// 12EF224: using guessed type int NtQueryDirectoryObject;
// 12EF228: using guessed type int (__stdcall *NtQuerySemaphore)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF22C: using guessed type int (__stdcall *NtQuerySection)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF230: using guessed type int (__stdcall *NtQueryEvent)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF234: using guessed type int (__stdcall *NtQueryMutant)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF23C: using guessed type int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF240: using guessed type int (__stdcall *NtQueryVirtualMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF244: using guessed type int (__stdcall *NtSuspendThread)(_DWORD, _DWORD);
// 12EF248: using guessed type int (__stdcall *NtResumeThread)(_DWORD, _DWORD);
// 12EF24C: using guessed type int (__stdcall *NtSuspendProcess)(_DWORD);
// 12EF250: using guessed type int (__stdcall *NtResumeProcess)(_DWORD);
// 12EF254: using guessed type int (__stdcall *NtOpenThread)(_DWORD, _DWORD, _DWORD, _DWORD);
// 12EF258: using guessed type int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD);
// 12EF25C: using guessed type int (__stdcall *RtlCreateQueryDebugBuffer)(_DWORD, _DWORD);
// 12EF260: using guessed type int (__stdcall *RtlQueryProcessDebugInformation)(_DWORD, _DWORD, _DWORD);
// 12EF264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 12EF268: using guessed type int (__stdcall *SedDiscretionaryAclEditor)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF270: using guessed type int (__stdcall *SedSystemAclEditor)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF2DC: using guessed type int (__stdcall *pfnFindExecutableImageExW)(_DWORD, _DWORD, _DWORD);
// 12EF2E0: using guessed type int (__stdcall *QueryProcessCycleTime)(_DWORD, _DWORD);
// 12EF2F8: using guessed type int (__stdcall *AllocateAndGetTcpExTableFromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF2FC: using guessed type int (__stdcall *AllocateAndGetUdpExTableFromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF300: using guessed type int (__stdcall *AllocateAndGetUdpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF304: using guessed type int (__stdcall *AllocateAndGetTcpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF32C: using guessed type int SetThreadGroupAffinity;
// 12EF334: using guessed type int (__stdcall *WTSDisconnectSession)(_DWORD, _DWORD, _DWORD);
// 12EF33C: using guessed type int (__stdcall *WinStationShadow)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF34C: using guessed type int (__stdcall *WTSLogoffSession)(_DWORD, _DWORD, _DWORD);
// 12EF350: using guessed type int (__stdcall *WTSSendMessageW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF354: using guessed type int (__stdcall *WTSFreeMemory)(_DWORD);
// 12EF360: using guessed type int (__stdcall *ChangeWindowMessageFilter)(_DWORD, _DWORD);
// 12EF364: using guessed type int CpuGetContext;
// 12EF368: using guessed type int (__stdcall *GetPackageFullName)(_DWORD, _DWORD, _DWORD);
// 12EF36C: using guessed type int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD);
// 12EF380: using guessed type int (__stdcall *HungWindowFromGhostWindow)(_DWORD);
// 12FBA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);
// 12FBA50: using guessed type int (__stdcall *SHGetStockIconInfo)(_DWORD, _DWORD, _DWORD);

//----- (012601B0) --------------------------------------------------------
char sub_12601B0()
{
  HMODULE v0; // eax
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  HMODULE v5; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  HMODULE v8; // eax
  HMODULE v9; // eax
  HMODULE v10; // eax

  v0 = GetModuleHandle(L"kernel32.dll");
  *CreateToolhelp32Snapshot_0 = GetProcAddress(v0, "CreateToolhelp32Snapshot");
  if ( !*CreateToolhelp32Snapshot_0 )
    return 0;
  v2 = GetModuleHandle(L"kernel32.dll");
  *Process32FirstW_0 = GetProcAddress(v2, "Process32FirstW");
  if ( !*Process32FirstW_0 )
    return 0;
  v3 = GetModuleHandle(L"kernel32.dll");
  *Process32NextW_0 = GetProcAddress(v3, "Process32NextW");
  if ( !*Process32NextW_0 )
    return 0;
  v4 = GetModuleHandle(L"kernel32.dll");
  *Thread32First_0 = GetProcAddress(v4, "Thread32First");
  if ( !*Thread32First_0 )
    return 0;
  v5 = GetModuleHandle(L"kernel32.dll");
  *Thread32Next_0 = GetProcAddress(v5, "Thread32Next");
  if ( !*Thread32Next_0 )
    return 0;
  v6 = GetModuleHandle(L"kernel32.dll");
  *Module32FirstW_0 = GetProcAddress(v6, "Module32FirstW");
  if ( !*Module32FirstW_0 )
    return 0;
  v7 = GetModuleHandle(L"kernel32.dll");
  *Module32NextW_0 = GetProcAddress(v7, "Module32NextW");
  if ( !*Module32NextW_0 )
    return 0;
  v8 = LoadLibraryW(L"dbghelp.dll");
  *ImageNtHeader = GetProcAddress(v8, "ImageNtHeader");
  if ( !*ImageNtHeader )
  {
    v9 = LoadLibraryW(L"imagehlp.dll");
    *ImageNtHeader = GetProcAddress(v9, "ImageNtHeader");
  }
  v10 = LoadLibraryW(L"user32.dll");
  IsHungThread = GetProcAddress(v10, "IsHungThread");
  return 1;
}
// 12EF320: using guessed type int IsHungThread;

//----- (012602C0) --------------------------------------------------------
void __cdecl sub_12602C0(HANDLE hProcess, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // eax
  wchar_t **v7; // edi
  LPCWSTR *v8; // esi
  wchar_t **v9; // ebx
  wchar_t *v10; // eax
  int pBuffer; // [esp+0h] [ebp-20h]
  LPCVOID lpBaseAddress[4]; // [esp+4h] [ebp-1Ch]
  __int64 v13; // [esp+14h] [ebp-Ch]
  int v14; // [esp+1Ch] [ebp-4h]

  v6 = a6;
  pBuffer = 0;
  v13 = 0i64;
  v14 = 0;
  _mm_storeu_si128(lpBaseAddress, 0i64);
  if ( v6 )
    *v6 = 0;
  v7 = a3;
  if ( a3 )
    *a3 = 0;
  v8 = a4;
  if ( a4 )
    *a4 = 0;
  v9 = a5;
  if ( a5 )
    *a5 = 0;
  if ( hProcess )
  {
    pBuffer = 32;
    if ( !NtQueryInformationProcess(hProcess, 0, &pBuffer, 0x20u, &a3)
      || !NtQueryInformationProcess(hProcess, 0, lpBaseAddress, 0x18u, &a3) )
    {
      if ( a6 )
        *a6 = v14 & 1;
      if ( lpBaseAddress[1] )
        sub_125B930(hProcess, lpBaseAddress[1], v7, v8, v9);
      if ( v8 )
      {
        if ( *v8 )
          sub_125C350(v8);
        else
          *v8 = _wcsdup(gpszTargetName);
      }
      if ( v7 && !*v7 )
        *v7 = _wcsdup(gpszTargetName);
      if ( v9 )
      {
        if ( !*v9 )
        {
          v10 = _wcsdup(L" ");
          *v9 = v10;
          *v10 = 0;
        }
      }
    }
  }
}

//----- (012603E0) --------------------------------------------------------
char __cdecl sub_12603E0(HANDLE hProcess, int a2, int a3, int a4, int a5)
{
  HANDLE v5; // ebx
  HANDLE v6; // ebx
  const wchar_t *v7; // eax
  WCHAR *v8; // edi
  DWORD v9; // eax
  DWORD v10; // ebx
  size_t v12; // edi
  WCHAR *v13; // esi
  void *v14; // edi
  int v15; // ebx
  CAtlStringMgr *v16; // eax
  volatile signed __int32 *v17; // edi
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+10h] [ebp-474h]
  WCHAR *v19; // [esp+2Ch] [ebp-458h]
  DWORD *v20; // [esp+30h] [ebp-454h]
  WCHAR *v21; // [esp+34h] [ebp-450h]
  wchar_t *v22; // [esp+38h] [ebp-44Ch]
  _DWORD *v23; // [esp+3Ch] [ebp-448h]
  wchar_t *v24; // [esp+40h] [ebp-444h]
  size_t SizeInWords; // [esp+44h] [ebp-440h]
  HANDLE v26; // [esp+48h] [ebp-43Ch]
  MODULEENTRY32W me; // [esp+4Ch] [ebp-438h]
  int v28; // [esp+480h] [ebp-4h]

  v5 = hProcess;
  v22 = a3;
  v23 = a4;
  v20 = a5;
  v26 = hProcess;
  v24 = a2;
  if ( *CreateToolhelp32Snapshot_0 )
  {
    v6 = CreateToolhelp32Snapshot_0(8u, a2);
    v26 = v6;
    if ( v6 != -1 )
    {
      me.dwSize = 1064;
      if ( Module32FirstW_0(v6, &me) )
      {
        do
        {
          v28 = 0;
          if ( !wcsncmp(me.szExePath, L"\\??\\", 4u) )
          {
            v7 = &me.szExePath[4];
          }
          else
          {
            if ( !_wcsnicmp(me.szExePath, L"\\Systemroot\\", 0xCu) )
            {
              SizeInWords = ExpandEnvironmentStringsW(L"%SystemRoot%", 0, 0) + 1 + wcslen(me.szExePath);
              v8 = malloc(2 * SizeInWords);
              v21 = v8;
              ExpandEnvironmentStringsW(L"%SystemRoot%", v8, SizeInWords);
              wcscat_s(v8, SizeInWords, &me.szExePath[11]);
              goto LABEL_10;
            }
            v7 = me.szExePath;
          }
          v8 = _wcsdup(v7);
          v21 = v8;
LABEL_10:
          if ( *GetLongPathNameW )
          {
            v9 = GetLongPathNameW(v8, 0, 0);
            v10 = v9;
            if ( v9 )
            {
              v19 = malloc(2 * v9 + 2);
              LOBYTE(v28) = 1;
              GetLongPathNameW(v8, v19, v10 + 1);
              free(v8);
              v8 = v19;
              LOBYTE(v28) = 0;
              j__free(0);
            }
            v6 = v26;
          }
          if ( me.th32ProcessID == v24 && !_wcsicmp(v22, v8) )
          {
            *v23 = me.modBaseAddr;
            *v20 = me.modBaseSize;
            j__free(v8);
            return 1;
          }
          v28 = -1;
          j__free(v8);
        }
        while ( Module32NextW_0(v6, &me) );
      }
      CloseHandle(v6);
    }
    return 0;
  }
  Buffer.BaseAddress = 0;
  if ( !VirtualQueryEx(hProcess, 0, &Buffer, 0x1Cu) )
    return 0;
  while ( 1 )
  {
    if ( Buffer.Type != 0x40000 || NtQueryVirtualMemory(v5, Buffer.BaseAddress, 2, 0, 0, &SizeInWords) != -1073741820 )
      goto LABEL_30;
    v12 = SizeInWords;
    v13 = malloc(SizeInWords);
    v19 = v13;
    v28 = 2;
    if ( !NtQueryVirtualMemory(v5, Buffer.BaseAddress, 2, v13, v12, &SizeInWords) )
      break;
LABEL_29:
    v28 = -1;
    j__free(v13);
LABEL_30:
    Buffer.BaseAddress = Buffer.BaseAddress + Buffer.RegionSize;
    if ( !VirtualQueryEx(v5, Buffer.BaseAddress, &Buffer, 0x1Cu) )
      return 0;
  }
  v14 = *(v13 + 1);
  v15 = *v13 >> 1;
  v16 = ATL::CAtlStringMgr::GetInstance();
  sub_122CF80(&v24, v14, v15, v16);
  v17 = (v24 - 8);
  if ( _wcsicmp(v24, v22) )
  {
    if ( _InterlockedDecrement(v17 + 3) <= 0 )
      (*(**v17 + 4))(v17);
    v5 = v26;
    goto LABEL_29;
  }
  *v23 = Buffer.BaseAddress;
  *v20 = Buffer.RegionSize;
  if ( _InterlockedDecrement(v17 + 3) <= 0 )
    (*(**v17 + 4))(v17);
  j__free(v13);
  return 1;
}
// 12EF240: using guessed type int (__stdcall *NtQueryVirtualMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (012607B0) --------------------------------------------------------
DWORD __usercall sub_12607B0@<eax>(DWORD edi0@<edi>, CHAR *a1)
{
  CHAR *v2; // edi
  DWORD v3; // esi
  unsigned int v4; // esi
  const CHAR *v5; // ebx
  const wchar_t **v6; // eax
  int v7; // eax
  int v8; // ebx
  HANDLE v9; // edi
  HANDLE v10; // eax
  DWORD result; // eax
  HANDLE v12; // eax
  __int64 v13; // rax
  HANDLE v14; // eax
  CHAR *v15; // ST14_4
  HANDLE v16; // eax
  BOOL v17; // eax
  HANDLE v18; // eax
  DWORD v19; // [esp-8h] [ebp-73Ch]
  int v20; // [esp+0h] [ebp-734h]
  int v21; // [esp+4h] [ebp-730h]
  LPSTR Name; // [esp+8h] [ebp-72Ch]
  DWORD64 BaseOfDll; // [esp+Ch] [ebp-728h]
  __int16 Buffer[260]; // [esp+14h] [ebp-720h]
  __int16 FileName[260]; // [esp+21Ch] [ebp-518h]
  __int16 Dst[260]; // [esp+424h] [ebp-310h]
  struct _IMAGEHLP_SYMBOL Symbol; // [esp+62Ch] [ebp-108h]

  Name = a1;
  if ( !*SymCleanup || !*SymInitialize || !Hook_SymLoadModuleExW || !*SymGetSymFromName )
    return 0;
  v19 = edi0;
  HIDWORD(BaseOfDll) = 1000;
  v2 = malloc(0x3E8u);
  if ( NtQuerySystemInformation(SystemGlobalFlag|0x2, v2, 0x3E8u, &BaseOfDll + 1) )
  {
    do
    {
      HIDWORD(BaseOfDll) += 1000;
      free(v2);
      v3 = HIDWORD(BaseOfDll);
      v2 = malloc(HIDWORD(BaseOfDll));
    }
    while ( NtQuerySystemInformation(SystemGlobalFlag|0x2, v2, v3, &BaseOfDll + 1) );
  }
  if ( IsProcessorFeaturePresent_0(v19) )
    tcscpy_s(Dst, 0x104u, L"ntkrnlpa.exe");
  else
    tcscpy_s(Dst, 0x104u, L"ntoskrnl.exe");
  v4 = 0;
  if ( *v2 )
  {
    v5 = v2 + 32;
    while ( 1 )
    {
      v6 = sub_1259EA0(&v21, v5);
      LODWORD(BaseOfDll) = wcsstr(*v6, Dst);
      v7 = v21 - 16;
      v20 = v21 - 16;
      if ( _InterlockedDecrement((v21 - 16 + 12)) <= 0 )
        (*(**v7 + 4))(v20);
      if ( BaseOfDll )
        break;
      ++v4;
      v5 += 284;
      if ( v4 >= *v2 )
        goto LABEL_16;
    }
    v8 = *&v2[284 * v4 + 12];
  }
  else
  {
LABEL_16:
    v8 = BaseOfDll;
  }
  free(v2);
  GetSystemDirectoryW(Buffer, 0x104u);
  stprintf(FileName, L"%s\\%s", Buffer, Dst);
  v9 = CreateFile(FileName, 0x80000000, 3u, 0, 3u, 0, 0);
  EnterCriticalSection(&gStrListLock);
  v10 = GetCurrentThread();
  if ( SymInitialize(v10, 0, 0) )
  {
    v12 = GetCurrentThread();
    LODWORD(v13) = Hook_SymLoadModuleExW(v12, v9, Dst, 0, v8, 0);
    if ( v13 )
    {
      Symbol.SizeOfStruct = 24;
      v15 = Name;
      Symbol.MaxNameLength = 237;
      v16 = GetCurrentThread();
      v17 = SymGetSymFromName(v16, v15, &Symbol);
      Symbol.Address &= -(v17 != 0);
      CloseHandle(v9);
      v18 = GetCurrentThread();
      SymCleanup(v18);
      LeaveCriticalSection(&gStrListLock);
      result = Symbol.Address;
    }
    else
    {
      CloseHandle(v9);
      v14 = GetCurrentThread();
      SymCleanup(v14);
      LeaveCriticalSection(&gStrListLock);
      result = 0;
    }
  }
  else
  {
    LeaveCriticalSection(&gStrListLock);
    CloseHandle(v9);
    result = 0;
  }
  return result;
}
// 12607B0: could not find valid save-restore pair for edi
// 12607B0: could not find valid save-restore pair for esi
// 12C56FC: using guessed type wchar_t aNtkrnlpaExe[13];

//----- (01260A90) --------------------------------------------------------
char __cdecl sub_1260A90(HANDLE hProcess, int a2, int a3, int a4)
{
  DWORD v4; // eax
  LPBYTE v5; // ecx
  SC_HANDLE v7; // ebx
  DWORD v8; // esi
  wchar_t *v9; // eax
  LPWSTR v10; // eax
  LPWSTR v11; // ecx
  int v12; // edx
  WCHAR v13; // ax
  rsize_t v14; // edi
  wchar_t *v15; // eax
  const wchar_t **v16; // esi
  DWORD v17; // eax
  DWORD v18; // edi
  WCHAR *v19; // eax
  DWORD v20; // eax
  DWORD v21; // esi
  WCHAR *v22; // eax
  const wchar_t *v23; // ecx
  wchar_t v24; // ax
  struct _QUERY_SERVICE_CONFIGW *v25; // [esp+Ch] [ebp-21Ch]
  WCHAR Filename[2]; // [esp+14h] [ebp-214h]
  DWORD pcbBytesNeeded; // [esp+18h] [ebp-210h]
  WCHAR Src; // [esp+1Ch] [ebp-20Ch]

  *Filename = a3;
  *a3 = 0;
  if ( !hProcess )
  {
    if ( *(a4 + 40) & 0x20 )
    {
      v4 = 0;
      if ( gdwServiceNameBufferRealSize )
      {
        v5 = gstrServiceNameBuffer + 36;
        while ( *v5 != a2 )
        {
          ++v4;
          v5 += 44;
          if ( v4 >= gdwServiceNameBufferRealSize )
            return 0;
        }
        v7 = OpenServiceW(ghSCManager, *&gstrServiceNameBuffer[0x2C * v4], 5u);
        QueryServiceConfigW(v7, 0, 0, &pcbBytesNeeded);
        v8 = pcbBytesNeeded;
        v25 = malloc(pcbBytesNeeded);
        QueryServiceConfigW(v7, v25, v8, &pcbBytesNeeded);
        if ( v25->lpBinaryPathName )
        {
          if ( !*(a4 + 800) )
            *(a4 + 800) = _wcsdup(v25->lpBinaryPathName);
          v9 = wcsstr(v25->lpBinaryPathName, L".exe");
          if ( v9 && v9[4] )
            v9[4] = 0;
          v10 = v25->lpBinaryPathName;
          if ( *v10 == 34 )
            v25->lpBinaryPathName = v10 + 1;
          v11 = v25->lpBinaryPathName;
          v12 = (v11 + 1);
          do
          {
            v13 = *v11;
            ++v11;
          }
          while ( v13 );
          v14 = ((v11 - v12) >> 1) + 5;
          v15 = malloc(2 * v14);
          v16 = *Filename;
          **Filename = v15;
          tcscpy_s(v15, v14, v25->lpBinaryPathName);
          free(v25);
          if ( GetFileAttributesW(*v16) == -1 )
          {
            if ( **v16 != 34 && wcschr(*v16, 0x20u) )
              *wcschr(*v16, 0x20u) = 0;
            if ( GetFileAttributesW(*v16) == -1 )
              wcscat_s(*v16, v14, L".exe");
          }
          return 1;
        }
        free(v25);
      }
    }
    return 0;
  }
  if ( !sub_125CF30(hProcess, a3) )
  {
    v17 = GetModuleFileNameExW(hProcess, 0, Filename, 2u);
    v18 = v17;
    if ( !v17 )
      return 0;
    v19 = malloc(2 * v17 + 2);
    *a3 = v19;
    if ( !GetModuleFileNameExW(hProcess, 0, v19, v18) )
      return 0;
  }
  if ( !_wcsnicmp(*a3, L"\\SystemRoot\\", 0xCu) )
  {
    stprintf(&Src, L"%%SystemRoot%%\\%s", *a3 + 24);
    v20 = ExpandEnvironmentStringsW(&Src, 0, 0);
    v21 = v20;
    v22 = malloc(2 * v20);
    *a3 = v22;
    ExpandEnvironmentStringsW(&Src, v22, v21);
    return 1;
  }
  if ( !wcsncmp(*a3, L"\\??\\", 4u) )
  {
    v23 = *a3;
    do
    {
      v24 = *v23;
      ++v23;
    }
    while ( v24 );
    tcscpy_s(*a3, (v23 - *a3 - 2) >> 1, (*a3 + 8));
  }
  return 1;
}

//----- (01260D70) --------------------------------------------------------
StrNode *__cdecl StrInList(wchar_t *str)
{
  StrNode *ppstr; // esi
  StrNode *result; // eax

  EnterCriticalSection(&gStrListLock);
  ppstr = gStrList;
  if ( gStrList )
  {
    while ( _wcsicmp(ppstr->strText, str) )
    {
      ppstr = ppstr->pNext;
      if ( !ppstr )
        goto LABEL_4;
    }
    LeaveCriticalSection(&gStrListLock);
    result = ppstr;
  }
  else
  {
LABEL_4:
    LeaveCriticalSection(&gStrListLock);
    result = 0;
  }
  return result;
}
// 12EB1DC: using guessed type int gStrList;

//----- (01260DD0) --------------------------------------------------------
void __cdecl sub_1260DD0(wchar_t *a1)
{
  int v1; // edi
  wchar_t *v2; // ebx
  __int16 *v3; // ecx
  size_t v4; // esi
  int v5; // edx
  unsigned int v6; // ecx
  __int16 *v7; // esi
  __int16 v8; // ax
  int v9; // esi
  __int16 *v10; // edx
  int v11; // esi
  int v12; // edi
  __int16 v13; // ax

  v1 = 0;
  if ( gszDeviceHarddi_0[0] )
  {
    v2 = a1;
    v3 = gszDeviceHarddi_0;
    while ( 1 )
    {
      v4 = wcslen(v3);
      if ( !_wcsnicmp(v3, v2, v4) && v2[v4] == 92 )
        break;
      v3 = &gszDeviceHarddi_0[257 * ++v1];
      if ( !gszDeviceHarddi_0[257 * v1] )
        return;
    }
    v5 = 257 * v1;
    *v2 = gstrDriverSymLinkName[257 * v1];
    v2[1] = 58;
    v6 = wcslen(v2);
    v7 = &gszDeviceHarddi_0[257 * v1 + 1];
    do
    {
      v8 = *v7;
      ++v7;
    }
    while ( v8 );
    v9 = v7 - &gszDeviceHarddi_0[v5 + 2];
    v10 = &gszDeviceHarddi_0[v5];
    v11 = v9 >> 1;
    v12 = (v10 + 1);
    do
    {
      v13 = *v10;
      ++v10;
    }
    while ( v13 );
    memmove_0(v2 + 2, &v2[(v10 - v12) >> 1], 2 * (v6 - v11));
    sub_125C270(&a1, 0x104u);
  }
}

//----- (01260EE0) --------------------------------------------------------
int __cdecl sub_1260EE0(wchar_t *Dst)
{
  int v1; // ebx
  size_t *v2; // esi
  int v3; // ebx
  REGUSERINFO *v4; // esi
  int result; // eax
  int v6; // eax
  char v7; // cl
  wchar_t *v8; // esi
  wchar_t i; // ax
  const wchar_t *v10; // esi
  char v11; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  v2 = &gstrRegistryUser[0].dwValue;
  do
  {
    if ( !_wcsnicmp(Dst, v2 - 288, *v2) && !_wcsnicmp(&Dst[*v2], gstrSidIndentityInfo, wcslen(gstrSidIndentityInfo)) )
    {
      v6 = _wcsnicmp(&Dst[wcslen(gstrSidIndentityInfo) + gstrRegistryUser[v1].dwValue], L"_Classes", 8u);
      v7 = 0;
      if ( !v6 )
        v7 = 1;
      v11 = v7;
      v8 = &Dst[gstrRegistryUser[v1].dwValue];
      for ( i = *v8; i; ++v8 )
      {
        if ( i == 92 )
          break;
        i = v8[1];
      }
      tcscpy_s(Dst, v8 - Dst, gstrRegistryUser[v1].szKey);
      if ( v11 )
        wcscat_s(Dst, v8 - Dst, L"\\Software\\Classes");
      return wcscat_s(Dst, 0x400u, v8);
    }
    v2 += 145;
    ++v1;
  }
  while ( v2 < &gstrRegistryUser[2].dwValue );
  v3 = 0;
  v4 = &gstrRegistryUser[2];
  while ( 1 )
  {
    result = _wcsnicmp(Dst, v4->szKeyName, v4->dwValue);
    if ( !result )
      break;
    ++v4;
    ++v3;
    if ( v4 >= &dword_12E10B8 )
      return result;
  }
  v10 = &Dst[gstrRegistryUser[v3 + 2].dwValue];
  tcscpy_s(Dst, (2 * gstrRegistryUser[v3 + 2].dwValue) >> 1, gstrRegistryUser[v3 + 2].szKey);
  return wcscat_s(Dst, 0x400u, v10);
}
// 12E10B8: using guessed type int dword_12E10B8;

//----- (01261080) --------------------------------------------------------
char __cdecl ErrMsxBox(int ArgList)
{
  WCHAR Text; // [esp+0h] [ebp-20Ch]

  stprintf(&Text, L"Not able to run on this version of Windows:\nMissing function: %s", ArgList);
  MessageBoxW(0, &Text, L"Process Explorer", 0x10u);
  return 0;
}

//----- (012610E0) --------------------------------------------------------
signed int __stdcall HanldeInfoDlgProc(HWND hWnd, int a3, unsigned __int16 a4, int a5)
{
  HWND v5; // eax
  DWORD v6; // esi
  const WCHAR *v7; // ebx
  bool v8; // cl
  const WCHAR *v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  const wchar_t *v14; // eax
  const wchar_t *v15; // eax
  int v16; // eax
  void (__stdcall *v17)(HANDLE); // ebx
  const wchar_t *v18; // eax
  int v19; // eax
  HWND v20; // eax
  HWND v21; // eax
  HWND v22; // eax
  int v23; // [esp+8h] [ebp-6C8h]
  int v24; // [esp+10h] [ebp-6C0h]
  int v25; // [esp+14h] [ebp-6BCh]
  int v26; // [esp+24h] [ebp-6ACh]
  int v27; // [esp+28h] [ebp-6A8h]
  char v28[4]; // [esp+2Ch] [ebp-6A4h]
  int v29; // [esp+30h] [ebp-6A0h]
  int v30; // [esp+34h] [ebp-69Ch]
  struct _FILETIME LocalFileTime; // [esp+38h] [ebp-698h]
  FILETIME FileTime; // [esp+40h] [ebp-690h]
  int v33; // [esp+48h] [ebp-688h]
  int v34; // [esp+4Ch] [ebp-684h]
  int v35; // [esp+50h] [ebp-680h]
  char v36; // [esp+55h] [ebp-67Bh]
  struct tagPOINT Point; // [esp+58h] [ebp-678h]
  char v38[4]; // [esp+60h] [ebp-670h]
  char v39[4]; // [esp+64h] [ebp-66Ch]
  ULONG ReturnLength; // [esp+68h] [ebp-668h]
  int v41; // [esp+6Ch] [ebp-664h]
  char v42[4]; // [esp+70h] [ebp-660h]
  void *OutBuffer; // [esp+74h] [ebp-65Ch]
  DWORD BytesReturned; // [esp+78h] [ebp-658h]
  int v45; // [esp+7Ch] [ebp-654h]
  HANDLE InBuffer; // [esp+80h] [ebp-650h]
  int ObjectInformation; // [esp+84h] [ebp-64Ch]
  int v48; // [esp+8Ch] [ebp-644h]
  int v49; // [esp+90h] [ebp-640h]
  char ArgList[4]; // [esp+94h] [ebp-63Ch]
  char v51[4]; // [esp+98h] [ebp-638h]
  FILETIME v52; // [esp+B4h] [ebp-61Ch]
  struct _SYSTEMTIME SystemTime; // [esp+BCh] [ebp-614h]
  char v54; // [esp+CCh] [ebp-604h]
  wchar_t Dst; // [esp+2CCh] [ebp-404h]
  WCHAR String; // [esp+4CCh] [ebp-204h]

  if ( a3 == 16 )
    goto LABEL_5;
  if ( a3 == 272 )
  {
    GetCursorPos(&Point);
    v5 = GetParent(hWnd);
    sub_125BDA0(v5);
    SetPropSheetRect(hWnd, Point.x - 375, Point.y - 430);
    PostMessageW(hWnd, 0x46Bu, 0, 0);
    v6 = *(a5 + 28);
    BytesReturned = v6;
    v7 = (v6 + 56);
    v8 = !_wcsicmp((v6 + 56), L"Mutant")
      || !_wcsicmp((v6 + 56), L"Section")
      || !_wcsicmp((v6 + 56), L"Event")
      || !_wcsicmp((v6 + 56), L"Semaphore");
    InBuffer = DuplicateProcessHandle(*(v6 + 36), *(v6 + 44), v8 != 0);
    if ( !InBuffer )
    {
      if ( *(v6 + 16) == 1 )
        MessageBoxW(ghWndNewOwner, L"Object does not exist.", L"Object Properties Error", 0x10u);
      else
        MessageBoxW(ghWndNewOwner, L"Unable to query the object", L"Object Properties Error", 0x10u);
      v21 = GetParent(hWnd);
      EndDialog(v21, 0);
      v22 = GetParent(hWnd);
      PostMessageW(v22, 0x471u, 5u, 0);
      return 0;
    }
    v9 = (v6 + 2232);
    VLogEntry(&String, L"%s Properties", v9);
    SetWindowTextW(hWnd, &String);
    SetDlgItemTextW(hWnd, 1005, v9);
    SetDlgItemTextW(hWnd, 1006, v7);
    if ( _wcsicmp(v7, L"file") )
    {
      if ( _wcsicmp(v7, L"directory") )
      {
        if ( _wcsicmp(v7, L"symboliclink") )
        {
          if ( _wcsicmp(v7, L"key") )
          {
            if ( _wcsicmp(v7, L"process") )
            {
              v10 = wcscmp(v7, L"thread");
              if ( v10 )
                v10 = -(v10 < 0) | 1;
              if ( v10 )
              {
                if ( _wcsicmp(v7, L"iocompletion") )
                {
                  if ( _wcsicmp(v7, L"mutant") )
                  {
                    if ( _wcsicmp(v7, L"event") && _wcsicmp(v7, L"semaphore") )
                    {
                      if ( _wcsicmp(v7, L"windowstation") )
                      {
                        if ( _wcsicmp(v7, L"desktop") )
                        {
                          if ( _wcsicmp(v7, L"port") && _wcsicmp(v7, L"waitableport") )
                          {
                            if ( _wcsicmp(v7, L"section") )
                            {
                              if ( _wcsicmp(v7, L"token") )
                              {
                                if ( !_wcsicmp(v7, L"timer") )
                                  SetDlgItemTextW(hWnd, 1050, L"A time-based synchronization object.");
                              }
                              else
                              {
                                SetDlgItemTextW(hWnd, 1050, L"Identifies a security context.");
                              }
                            }
                            else
                            {
                              SetDlgItemTextW(hWnd, 1050, L"A memory mapped file or paging-file backed memory region.");
                            }
                          }
                          else
                          {
                            SetDlgItemTextW(hWnd, 1050, L"An interprocess communications endpoint.");
                          }
                        }
                        else
                        {
                          SetDlgItemTextW(hWnd, 1050, L"Contains application windows.");
                        }
                      }
                      else
                      {
                        SetDlgItemTextW(hWnd, 1050, L"Contains one or more desktops with windows.");
                      }
                    }
                    else
                    {
                      SetDlgItemTextW(hWnd, 1050, L"A synchronization object.");
                    }
                  }
                  else
                  {
                    SetDlgItemTextW(hWnd, 1050, L"A synchronization object (a Win32 mutex).");
                  }
                }
                else
                {
                  SetDlgItemTextW(hWnd, 1050, L"An asynchronous I/O notification object.");
                }
              }
              else
              {
                SetDlgItemTextW(hWnd, 1050, L"An object that executes program code.");
              }
            }
            else
            {
              SetDlgItemTextW(hWnd, 1050, L"Contains threads, an address space, and handles.");
            }
          }
          else
          {
            SetDlgItemTextW(hWnd, 1050, L"A Registry key.");
          }
        }
        else
        {
          SetDlgItemTextW(hWnd, 1050, L"An Object Manager namespace link.");
        }
      }
      else
      {
        SetDlgItemTextW(hWnd, 1050, L"An Object Manager namespace directory.");
      }
    }
    else
    {
      SetDlgItemTextW(hWnd, 1050, L"A disk file, communications endpoint, or driver interface.");
    }
    VLogEntry(&String, L"0x%X", *(BytesReturned + 40));
    SetDlgItemTextW(hWnd, 1051, &String);
    NtQueryObject(InBuffer, 0, &ObjectInformation, 0x38u, &ReturnLength);
    VLogEntry(&String, L"%d", v48 - 1);
    SetDlgItemTextW(hWnd, 1008, &String);
    VLogEntry(&String, L"%d", v49 - 2);
    SetDlgItemTextW(hWnd, 1019, &String);
    VLogEntry(&String, L"%d", *ArgList);
    SetDlgItemTextW(hWnd, 1010, &String);
    VLogEntry(&String, L"%d", *v51);
    SetDlgItemTextW(hWnd, 1013, &String);
    v11 = wcscmp(v7, L"SymbolicLink");
    if ( v11 )
      v11 = -(v11 < 0) | 1;
    if ( !v11 )
    {
      SetDlgItemTextW(hWnd, 1025, L"Symbolic Link Info");
      SetDlgItemTextW(hWnd, 1024, L"Creation Time:");
      FileTime = v52;
      FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      VLogEntry(
        &String,
        L"%d:%02d:%02d, %d/%d/%d",
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wYear);
      SetDlgItemTextW(hWnd, 1022, &String);
      SetDlgItemTextW(hWnd, 1028, L"Link:");
      HIWORD(v41) = 256;
      *v42 = &v54;
      if ( NtQuerySymbolicLinkObject(InBuffer, &v41, &v45) )
        tcscpy_s(&String, 0x100u, L"<Error Querying Link>");
      else
        VLogEntry(&String, L"%s", *v42);
      SetDlgItemTextW(hWnd, 1027, &String);
      goto LABEL_94;
    }
    v12 = wcscmp(v7, L"Semaphore");
    if ( v12 )
      v12 = -(v12 < 0) | 1;
    if ( v12 )
    {
      v13 = wcscmp(v7, L"Event");
      if ( v13 )
        v13 = -(v13 < 0) | 1;
      if ( v13 )
      {
        v16 = wcscmp(v7, L"Mutant");
        if ( v16 )
          v16 = -(v16 < 0) | 1;
        if ( !v16 )
        {
          SetDlgItemTextW(hWnd, 1025, L"Mutant Info");
          SetDlgItemTextW(hWnd, 1024, L"Held:");
          NtQueryMutant(InBuffer, 0, &v35, 8, &v45);
          VLogEntry(&String, L"FALSE");
          if ( v35 <= 0
            && (VLogEntry(&String, L"TRUE"),
                DeviceIoControl(theDriver, 0x8335002C, &InBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0))
            && OutBuffer )
          {
            if ( !NtQueryInformationThread(OutBuffer, 0, &v23, 28, &ReturnLength) )
            {
              sub_1278310(v24, 0, &Dst, 0x100u);
              VLogEntry(&String, L"%s(%d): %d", &Dst, v24, v25);
            }
            v17 = CloseHandle;
            CloseHandle(OutBuffer);
          }
          else
          {
            v17 = CloseHandle;
          }
          SetDlgItemTextW(hWnd, 1022, &String);
          SetDlgItemTextW(hWnd, 1028, L"Abandoned:");
          v18 = L"TRUE";
          if ( !v36 )
            v18 = L"FALSE";
          VLogEntry(&String, L"%s", v18);
          SetDlgItemTextW(hWnd, 1027, &String);
          v17(InBuffer);
          return 1;
        }
        v19 = wcscmp(v7, L"Section");
        if ( v19 )
          v19 = -(v19 < 0) | 1;
        if ( v19 )
        {
          v20 = GetDlgItem(hWnd, 1025);
          ShowWindow(v20, 0);
        }
        else
        {
          SetDlgItemTextW(hWnd, 1025, L"Section Info");
          NtQuerySection(InBuffer, 0, &v26, 16, &v30);
          if ( v27 & 0x1000000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            tcscpy_s(&String, 0x100u, L"IMAGE");
          }
          else if ( v27 & 0x800000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            tcscpy_s(&String, 0x100u, L"FILE");
          }
          else if ( v27 & 0x4000000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            tcscpy_s(&String, 0x100u, L"RESERVED");
          }
          else if ( v27 & 0x8000000 )
          {
            SetDlgItemTextW(hWnd, 1024, L"Type:");
            tcscpy_s(&String, 0x100u, L"COMMITED");
          }
          SetDlgItemTextW(hWnd, 1022, &String);
          SetDlgItemTextW(hWnd, 1028, L"Size:");
          VLogEntry(&String, L"0x%08x", *v28, v29);
          SetDlgItemTextW(hWnd, 1027, &String);
        }
LABEL_94:
        CloseHandle(InBuffer);
        return 1;
      }
      SetDlgItemTextW(hWnd, 1025, L"Event Info");
      SetDlgItemTextW(hWnd, 1024, L"Type:");
      NtQueryEvent(InBuffer, 0, &v33, 8, &v45);
      v14 = L"Notification";
      if ( v33 )
        v14 = L"Synchronization";
      VLogEntry(&String, L"%s", v14);
      SetDlgItemTextW(hWnd, 1022, &String);
      SetDlgItemTextW(hWnd, 1028, L"Signaled:");
      v15 = L"TRUE";
      if ( !v34 )
        v15 = L"FALSE";
      VLogEntry(&String, L"%s", v15);
    }
    else
    {
      SetDlgItemTextW(hWnd, 1025, L"Semaphore Info");
      SetDlgItemTextW(hWnd, 1024, L"Count:");
      NtQuerySemaphore(InBuffer, 0, v38, 8, &v45);
      VLogEntry(&String, L"%d", *v38);
      SetDlgItemTextW(hWnd, 1022, &String);
      SetDlgItemTextW(hWnd, 1028, L"Limit:");
      VLogEntry(&String, L"%d", *v39);
    }
    SetDlgItemTextW(hWnd, 1027, &String);
    goto LABEL_94;
  }
  if ( a3 == 273 && a4 - 1 <= 1 )
  {
LABEL_5:
    DestroyWindow(hWnd);
    return 1;
  }
  return 0;
}
// 12C48C0: using guessed type wchar_t aADiskFileCommu[59];
// 12C4950: using guessed type wchar_t aAnObjectManage[39];
// 12C49C0: using guessed type wchar_t aAnObjectManage_0[34];
// 12C4A0C: using guessed type wchar_t aARegistryKey[16];
// 12C4A30: using guessed type wchar_t aContainsThread[49];
// 12C4A98: using guessed type wchar_t aAnObjectThatEx[38];
// 12C4B00: using guessed type wchar_t aAnAsynchronous[41];
// 12C4B68: using guessed type wchar_t aASynchronizati[42];
// 12C4C30: using guessed type wchar_t aContainsOneOrM[44];
// 12C4C98: using guessed type wchar_t aContainsApplic[30];
// 12C4D00: using guessed type wchar_t aAnInterprocess[41];
// 12C4D68: using guessed type wchar_t aAMemoryMappedF[58];
// 12C4DDC: using guessed type wchar_t aIdentifiesASec[31];
// 12C4E28: using guessed type wchar_t aATimeBasedSync[37];
// 12C4E74: using guessed type wchar_t aSymboliclink_0[13];
// 12C4FA4: using guessed type wchar_t aNotification[13];
// 12C4FC0: using guessed type wchar_t aSynchronizatio[16];
// 12C504C: using guessed type wchar_t aImage_0[6];
// 12C5058: using guessed type wchar_t aFile_2[5];
// 12C5064: using guessed type wchar_t aReserved[9];
// 12C50D8: using guessed type wchar_t aObjectDoesNotE[23];
// 12EF21C: using guessed type int (__stdcall *NtQuerySymbolicLinkObject)(_DWORD, _DWORD, _DWORD);
// 12EF228: using guessed type int (__stdcall *NtQuerySemaphore)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF22C: using guessed type int (__stdcall *NtQuerySection)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF230: using guessed type int (__stdcall *NtQueryEvent)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF234: using guessed type int (__stdcall *NtQueryMutant)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF23C: using guessed type int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (01261C00) --------------------------------------------------------
int __stdcall SecurityPageProc(HWND hWnd, DWORD nLengthNeeded, DWORD pSIRequested, int a4)
{
  int result; // eax
  HWND v5; // edi
  HWND v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  char v11; // al
  HANDLE v12; // esi
  HWND v13; // eax
  unsigned int v14; // edx
  const unsigned __int16 *v15; // ebx
  __int16 *v16; // ecx
  __int16 v17; // ax
  __int16 *v18; // esi
  __int16 v19; // ax
  unsigned int v20; // edx
  HWND hWnda; // [esp+8h] [ebp+8h]

  if ( nLengthNeeded == 272 )
  {
    v5 = hWnd;
    PostMessageW(hWnd, 0x46Bu, 0, 0);
    dword_12FC038 = *(a4 + 28);
    hWnda = DuplicateProcessHandle(*(dword_12FC038 + 36), *(dword_12FC038 + 44), 0x80000000);
    if ( hWnda )
    {
      byte_12FC083 = 0;
      byte_12FC084 = 0;
      byte_12FC085 = 0;
      byte_12FC082 = 0;
      v7 = wcscmp((dword_12FC038 + 56), L"Directory");
      if ( v7 )
        v7 = -(v7 < 0) | 1;
      if ( v7 )
      {
        v8 = wcscmp((dword_12FC038 + 56), L"Device");
        if ( v8 )
          v8 = -(v8 < 0) | 1;
        if ( v8 )
        {
          v9 = wcscmp((dword_12FC038 + 56), L"Process");
          if ( v9 )
            v9 = -(v9 < 0) | 1;
          if ( v9 )
          {
            v10 = wcscmp((dword_12FC038 + 56), L"Key");
            if ( v10 )
              v10 = -(v10 < 0) | 1;
            v11 = byte_12FC084;
            if ( !v10 )
              v11 = 1;
            byte_12FC084 = v11;
          }
          else
          {
            byte_12FC082 = 1;
          }
        }
        else
        {
          byte_12FC085 = 1;
        }
      }
      else
      {
        byte_12FC083 = 1;
      }
      pSIRequested = 23;
      byte_12FC080 = GetUserObjectSecurity(hWnda, &pSIRequested, pSID, 0x2000u, &nLengthNeeded) != 0;
      CloseHandle(hWnda);
    }
    else
    {
      byte_12FC080 = 0;
      v6 = GetDlgItem(v5, 127);
      EnableWindow(v6, 0);
    }
    v12 = DuplicateProcessHandle(*(dword_12FC038 + 36), *(dword_12FC038 + 44), 0x81000000);
    if ( v12 || (v12 = DuplicateProcessHandle(*(dword_12FC038 + 36), *(dword_12FC038 + 44), 0x1000000u)) != 0 )
    {
      pSIRequested = 9;
      byte_12FC081 = GetUserObjectSecurity(v12, &pSIRequested, off_12E10D0, 0x2000u, &nLengthNeeded) != 0;
      CloseHandle(v12);
    }
    else
    {
      byte_12FC081 = 0;
      v13 = GetDlgItem(v5, 128);
      EnableWindow(v13, 0);
    }
    v14 = 0;
    v15 = (dword_12FC038 + 184);
    v16 = (dword_12FC038 + 184);
    do
    {
      v17 = *v16;
      ++v16;
    }
    while ( v17 );
    if ( (v16 - dword_12FC038 - 186) >> 1 )
    {
      v18 = (dword_12FC038 + 184);
      do
      {
        v19 = *v18;
        ++v18;
        word_12FC088[v14++] = v19;
      }
      while ( v14 < wcslen(v15) );
    }
    v20 = v14;
    if ( v20 >= 1024 )
    {
      __report_rangecheckfailure();
      JUMPOUT(*algn_126224B);
    }
    dword_12FC054 = 257;
    word_12FC088[v20] = 0;
    if ( byte_12FC084 )
    {
      dword_12FC058 = &unk_12E0300;
      dword_12FC05C = &unk_12E0300;
    }
    else
    {
      dword_12FC058 = &unk_12E02F0;
      dword_12FC05C = &unk_12E02F0;
    }
    dword_12FC06C = 0;
    dword_12FC068 = 0;
    dword_12FC070 = 0;
    result = 1;
    dword_12FC060 = aObject_0;
    dword_12FC064 = &szHelpFileName;
    dword_12FC074 = aSpecialAccess;
    return result;
  }
  if ( nLengthNeeded != 273 )
    return 0;
  if ( pSIRequested != 127 )
  {
    if ( pSIRequested == 128 )
    {
      if ( !byte_12FC081 )
      {
        MessageBoxW(0, L"You do not have permission to view the Audit Information for\nthis object.", L"WinObj", 0x10u);
        return 0;
      }
      dword_12FC078 = 7;
      dword_12FC07C = &unk_12E0280;
      dword_12FC040 = *(dword_12FC038 + 44);
      dword_12FC03C = *(dword_12FC038 + 36);
      dword_12FC044 = 1;
      dword_12FC048 = dword_12FBC38;
      dword_12FC04C = off_12E10D0;
      dword_12FC050 = &byte_12FC081;
      if ( SedSystemAclEditor(
             0,
             0,
             0,
             &dword_12FC054,
             &dword_12FC078,
             word_12FC088,
             sub_125A580,
             &dword_12FC03C,
             off_12E10D0,
             0,
             &nLengthNeeded,
             0) )
      {
        MessageBoxW(0, L"The SACL Editor does not understand the Security Information.", L"WinObj", 0x10u);
        return 0;
      }
      return 0;
    }
    if ( pSIRequested == 129 )
    {
      if ( byte_12FC080 )
      {
        dword_12FC040 = *(dword_12FC038 + 44);
        dword_12FC03C = *(dword_12FC038 + 36);
        dword_12FC044 = 2;
        dword_12FC048 = dword_12FBC38;
        dword_12FC04C = pSID;
        dword_12FC050 = &byte_12FC080;
        tcscpy_s(&Dst, 0x400u, L"&Object");
        if ( SedTakeOwnership(
               0,
               0,
               0,
               &Dst,
               word_12FC088,
               1,
               sub_125A580,
               &dword_12FC03C,
               pSID,
               0,
               0,
               &nLengthNeeded,
               &szHelpFileName,
               0) )
        {
          if ( IsValidSecurityDescriptor(pSID) )
          {
            MessageBoxW(0, L"The Ownership Editor does not understand the Security Information.", L"WinObj", 0x10u);
            return 0;
          }
          goto LABEL_10;
        }
        return 0;
      }
      goto LABEL_29;
    }
    return 0;
  }
  if ( !byte_12FC080 )
  {
LABEL_29:
    MessageBoxW(0, L"You do not have permission to view the Security Information for\nthis object.", L"WinObj", 0x10u);
    return 0;
  }
  if ( !byte_12FC083 )
  {
    if ( byte_12FC084 )
    {
      dword_12FC07C = &unk_12E01C0;
    }
    else
    {
      if ( byte_12FC085 )
      {
        dword_12FC078 = 11;
        dword_12FC07C = &unk_12E0110;
        goto LABEL_26;
      }
      if ( byte_12FC082 )
      {
        dword_12FC078 = 14;
        dword_12FC07C = &unk_12DFED0;
        goto LABEL_26;
      }
      dword_12FC07C = &dword_12DFD10;
    }
    dword_12FC078 = 12;
    goto LABEL_26;
  }
  dword_12FC078 = 22;
  dword_12FC07C = &unk_12DFFB0;
LABEL_26:
  dword_12FC040 = *(dword_12FC038 + 44);
  dword_12FC03C = *(dword_12FC038 + 36);
  dword_12FC044 = 0;
  dword_12FC048 = dword_12FBC38;
  dword_12FC04C = pSID;
  dword_12FC050 = &byte_12FC080;
  if ( !SedDiscretionaryAclEditor(
          0,
          0,
          0,
          &dword_12FC054,
          &dword_12FC078,
          word_12FC088,
          sub_125A580,
          &dword_12FC03C,
          pSID,
          0,
          0,
          &nLengthNeeded,
          0) )
    return 0;
  if ( !IsValidSecurityDescriptor(pSID) )
  {
LABEL_10:
    MessageBoxW(0, L"The Security Information is invalid.", L"WinObj", 0x10u);
    return 0;
  }
  MessageBoxW(0, L"The ACL Editor does not understand the Security Information.", L"WinObj", 0x10u);
  return 0;
}
// 12867E8: using guessed type int __report_rangecheckfailure(void);
// 12DFCB8: using guessed type wchar_t aObject_0[7];
// 12DFCE0: using guessed type wchar_t aSpecialAccess[18];
// 12DFD04: using guessed type wchar_t *szHelpFileName;
// 12DFD10: using guessed type int dword_12DFD10;
// 12EF268: using guessed type int (__stdcall *SedDiscretionaryAclEditor)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF270: using guessed type int (__stdcall *SedSystemAclEditor)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12FBC38: using guessed type int dword_12FBC38[256];
// 12FC038: using guessed type int dword_12FC038;
// 12FC03C: using guessed type int dword_12FC03C;
// 12FC040: using guessed type int dword_12FC040;
// 12FC044: using guessed type int dword_12FC044;
// 12FC048: using guessed type int dword_12FC048;
// 12FC04C: using guessed type int dword_12FC04C;
// 12FC050: using guessed type int dword_12FC050;
// 12FC054: using guessed type int dword_12FC054;
// 12FC058: using guessed type int dword_12FC058;
// 12FC05C: using guessed type int dword_12FC05C;
// 12FC060: using guessed type int dword_12FC060;
// 12FC064: using guessed type int dword_12FC064;
// 12FC068: using guessed type int dword_12FC068;
// 12FC06C: using guessed type int dword_12FC06C;
// 12FC070: using guessed type int dword_12FC070;
// 12FC074: using guessed type int dword_12FC074;
// 12FC078: using guessed type int dword_12FC078;
// 12FC07C: using guessed type int dword_12FC07C;
// 12FC080: using guessed type char byte_12FC080;
// 12FC081: using guessed type char byte_12FC081;
// 12FC082: using guessed type char byte_12FC082;
// 12FC083: using guessed type char byte_12FC083;
// 12FC084: using guessed type char byte_12FC084;
// 12FC085: using guessed type char byte_12FC085;

//----- (01262250) --------------------------------------------------------
HANDLE __cdecl DuplicateProcessHandle(DWORD dwProcessId, HANDLE hSourceHandle, DWORD dwDesiredAccess)
{
  DWORD dwPID; // edi
  HANDLE ProcessHandle; // esi
  DWORD v5; // ST14_4
  HANDLE v6; // ST0C_4
  HANDLE v7; // edi
  DWORD v8; // ST14_4
  HANDLE v9; // ST0C_4
  int InBuffer[4]; // [esp+8h] [ebp-20h]
  DWORD v12; // [esp+18h] [ebp-10h]
  DWORD BytesReturned; // [esp+1Ch] [ebp-Ch]
  DWORD InBuffer1; // [esp+20h] [ebp-8h]
  HANDLE OutBuffer; // [esp+24h] [ebp-4h]

  dwPID = dwProcessId;
  OutBuffer = NULL;
  InBuffer1 = dwProcessId;
  ProcessHandle = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
  dwProcessId = ProcessHandle;
  if ( ProcessHandle )
    goto __SYSKERNELPROC;
  // 使用自定义驱动加载进程
  if ( GetLastError() == ERROR_ACCESS_DENIED )
    DeviceIoControl(theDriver, 0x8335003C, &InBuffer1, 4u, &dwProcessId, 4u, &BytesReturned, 0);
  ProcessHandle = dwProcessId;
  if ( dwProcessId )
  {
    // 系统核心进程
__SYSKERNELPROC:
    if ( dwPID <= 8 )
    {
      InBuffer[0] = dwPID;
      v7 = hSourceHandle;
      InBuffer[3] = hSourceHandle;
      if ( theDriver == INVALID_HANDLE_VALUE
        || !DeviceIoControl(theDriver, 0x83350014, InBuffer, 16u, &OutBuffer, 4u, &v12, 0) )
      {
        v8 = dwDesiredAccess;
        v9 = GetCurrentProcess();
        DuplicateHandle(ProcessHandle, v7, v9, &OutBuffer, v8, 0, 0);
      }
    }
    else
    {
      v5 = dwDesiredAccess;
      v6 = GetCurrentProcess();
      DuplicateHandle(ProcessHandle, hSourceHandle, v6, &OutBuffer, v5, 0, 0);
    }
    CloseHandle(ProcessHandle);
  }
  return OutBuffer;
}

//----- (01262330) --------------------------------------------------------
int *__thiscall sub_1262330(int *this, int a2)
{
  int v2; // esi
  int *v3; // edi
  int v4; // ecx
  int *result; // eax
  signed int v6; // ecx
  int v7; // ecx
  int v8; // ecx

  v2 = a2;
  v3 = this;
  v4 = *this;
  if ( *(v4 - 12) > a2 )
    v2 = *(v4 - 12);
  if ( *(v4 - 4) > 1 )
    return sub_125BDF0(v3, v2);
  v6 = *(v4 - 8);
  if ( v6 < v2 )
  {
    if ( v6 <= 0x40000000 )
    {
      v8 = v6 / 2 + v6;
      if ( v8 < v2 )
        v8 = v2;
      result = sub_126DE20(v3, v8);
    }
    else
    {
      v7 = v6 + 0x100000;
      if ( v7 < v2 )
        v7 = v2;
      result = sub_126DE20(v3, v7);
    }
  }
  return result;
}

//----- (012623A0) --------------------------------------------------------
int __stdcall PerfGraphPageWndProc(HWND hWnd, int uMsg, WPARAM wParam, LONG dwNewLong)
{
  HWND v4; // eax
  int result; // eax
  CResize *v6; // eax
  LONG dwStyle; // eax
  HWND (__stdcall *v8)(HWND, int); // esi
  HWND v9; // edi
  HWND v10; // esi
  HWND v11; // edi
  HWND v12; // esi
  HWND v13; // edi
  HWND v14; // esi
  CResize *v15; // edi
  HWND v16; // eax
  HWND v17; // ST2C_4
  HWND v18; // eax
  HWND v19; // ST2C_4
  HWND v20; // eax
  HWND v21; // ST2C_4
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  WPARAM v31; // [esp-8h] [ebp-38h]
  CResize *pResize; // [esp+10h] [ebp-20h]
  HWND pHwnds; // [esp+14h] [ebp-1Ch]
  HWND v34; // [esp+18h] [ebp-18h]
  HWND v35; // [esp+1Ch] [ebp-14h]
  int v36; // [esp+2Ch] [ebp-4h]

  GetWindowLongW(hWnd, GWL_USERDATA);
  if ( uMsg > WM_TIMER )
  {
    if ( uMsg == WM_CTLCOLOREDIT || uMsg == WM_CTLCOLORDLG || uMsg == WM_CTLCOLORSTATIC )
      return sub_1246710(hWnd, wParam);
    return 0;
  }
  if ( uMsg == WM_TIMER || uMsg == WM_SIZE )
  {
    if ( IsWindowVisible(hWnd) )
    {
      v25 = GetDlgItem(hWnd, 1158);
      SendMessageW(v25, 0x400u, 0, 0);
      v26 = GetDlgItem(hWnd, 2000);
      SendMessageW(v26, 0x400u, 0, 0);
      v27 = GetDlgItem(hWnd, 1161);
      SendMessageW(v27, 0x400u, 0, 0);
      v28 = GetDlgItem(hWnd, 1159);
      SendMessageW(v28, 0x400u, 0, 0);
      v29 = GetDlgItem(hWnd, 1332);
      SendMessageW(v29, 0x400u, 0, 0);
      v30 = GetDlgItem(hWnd, 1330);
      SendMessageW(v30, 0x400u, 0, 0);
      return 0;
    }
    return 0;
  }
  if ( uMsg != WM_INITDIALOG )
  {
    if ( uMsg == 273 )
    {
      switch ( wParam )
      {
        case IDS_PROCEXPLORERMENU_EXIT:
          v31 = 40014;
          goto LABEL_8;
        case IDS_PROCEXPLORERMENU_REFRESH_NOW:
          SetEvent(ghEventRefreshSearchResult);
          result = 0;
          break;
        case IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT|0x8:
        case IDS_PROCEXPLORERMENU_SHOW_COLUMN_HEATMAPS|0x4:
          v31 = wParam;
LABEL_8:
          v4 = GetParent(hWnd);
          PostMessageW(v4, WM_COMMAND, v31, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
    return 0;
  }
  v6 = operator new(0x40u);
  v36 = 0;
  if ( v6 )
    pResize = CResize::CResize(v6, hWnd);
  else
    pResize = 0;
  v36 = -1;
  dwStyle = GetWindowLongW(hWnd, GWL_STYLE);
  SetWindowLongW(hWnd, -16, dwStyle | WS_CLIPCHILDREN);
  SetWindowLongW(hWnd, GWL_USERDATA, dwNewLong);
  CreateGraphWindowInDlg(hWnd, IDD_PROCGPU_CTRL_STATIC2, *(dwNewLong + 1372));
  CreateGraphWindowInDlg(hWnd, 2000, *(dwNewLong + 1372));
  CreateGraphWindowInDlg(hWnd, 1161, *(dwNewLong + 908));
  CreateGraphWindowInDlg(hWnd, 1159, *(dwNewLong + 908));
  if ( *(dwNewLong + 1064) )
  {
    CreateGraphWindowInDlg(hWnd, 1332, *(dwNewLong + 1064));
    CreateGraphWindowInDlg(hWnd, 1330, *(dwNewLong + 1064));
  }
  v8 = GetDlgItem;
  if ( *(dwNewLong + 1064) )
  {
    v9 = GetDlgItem(hWnd, 1331);
    v10 = GetDlgItem(hWnd, 1160);
    pHwnds = GetDlgItem(hWnd, 1157);
    v34 = v10;
    v35 = v9;
    CResize::Update(pResize, 3, &pHwnds);
    v11 = GetDlgItem(hWnd, 1332);
    v12 = GetDlgItem(hWnd, 1161);
    pHwnds = GetDlgItem(hWnd, 1158);
    v34 = v12;
    v35 = v11;
    CResize::Update(pResize, 3, &pHwnds);
    v13 = GetDlgItem(hWnd, 1330);
    v14 = GetDlgItem(hWnd, 1159);
    pHwnds = GetDlgItem(hWnd, 2000);
    v35 = v13;
    v15 = pResize;
    v34 = v14;
    CResize::Update(pResize, 3, &pHwnds);
    v8 = GetDlgItem;
    v16 = GetDlgItem(hWnd, 1331);
    *&CResize::InitResizeBuffer(pResize, v16, 1)->d21.right = doubleFourPointZero;
  }
  else
  {
    v17 = GetDlgItem(hWnd, 1160);
    v18 = GetDlgItem(hWnd, 1157);
    v15 = pResize;
    sub_12704E0(pResize, v18, v17);
    v19 = GetDlgItem(hWnd, 1161);
    v20 = GetDlgItem(hWnd, 1158);
    sub_12704E0(pResize, v20, v19);
    v21 = GetDlgItem(hWnd, 1159);
    v22 = GetDlgItem(hWnd, 2000);
    sub_12704E0(pResize, v22, v21);
  }
  v23 = v8(hWnd, 1157);
  *&CResize::InitResizeBuffer(v15, v23, 1)->d21.right = doubleFourPointZero;
  v24 = v8(hWnd, 1160);
  *&CResize::InitResizeBuffer(v15, v24, 1)->d21.right = doubleFourPointZero;
  ResizeTab(hWnd);
  SendMessageW(hWnd, 0x113u, 0, 0);
  return 1;
}
// 12BCB38: using guessed type double doubleFourPointZero;

//----- (01262810) --------------------------------------------------------
int __stdcall ProcEnvWndProc(HWND hWnd, int a2, WPARAM wParam, int a4)
{
  HWND v4; // ebx
  CResize *v5; // eax
  LONG v6; // eax
  void (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v8; // eax
  __int16 *v9; // esi
  __int16 *v10; // ecx
  int v11; // edi
  __int16 i; // ax
  int v13; // edx
  char *v14; // ecx
  __int16 v15; // ax
  HWND v17; // eax
  LRESULT v18; // esi
  WPARAM v19; // [esp-8h] [ebp-2ACh]
  LPARAM v20; // [esp+10h] [ebp-294h]
  int v21; // [esp+1Ch] [ebp-288h]
  int v22; // [esp+20h] [ebp-284h]
  void *v23; // [esp+44h] [ebp-260h]
  LVITEMW lParam; // [esp+48h] [ebp-25Ch]
  int Indent; // [esp+7Ch] [ebp-228h]
  int v26; // [esp+80h] [ebp-224h]
  int a3; // [esp+84h] [ebp-220h]
  NMHDR *pNMhdr; // [esp+88h] [ebp-21Ch]
  __int16 v29; // [esp+8Ch] [ebp-218h]
  int v30; // [esp+2A0h] [ebp-4h]

  pNMhdr = a4;
  GetWindowLongW(hWnd, GWL_USERDATA);
  lParam.mask = 0;
  memset(&lParam.iItem, 0, 0x30u);
  v4 = GetDlgItem(hWnd, 1055);
  Indent = 1057;
  v26 = 1058;
  LOWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  if ( a2 > 0x111 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return sub_1246710(hWnd, wParam);
    return 0;
  }
  switch ( a2 )
  {
    case 273:
      if ( wParam <= 40093 )
      {
        if ( wParam >= 40092 )
        {
          v19 = wParam;
        }
        else
        {
          if ( wParam != 40001 )
            return 0;
          v19 = 40014;
        }
        v17 = GetParent(hWnd);
        PostMessageW(v17, 0x111u, v19, 0);
        return 0;
      }
      if ( wParam == 40631 )
      {
        v18 = 0;
        if ( SendMessageW(v4, 0x1004u, 0, 0) > 0 )
        {
          do
          {
            v22 = 2;
            v21 = 2;
            SendMessageW(v4, 0x102Bu, v18++, &v20);
          }
          while ( v18 < SendMessageW(v4, 0x1004u, 0, 0) );
          return 0;
        }
      }
      return 0;
    case 43:
      FindDlg_DrawItem(pNMhdr);
      return 0;
    case 44:
      return HandleMeasureItem(hWnd, 0x2Cu, wParam, pNMhdr);
  }
  if ( a2 != WM_INITDIALOG )
    return 0;
  v5 = operator new(0x40u);
  v23 = v5;
  v30 = 0;
  if ( v5 )
    CResize::CResize(v5, hWnd);
  ResizeTab(hWnd);
  v6 = GetWindowLongW(v4, GWL_STYLE);
  SetWindowLongW(v4, GWL_STYLE, v6 & -3u | LVS_REPORT);
  v7 = SendMessageW;
  SendMessageW(v4, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 16416);
  v8 = SendMessageW(v4, LVM_GETTOOLTIPS, 0, 0);
  InitToolTips(v8);
  SetWindowLongW(v4, GWL_WNDPROC, PEListCtrlWndProc);
  SendMessageW(v4, WM_SETFONT, ghDefaultFont, 0);
  InitListCtrl(v4, &Indent, &a3, 2);
  v9 = pNMhdr[67].idFrom;
  if ( v9 )
  {
    while ( *v9 )
    {
      v10 = &v29;
      v29 = 0;
      v11 = 0;
      for ( i = *v9; i; ++v9 )
      {
        if ( !v11 )
        {
          if ( i == 61 )
          {
            v11 = (v9 + 1);
            *v10 = 0;
          }
          else
          {
            *v10 = i;
            ++v10;
          }
        }
        i = v9[1];
      }
      lParam.mask = 5;
      lParam.pszText = &v29;
      lParam.iItem = 0x7FFFFFFF;
      lParam.iSubItem = 0;
      lParam.state = 0;
      lParam.stateMask = 0;
      lParam.iImage = 0;
      lParam.lParam = 1;
      v13 = SendMessageW(v4, LVM_INSERTITEMW, 0, &lParam);
      if ( v13 == -1 )
        return 0;
      if ( v11 )
      {
        v14 = v11;
        pNMhdr = (v11 + 2);
        do
        {
          v15 = *v14;
          v14 += 2;
        }
        while ( v15 );
        if ( ((v14 - pNMhdr) >> 1) > 0x1FFF )
          *(v11 + 16382) = 0;
        lParam.pszText = v11;
        v7 = SendMessageW;
        lParam.mask = 1;
        lParam.iItem = v13;
        lParam.iSubItem = 1;
        SendMessageW(v4, 0x104Cu, 0, &lParam);
      }
      else
      {
        v7 = SendMessageW;
      }
      ++v9;
      if ( !v9 )
        break;
    }
  }
  v7(v4, 0x101Eu, 0, 0xFFFF);
  v7(v4, 0x101Eu, 1u, 0xFFFF);
  return 1;
}

//----- (01262C20) --------------------------------------------------------
HBRUSH __stdcall ProcInfoPageProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM dwNewLong)
{
  HWND hDlg; // ebx
  LONG v5; // edx
  BSTR v6; // esi
  CResize *v7; // eax
  CResize *v8; // eax
  HWND v9; // eax
  ResizeInfo *v10; // eax
  HWND v11; // eax
  ResizeInfo *v12; // eax
  bool v13; // zf
  void *v14; // ST08_4
  void *v15; // ST04_4
  void *v16; // ST00_4
  const WCHAR *v17; // edi
  const WCHAR *v18; // eax
  BOOL v19; // ST2C_4
  HWND v20; // eax
  int v21; // edi
  BOOL v22; // ST2C_4
  HWND v23; // eax
  HWND v24; // eax
  int v25; // ebx
  HWND v26; // eax
  HWND v27; // eax
  char v28; // al
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  OLECHAR *v32; // ST2C_4
  CComBSTR **v33; // edi
  CComBSTR **v34; // eax
  _bstr_t *v35; // eax
  _bstr_t *v36; // eax
  const WCHAR *v37; // eax
  const WCHAR *v38; // eax
  HWND v39; // eax
  _WORD *v40; // eax
  int v41; // ST2C_4
  HWND v42; // eax
  HWND v43; // eax
  _WORD *v44; // eax
  HWND v45; // eax
  DWORD v46; // edi
  void *v47; // edi
  wchar_t *v48; // eax
  HICON v49; // eax
  LPARAM v50; // ST2C_4
  HWND v51; // eax
  HICON v52; // eax
  LPARAM v53; // ST2C_4
  HWND v54; // eax
  HICON v55; // eax
  LPARAM v56; // ST2C_4
  HWND v57; // eax
  int v58; // eax
  int v59; // ST2C_4
  HWND v60; // eax
  HBRUSH v61; // edi
  const unsigned __int16 *v62; // eax
  int v63; // eax
  HWND v64; // eax
  int v65; // ST2C_4
  HWND v66; // eax
  const WCHAR *v67; // eax
  HWND v68; // eax
  LPCWSTR v69; // edi
  char v70; // cl
  int v71; // eax
  int v72; // ST2C_4
  HWND v73; // eax
  HWND v75; // eax
  HKEY v76; // [esp-8h] [ebp-1664h]
  FILETIME LocalFileTime; // [esp+10h] [ebp-164Ch]
  DWORD dwHandle; // [esp+18h] [ebp-1644h]
  BSTR *v79; // [esp+1Ch] [ebp-1640h]
  OLECHAR **v80; // [esp+20h] [ebp-163Ch]
  BSTR *v81; // [esp+24h] [ebp-1638h]
  OLECHAR **v82; // [esp+28h] [ebp-1634h]
  void *v83; // [esp+2Ch] [ebp-1630h]
  char v84[5]; // [esp+33h] [ebp-1629h]
  LPARAM lParam; // [esp+38h] [ebp-1624h]
  HANDLE hObject; // [esp+3Ch] [ebp-1620h]
  LPCWSTR lpString; // [esp+40h] [ebp-161Ch]
  CComBSTR v88; // [esp+44h] [ebp-1618h]
  SYSTEMTIME SystemTime; // [esp+50h] [ebp-160Ch]
  WCHAR v90; // [esp+60h] [ebp-15FCh]
  WCHAR DateStr; // [esp+860h] [ebp-DFCh]
  WCHAR v92; // [esp+A60h] [ebp-BFCh]
  WCHAR Dest; // [esp+C4Ch] [ebp-A10h]
  WCHAR String; // [esp+E4Ch] [ebp-810h]
  int v95; // [esp+1658h] [ebp-4h]

  hDlg = hWnd;
  *&v84[1] = hWnd;
  v88.hKey = wParam;
  lParam = dwNewLong;
  v5 = GetWindowLongW(hWnd, -21);
  v6 = 0;
  lpString = v5;
  v88.bstr = 0;
  v95 = 0;
  switch ( msg )
  {
    case 0x110u:
      v7 = operator new(0x40u);
      v83 = v7;
      LOBYTE(v95) = 1;
      if ( v7 )
        v8 = CResize::CResize(v7, hWnd);
      else
        v8 = 0;
      v88.hKey = v8;
      LOBYTE(v95) = 0;
      v8->m_WidthScale = 85;
      v8->m_HeightScale = 100;
      v9 = GetDlgItem(hWnd, 1015);
      if ( v9 )
      {
        v10 = CResize::InitResizeBuffer(v88.hKey, v9, 1);
        *&v10->d1.left = 0i64;
        *&v10->d1.right = doubleOnePointZero;
      }
      v11 = GetDlgItem(hWnd, 1656);
      if ( v11 )
      {
        v12 = CResize::InitResizeBuffer(v88.hKey, v11, 1);
        *&v12->d1.left = 0i64;
        *&v12->d1.right = doubleOnePointZero;
      }
      SetWindowLongW(hWnd, -21, dwNewLong);
      FormatTex(&String, L"%s(%08X) (netsvcs) Properties", *(dwNewLong + 60), *(dwNewLong + 68));
      SetWindowTextW(hWnd, &String);
      v13 = (*(dwNewLong + 40) & 0x100) == 0;
      lpString = *(dwNewLong + 792);
      if ( !v13 )
        SetDlgItemTextW(hWnd, 106, L"Path (Image is probably packed):");
      hObject = PEOpenProcess(0x2000000u, 0, *(dwNewLong + 68));
      sub_12602C0(hObject, *(dwNewLong + 68), &v88.Length, &v88.hKey, &v83, v84);
      v14 = *(dwNewLong + 800);
      *(dwNewLong + 800) = v88.Length;
      free(v14);
      v15 = *(dwNewLong + 804);
      *(dwNewLong + 804) = v88.hKey;
      free(v15);
      v16 = *(dwNewLong + 808);
      *(dwNewLong + 808) = v83;
      free(v16);
      SetDlgItemTextW(hWnd, 1032, *(dwNewLong + 800));
      SetDlgItemTextW(hWnd, 1035, *(dwNewLong + 804));
      v17 = L"n/a";
      v18 = L"n/a";
      if ( lpString )
        v18 = lpString;
      SetDlgItemTextW(hWnd, 1015, v18);
      SetDlgItemTextW(hWnd, 1190, *(lParam + 796));
      if ( *(lParam + 828) )
        v17 = *(lParam + 828);
      SetDlgItemTextW(hWnd, 1656, v17);
      v19 = lpString != 0;
      v20 = GetDlgItem(hWnd, 1307);
      EnableWindow(v20, v19);
      v21 = lParam;
      v22 = *(lParam + 828) != 0;
      v23 = GetDlgItem(hWnd, 1306);
      EnableWindow(v23, v22);
      v24 = GetDlgItem(hWnd, 1195);
      ShowWindow(v24, 0);
      if ( gbProcessDEPStatus )
      {
        sub_125BEF0(v21, hObject);
        v25 = *(v21 + 636);
        if ( v25 == -1 )
        {
          tcscpy_s(&String, 0x400u, L"n/a");
        }
        else
        {
          if ( v25 & 1 )
            tcscpy_s(&String, 0x400u, L"Enabled");
          else
            tcscpy_s(&String, 0x400u, L"Disabled");
          if ( v25 & 8 )
            wcscat_s(&String, 0x400u, L" (permanent)");
        }
        hDlg = *&v84[1];
        SetDlgItemTextW(*&v84[1], 1202, &String);
      }
      else
      {
        v26 = GetDlgItem(hWnd, 1203);
        ShowWindow(v26, 0);
        v27 = GetDlgItem(hWnd, 1202);
        ShowWindow(v27, 0);
      }
      if ( gdwOsType >= 3 && hObject )
      {
        if ( sub_125F5C0(hObject, 1, &v88.hKey, 4) )
        {
          bstr_t::Assign(&v88, gpszTargetName);
          v28 = v88.hKey;
          if ( v88.hKey & 8 )
          {
            bstr_t::EqualAssign(&v88.Length, L"Disallow-Stripped");
            LOBYTE(v95) = 2;
            bstr_t::Append(&v88, &v88.Length);
            LOBYTE(v95) = 0;
            bstr_t::Data_t::Free(&v88.Length);
            v28 = v88.hKey;
          }
          if ( v28 & 4 )
          {
            if ( sub_1200440(&v88) )
            {
              bstr_t::EqualAssign(&v88.Length, L", ");
              LOBYTE(v95) = 3;
              bstr_t::Append(&v88, &v88.Length);
              LOBYTE(v95) = 0;
              bstr_t::Data_t::Free(&v88.Length);
            }
            bstr_t::EqualAssign(&v88.Length, L"High-Entropy");
            LOBYTE(v95) = 4;
            bstr_t::Append(&v88, &v88.Length);
            LOBYTE(v95) = 0;
            bstr_t::Data_t::Free(&v88.Length);
            v28 = v88.hKey;
          }
          if ( v28 & 1 )
          {
            if ( sub_1200440(&v88) )
            {
              bstr_t::EqualAssign(&v88.Length, L", ");
              LOBYTE(v95) = 5;
              bstr_t::Append(&v88, &v88.Length);
              LOBYTE(v95) = 0;
              bstr_t::Data_t::Free(&v88.Length);
            }
            bstr_t::EqualAssign(&v88.Length, L"Bottom-Up");
            LOBYTE(v95) = 6;
            bstr_t::Append(&v88, &v88.Length);
            LOBYTE(v95) = 0;
            bstr_t::Data_t::Free(&v88.Length);
            v28 = v88.hKey;
          }
          if ( v28 & 2 )
          {
            if ( sub_1200440(&v88) )
            {
              bstr_t::EqualAssign(&v88.Length, L", ");
              LOBYTE(v95) = 7;
              bstr_t::Append(&v88, &v88.Length);
              LOBYTE(v95) = 0;
              bstr_t::Data_t::Free(&v88.Length);
            }
            bstr_t::EqualAssign(&v88.Length, L"Force-Relocate");
            LOBYTE(v95) = 8;
            bstr_t::Append(&v88, &v88.Length);
            LOBYTE(v95) = 0;
            bstr_t::Data_t::Free(&v88.Length);
          }
          if ( sub_1200440(&v88) )
          {
            v6 = v88.bstr;
            if ( v88.bstr )
              tcscpy_s(&String, 0x400u, *v88.bstr);
            else
              tcscpy_s(&String, 0x400u, 0);
          }
          else
          {
            wcscat_s(&String, 0x400u, L"Disabled");
            v6 = v88.bstr;
          }
        }
        else
        {
          sub_125BE70(&String, 0x400u);
        }
      }
      else
      {
        if ( gdwOsType < 1 )
        {
          v29 = GetDlgItem(hDlg, 1204);
          ShowWindow(v29, 0);
          v30 = GetDlgItem(hDlg, 1205);
          ShowWindow(v30, 0);
          goto LABEL_56;
        }
        if ( *(v21 + 650) & 0x40 )
        {
          tcscpy_s(&String, 0x400u, L"Enabled");
        }
        else if ( *(v21 + 648) )
        {
          tcscpy_s(&String, 0x400u, L"Disabled");
        }
        else
        {
          tcscpy_s(&String, 0x400u, L"n/a");
        }
      }
      SetDlgItemTextW(hDlg, 1205, &String);
LABEL_56:
      if ( gdwOsType < 4 )
      {
        v31 = GetDlgItem(hDlg, 1666);
        ShowWindow(v31, 0);
      }
      else
      {
        if ( *(v21 + 650) & 0x4000 )
        {
          tcscpy_s(&String, 0x400u, L"Enabled");
        }
        else if ( *(v21 + 648) && *(v21 + 650) )
        {
          tcscpy_s(&String, 0x400u, L"Disabled");
        }
        else
        {
          tcscpy_s(&String, 0x400u, L"n/a");
        }
        SetDlgItemTextW(hDlg, 1666, &String);
      }
      if ( hObject )
        CloseHandle(hObject);
      if ( *(v21 + 784) )
      {
        bstr_t::EqualAssign(&hObject, *(v21 + 784));
        v13 = *(v21 + 824) == 0;
        LOBYTE(v95) = 9;
        if ( !v13 )
        {
          bstr_t::EqualAssign(&v88.Length, L")");
          v32 = *(v21 + 824);
          LOBYTE(v95) = 10;
          v33 = bstr_t::EqualAssign(&v81, v32);
          LOBYTE(v95) = 11;
          v34 = bstr_t::EqualAssign(&v79, L" (");
          LOBYTE(v95) = 12;
          v35 = CComBSTR::AppendTail(v34, &v82, v33);
          LOBYTE(v95) = 13;
          v36 = CComBSTR::AppendTail(v35, &v80, &v88.Length);
          LOBYTE(v95) = 14;
          bstr_t::Append(&hObject, v36);
          bstr_t::Data_t::Free(&v80);
          bstr_t::Data_t::Free(&v82);
          bstr_t::Data_t::Free(&v79);
          bstr_t::Data_t::Free(&v81);
          bstr_t::Data_t::Free(&v88.Length);
          v21 = lParam;
        }
        if ( hObject )
          v37 = *hObject;
        else
          v37 = 0;
        SetDlgItemTextW(hDlg, 1183, v37);
        LOBYTE(v95) = 0;
        bstr_t::Data_t::Free(&hObject);
      }
      v38 = VerifySignatureOK(v21, gbVerifySignatures);
      SetDlgItemTextW(hDlg, 3, v38);
      v39 = GetDlgItem(hDlg, 1672);
      SetWindowSubclass(v39, pfnSubclass, 0, 0);
      sub_1281A50(*(v21 + 844), &String);
      SetDlgItemTextW(hDlg, 1672, &String);
      v40 = *(v21 + 792);
      if ( v40 && *v40 != 91 )
      {
        v41 = sub_1281C10(*(v21 + 844));
        v42 = GetDlgItem(hDlg, 1671);
        EnableWindow(v42, v41);
      }
      if ( gbWintrustInited )
      {
        if ( *(v21 + 832) || (v44 = *(v21 + 792)) == 0 || *v44 == 91 )
        {
          v45 = GetDlgItem(hDlg, 1005);
          EnableWindow(v45, 0);
        }
      }
      else
      {
        v43 = GetDlgItem(hDlg, 1005);
        ShowWindow(v43, 0);
      }
      FormatTex(&String, L"n/a");
      if ( lpString )
      {
        v84[1] = unknown_libname_2(255);
        v46 = GetFileVersionInfoSizeW(lpString, &dwHandle);
        v88.Length = malloc(v46);
        if ( GetFileVersionInfoW(lpString, 0, v46, v88.Length) )
        {
          v47 = v88.Length;
          sub_1259660(*(v88.Length + 52), *(v88.Length + 48), &String);
        }
        else
        {
          FormatTex(&String, L"n/a");
          v47 = v88.Length;
        }
        free(v47);
        unknown_libname_2(v84[1]);
        v21 = lParam;
      }
      SetDlgItemTextW(hDlg, 25, &String);
      if ( *(v21 + 640) )
        v48 = _wctime32((v21 + 640));
      else
        v48 = L"n/a";
      SetDlgItemTextW(hDlg, 30, v48);
      v49 = *(v21 + 56);
      if ( !v49 )
        v49 = LoadIconW(0, 0x7F00);
      v50 = v49;
      v51 = GetDlgItem(hDlg, 1033);
      SendMessageW(v51, 0x172u, 1u, v50);
      v52 = *(v21 + 56);
      if ( !v52 )
        v52 = LoadIconW(0, 0x7F00);
      v53 = v52;
      v54 = GetParent(hDlg);
      SendMessageW(v54, 0x80u, 1u, v53);
      if ( *(v21 + 56) )
        v55 = *(v21 + 52);
      else
        v55 = LoadIconW(0, 0x7F00);
      v56 = v55;
      v57 = GetParent(hDlg);
      SendMessageW(v57, 0x80u, 0, v56);
      SetDlgItemTextW(hDlg, 35, *(v21 + 72));
      FormatTex(&String, L"%d K", *(v21 + 900) >> 10);
      SetDlgItemTextW(hDlg, 1008, &String);
      FormatTex(&String, L"%d K", *(v21 + 888) >> 10);
      SetDlgItemTextW(hDlg, 1009, &String);
      if ( *(v21 + 624) )
      {
        FileTimeToLocalFileTime((v21 + 624), &LocalFileTime);
        FileTimeToSystemTime(&LocalFileTime, &SystemTime);
        GetTimeFormatW(0x400u, 0, &SystemTime, 0, &String, 512);
        GetDateFormatW(0x400u, 0, &SystemTime, 0, &DateStr, 128);
        wcscat_s(&String, 0x400u, L"   ");
        wcscat_s(&String, 0x400u, &DateStr);
      }
      else
      {
        tcscpy_s(&String, 0x400u, L"n/a");
      }
      SetDlgItemTextW(hDlg, 1007, &String);
      SetDlgItemTextW(hDlg, 19, *(v21 + 88));
      ResizeTab(hDlg);
      ShowWindow(hDlg, 1);
      goto LABEL_141;
    case 0x111u:
      if ( LOWORD(v88.hKey) > 1306 )
      {
        if ( LOWORD(v88.hKey) > 40001 )
        {
          if ( LOWORD(v88.hKey) == 40002 )
          {
            SetEvent(ghEventRefreshSearchResult);
            return 0;
          }
          if ( LOWORD(v88.hKey) - 40092 > 1 )
            return 0;
          v76 = v88.hKey;
        }
        else
        {
          if ( LOWORD(v88.hKey) != 40001 )
          {
            if ( LOWORD(v88.hKey) == 1307 )
            {
              sub_122B780(hWnd, *(v5 + 792));
              goto LABEL_141;
            }
            if ( LOWORD(v88.hKey) != 1671 )
              return 0;
            if ( sub_12817E0() )
            {
              v69 = lpString;
              v70 = 0;
              v71 = *(lpString + 211);
              if ( v71 )
              {
                v70 = 1;
                *(v71 + 4) = 6;
              }
              sub_1281C30(v69, 1, v70 != 0);
              v72 = sub_1281C10(*(v69 + 211));
              v73 = GetDlgItem(hWnd, 1671);
              EnableWindow(v73, v72);
              sub_1281A50(*(v69 + 211), &Dest);
              SetDlgItemTextW(hWnd, 1672, &Dest);
              PostMessageW(ghWndNewOwner, 0x7F9u, 0, *(v69 + 211));
            }
            goto LABEL_141;
          }
          v76 = 40014;
        }
        v75 = GetParent(hWnd);
        PostMessageW(v75, 0x111u, v76, 0);
        return 0;
      }
      if ( LOWORD(v88.hKey) == 1306 )
      {
        sub_122B780(hWnd, *(v5 + 828));
        goto LABEL_141;
      }
      if ( LOWORD(v88.hKey) > 1004 )
      {
        if ( LOWORD(v88.hKey) == 1005 )
        {
          v67 = VerifySignatureOK(v5, 1);
          SetDlgItemTextW(hWnd, 3, v67);
          v68 = GetDlgItem(hWnd, 1005);
          EnableWindow(v68, 0);
          goto LABEL_141;
        }
        if ( LOWORD(v88.hKey) == 1160 )
        {
          v65 = *(v5 + 68);
          v66 = GetParent(hWnd);
          ShowMainWindow(v66, 40084, v65);
          CheckProcessWindowMenuItems(lpString);
          goto LABEL_141;
        }
        return 0;
      }
      switch ( LOWORD(v88.hKey) )
      {
        case 0x3ECu:
          if ( sub_1278030(*(v5 + 60), *(v5 + 68)) )
          {
            v64 = GetParent(hWnd);
            PostMessageW(v64, 0x471u, 5u, 0);
          }
          break;
        case 1u:
          GetDlgItemTextW(hWnd, 1190, &v90, 1024);
          v62 = *(lpString + 199);
          if ( !v62 )
            goto LABEL_159;
          v63 = wcscmp(&v90, v62);
          if ( v63 )
            v63 = -(v63 < 0) | 1;
          if ( v63 )
LABEL_159:
            sub_12462A0(lpString, &v90);
          break;
        case 2u:
          break;
        default:
          return 0;
      }
LABEL_141:
      v61 = 1;
LABEL_142:
      if ( v6 && !InterlockedDecrement(v6 + 2) )
      {
        if ( *v6 )
        {
          SysFreeString(*v6);
          *v6 = 0;
        }
        if ( *(v6 + 1) )
        {
          j_j__free(*(v6 + 1));
          *(v6 + 1) = 0;
        }
        j__free(v6);
      }
      return v61;
    case 0x113u:
      GetDlgItemTextW(hWnd, 1672, &v92, 245);
      sub_1281A50(*(lpString + 211), &Dest);
      v58 = wcscmp(&v92, &Dest);
      if ( v58 )
        v58 = -(v58 < 0) | 1;
      if ( v58 )
      {
        SetDlgItemTextW(hWnd, 1672, &Dest);
        v59 = sub_1281C10(*(lpString + 211));
        v60 = GetDlgItem(hWnd, 1671);
        EnableWindow(v60, v59);
      }
      goto LABEL_141;
    case 0x133u:
    case 0x136u:
      goto LABEL_112;
    case 0x138u:
      if ( dwNewLong == GetDlgItem(hWnd, 1672) && sub_1281820(*(lpString + 211)) )
      {
        if ( sub_1282910(*(lpString + 211)) )
          SetTextColor(v88.hKey, 0xFFu);
        else
          SetTextColor(v88.hKey, 0xFF0000u);
        SelectObject(v88.hKey, ghDefaultGuiFontUnderline);
        v61 = GetSysColorBrush(20);
      }
      else
      {
LABEL_112:
        v61 = sub_1246710(hWnd, v88.hKey);
      }
      goto LABEL_142;
    default:
      return 0;
  }
}
// 1245410: using guessed type _DWORD __cdecl unknown_libname_2(char);
// 12BCB30: using guessed type double doubleOnePointZero;
// 12E4E54: using guessed type int gdwOsType;
// 12E96D7: using guessed type char gbVerifySignatures;
// 12EA390: using guessed type char gbProcessDEPStatus;
// 12EA391: using guessed type char gbWintrustInited;

//----- (01263C50) --------------------------------------------------------
int __stdcall ProcJOBWndProc(HWND hWnd, int msg, WPARAM wParam, LPARAM lParam)
{
  CResize *v4; // eax
  void (__stdcall *v5)(HANDLE); // edi
  HWND v6; // edi
  LONG v7; // eax
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // esi
  int *v9; // edi
  DWORD v10; // esi
  int *v11; // eax
  HANDLESANDDLLSLISTUSERPARAM *v12; // eax
  int v13; // eax
  HWND hListCtrl; // eax
  HWND hWndList; // ebx
  LONG v16; // eax
  HWND v17; // eax
  __int16 v18; // ax
  HANDLE v19; // esi
  char v20; // al
  void *v21; // edi
  DWORD v22; // esi
  int result; // eax
  HWND v24; // eax
  WPARAM v25; // [esp-8h] [ebp-1174h]
  LVITEMW v26; // [esp+10h] [ebp-115Ch]
  LVITEMW item; // [esp+44h] [ebp-1128h]
  int uIDs; // [esp+78h] [ebp-10F4h]
  int v29; // [esp+7Ch] [ebp-10F0h]
  int Indent; // [esp+80h] [ebp-10ECh]
  int v31; // [esp+84h] [ebp-10E8h]
  void *v32; // [esp+88h] [ebp-10E4h]
  HANDLE v33; // [esp+8Ch] [ebp-10E0h]
  int a3; // [esp+90h] [ebp-10DCh]
  _DWORD *v35; // [esp+94h] [ebp-10D8h]
  HANDLE hObject; // [esp+98h] [ebp-10D4h]
  HWND v37; // [esp+9Ch] [ebp-10D0h]
  HWND v38; // [esp+A0h] [ebp-10CCh]
  size_t ReturnLength; // [esp+A4h] [ebp-10C8h]
  int v40; // [esp+A8h] [ebp-10C4h]
  __int64 JobObjectInformation; // [esp+ACh] [ebp-10C0h]
  __int64 v42; // [esp+B4h] [ebp-10B8h]
  int v43; // [esp+BCh] [ebp-10B0h]
  unsigned int v44; // [esp+C0h] [ebp-10ACh]
  unsigned int v45; // [esp+C4h] [ebp-10A8h]
  char ArgList[4]; // [esp+C8h] [ebp-10A4h]
  char v47[4]; // [esp+CCh] [ebp-10A0h]
  char v48[4]; // [esp+D0h] [ebp-109Ch]
  char v49[4]; // [esp+D4h] [ebp-1098h]
  unsigned int v50; // [esp+10Ch] [ebp-1060h]
  unsigned int v51; // [esp+110h] [ebp-105Ch]
  wchar_t v52[1024]; // [esp+11Ch] [ebp-1050h]
  __int16 Dst[1024]; // [esp+91Ch] [ebp-850h]
  wchar_t v54[32]; // [esp+111Ch] [ebp-50h]
  int v55; // [esp+1168h] [ebp-4h]

  GetWindowLongW(hWnd, GWL_USERDATA);
  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  Indent = 3;
  v31 = 4;
  uIDs = 1075;
  v29 = 1058;
  LOWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  if ( msg > WM_COMMAND )
  {
    if ( msg == WM_CTLCOLOREDIT || msg == WM_CTLCOLORDLG || msg == WM_CTLCOLORSTATIC )
      return sub_1246710(hWnd, wParam);
    return 0;
  }
  switch ( msg )
  {
    case WM_COMMAND:
      switch ( wParam )
      {
        case IDS_PROCEXPLORERMENU_EXIT:
          v25 = 40014;
          goto LABEL_90;
        case IDS_PROCEXPLORERMENU_REFRESH_NOW:
          SetEvent(ghEventRefreshSearchResult);
          result = 0;
          break;
        case IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT|0x8:
        case IDS_PROCEXPLORERMENU_SHOW_COLUMN_HEATMAPS|0x4:
          v25 = wParam;
LABEL_90:
          v24 = GetParent(hWnd);
          PostMessageW(v24, 0x111u, v25, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    case WM_DRAWITEM:
      FindDlg_DrawItem(lParam);
      return 0;
    case WM_MEASUREITEM:
      return HandleMeasureItem(hWnd, 0x2Cu, wParam, lParam);
  }
  if ( msg != WM_INITDIALOG )
    return 0;
  // WM_INITDIALOG
  v4 = operator new(0x40u);
  v33 = v4;
  v55 = 0;
  if ( v4 )
    CResize::CResize(v4, hWnd);
  v55 = -1;
  ResizeTab(hWnd);
  SetWindowLongW(hWnd, GWL_USERDATA, lParam);
  GetSystemHandlesInfo(1);
  v33 = PEOpenProcess(0x2000000u, 0, *(lParam + 68));
  v5 = CloseHandle;
  if ( sub_126DA70(v33, *(lParam + 68), &hObject, &v32) )
  {
    if ( *v32 )
      SetDlgItemTextW(hWnd, 1075, v32);
    else
      SetDlgItemTextW(hWnd, 1075, L"<Unnamed Job>");
    v6 = GetDlgItem(hWnd, 1076);
    v37 = v6;
    v7 = GetWindowLongW(v6, -16);
    SetWindowLongW(v6, -16, v7 & 0xFFFFFFFD | 1);
    SendMessageW = ::SendMessageW;
    ::SendMessageW(v6, 0x1036u, 0x4020u, 16416);
    OldListCtrlWndProc = SetWindowLongW(v6, -4, PEListCtrlWndProc);
    ::SendMessageW(v6, 0x30u, ghDefaultFont, 0);
    InitListCtrl(v6, &Indent, &a3, 2);
    ReturnLength = 1200;
    v9 = malloc(0x4B0u);
    if ( !QueryInformationJobObject(hObject, JobObjectBasicProcessIdList, v9, 0x4B0u, &ReturnLength) )
    {
      do
      {
        if ( GetLastError() != 24 )
          break;
        free(v9);
        v10 = ReturnLength;
        v9 = malloc(ReturnLength);
      }
      while ( !QueryInformationJobObject(hObject, JobObjectBasicProcessIdList, v9, v10, &ReturnLength) );
      SendMessageW = ::SendMessageW;
    }
    if ( v9 )
    {
      v38 = 0;
      if ( v9[1] )
      {
        v11 = v9 + 2;
        v35 = v9 + 2;
        do
        {
          sub_1278310(*v11, 0, v52, 0x400u);
          sub_1259D80(v54, L"%d", *v35);
          item.mask = 5;
          item.pszText = v52;
          v12 = (v38 + 1);
          item.iItem = 0x7FFFFFFF;
          v38 = v12;
          item.lParam = v12;
          item.iSubItem = 0;
          item.stateMask = 0;
          item.state = 0;
          item.iImage = 0;
          v13 = SendMessageW(v37, 0x104Du, 0, &item);
          if ( v13 == -1 )
            return 0;
          item.iItem = v13;
          item.pszText = v54;
          item.mask = 1;
          item.iSubItem = 1;
          SendMessageW(v37, 0x104Cu, 0, &item);
          v11 = v35 + 1;
          ++v35;
        }
        while ( v38 < v9[1] );
      }
      SendMessageW(v37, LVM_SETCOLUMNWIDTH, 0, 0xFFFF);
      SendMessageW(v37, LVM_SETCOLUMNWIDTH, 1u, 65534);
      v26.stateMask = 3;
      v26.state = 3;
      SendMessageW(v37, LVM_SETITEMSTATE, 0, &v26);
      SetFocus(v37);
      free(v9);
    }
    hListCtrl = GetDlgItem(hWnd, IDD_PROCJOB_CTRL_LISTVIEW2);
    hWndList = hListCtrl;
    v38 = hListCtrl;
    v16 = GetWindowLongW(hListCtrl, GWL_STYLE);
    SetWindowLongW(hWndList, -16, v16 & 0xFFFFFFFD | 1);
    SendMessageW(hWndList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 16416);
    v17 = SendMessageW(hWndList, 0x104Eu, 0, 0);
    InitToolTips(v17);
    OldListCtrlWndProc = SetWindowLongW(hWndList, GWL_WNDPROC, PEListCtrlWndProc);
    SendMessageW(hWndList, WM_SETFONT, ghDefaultFont, 0);
    InitListCtrl(hWndList, &uIDs, &a3, 2);
    QueryInformationJobObject(
      hObject,
      MaxJobObjectInfoClass|JobObjectBasicAccountingInformation,
      &JobObjectInformation,
      0x70u,
      &ReturnLength);
    v18 = v43;
    if ( v43 & 0x2000 )
    {
      InsertJobToList(hWndList, L"Kill on Job Close", L"True");
      v18 = v43;
    }
    if ( v18 & 0x400 )
    {
      InsertJobToList(hWndList, L"Die on Unhandled Exception", L"True");
      v18 = v43;
    }
    if ( v18 & 0x800 )
    {
      InsertJobToList(hWndList, L"Breakaway OK", L"True");
      v18 = v43;
    }
    if ( v18 & 0x1000 )
    {
      InsertJobToList(hWndList, L"Silent Breakaway OK", L"True");
      v18 = v43;
    }
    if ( v18 & 0x40 )
    {
      InsertJobToList(hWndList, L"Preserve Job Time", L"True");
      v18 = v43;
    }
    if ( v18 & 0x4000 )
    {
      InsertJobToList(hWndList, L"Subset Affinity Allowed", L"True");
      v18 = v43;
    }
    if ( v18 & 2 )
    {
      FormatTex(Dst, L"%I64d s", JobObjectInformation / 10000000);
      InsertJobToList(hWndList, L"Process CPU Limit", Dst);
      v18 = v43;
    }
    if ( v18 & 4 )
    {
      FormatTex(Dst, L"%I64d s", v42 / 10000000);
      InsertJobToList(hWndList, L"User CPU Limit", Dst);
      v18 = v43;
    }
    if ( v18 & 1 )
    {
      FormatTex(Dst, L"%d", v44 >> 10);
      GetNumberTextFormat(Dst, 0x400u);
      wcscat_s(Dst, 0x400u, L" KB");
      InsertJobToList(hWndList, L"Min Working Set", Dst);
      v18 = v43;
      if ( v43 & 1 )
      {
        FormatTex(Dst, L"%d", v45 >> 10);
        GetNumberTextFormat(Dst, 0x400u);
        wcscat_s(Dst, 0x400u, L" KB");
        InsertJobToList(hWndList, L"Max Working Set", Dst);
        v18 = v43;
      }
    }
    if ( v18 & 0x100 )
    {
      FormatTex(Dst, L"%d", v50 >> 10);
      GetNumberTextFormat(Dst, 0x400u);
      wcscat_s(Dst, 0x400u, L" KB");
      InsertJobToList(hWndList, L"Process Memory Limit", Dst);
      v18 = v43;
    }
    if ( v18 & 0x200 )
    {
      FormatTex(Dst, L"%d", v51 >> 10);
      GetNumberTextFormat(Dst, 0x400u);
      wcscat_s(Dst, 0x400u, L" KB");
      InsertJobToList(hWndList, L"Job Memory Limit", Dst);
      LOBYTE(v18) = v43;
    }
    if ( v18 & 8 )
    {
      FormatTex(Dst, L"%d", *ArgList);
      InsertJobToList(hWndList, L"Active Processes", Dst);
      LOBYTE(v18) = v43;
    }
    if ( v18 & 0x10 )
    {
      FormatTex(Dst, L"%x", *v47);
      InsertJobToList(hWndList, L"Affinity", Dst);
      LOBYTE(v18) = v43;
    }
    if ( v18 & 0x20 )
    {
      FormatTex(Dst, L"%d", *v48);
      InsertJobToList(hWndList, L"Priority Class", Dst);
      LOBYTE(v18) = v43;
    }
    if ( (v18 & 0x80u) != 0 )
    {
      FormatTex(Dst, L"%d", *v49);
      InsertJobToList(hWndList, L"Scheduling Class", Dst);
      LOBYTE(v18) = v43;
    }
    if ( v18 & 4 )
    {
      FormatTex(
        Dst,
        L"%I64d:%02I64d:%02I64d.%03I64d",
        v42 / 0x861C46800ui64,
        v42 / 0x23C34600ui64 % 0x3C,
        v42 / 10000000 % 60,
        v42 % 10000000 / 10000);
      hWndList = v38;
      InsertJobToList(v38, L"Job Time", Dst);
      LOBYTE(v18) = v43;
    }
    if ( v18 & 2 )
    {
      FormatTex(
        Dst,
        L"%I64d:%02I64d:%02I64d.%03I64d",
        JobObjectInformation / 0x861C46800ui64,
        JobObjectInformation / 0x23C34600ui64 % 0x3C,
        JobObjectInformation / 10000000 % 60,
        JobObjectInformation % 10000000 / 10000);
      hWndList = v38;
      InsertJobToList(v38, L"Process Time", Dst);
    }
    v19 = hObject;
    QueryInformationJobObject(hObject, JobObjectBasicUIRestrictions, &v40, 4u, &ReturnLength);
    v20 = v40;
    if ( v40 & 0x40 )
    {
      InsertJobToList(hWndList, L"Desktop", L"Limited");
      v20 = v40;
    }
    if ( v20 & 0x10 )
    {
      InsertJobToList(hWndList, L"Display Settings", L"Limited");
      v20 = v40;
    }
    if ( v20 < 0 )
    {
      InsertJobToList(hWndList, L"Exit Windows", L"Limited");
      v20 = v40;
    }
    if ( v20 & 0x20 )
    {
      InsertJobToList(hWndList, L"Global Atoms", L"Limited");
      v20 = v40;
    }
    if ( v20 & 1 )
    {
      InsertJobToList(hWndList, L"USER Handles", L"Limited");
      v20 = v40;
    }
    if ( v20 & 2 )
    {
      InsertJobToList(hWndList, L"Read Clipboard", L"Limited");
      v20 = v40;
    }
    if ( v20 & 8 )
    {
      InsertJobToList(hWndList, L"System Parameters", L"Limited");
      v20 = v40;
    }
    if ( v20 & 4 )
      InsertJobToList(hWndList, L"Write Clipboard", L"Limited");
    ReturnLength = 2000;
    v21 = malloc(0x7D0u);
    if ( !QueryInformationJobObject(v19, JobObjectSecurityLimitInformation, v21, 0x7D0u, &ReturnLength) )
    {
      do
      {
        if ( GetLastError() != 24 )
          break;
        free(v21);
        v22 = ReturnLength;
        v21 = malloc(ReturnLength);
      }
      while ( !QueryInformationJobObject(hObject, JobObjectSecurityLimitInformation, v21, v22, &ReturnLength) );
    }
    if ( v40 & 1 )
      InsertJobToList(hWndList, L"Administrator Access", L"Limited");
    free(v21);
    if ( ::SendMessageW(hWndList, 0x1004u, 0, 0) )
    {
      ::SendMessageW(hWndList, 0x101Eu, 0, 0xFFFF);
      ::SendMessageW(hWndList, 0x101Eu, 1u, 65534);
      v26.stateMask = 3;
      v26.state = 3;
      ::SendMessageW(hWndList, 0x102Bu, 0, &v26);
    }
    v5 = CloseHandle;
    CloseHandle(hObject);
    free(v32);
  }
  else
  {
    SetDlgItemTextW(hWnd, 1075, L"<Access denied>");
  }
  if ( v33 )
    v5(v33);
  return 1;
}

//----- (01264990) --------------------------------------------------------
int __stdcall ProcGPUWndProc(HWND hWnd, int a2, WPARAM wParam, LONG dwNewLong)
{
  HWND v4; // eax
  int result; // eax
  CResize *v6; // eax
  LONG v7; // eax
  HWND v8; // ebx
  HWND v9; // edi
  HWND v10; // esi
  HWND v11; // ebx
  HWND v12; // edi
  HWND v13; // esi
  HWND v14; // ebx
  HWND v15; // edi
  HWND v16; // esi
  HWND v17; // eax
  HWND v18; // eax
  HWND v19; // eax
  HWND v20; // eax
  HWND v21; // eax
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  WPARAM v29; // [esp-8h] [ebp-40h]
  CResize *pResize; // [esp+10h] [ebp-28h]
  HWND pHwnds; // [esp+18h] [ebp-20h]
  HWND v32; // [esp+1Ch] [ebp-1Ch]
  HWND v33; // [esp+20h] [ebp-18h]
  HWND v34; // [esp+24h] [ebp-14h]
  int v35; // [esp+34h] [ebp-4h]

  GetWindowLongW(hWnd, -21);
  if ( a2 > 0x113 )
  {
    if ( a2 == 307 || a2 == 310 || a2 == 312 )
      return sub_1246710(hWnd, wParam);
    return 0;
  }
  if ( a2 == 275 || a2 == 5 )
  {
    if ( IsWindowVisible(hWnd) )
    {
      v21 = GetDlgItem(hWnd, 1158);
      SendMessageW(v21, 0x400u, 0, 0);
      v22 = GetDlgItem(hWnd, 2000);
      SendMessageW(v22, 0x400u, 0, 0);
      v23 = GetDlgItem(hWnd, 1160);
      SendMessageW(v23, 0x400u, 0, 0);
      v24 = GetDlgItem(hWnd, 2601);
      SendMessageW(v24, 0x400u, 0, 0);
      v25 = GetDlgItem(hWnd, 1162);
      SendMessageW(v25, 0x400u, 0, 0);
      v26 = GetDlgItem(hWnd, 2602);
      SendMessageW(v26, 0x400u, 0, 0);
      v27 = GetDlgItem(hWnd, 1164);
      SendMessageW(v27, 0x400u, 0, 0);
      v28 = GetDlgItem(hWnd, 2603);
      SendMessageW(v28, 0x400u, 0, 0);
      return 0;
    }
    return 0;
  }
  if ( a2 == 272 )
  {
    v6 = operator new(0x40u);
    v35 = 0;
    if ( v6 )
      pResize = CResize::CResize(v6, hWnd);
    else
      pResize = 0;
    v35 = -1;
    v7 = GetWindowLongW(hWnd, -16);
    SetWindowLongW(hWnd, -16, v7 | 0x2000000);
    SetWindowLongW(hWnd, -21, dwNewLong);
    CreateGraphWindowInDlg(hWnd, 1158, *(dwNewLong + 1392));
    CreateGraphWindowInDlg(hWnd, 2000, *(dwNewLong + 1392));
    CreateGraphWindowInDlg(hWnd, 1160, *(dwNewLong + 1432));
    CreateGraphWindowInDlg(hWnd, 2601, *(dwNewLong + 1432));
    CreateGraphWindowInDlg(hWnd, 1162, *(dwNewLong + 1416));
    CreateGraphWindowInDlg(hWnd, 2602, *(dwNewLong + 1416));
    CreateGraphWindowInDlg(hWnd, 1164, *(dwNewLong + 1448));
    CreateGraphWindowInDlg(hWnd, 2603, *(dwNewLong + 1448));
    v8 = GetDlgItem(hWnd, 1659);
    v9 = GetDlgItem(hWnd, 1161);
    v10 = GetDlgItem(hWnd, 1159);
    pHwnds = GetDlgItem(hWnd, 1157);
    v32 = v10;
    v33 = v9;
    v34 = v8;
    CResize::Update(pResize, 4, &pHwnds);
    v11 = GetDlgItem(hWnd, 1164);
    v12 = GetDlgItem(hWnd, 1162);
    v13 = GetDlgItem(hWnd, 1160);
    pHwnds = GetDlgItem(hWnd, 1158);
    v32 = v13;
    v33 = v12;
    v34 = v11;
    CResize::Update(pResize, 4, &pHwnds);
    v14 = GetDlgItem(hWnd, 2603);
    v15 = GetDlgItem(hWnd, 2602);
    v16 = GetDlgItem(hWnd, 2601);
    pHwnds = GetDlgItem(hWnd, 2000);
    v33 = v15;
    v32 = v16;
    v34 = v14;
    CResize::Update(pResize, 4, &pHwnds);
    v17 = GetDlgItem(hWnd, 1157);
    *&CResize::InitResizeBuffer(pResize, v17, 1)->d21.right = doubleFourPointZero;
    v18 = GetDlgItem(hWnd, 1159);
    *&CResize::InitResizeBuffer(pResize, v18, 1)->d21.right = doubleFourPointZero;
    v19 = GetDlgItem(hWnd, 1161);
    *&CResize::InitResizeBuffer(pResize, v19, 1)->d21.right = doubleFourPointZero;
    v20 = GetDlgItem(hWnd, 1659);
    *&CResize::InitResizeBuffer(pResize, v20, 1)->d21.right = doubleFourPointZero;
    ResizeTab(hWnd);
    SendMessageW(hWnd, 0x113u, 0, 0);
    return 1;
  }
  if ( a2 != 273 )
    return 0;
  switch ( wParam )
  {
    case 0x9C41u:
      v29 = 40014;
      goto LABEL_8;
    case 0x9C42u:
      SetEvent(ghEventRefreshSearchResult);
      result = 0;
      break;
    case 0x9C9Cu:
    case 0x9C9Du:
      v29 = wParam;
LABEL_8:
      v4 = GetParent(hWnd);
      PostMessageW(v4, 0x111u, v29, 0);
      result = 0;
      break;
    default:
      return 0;
  }
  return result;
}
// 12BCB38: using guessed type double doubleFourPointZero;

//----- (01264E40) --------------------------------------------------------
signed int __stdcall PerfPageWndProc(HWND hWnd, unsigned int uMsg, HDC wParam, CProcPerfInfo *pPageData)
{
  HWND v4; // ebx
  CProcPerfInfo *pSystemInfo1; // esi
  HICON v6; // ST50_4
  HWND v7; // eax
  CProcPerfInfo *pPerfInfo; // esi
  HANDLE hProc; // edi
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  signed int result; // eax
  HWND v14; // eax
  HANDLE hProcess; // edi
  void (__stdcall *SetDlgItemTextW)(HWND, int, LPCWSTR); // esi
  const WCHAR *v17; // eax
  const WCHAR *v18; // eax
  const WCHAR *v19; // eax
  const WCHAR *v20; // eax
  const WCHAR *v21; // eax
  const WCHAR *v22; // eax
  __m128i *v23; // eax
  const WCHAR *v24; // eax
  CProcPerfInfo *v25; // ecx
  const WCHAR *v26; // ST50_4
  const WCHAR *v27; // eax
  const WCHAR *v28; // ST50_4
  DWORD v29; // eax
  LPCWSTR v30; // eax
  DWORD v31; // eax
  const WCHAR *v32; // eax
  signed __int64 v33; // [esp+4Ch] [ebp-500h]
  PROCESS_BASIC_INFORMATION pbi; // [esp+60h] [ebp-4ECh]
  struct _FILETIME LocalFileTime; // [esp+78h] [ebp-4D4h]
  char v36; // [esp+80h] [ebp-4CCh]
  _DWORD v37[2]; // [esp+84h] [ebp-4C8h]
  char dwHandleCount2[4]; // [esp+8Ch] [ebp-4C0h]
  char dwHandleCount[4]; // [esp+90h] [ebp-4BCh]
  char v40[4]; // [esp+94h] [ebp-4B8h]
  char ArgList[4]; // [esp+98h] [ebp-4B4h]
  int nState; // [esp+9Ch] [ebp-4B0h]
  unsigned int v43; // [esp+A0h] [ebp-4ACh]
  DWORD v44; // [esp+A4h] [ebp-4A8h]
  HANDLE v45; // [esp+A8h] [ebp-4A4h]
  void *v46; // [esp+ACh] [ebp-4A0h]
  HWND hDlg; // [esp+B0h] [ebp-49Ch]
  ULONG ulRet; // [esp+B4h] [ebp-498h]
  CProcPerfInfo *v49; // [esp+B8h] [ebp-494h]
  struct _SYSTEMTIME SystemTime; // [esp+BCh] [ebp-490h]
  _VM_COUNTERS ProcessVmCounters; // [esp+CCh] [ebp-480h]
  _IO_COUNTERS IoCounters; // [esp+F8h] [ebp-454h]
  FILETIME FileTime[4]; // [esp+128h] [ebp-424h]
  __int16 DateStr[256]; // [esp+148h] [ebp-404h]
  __int16 strFormat[256]; // [esp+348h] [ebp-204h]

  v4 = hWnd;
  hDlg = hWnd;
  pSystemInfo1 = GetWindowLongW(hWnd, GWL_USERDATA);
  v46 = 0;
  v49 = pSystemInfo1;
  if ( uMsg <= WM_CTLCOLOREDIT )
  {
    if ( uMsg != WM_CTLCOLOREDIT )
    {
      switch ( uMsg )
      {
        case WM_KEYDOWN:
          if ( wParam != VK_F5 )
            return 0;
          PostMessageW(hWnd, WM_TIMER, 1u, 0);
          result = 0;
          break;
        case WM_INITDIALOG:
          ResizeTab(hWnd);
          v6 = LoadIconW(ghInstance, 0x6E);
          v7 = GetDlgItem(hWnd, IDC_SYSTEMINFOMEM_STATIC_STATIC20);
          SendMessageW(
            v7,
            IDC_SESSION_PROPERTIES_STATIC_CLIENT_DISPLAY_RESOLUTION|IDD_SYMBOLCONFIG_BUTTON_CANCEL|0x100,
            1u,
            v6);
          pPerfInfo = malloc(0x60u);
          v46 = pPerfInfo;
          pPerfInfo->PageInfo = pPageData;
          hProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pPageData->ProcessIoCounters.OtherOperationCount.HighPart);
          if ( hProc || (hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, *(pPerfInfo->PageInfo + 0x44))) != 0 )
          {
            NtQueryInformationProcess(hProc, ProcessVmCounters, &pPerfInfo->ProcessVmCounters, 44u, &ulRet);
            NtQueryInformationProcess(hProc, ProcessIoCounters, &pPerfInfo->ProcessIoCounters, 48u, &ulRet);
            if ( NtQueryInformationProcess(hProc, ProcessHandleCount, dwHandleCount, 8u, &ulRet) )
            {
              v10 = GetDlgItem(hWnd, IDD_PROCPERF_STATIC_PEAK_HANDLES);
              EnableWindow(v10, 0);
              v11 = GetDlgItem(hWnd, IDD_PROCPERF_STATIC_NA30);
              EnableWindow(v11, 0);
              pPerfInfo = v46;
            }
            CloseHandle(hProc);
          }
          if ( !QueryProcessCycleTime )
          {
            v12 = GetDlgItem(hWnd, IDD_PROCPERF_STATIC_CYCLES);
            SetWindowTextW(v12, L"Context Switch Delta");
          }
          SetWindowLongW(hWnd, GWL_USERDATA, pPerfInfo);
          SendMessageW(hWnd, WM_TIMER, 0, 0);
          result = 0;
          break;
        case WM_COMMAND:
          switch ( wParam )
          {
            case IDS_PROCEXPLORERMENU_EXIT:
              v33 = 40014i64;
              goto LABEL_18;
            case IDS_PROCEXPLORERMENU_REFRESH_NOW:
              SetEvent(ghEventRefreshSearchResult);
              result = 0;
              break;
            case IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT|0x8:
            case IDS_PROCEXPLORERMENU_SHOW_COLUMN_HEATMAPS|0x4:
              v33 = wParam;
LABEL_18:
              v14 = GetParent(hWnd);
              PostMessageW(v14, WM_COMMAND, v33, SHIDWORD(v33));
              result = 0;
              break;
            default:
              return 0;
          }
          break;
        case WM_TIMER:
          hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 0, *(pSystemInfo1->PageInfo + 68));
          v45 = hProcess;
          if ( hProcess
            || (hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, *(pSystemInfo1->PageInfo + 68)),
                (v45 = hProcess) != 0) )
          {
            SetDlgItemTextW = ::SetDlgItemTextW;
            if ( !NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, 0x18u, &ulRet) )
            {
              VLogEntry(strFormat, L"%d", pbi.Reserved2[1]);
              ::SetDlgItemTextW(hWnd, IDD_PROCPERF_STATIC_NA10, strFormat);
            }
            if ( !NtQueryInformationProcess(hProcess, ProcessTimes, FileTime, 0x20u, &ulRet) )
            {
              if ( FileTime[0] )
              {
                FileTimeToLocalFileTime(FileTime, &LocalFileTime);
                FileTimeToSystemTime(&LocalFileTime, &SystemTime);
                GetTimeFormatW(0x400u, 0, &SystemTime, 0, strFormat, 128);
                GetDateFormatW(0x400u, 0, &SystemTime, 0, DateStr, 128);
                wcscat_s(strFormat, 0x100u, L"   ");
                wcscat_s(strFormat, 0x100u, DateStr);
              }
              else
              {
                tcscpy_s(strFormat, 0x100u, L"n/a");
              }
              ::SetDlgItemTextW(hWnd, IDD_PROCINFO_EDITTEXT_EDIT11, strFormat);
              VLogEntry(
                strFormat,
                L"%I64d:%02I64d:%02I64d.%03I64d",
                *&FileTime[2] / 0x861C46800ui64,
                *&FileTime[2] / 0x23C34600ui64 % 0x3C,
                *&FileTime[2] / 10000000i64 % 60,
                *&FileTime[2] % 10000000i64 / 10000);
              ::SetDlgItemTextW(hDlg, IDD_PROCPERF_STATIC_NA7, strFormat);
              VLogEntry(
                strFormat,
                L"%I64d:%02I64d:%02I64d.%03I64d",
                *&FileTime[3] / 0x861C46800ui64,
                *&FileTime[3] / 0x23C34600ui64 % 0x3C,
                *&FileTime[3] / 10000000i64 % 60,
                *&FileTime[3] % 10000000i64 / 10000);
              ::SetDlgItemTextW(hDlg, IDD_PROCPERF_STATIC_NA8, strFormat);
              v44 = FileTime[2].dwLowDateTime + FileTime[3].dwLowDateTime;
              VLogEntry(
                strFormat,
                L"%I64d:%02I64d:%02I64d.%03I64d",
                (*&FileTime[2] + *&FileTime[3]) / 0x861C46800ui64,
                (*&FileTime[2] + *&FileTime[3]) / 0x23C34600ui64 % 0x3C,
                (*&FileTime[2] + *&FileTime[3]) / 0x989680ui64 % 0x3C,
                (*&FileTime[2] + *&FileTime[3]) % 0x989680ui64 / 0x2710);
              v4 = hDlg;
              SetDlgItemTextW = ::SetDlgItemTextW;
              ::SetDlgItemTextW(hDlg, IDD_PROCPERF_STATIC_NA9, strFormat);
              hProcess = v45;
            }
            if ( NtQueryInformationProcess(hProcess, ProcessIoCounters, &IoCounters, 0x30u, &ulRet) )
            {
              v23 = v49;

            }
            else
            {
              VLogEntry(strFormat, L"%I64d", IoCounters.ReadOperationCount.QuadPart);
              v17 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA1, v17);
              VLogEntry(
                strFormat,
                L"%I64d",
                IoCounters.ReadOperationCount.QuadPart - v49->ProcessIoCounters.ReadOperationCount.QuadPart);
              v18 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA4, v18);
              VLogEntry(strFormat, L"%I64d", IoCounters.WriteOperationCount.QuadPart);
              v19 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA2, v19);
              VLogEntry(
                strFormat,
                L"%I64d",
                IoCounters.WriteOperationCount.QuadPart - v49->ProcessIoCounters.WriteOperationCount.QuadPart);
              v20 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_HANDLEINFO_STATIC_STATIC1, v20);
              VLogEntry(strFormat, L"%I64d", IoCounters.OtherOperationCount.QuadPart);
              v21 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA3, v21);
              VLogEntry(
                strFormat,
                L"%I64d",
                IoCounters.OtherOperationCount.QuadPart - v49->ProcessIoCounters.OtherOperationCount.QuadPart);
              v22 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA5, v22);
              sub_1232200(
                0,
                strFormat,
                0x100u,
                COERCE__INT64((IoCounters.WriteTransferCount.QuadPart
                             - v49->ProcessIoCounters.WriteTransferCount.QuadPart)),
                0i64,
                0i64 >> 63);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA26, strFormat);
              sub_1232200(
                0,
                strFormat,
                0x100u,
                COERCE__INT64((IoCounters.ReadTransferCount.QuadPart - v49->ProcessIoCounters.ReadTransferCount.QuadPart)),
                0i64,
                0i64 >> 63);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA25, strFormat);
              sub_1232200(
                0,
                strFormat,
                0x100u,
                COERCE__INT64((IoCounters.OtherTransferCount.QuadPart
                             - v49->ProcessIoCounters.OtherTransferCount.QuadPart)),
                0i64,
                0i64 >> 63);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA27, strFormat);
              v23 = v49;
              _mm_storeu_si128(&v49->ProcessIoCounters, _mm_loadu_si128(&IoCounters));
              _mm_storeu_si128(v23 + 4, _mm_loadu_si128(&IoCounters.OtherOperationCount));
              _mm_storeu_si128(v23 + 5, _mm_loadu_si128(&IoCounters.WriteTransferCount));
            }
            if ( QueryProcessCycleTime )
            {
              QueryProcessCycleTime(hProcess, v37);
              VLogEntry(strFormat, L"%I64u", v37[0], v37[1]);
            }
            else
            {
              VLogEntry(strFormat, L"%I64d", *(v23->m128i_i32[0] + 1336));
            }
            v24 = GetNumberTextFormat(strFormat, 0x100u);
            SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA24, v24);
            if ( NtQueryInformationProcess(hProcess, PowerShutdownNotification, ArgList, 4u, &ulRet) )
              VLogEntry(strFormat, L"n/a");
            else
              VLogEntry(strFormat, L"%d", *ArgList);
            SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA28, strFormat);
            if ( NtQueryInformationProcess(hProcess, ProcessorIdleStates, &nState, 4u, &ulRet) )
              VLogEntry(strFormat, L"n/a");
            else
              sub_1277790(nState, strFormat, 0x100u);
            SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA29, strFormat);
            v45 = 0;
            sub_125EB20(hProcess, &v46, &v45, &v36, &v44, &v43, &hDlg);
            free(v46);
            VLogEntry(strFormat, L"%ld", v44 >> 10);
            GetNumberTextFormat(strFormat, 0x100u);
            wcscat_s(strFormat, 0x100u, L" K");
            SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA20, strFormat);
            VLogEntry(strFormat, L"%ld", hDlg >> 10);
            GetNumberTextFormat(strFormat, 0x100u);
            wcscat_s(strFormat, 0x100u, L" K");
            SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA22, strFormat);
            VLogEntry(strFormat, L"%ld", v43 >> 10);
            GetNumberTextFormat(strFormat, 0x100u);
            wcscat_s(strFormat, 0x100u, L" K");
            SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA21, strFormat);
            if ( !NtQueryInformationProcess(hProcess, ProcessVmCounters, &ProcessVmCounters, 0x2Cu, &ulRet) )
            {
              VLogEntry(strFormat, L"%ld", ProcessVmCounters.WorkingSetSize >> 10);
              GetNumberTextFormat(strFormat, 0x100u);
              wcscat_s(strFormat, 0x100u, L" K");
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA14, strFormat);
              VLogEntry(strFormat, L"%ld", ProcessVmCounters.PeakWorkingSetSize >> 10);
              GetNumberTextFormat(strFormat, 0x100u);
              wcscat_s(strFormat, 0x100u, L" K");
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA17, strFormat);
              VLogEntry(strFormat, L"%ld", ProcessVmCounters.PagefileUsage >> 10);
              GetNumberTextFormat(strFormat, 0x100u);
              wcscat_s(strFormat, 0x100u, L" K");
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA15, strFormat);
              VLogEntry(strFormat, L"%ld", ProcessVmCounters.PeakPagefileUsage >> 10);
              GetNumberTextFormat(strFormat, 0x100u);
              wcscat_s(strFormat, 0x100u, L" K");
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA16, strFormat);
              VLogEntry(strFormat, L"%I64u", ProcessVmCounters.VirtualSize >> 10, 0);
              GetNumberTextFormat(strFormat, 0x100u);
              wcscat_s(strFormat, 0x100u, L" K");
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA23, strFormat);
              VLogEntry(strFormat, L"%ld", ProcessVmCounters.PageFaultCount);
              GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA18, strFormat);
              VLogEntry(strFormat, L"%d", ProcessVmCounters.PageFaultCount - v49->ProcessVmCounters.PageFaultCount);
              GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA19, strFormat);
              v25 = v49;
              _mm_storeu_si128(&v49->ProcessVmCounters, _mm_loadu_si128(&ProcessVmCounters));
              _mm_storeu_si128(
                &v25->ProcessVmCounters.WorkingSetSize,
                _mm_loadu_si128(&ProcessVmCounters.WorkingSetSize));
              _mm_storel_epi64(
                &v25->ProcessVmCounters.QuotaNonPagedPoolUsage,
                _mm_loadl_epi64(&ProcessVmCounters.QuotaNonPagedPoolUsage));
              v25->ProcessVmCounters.PeakPagefileUsage = ProcessVmCounters.PeakPagefileUsage;
            }
            if ( NtQueryInformationProcess(hProcess, ProcessHandleCount, dwHandleCount, 8u, &ulRet) )
            {
              if ( !NtQueryInformationProcess(hProcess, ProcessHandleCount, dwHandleCount2, 4u, &ulRet) )
              {
                VLogEntry(strFormat, L"%d", *dwHandleCount2);
                v26 = GetNumberTextFormat(strFormat, 0x100u);
                SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA13, v26);
              }
            }
            else
            {
              VLogEntry(strFormat, L"%d", *dwHandleCount);
              v27 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA13, v27);
              VLogEntry(strFormat, L"%d", *v40);
              v28 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA30, v28);
            }
            if ( *GetGuiResources )
            {
              v29 = GetGuiResources(hProcess, 0);
              VLogEntry(strFormat, L"%d", v29);
              v30 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA11, v30);
              v31 = GetGuiResources(hProcess, 1u);
              VLogEntry(strFormat, L"%d", v31);
              v32 = GetNumberTextFormat(strFormat, 0x100u);
              SetDlgItemTextW(v4, IDD_PROCPERF_STATIC_NA12, v32);
            }
            CloseHandle(hProcess);
          }
          result = 1;
          break;
        default:
          return 0;
      }
      return result;
    }
    return sub_1246710(hWnd, wParam);
  }
  if ( uMsg == WM_CTLCOLORDLG || uMsg == WM_CTLCOLORSTATIC )
    return sub_1246710(hWnd, wParam);
  if ( uMsg == 0x7F1 )
  {
    free(pSystemInfo1);
    DestroyWindow(hWnd);
  }
  return 0;
}
// 12EF2E0: using guessed type int (__stdcall *QueryProcessCycleTime)(_DWORD, _DWORD);

//----- (01265E50) --------------------------------------------------------
int __stdcall ProcPerfETWWndProc(HWND hWnd, int a2, HDC hdc, int a4)
{
  void *v4; // eax
  void *v5; // ebx
  _DWORD *v6; // eax
  int result; // eax
  HWND v8; // eax
  const WCHAR *v9; // eax
  const WCHAR *v10; // eax
  const WCHAR *v11; // eax
  const WCHAR *v12; // eax
  const WCHAR *v13; // eax
  const WCHAR *v14; // eax
  const WCHAR *v15; // eax
  const WCHAR *v16; // eax
  const WCHAR *v17; // eax
  const WCHAR *v18; // eax
  const WCHAR *v19; // eax
  const WCHAR *v20; // eax
  signed __int64 v21; // [esp+10h] [ebp-218h]
  WCHAR String; // [esp+24h] [ebp-204h]

  v4 = GetWindowLongW(hWnd, -21);
  v5 = v4;
  if ( a2 <= 0x133 )
  {
    if ( a2 != 307 )
    {
      switch ( a2 )
      {
        case 256:
          if ( hdc != 116 )
            return 0;
          PostMessageW(hWnd, 0x113u, 1u, 0);
          result = 0;
          break;
        case 272:
          ResizeTab(hWnd);
          v6 = malloc(0x60u);
          *v6 = a4;
          SetWindowLongW(hWnd, -21, v6);
          SendMessageW(hWnd, 0x113u, 0, 0);
          result = 0;
          break;
        case 273:
          switch ( hdc )
          {
            case 0x9C41u:
              v21 = 40014i64;
              goto LABEL_11;
            case 0x9C42u:
              SetEvent(ghEventRefreshSearchResult);
              result = 0;
              break;
            case 0x9C9Cu:
            case 0x9C9Du:
              v21 = hdc;
LABEL_11:
              v8 = GetParent(hWnd);
              PostMessageW(v8, 0x111u, v21, SHIDWORD(v21));
              result = 0;
              break;
            default:
              return 0;
          }
          break;
        case 275:
          VLogEntry(&String, L"%u", *(*v4 + 1176));
          v9 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1186, v9);
          VLogEntry(&String, L"%u", *(*v5 + 1192));
          v10 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1048, v10);
          VLogEntry(&String, L"%u", *(*v5 + 1208));
          v11 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1187, v11);
          VLogEntry(&String, L"%u", *(*v5 + 1224));
          v12 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1053, v12);
          VLogEntry(&String, L"%u", *(*v5 + 1240));
          v13 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1047, v13);
          VLogEntry(&String, L"%u", *(*v5 + 1256));
          v14 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1052, v14);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1232)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1336, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1200)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1335, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1264)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1054, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1216)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1204, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1184)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1202, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1248)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1206, &String);
          VLogEntry(&String, L"%u", *(*v5 + 1072));
          v15 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1638, v15);
          VLogEntry(&String, L"%u", *(*v5 + 1088));
          v16 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1639, v16);
          VLogEntry(&String, L"%u", *(*v5 + 1104));
          v17 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1641, v17);
          VLogEntry(&String, L"%u", *(*v5 + 1120));
          v18 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1643, v18);
          VLogEntry(&String, L"%u", *(*v5 + 1136));
          v19 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1645, v19);
          VLogEntry(&String, L"%u", *(*v5 + 1152));
          v20 = GetNumberTextFormat(&String, 0x100u);
          SetDlgItemTextW(hWnd, 1646, v20);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1128)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1644, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1096)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1640, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1160)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1647, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1112)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1205, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1080)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1203, &String);
          sub_1232200(0, &String, 0x100u, COERCE__INT64(*(*v5 + 1144)), 0i64, 0i64 >> 63);
          SetDlgItemTextW(hWnd, 1207, &String);
          result = 1;
          break;
        default:
          return 0;
      }
      return result;
    }
    return sub_1246710(hWnd, hdc);
  }
  if ( a2 == 310 || a2 == 312 )
    return sub_1246710(hWnd, hdc);
  if ( a2 == 2033 )
  {
    free(v4);
    DestroyWindow(hWnd);
  }
  return 0;
}

//----- (012666A0) --------------------------------------------------------
// 显示进程属性对话框
BOOL __stdcall ProcessPropsheetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, CPropSheetDlg *pDlgProp)
{
  HWND hTabCtrl; // eax
  HWND hTab; // ebx
  CPropSheetDlg *pDlgSheet; // eax
  PROPPAGEDATA *pPageData; // edi
  HWND TabCount; // eax
  LRESULT nIndex; // eax
  CPropSheetDlg *v11; // ebx
  int v12; // esi
  CPropSheetDlg *PageData1; // edi
  BOOL (__stdcall *v14)(HWND, UINT, WPARAM, LPARAM); // ST14_4
  signed int MaxCount; // edi
  PROPPAGEDATA *PageData; // esi
  WPARAM nTab_1; // eax
  LRESULT v18; // eax
  WPARAM v19; // ecx
  int *v20; // eax
  CResize *pResizeDlg; // eax
  LONG dwExStyle; // eax
  LONG dwStyle; // eax
  const wchar_t *pszName; // ecx
  WPARAM nTab; // ebx
  WPARAM iTab; // esi
  WPARAM iiTab; // esi
  TREELISTITEMPARAM *pData; // eax
  WPARAM tab; // esi
  WPARAM tabidx; // esi
  HWND hTabWnd; // esi
  WPARAM nTabCount; // ebx
  CPropSheetDlg *pUserData; // eax
  int tabcount; // ebx
  int nItemCount; // esi
  int nCount; // esi
  int nTabIndex; // ebx
  CPropSheetDlg *processHandle; // eax
  TREELISTITEMPARAM *pTreeItemData; // ecx
  CPropSheetDlg *hProcessHandle; // esi
  bool v41; // zf
  TREELISTITEMPARAM *pTreeListItemData; // eax
  int nIndexTab; // esi
  int nIdxTab; // esi
  void *v45; // esi
  int nCurTab; // esi
  int nCurrentTab; // esi
  WPARAM nLastTab; // ST14_4
  TREELISTITEMPARAM *TreeListItemData; // eax
  HWND hWndTab; // esi
  int v51; // eax
  WPARAM v52; // ecx
  HCURSOR v53; // eax
  int v54; // [esp+0h] [ebp-274h]
  POINT Point; // [esp+10h] [ebp-264h]
  NMHDR nmhdr; // [esp+18h] [ebp-25Ch]
  TCITEMW item; // [esp+24h] [ebp-250h]
  HWND hWndDlg; // [esp+40h] [ebp-234h]
  HWND hWndTabCtrl; // [esp+44h] [ebp-230h]
  CPropSheetDlg *hObject; // [esp+48h] [ebp-22Ch]
  RECT Rect; // [esp+4Ch] [ebp-228h]
  TCHAR String[260]; // [esp+5Ch] [ebp-218h]
  int v63; // [esp+270h] [ebp-4h]

  hWndDlg = hDlg;
  hTabCtrl = GetDlgItem(hDlg, IDD_PROCPROPSHEET_CTRL_TABCTRL);
  hTab = hTabCtrl;
  hWndTabCtrl = hTabCtrl;
  pDlgSheet = GetWindowLongW(hDlg, GWL_USERDATA);
  hObject = pDlgSheet;
  if ( uMsg > WM_NOTIFY )
  {
    if ( uMsg == WM_INITDIALOG )
    {
      ShowWindow(hDlg, SW_HIDE);
      pResizeDlg = operator new(0x40u);
      hObject = pResizeDlg;
      v63 = 0;
      if ( pResizeDlg )
        CResize::CResize(pResizeDlg, hDlg);
      v63 = -1;
      SetWindowLongW(hDlg, GWL_USERDATA, pDlgProp);
      item.mask = 3;                            // TCIF_TEXT|TCIF_IMAGE
      item.iImage = -1;
      dwExStyle = GetWindowLongW(hTab, GWL_EXSTYLE);
      SetWindowLongW(hTab, GWL_EXSTYLE, dwExStyle | WS_EX_CONTROLPARENT);
      dwStyle = GetWindowLongW(hTab, GWL_STYLE);
      SetWindowLongW(hTab, GWL_STYLE, dwStyle | WS_CLIPCHILDREN);
      if ( pDlgProp->TreeListItemData )
      {
        InitTreeListItemColor(pDlgProp->TreeListItemData);
        item.pszText = L"Image";
        SendMessageW(hTab, TCM_INSERTITEMW, 0, &item);
        tcscpy_s(pDlgProp->PageData[1].TemplateName, 0x100u, L"PROCPERF");
        pDlgProp->PageData[1].TabId = 2;

        pDlgProp->PageData[1].PageWndProc = PerfPageWndProc;
        item.pszText = L"Performance";
        SendMessageW(hTab, TCM_INSERTITEMW, 1u, &item);
        pszName = L"PROCCPUIO";
        if ( !*(pDlgProp->TreeListItemData + 266) )
          pszName = L"PROCCPU";
        tcscpy_s(pDlgProp->PageData[2].TemplateName, 0x100u, pszName);
        pDlgProp->PageData[2].TabId = 4;
        pDlgProp->PageData[2].PageWndProc = PerfGraphPageWndProc;
        item.pszText = L"Performance Graph";
        SendMessageW(hTab, TCM_INSERTITEMW, 2u, &item);
        nTab = 3;
        if ( dword_12E5390 )
        {
          tcscpy_s(pDlgProp->PageData[3].TemplateName, 0x100u, L"PROCPERFETW");
          pDlgProp->PageData[3].TabId = 14;
          pDlgProp->PageData[3].PageWndProc = ProcPerfETWWndProc;
          item.pszText = L"Disk and Network";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, 3u, &item);
          nTab = 4;
        }
        if ( gdwAdapterRuntingTime )
        {
          iTab = nTab;
          tcscpy_s(pDlgProp->PageData[nTab].TemplateName, 0x100u, L"PROCGPU");
          pDlgProp->PageData[iTab].TabId = 15;
          pDlgProp->PageData[iTab].PageWndProc = ProcGPUWndProc;
          item.pszText = L"GPU Graph";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTab++, &item);
        }
        if ( *(pDlgProp->TreeListItemData + 40) & 0x20 )
        {
          iiTab = nTab;
          tcscpy_s(pDlgProp->PageData[nTab].TemplateName, 0x100u, L"PROCSERVICES");
          pDlgProp->PageData[iiTab].TabId = 5;
          pDlgProp->PageData[iiTab].PageWndProc = ProcServicesWndProc;
          item.pszText = L"Services";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTab++, &item);
        }
        pData = pDlgProp->TreeListItemData;
        if ( pData && pData[1].field_140[9] )
        {
          tab = nTab;
          tcscpy_s(pDlgProp->PageData[nTab].TemplateName, 0x100u, L"PROCWMIPROVIDERS");
          pDlgProp->PageData[tab].TabId = 16;
          pDlgProp->PageData[tab].PageWndProc = ProcWMIProvidersWndProc;
          item.pszText = L"WMI Providers";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTab++, &item);
        }
        tabidx = nTab;
        tcscpy_s(pDlgProp->PageData[nTab].TemplateName, 0x100u, L"PROCTHREADS");
        pDlgProp->PageData[tabidx].TabId = 6;
        pDlgProp->PageData[tabidx].PageWndProc = ProcThreadsWndProc;
        hTabWnd = hWndTabCtrl;
        item.pszText = L"Threads";
        SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTab, &item);
        nTabCount = nTab + 1;
        hObject = (pDlgProp + 0x20C * nTabCount);
        if ( AllocateAndGetUdpExTable2FromStack )
          tcscpy_s(hObject->PageData[0].TemplateName, 0x100u, L"PROCTCPUDPSTACK");
        else
          tcscpy_s(hObject->PageData[0].TemplateName, 0x100u, L"PROCTCPUDP");
        pUserData = hObject;
        item.pszText = L"TCP/IP";
        hObject->PageData[0].TabId = 7;
        pUserData->PageData[0].PageWndProc = ProcTcpUdpStackWndProc;
        SendMessageW(hTabWnd, TCM_INSERTITEMW, nTabCount, &item);
        tabcount = nTabCount + 1;
        nItemCount = tabcount;
        tcscpy_s(pDlgProp->PageData[tabcount].TemplateName, 0x100u, L"PROCSECURITY");
        pDlgProp->PageData[nItemCount].TabId = 8;
        pDlgProp->PageData[nItemCount].PageWndProc = ProcSecurityWndProc;
        item.pszText = L"Security";
        SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, tabcount++, &item);
        nCount = tabcount;
        tcscpy_s(pDlgProp->PageData[tabcount].TemplateName, 0x100u, L"PROCENV");
        pDlgProp->PageData[nCount].TabId = 9;
        pDlgProp->PageData[nCount].PageWndProc = ProcEnvWndProc;
        item.pszText = L"Environment";
        SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, tabcount, &item);
        nTabIndex = tabcount + 1;
        processHandle = PEOpenProcess(0x2000000u, 0, *(pDlgProp->TreeListItemData + 17));
        pTreeItemData = pDlgProp->TreeListItemData;
        hProcessHandle = processHandle;
        hObject = processHandle;
        v41 = sub_126DA70(processHandle, pTreeItemData->field_40[1], 0, 0) == 0;
        pTreeListItemData = pDlgProp->TreeListItemData;
        if ( v41 )
        {
          pTreeListItemData->t00[10] &= -0x801u;
        }
        else
        {
          pTreeListItemData->t00[10] |= 0x800u;
          nIndexTab = nTabIndex;
          tcscpy_s(pDlgProp->PageData[nTabIndex].TemplateName, 0x100u, L"PROCJOB");
          pDlgProp->PageData[nIndexTab].TabId = 10;
          pDlgProp->PageData[nIndexTab].PageWndProc = ProcJOBWndProc;
          item.pszText = L"Job";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTabIndex, &item);
          hProcessHandle = hObject;
          ++nTabIndex;
        }
        if ( hProcessHandle )
          CloseHandle(hProcessHandle);
        if ( sub_1230960(pDlgProp->TreeListItemData) )
        {
          nIdxTab = nTabIndex;
          tcscpy_s(pDlgProp->PageData[nTabIndex].TemplateName, 0x100u, L"PROCCLR");
          pDlgProp->PageData[nIdxTab].TabId = 11;
          pDlgProp->PageData[nIdxTab].PageWndProc = ProcCLRWndProc;
          item.pszText = L".NET Assemblies";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTabIndex++, &item);
          if ( !*(pDlgProp->TreeListItemData + 321) )
          {
            v45 = malloc(0x88u);
            memset(v45, 0, 0x88u);
            *(pDlgProp->TreeListItemData + 321) = v45;
          }
        }
        if ( *(pDlgProp->TreeListItemData + 321) )
        {
          CoInitialize(0);
          nCurTab = nTabIndex;
          tcscpy_s(pDlgProp->PageData[nTabIndex].TemplateName, 0x100u, L"PROCNET");
          pDlgProp->PageData[nCurTab].TabId = 12;
          pDlgProp->PageData[nCurTab].PageWndProc = ProcNetWndProc;
          item.pszText = L".NET Performance";
          SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nTabIndex++, &item);
        }
        nCurrentTab = nTabIndex;
        tcscpy_s(pDlgProp->PageData[nTabIndex].TemplateName, 0x100u, L"PROCSTRINGS");
        pDlgProp->PageData[nCurrentTab].TabId = 13;
        pDlgProp->PageData[nCurrentTab].PageWndProc = ProcStringsWndProc;
        item.pszText = L"Strings";
        nLastTab = nTabIndex;
        hTab = hWndTabCtrl;
        SendMessageW(hWndTabCtrl, TCM_INSERTITEMW, nLastTab, &item);
        TreeListItemData = pDlgProp->TreeListItemData;
        if ( TreeListItemData[1].field_140[8] )
        {
          stprintf(
            String,
            L"%s:%d (%s) Properties",
            TreeListItemData->t00[15],
            TreeListItemData->field_40[1],
            TreeListItemData[1].field_140[8]);
        }
        else if ( TreeListItemData->field_40[1] < 0 )
        {
          stprintf(String, L"%s Properties", TreeListItemData->t00[15]);
        }
        else
        {
          stprintf(String, L"%s:%d Properties", TreeListItemData->t00[15], TreeListItemData->field_40[1], v54);
        }
        hWndTab = hWndDlg;
        SetWindowTextW(hWndDlg, String);
        pDlgProp->PageData[0].hWnd = CreateDialogParamW(
                                       ghInstance2,
                                       L"PROCINFO",
                                       hWndTab,
                                       ProcInfoPageProc,
                                       pDlgProp->TreeListItemData);
        pDlgProp->PageData[0].TabId = 1;
      }
      else
      {
        hWndTab = hWndDlg;
      }
      ShowWindow(pDlgProp->PageData[0].hWnd, SW_SHOW);
      SetForegroundWindow(hWndTab);
      v51 = pDlgProp->PageData[0].TabId;
      v52 = 0;
      if ( v51 )
      {
        while ( gdwDefaultProcPropPage != v51 )
        {
          v51 = *(&pDlgProp->TabIndex + 131 * (++v52 + 1));
          if ( !v51 )
            goto LABEL_77;
        }
      }
      else
      {
LABEL_77:
        v52 = 0;
      }
      SendMessageW(hTab, TCM_SETCURSEL, v52, 0);
      nmhdr.idFrom = IDD_PROCPROPSHEET_CTRL_TABCTRL;
      nmhdr.code = TCN_SELCHANGE;
      SendMessageW(hWndTab, WM_NOTIFY, 0, &nmhdr);
      if ( gWindowPlacement[SysinfoWindowplacement].rcNormalPosition.right == gWindowPlacement[SysinfoWindowplacement].rcNormalPosition.left )
      {
        GetCursorPos(&Point);
        SetPropSheetRect(hWndTab, Point.x - 385, Point.y - 408);
      }
      else
      {
        sub_126DC50(hWndTab, pDlgProp->TreeListItemData);
      }
      ShowWindow(hWndTab, SW_SHOW);
      InterlockedDecrement(&gnLock);
      v53 = LoadCursorW(0, IDC_ARROW);
      SetCursor(v53);
      return 1;
    }
    if ( uMsg == 273 )
    {
      if ( wParam > 40092 )
      {
        if ( wParam == 40093 )
        {
          v18 = SendMessageW(hTab, TCM_GETCURSEL, 0, 0);
          v19 = v18 - 1;
          if ( !v18 )
          {
            v19 = 0;
            v20 = &hObject->PageData[1].PageWndProc;
            if ( hObject->PageData[1].PageWndProc )
            {
              do
              {
                v20 += 131;
                ++v19;
              }
              while ( *v20 );
            }
          }
          SendMessageW(hTab, TCM_SETCURSEL, v19, 0);
          nmhdr.idFrom = IDD_PROCPROPSHEET_CTRL_TABCTRL;
          nmhdr.code = -0x227u;                 // TCN_SELCHANGE
          SendMessageW(hDlg, WM_NOTIFY, 0, &nmhdr);
        }
      }
      else
      {
        if ( wParam == 40092 )
        {
          nTab_1 = SendMessageW(hTab, TCM_GETCURSEL, 0, 0) + 1;
          if ( !hObject->PageData[nTab_1].PageWndProc )
            nTab_1 = 0;
          SendMessageW(hTab, TCM_SETCURSEL, nTab_1, 0);
          nmhdr.idFrom = IDD_PROCPROPSHEET_CTRL_TABCTRL;
          nmhdr.code = TCN_SELCHANGE;
          SendMessageW(hWndDlg, WM_NOTIFY, 0, &nmhdr);
          return 0;
        }
        if ( wParam > 0 && (wParam <= 2 || wParam == 40014) )
        {
          ShowWindow(hDlg, 0);
          MaxCount = 32;
          PageData = hObject->PageData;
          while ( 1 )
          {
            if ( PageData->hWnd )
            {
              SendMessageW(PageData->hWnd, WM_COMMAND, wParam, 0);
              SendMessageW(PageData->hWnd, PMT_MSG_7F1, 0, 0);
            }
            ++PageData;
            if ( !--MaxCount )
            {
              // 通知主界面删除本TreeListItemData对象
              PostMessageW(ghWndNewOwner, PMT_MSG_7ED, 0, hObject->TreeListItemData);
              if ( *(hObject->TreeListItemData + 321) )
                CoUninitialize();
              free(hObject);
              GetWindowPlacement(hWndDlg, &gWindowPlacement[SysinfoWindowplacement]);
              DestroyWindow(hWndDlg);
              _endthread();
            }
          }
        }
      }
    }
    return 0;
  }
  if ( uMsg == WM_NOTIFY )
  {
    if ( pDlgProp->TreeListItemData == IDD_PROCPROPSHEET_CTRL_TABCTRL && pDlgProp->PageData[0].hWnd == -551 )
    {
      nIndex = SendMessageW(hTab, TCM_GETCURSEL, 0, 0);
      v11 = hObject;
      v12 = nIndex;
      PageData1 = (hObject + 0x20C * nIndex);
      hObject = PageData1;
      gdwDefaultProcPropPage = PageData1->PageData[0].TabId;
      ShowWindow(v11->PageData[v11->TabIndex].hWnd, SW_HIDE);
      v11->TabIndex = v12;
      if ( !PageData1->PageData[0].hWnd )
      {
        v14 = PageData1->PageData[0].PageWndProc;
        PageData1 = hObject;
        hObject->PageData[0].hWnd = CreateDialogParamW(
                                      ghInstance2,
                                      hObject->PageData[0].TemplateName,
                                      hWndDlg,
                                      v14,
                                      v11->TreeListItemData);
      }
      ShowWindow(PageData1->PageData[0].hWnd, SW_SHOW);
      return 0;
    }
    return 0;
  }
  if ( uMsg != WM_SIZE )
  {
    if ( uMsg == WM_GETMINMAXINFO )
    {
      pDlgProp->PageData[0].hWnd = 2 * gScreenWidth;
      return 0;
    }
    return 0;
  }
  // Handle WM_SIZE
  pPageData = pDlgSheet->PageData;
  TabCount = 32;
  hWndDlg = 32;
  do
  {
    if ( pPageData->hWnd )
    {
      GetWindowRect(hTab, &Rect);
      SendMessageW(hTab, TCM_ADJUSTRECT, 0, &Rect);
      MapWindowPoints(0, hDlg, &Rect, 2u);
      MoveWindow(pPageData->hWnd, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 1);
      InvalidateRect(pPageData->hWnd, 0, TRUE);
      TabCount = hWndDlg;
    }
    ++pPageData;
    TabCount = (TabCount - 1);
    hWndDlg = TabCount;
  }
  while ( TabCount );
  return 0;
}
// 128A009: using guessed type int _endthread(void);
// 12ACFEC: using guessed type wchar_t aEnvironment[12];
// 12C5168: using guessed type wchar_t aSecurity_0[9];
// 12C6390: using guessed type wchar_t aPerformance[12];
// 12C63A8: using guessed type wchar_t aProccpuio[10];
// 12C63CC: using guessed type wchar_t aPerformanceGra[18];
// 12C6408: using guessed type wchar_t aDiskAndNetwork[17];
// 12C643C: using guessed type wchar_t aGpuGraph[10];
// 12C646C: using guessed type wchar_t aServices_0[9];
// 12C64A4: using guessed type wchar_t aWmiProviders[14];
// 12C64D8: using guessed type wchar_t aThreads[8];
// 12C64E8: using guessed type wchar_t aProctcpudpstac[16];
// 12C6520: using guessed type wchar_t aTcpIp[7];
// 12C657C: using guessed type wchar_t aNetAssemblies[16];
// 12C65AC: using guessed type wchar_t aNetPerformance[17];
// 12C65E8: using guessed type wchar_t aStrings[8];
// 12E4E28: using guessed type int gScreenWidth;
// 12E5390: using guessed type int dword_12E5390;
// 12E96E8: using guessed type int gdwDefaultProcPropPage;
// 12EF300: using guessed type int (__stdcall *AllocateAndGetUdpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (01267240) --------------------------------------------------------
void __cdecl __noreturn ProcessPropSheetThreadProc(TREELISTITEMPARAM *pTreeListItemData)
{
  HCURSOR hCursor; // eax
  CPropSheetDlg *pPropSheet; // esi
  HWND hPropSheet; // ebx
  PROPPAGEDATA *v4; // edi
  HWND hWndAcc; // eax
  HWND hDlg; // esi
  DWORD res; // ebx
  HWND *hWnd; // esi
  signed int idx; // edi
  UINT v10; // eax
  struct tagMSG Msg; // [esp+Ch] [ebp-2Ch]
  HANDLE pHandles[2]; // [esp+28h] [ebp-10h]
  HACCEL hAccTable; // [esp+30h] [ebp-8h]
  CPropSheetDlg *pPropSheetCopy; // [esp+34h] [ebp-4h]
  TREELISTITEMPARAM *hWndProp; // [esp+40h] [ebp+8h]

  InterlockedIncrement(&gnLock);
  hCursor = LoadCursorW(0, IDC_APPSTARTING);
  SetCursor(hCursor);
  pPropSheet = malloc(16776u);
  pPropSheetCopy = pPropSheet;
  memset(pPropSheet, 0, 0x4188u);
  pPropSheet->TreeListItemData = pTreeListItemData;
  hPropSheet = CreateDialogParamW(ghInstance2, L"PROCPROPSHEET", ghWndNewOwner, ProcessPropsheetDlgProc, pPropSheet);
  hWndProp = hPropSheet;
  hAccTable = LoadAcceleratorsW(ghInstance2, L"PROCPROPERTIES");
  while ( !PeekMessageW(&Msg, 0, 0, 0, PM_REMOVE) )
  {
LABEL_15:
    pHandles[0] = ghEvent5;
    pHandles[1] = ghEvent6;
    res = MsgWaitForMultipleObjects(2u, pHandles, FALSE, INFINITE, QS_ALLINPUT);
    if ( res != 2 )
    {
      hWnd = pPropSheet->PageData;
      idx = 32;
      do
      {
        if ( *hWnd )
        {
          v10 = WM_USER;
          if ( !res )
            v10 = WM_TIMER;
          PostMessageW(*hWnd, v10, 1u, 0);
        }
        hWnd += 131;
        --idx;
      }
      while ( idx );
      pPropSheet = pPropSheetCopy;
    }
    hPropSheet = hWndProp;
  }
  while ( 1 )
  {
    v4 = (pPropSheet + 0x20C * pPropSheet->TabIndex);
    hWndAcc = *&v4->TemplateName[2];
    if ( hWndAcc && TranslateAcceleratorW(hWndAcc, hAccTable, &Msg) )
      goto LABEL_14;
    hDlg = GetPropW(hPropSheet, L"FindWindow");
    if ( !hDlg )
    {
LABEL_10:
      if ( !IsDialogMessageW(*&v4->TemplateName[2], &Msg) && !IsDialogMessageW(hPropSheet, &Msg) )
      {
        TranslateMessage(&Msg);
        DispatchMessageW(&Msg);
      }
      goto LABEL_13;
    }
    if ( IsDialogMessageW(hDlg, &Msg) )
    {
      if ( Msg.message != WM_COMMAND || LOWORD(Msg.wParam) != 40014 )
        goto LABEL_13;
    }
    else if ( Msg.message != WM_COMMAND || LOWORD(Msg.wParam) != 40014 )
    {
      goto LABEL_10;
    }
    PostMessageW(hDlg, WM_COMMAND, IDABORT, 0);
    SetPropW(hPropSheet, L"FindWindow", 0);
LABEL_13:
    pPropSheet = pPropSheetCopy;
LABEL_14:
    if ( !PeekMessageW(&Msg, 0, 0, 0, PM_REMOVE) )
      goto LABEL_15;
  }
}

//----- (01267440) --------------------------------------------------------
int __stdcall sub_1267440(volatile LONG *lpAddend)
{
  signed int v1; // edi
  HWND v2; // ST0C_4
  DWORD v3; // eax
  void *v4; // ST18_4
  PSID v5; // ST14_4
  DWORD v6; // eax
  HWND v7; // eax
  wchar_t *v8; // eax
  LPARAM v9; // ST18_4
  HWND v10; // eax
  HWND v11; // ST0C_4
  LPARAM lParam; // [esp+Ch] [ebp-46Ch]
  int v14; // [esp+10h] [ebp-468h]
  int v15; // [esp+14h] [ebp-464h]
  int v16; // [esp+2Ch] [ebp-44Ch]
  enum _SID_NAME_USE peUse; // [esp+40h] [ebp-438h]
  WPARAM wParam; // [esp+44h] [ebp-434h]
  DWORD v19; // [esp+48h] [ebp-430h]
  DWORD cchName; // [esp+4Ch] [ebp-42Ch]
  void *v21; // [esp+50h] [ebp-428h]
  DWORD cchReferencedDomainName; // [esp+54h] [ebp-424h]
  LRESULT v23; // [esp+58h] [ebp-420h]
  PSID Sid; // [esp+5Ch] [ebp-41Ch]
  int v25; // [esp+60h] [ebp-418h]
  WCHAR Name; // [esp+64h] [ebp-414h]
  WCHAR ReferencedDomainName; // [esp+26Ch] [ebp-20Ch]

  lParam = 0;
  memset(&v14, 0, 0x30u);
  EnterCriticalSection((lpAddend + 3));
  v1 = 0;
  v23 = SendMessageW(*(lpAddend + 9), 0x1004u, 0, 0);
  if ( v23 > 0 )
  {
    do
    {
      if ( *(lpAddend + 40) == 1 )
        break;
      lParam = 4;
      v2 = *(lpAddend + 9);
      v14 = v1;
      v15 = 0;
      if ( !SendMessageW(v2, 0x104Bu, 0, &lParam) )
        break;
      v25 = v16;
      v3 = GetLengthSid(*(v16 + 36));
      Sid = malloc(v3);
      v4 = *(v25 + 36);
      v5 = Sid;
      v6 = GetLengthSid(*(v25 + 36));
      CopySid(v6, v5, v4);
      LeaveCriticalSection((lpAddend + 3));
      cchName = 260;
      cchReferencedDomainName = 260;
      if ( LookupAccountSidW(
             gpszTargetName,
             Sid,
             &Name,
             &cchName,
             &ReferencedDomainName,
             &cchReferencedDomainName,
             &peUse) )
      {
        if ( ReferencedDomainName )
        {
          wcscat_s(&ReferencedDomainName, 0x104u, L"\\");
          wcscat_s(&ReferencedDomainName, 0x104u, &Name);
        }
        else
        {
          tcscpy_s(&ReferencedDomainName, 0x104u, &Name);
        }
        EnterCriticalSection((lpAddend + 3));
        if ( *(lpAddend + 40) )
          break;
        LeaveCriticalSection((lpAddend + 3));
        v7 = GetParent(*(lpAddend + 9));
        SendMessageW(v7, 0x7F7u, v1, &ReferencedDomainName);
        v21 = *(v25 + 40);
        v8 = _wcsdup(&ReferencedDomainName);
        *(v25 + 40) = v8;
        if ( v21 )
          free(v21);
      }
      EnterCriticalSection((lpAddend + 3));
      free(Sid);
      ++v1;
    }
    while ( v1 < v23 );
  }
  v9 = *(lpAddend + 9);
  v10 = GetParent(*(lpAddend + 9));
  SendMessageW(v10, 0x7F6u, 0, v9);
  LeaveCriticalSection((lpAddend + 3));
  SendMessageW(*(lpAddend + 9), 0x101Eu, 0, 0xFFFF);
  if ( !InterlockedDecrement(lpAddend) )
  {
    DeleteCriticalSection((lpAddend + 3));
    free(lpAddend);
  }
  InvalidateRect(*(lpAddend + 9), 0, 0);
  v19 = gdwSortableColumnVector[23];
  v11 = *(lpAddend + 9);
  wParam = 1040;
  SendMessageW(v11, 0x1030u, &wParam, TreeListSort);
  return 0;
}

//----- (01267710) --------------------------------------------------------
int __stdcall ProcSecurityWndProc(HWND hWnd, int uMsg, WPARAM arg8, int a4)
{
  LONG v4; // ebx
  CResize *v5; // eax
  CResize *v6; // esi
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  ResizeInfo *v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  HWND v17; // eax
  HICON v18; // ST24_4
  HWND v19; // eax
  HICON v20; // ST24_4
  HWND v21; // eax
  HWND v22; // edi
  LONG v23; // eax
  HWND v24; // eax
  _IMAGELIST *v25; // edi
  HICON v26; // eax
  HICON v27; // eax
  HWND v28; // esi
  LONG v29; // eax
  LRESULT (__stdcall *v30)(HWND, UINT, WPARAM, LPARAM); // ebx
  HWND v31; // esi
  HWND v32; // edi
  LONG v33; // eax
  HWND v34; // eax
  void *v35; // esi
  HWND v36; // eax
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // esi
  const WCHAR *v41; // esi
  const WCHAR *v42; // eax
  unsigned __int8 v43; // cl
  void (__stdcall *v44)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD); // ebx
  DWORD (__stdcall *v45)(); // esi
  unsigned int v46; // eax
  TOKEN_INFORMATION_CLASS v47; // edi
  DWORD v48; // esi
  _DWORD *v49; // ebx
  bool v50; // zf
  _DWORD *v51; // esi
  void *v52; // edi
  _DWORD *v53; // ebx
  DWORD v54; // eax
  void *v55; // eax
  void *v56; // ST20_4
  DWORD v57; // eax
  DWORD v58; // esi
  PSID *v59; // edi
  void *v60; // eax
  int v61; // ebx
  DWORD v62; // eax
  void *v63; // eax
  PSID v64; // ST24_4
  void *v65; // ST20_4
  DWORD v66; // eax
  HWND v67; // esi
  LRESULT v68; // eax
  wchar_t *v69; // eax
  DWORD v70; // esi
  DWORD v71; // esi
  void **v72; // edi
  void **v73; // ecx
  void *v74; // esi
  _DWORD *v75; // edi
  DWORD v76; // eax
  void *v77; // eax
  void *v78; // ST20_4
  DWORD v79; // eax
  HWND v80; // esi
  LRESULT v81; // eax
  wchar_t *v82; // eax
  unsigned int v83; // ecx
  char *v84; // eax
  int v85; // edi
  DWORD v86; // esi
  HWND v87; // eax
  HWND v88; // esi
  HWND v89; // esi
  HWND v90; // eax
  HWND v91; // edi
  HWND v93; // eax
  HWND v94; // ebx
  int v95; // eax
  HWND v96; // ST18_4
  HWND v97; // ST18_4
  WPARAM v98; // [esp-8h] [ebp-1C10h]
  WCHAR *v99; // [esp-4h] [ebp-1C0Ch]
  DWORD v100; // [esp+0h] [ebp-1C08h]
  LPARAM v101; // [esp+4h] [ebp-1C04h]
  LPARAM v102; // [esp+10h] [ebp-1BF8h]
  int v103; // [esp+18h] [ebp-1BF0h]
  HWND v104; // [esp+24h] [ebp-1BE4h]
  int uIDs; // [esp+44h] [ebp-1BC4h]
  int v106; // [esp+48h] [ebp-1BC0h]
  int Indent; // [esp+4Ch] [ebp-1BBCh]
  int v108; // [esp+50h] [ebp-1BB8h]
  WPARAM wParam; // [esp+54h] [ebp-1BB4h]
  DWORD v110; // [esp+58h] [ebp-1BB0h]
  DWORD ReturnLength; // [esp+5Ch] [ebp-1BACh]
  DWORD cchName; // [esp+60h] [ebp-1BA8h]
  enum _SID_NAME_USE peUse; // [esp+64h] [ebp-1BA4h]
  int nWidths; // [esp+68h] [ebp-1BA0h]
  int a3; // [esp+6Ch] [ebp-1B9Ch]
  DWORD cchReferencedDomainName; // [esp+70h] [ebp-1B98h]
  HWND v117; // [esp+74h] [ebp-1B94h]
  LPARAM lParam; // [esp+78h] [ebp-1B90h]
  DWORD v119; // [esp+7Ch] [ebp-1B8Ch]
  int v120; // [esp+80h] [ebp-1B88h]
  int v121; // [esp+84h] [ebp-1B84h]
  int v122; // [esp+88h] [ebp-1B80h]
  wchar_t *v123; // [esp+8Ch] [ebp-1B7Ch]
  int v124; // [esp+94h] [ebp-1B74h]
  _DWORD *v125; // [esp+98h] [ebp-1B70h]
  unsigned int v126; // [esp+ACh] [ebp-1B5Ch]
  HANDLE InBuffer; // [esp+B0h] [ebp-1B58h]
  int v128; // [esp+B4h] [ebp-1B54h]
  LPVOID v129; // [esp+B8h] [ebp-1B50h]
  HWND v130; // [esp+BCh] [ebp-1B4Ch]
  DWORD BytesReturned; // [esp+C0h] [ebp-1B48h]
  DWORD cbSid; // [esp+C4h] [ebp-1B44h]
  DWORD TokenInformationLength; // [esp+C8h] [ebp-1B40h]
  HANDLE OutBuffer; // [esp+CCh] [ebp-1B3Ch]
  HWND hDlg; // [esp+D0h] [ebp-1B38h]
  HWND v136; // [esp+D4h] [ebp-1B34h]
  char a2; // [esp+D8h] [ebp-1B30h]
  DWORD v138; // [esp+FCh] [ebp-1B0Ch]
  int v139; // [esp+100h] [ebp-1B08h]
  HANDLE v140; // [esp+104h] [ebp-1B04h]
  wchar_t v141; // [esp+110h] [ebp-1AF8h]
  wchar_t v142; // [esp+190h] [ebp-1A78h]
  char TokenInformation; // [esp+1198h] [ebp-A70h]
  int v144; // [esp+11A0h] [ebp-A68h]
  int v145; // [esp+11A4h] [ebp-A64h]
  WCHAR Name; // [esp+11D0h] [ebp-A38h]
  WCHAR ReferencedDomainName; // [esp+13D8h] [ebp-830h]
  wchar_t v148; // [esp+15E0h] [ebp-628h]
  WCHAR String; // [esp+17E8h] [ebp-420h]
  wchar_t Dst; // [esp+19F0h] [ebp-218h]
  int v151; // [esp+1C04h] [ebp-4h]

  hDlg = hWnd;
  v136 = a4;
  OutBuffer = 0;
  v4 = GetWindowLongW(hWnd, -21);
  lParam = 0;
  v128 = v4;
  memset(&v119, 0, 0x30u);
  Indent = 1046;
  v108 = 1049;
  LOWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  uIDs = 1047;
  v106 = 1051;
  LOWORD(nWidths) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(nWidths) = MulDiv(100, gLogPixelsX, 96);
  if ( uMsg <= 0x133 )
  {
    if ( uMsg != 307 )
    {
      switch ( uMsg )
      {
        case 43:
          FindDlg_DrawItem(v136);
          return 0;
        case 44:
          return HandleMeasureItem(hWnd, uMsg, arg8, v136);
        case 78:
          v94 = v136;
          v95 = *(v136 + 2);
          if ( v95 == -108 )
            return OnTreeListColumnClick(arg8, v136, v100, v101);
          if ( v95 == -101 || v95 == -2 )
          {
            v96 = *v136;
            lParam = 4;
            v119 = SendMessageW(v96, 0x100Cu, 0xFFFFFFFF, 2);
            v97 = *v94;
            v120 = 0;
            if ( SendMessageW(v97, 0x104Bu, 0, &lParam) && v125 > 1 )
            {
              if ( *v94 == GetDlgItem(hWnd, 1040) )
              {
                cbSid = 260;
                FormatSID(v125[9], &String, &cbSid);
                SetDlgItemTextW(hWnd, 1342, &String);
              }
              else
              {
                GetDlgItem(hWnd, 1038);
              }
            }
          }
          return 0;
        case 272:
          v5 = operator new(0x40u);
          BytesReturned = v5;
          v151 = 0;
          if ( v5 )
            v6 = CResize::CResize(v5, hWnd);
          else
            v6 = 0;
          v151 = -1;
          v7 = GetDlgItem(hWnd, 1337);
          if ( v7 )
            CResize::InitResizeBuffer(v6, v7, 1)->d1 = 0i64;
          v8 = GetDlgItem(hWnd, 1669);
          if ( v8 )
            CResize::InitResizeBuffer(v6, v8, 1)->d1 = 0i64;
          v9 = GetDlgItem(hWnd, 1668);
          if ( v9 )
            CResize::InitResizeBuffer(v6, v9, 1)->d1 = 0i64;
          v10 = GetDlgItem(hWnd, 1057);
          if ( v10 )
            CResize::InitResizeBuffer(v6, v10, 1)->d1 = 0i64;
          v11 = GetDlgItem(hWnd, 1040);
          if ( v11 )
          {
            v12 = CResize::InitResizeBuffer(v6, v11, 1);
            *&v12->d21.left = 0i64;
            *&v12->d21.right = doubleOnePointZero;
          }
          v13 = GetDlgItem(hWnd, 1342);
          if ( v13 )
            CResize::InitResizeBuffer(v6, v13, 1)->d21 = xmmword_12C6C70;
          v14 = GetDlgItem(hWnd, 1346);
          if ( v14 )
            CResize::InitResizeBuffer(v6, v14, 1)->d21 = xmmword_12C6C70;
          v15 = GetDlgItem(hWnd, 1128);
          if ( v15 )
            CResize::InitResizeBuffer(v6, v15, 1)->d21 = xmmword_12C6C70;
          v16 = GetDlgItem(hWnd, 1038);
          if ( v16 )
            CResize::InitResizeBuffer(v6, v16, 1)->d21 = xmmword_12C6C70;
          v17 = GetDlgItem(hWnd, 1038);
          if ( v17 )
            CResize::InitResizeBuffer(v6, v17, 1)->d21 = xmmword_12C6C70;
          ResizeTab(hWnd);
          v18 = LoadIconW(ghInstance, 0x70);
          v19 = GetDlgItem(hWnd, 1127);
          SendMessageW(v19, 0x172u, 1u, v18);
          v20 = LoadIconW(ghInstance, 0x6F);
          v21 = GetDlgItem(hWnd, 1128);
          SendMessageW(v21, 0x172u, 1u, v20);
          SetDlgItemTextW(hWnd, 1342, L"n/a");
          SetDlgItemTextW(hDlg, 1057, L"n/a");
          v22 = GetDlgItem(hDlg, 1040);
          v130 = v22;
          v23 = GetWindowLongW(v22, -16);
          SetWindowLongW(v22, -16, v23 & 0xFFFFFFFD | 1);
          SendMessageW(v22, 0x1036u, 0x4020u, 16416);
          v24 = SendMessageW(v22, 0x104Eu, 0, 0);
          InitToolTips(v24);
          OldListCtrlWndProc = SetWindowLongW(v22, -4, PEListCtrlWndProc);
          SendMessageW(v22, 0x30u, ghDefaultFont, 0);
          InitListCtrl(v22, &Indent, &a3, 2);
          v25 = ImageList_Create(16, 16, 1u, 256, 256);
          v26 = LoadIconW(ghInstance, 0xCB);
          ImageList_ReplaceIcon(v25, -1, v26);
          v27 = LoadIconW(ghInstance, 0x71);
          ImageList_ReplaceIcon(v25, -1, v27);
          v28 = v130;
          v29 = GetWindowLongW(v130, -16);
          SetWindowLongW(v28, -16, v29 | 0x40);
          v30 = SendMessageW;
          SendMessageW(v28, 0x1003u, 1u, v25);
          InitTreeListSortableHeader(
            v28,
            gdwSortableColumnVector[23],
            gdwSortableColumnVector[23],
            gbProcessSecurityUserListSortAscending);
          v31 = hDlg;
          v32 = GetDlgItem(hDlg, 1038);
          v117 = v32;
          v33 = GetWindowLongW(v32, -16);
          SetWindowLongW(v32, -16, v33 & 0xFFFFFFFD | 1);
          SendMessageW(v32, 0x1036u, 0x4020u, 16416);
          v34 = SendMessageW(v32, 0x104Eu, 0, 0);
          InitToolTips(v34);
          OldListCtrlWndProc = SetWindowLongW(v32, -4, PEListCtrlWndProc);
          SendMessageW(v32, 0x30u, ghDefaultFont, 0);
          InitListCtrl(v32, &uIDs, &nWidths, 2);
          SetDlgItemTextW(v31, 19, *(v136 + 22));
          cbSid = 0;
          cchReferencedDomainName = 0;
          LookupAccountNameW(0, *(v136 + 22), 0, &cbSid, &ReferencedDomainName, &cchReferencedDomainName, &peUse);
          if ( cbSid )
          {
            v35 = malloc(cbSid);
            LookupAccountNameW(0, *(v136 + 22), v35, &cbSid, &ReferencedDomainName, &cchReferencedDomainName, &peUse);
            cbSid = 260;
            FormatSID(v35, &String, &cbSid);
            free(v35);
            v31 = hDlg;
          }
          else
          {
            stprintf(&String, L"n/a");
          }
          SetDlgItemTextW(v31, 20, &String);
          if ( *(v136 + 25) == -1 )
            stprintf(&String, L"n/a");
          else
            stprintf(&String, L"%d", *(v136 + 25));
          SetDlgItemTextW(v31, 1056, &String);
          if ( gdwOsType >= 1 )
          {
            v41 = L"Yes";
            v42 = L"Yes";
            if ( !(*(v136 + 40) & 0x200) )
              v42 = L"No";
            SetDlgItemTextW(hDlg, 1337, v42);
            if ( *(v136 + 40) & 0x400 && gdwOsType >= 3 )
            {
              v43 = *(v136 + 649);
              Name = 0;
              if ( (v43 & 0xF0u) < 0x70 )
                wcscat_s(&Name, 0x104u, &aPsprotectedsig[64 * (v43 >> 4)]);
              if ( (*(v136 + 649) & 7) == 1 )
                wcscat_s(&Name, 0x104u, L"-Light");
              v99 = &Name;
            }
            else
            {
              if ( !(*(v136 + 40) & 0x400) )
                v41 = L"No";
              v99 = v41;
            }
            v40 = hDlg;
            SetDlgItemTextW(hDlg, 1668, v99);
          }
          else
          {
            v36 = GetDlgItem(v31, 1335);
            ShowWindow(v36, 0);
            v37 = GetDlgItem(hDlg, 1337);
            ShowWindow(v37, 0);
            v38 = GetDlgItem(hDlg, 1669);
            ShowWindow(v38, 0);
            v39 = GetDlgItem(hDlg, 1668);
            ShowWindow(v39, 0);
            v40 = hDlg;
          }
          InBuffer = PEOpenProcess(0x400u, 0, *(v136 + 17));
          if ( InBuffer )
          {
            if ( !DeviceIoControl(theDriver, 0x8335000C, &InBuffer, 4u, &OutBuffer, 4u, &BytesReturned, 0) )
              OpenProcessToken(InBuffer, 8u, &OutBuffer);
            if ( OutBuffer )
            {
              v44 = GetTokenInformation;
              v145 = 0;
              v144 = 0;
              ReturnLength = 56;
              GetTokenInformation(OutBuffer, TokenStatistics, &TokenInformation, 0x38u, &ReturnLength);
              swprintf_s(&String, 0x104u, L"%x", v144, v145);
              SetDlgItemTextW(v40, 1057, &String);
              v45 = GetLastError;
              v46 = 0;
              v128 = 0;
              do
              {
                v47 = 11;
                if ( !v46 )
                  v47 = 2;
                v44(OutBuffer, v47, 0, 0, &TokenInformationLength);
                if ( v45() == 122 )
                {
                  v48 = TokenInformationLength;
                  v49 = malloc(TokenInformationLength);
                  v129 = v49;
                  if ( GetTokenInformation(OutBuffer, v47, v49, v48, &TokenInformationLength) )
                  {
                    v50 = *v49 == 0;
                    v126 = 0;
                    if ( !v50 )
                    {
                      v51 = v49 + 2;
                      do
                      {
                        v52 = *(v51 - 1);
                        v53 = malloc(0x34u);
                        memset(v53, 0, 0x34u);
                        v53[11] = *v51;
                        v54 = GetLengthSid(v52);
                        v55 = malloc(v54);
                        v53[9] = v55;
                        v56 = v55;
                        v57 = GetLengthSid(v52);
                        CopySid(v57, v56, v52);
                        FormatSID(v52, &String, &cbSid);
                        if ( *GetSidSubAuthority(v52, 0) != 5 || *GetSidSubAuthority(v52, 1u) )
                          stprintf(&ReferencedDomainName, L"%s", &String);
                        else
                          stprintf(&ReferencedDomainName, L"Logon SID (%s)", &String);
                        v123 = &ReferencedDomainName;
                        lParam = 5;
                        v119 = 0x7FFFFFFF;
                        v120 = 0;
                        v121 = 0;
                        v122 = 0;
                        v124 = 0;
                        v125 = v53;
                        BytesReturned = SendMessageW(v130, 0x104Du, 0, &lParam);
                        if ( BytesReturned == -1 )
                          return 0;
                        Dst = 0;
                        if ( *v51 & 0x10 )
                          tcscpy_s(&Dst, 0x104u, L"Deny");
                        if ( *v51 & 0x20000000 )
                        {
                          if ( Dst )
                            wcscat_s(&Dst, 0x104u, L", ");
                          wcscat_s(&Dst, 0x104u, L"Domain-Local");
                        }
                        if ( *v51 & 1 && !(*v51 & 8) )
                        {
                          if ( Dst )
                            wcscat_s(&Dst, 0x104u, L", ");
                          wcscat_s(&Dst, 0x104u, L"Mandatory");
                        }
                        if ( *v51 & 8 )
                        {
                          if ( Dst )
                            wcscat_s(&Dst, 0x104u, L", ");
                          wcscat_s(&Dst, 0x104u, L"Owner");
                        }
                        if ( *v51 & 0x20 )
                        {
                          if ( Dst )
                            wcscat_s(&Dst, 0x104u, L", ");
                          if ( *v51 & 0x40 )
                            wcscat_s(&Dst, 0x104u, L"Integrity");
                          else
                            wcscat_s(&Dst, 0x104u, L"DesktopIntegrity");
                        }
                        if ( v128 == 1 )
                        {
                          if ( Dst )
                            wcscat_s(&Dst, 0x104u, L", ");
                          wcscat_s(&Dst, 0x104u, L"Restricted");
                        }
                        v119 = BytesReturned;
                        v123 = &Dst;
                        lParam = 1;
                        v120 = 1;
                        SendMessageW(v130, 0x104Cu, 0, &lParam);
                        v53[10] = _wcsdup(&ReferencedDomainName);
                        v53[12] = _wcsdup(&Dst);
                        v51 += 2;
                        v49 = v129;
                        ++v126;
                      }
                      while ( v126 < *v129 );
                    }
                  }
                  free(v49);
                  v44 = GetTokenInformation;
                  v45 = GetLastError;
                }
                v46 = v128 + 1;
                v128 = v46;
              }
              while ( v46 < 2 );
              v44(OutBuffer, MaxTokenInfoClass|TokenGroups, 0, 0, &TokenInformationLength);
              if ( v45() == 122 )
              {
                v58 = TokenInformationLength;
                v59 = malloc(TokenInformationLength);
                if ( (v44)(OutBuffer, MaxTokenInfoClass|TokenGroups, v59, v58, &TokenInformationLength) && *v59 )
                {
                  v60 = malloc(0x34u);
                  v61 = v60;
                  BytesReturned = v60;
                  memset(v60, 0, 0x34u);
                  v62 = GetLengthSid(*v59);
                  v63 = malloc(v62);
                  *(v61 + 36) = v63;
                  v64 = *v59;
                  v65 = v63;
                  v66 = GetLengthSid(*v59);
                  CopySid(v66, v65, v64);
                  FormatSID(*v59, &String, &cbSid);
                  v67 = v130;
                  v123 = &String;
                  v125 = v61;
                  v30 = SendMessageW;
                  lParam = 5;
                  v119 = 0x7FFFFFFF;
                  v120 = 0;
                  v121 = 0;
                  v122 = 0;
                  v124 = 0;
                  v68 = SendMessageW(v130, 0x104Du, 0, &lParam);
                  if ( v68 == -1 )
                    return 0;
                  v119 = v68;
                  lParam = 1;
                  v120 = 1;
                  v123 = L"AppContainer";
                  SendMessageW(v67, 0x104Cu, 0, &lParam);
                  v69 = _wcsdup(&String);
                  v70 = BytesReturned;
                  *(BytesReturned + 40) = v69;
                  *(v70 + 48) = _wcsdup(v123);
                  free(v59);
                  v45 = GetLastError;
                }
                else
                {
                  v30 = SendMessageW;
                  free(v59);
                  v45 = GetLastError;
                }
              }
              else
              {
                v30 = SendMessageW;
              }
              GetTokenInformation(OutBuffer, TokenLogonSid|TokenGroups, v129, 0, &TokenInformationLength);
              if ( v45() == 122 )
              {
                v71 = TokenInformationLength;
                v72 = malloc(TokenInformationLength);
                BytesReturned = v72;
                if ( GetTokenInformation(OutBuffer, TokenLogonSid|TokenGroups, v72, v71, &TokenInformationLength) )
                {
                  v50 = *v72 == 0;
                  v129 = 0;
                  if ( !v50 )
                  {
                    v73 = v72 + 1;
                    v126 = (v72 + 1);
                    do
                    {
                      v74 = *v73;
                      v75 = malloc(0x34u);
                      memset(v75, 0, 0x34u);
                      v76 = GetLengthSid(v74);
                      v77 = malloc(v76);
                      v75[9] = v77;
                      v78 = v77;
                      v79 = GetLengthSid(v74);
                      CopySid(v79, v78, v74);
                      FormatSID(v74, &String, &cbSid);
                      v80 = v130;
                      v123 = &String;
                      lParam = 5;
                      v119 = 0x7FFFFFFF;
                      v120 = 0;
                      v121 = 0;
                      v122 = 0;
                      v124 = 0;
                      v125 = v75;
                      v81 = v30(v130, 0x104Du, 0, &lParam);
                      if ( v81 == -1 )
                        return 0;
                      v119 = v81;
                      lParam = 1;
                      v120 = 1;
                      v123 = L"Capability";
                      v30(v80, 0x104Cu, 0, &lParam);
                      v75[10] = _wcsdup(&String);
                      v82 = _wcsdup(v123);
                      v83 = v126;
                      v75[12] = v82;
                      v73 = (v83 + 8);
                      v72 = BytesReturned;
                      v129 = v129 + 1;
                      v126 = v73;
                    }
                    while ( v129 < *BytesReturned );
                  }
                }
                free(v72);
              }
              v84 = malloc(0x2Cu);
              v85 = v84;
              *(v84 + 1) = v136;
              *(v84 + 9) = v130;
              *v84 = 2;
              v84[40] = 0;
              InitializeCriticalSection((v84 + 12));
              *(v85 + 8) = _beginthreadex(0, 0, sub_1267440, v85, 0, 0);
              SetWindowLongW(hDlg, -21, v85);
              GetTokenInformation(OutBuffer, TokenPrivileges, 0, 0, &TokenInformationLength);
              v86 = TokenInformationLength;
              v136 = malloc(TokenInformationLength);
              v50 = GetTokenInformation(OutBuffer, TokenPrivileges, v136, v86, &TokenInformationLength) == 0;
              v87 = v136;
              if ( !v50 )
              {
                v50 = *v136 == 0;
                v129 = 0;
                if ( !v50 )
                {
                  v88 = v136 + 3;
                  do
                  {
                    cchName = 260;
                    if ( LookupPrivilegeNameW(0, v88 - 1, &Name, &cchName) )
                    {
                      lParam = 5;
                      v123 = &Name;
                      v119 = 0x7FFFFFFF;
                      v120 = 0;
                      v121 = 0;
                      v122 = 0;
                      v124 = 0;
                      v125 = 1;
                      BytesReturned = v30(v117, 0x104Du, 0, &lParam);
                      if ( BytesReturned == -1 )
                        return 0;
                      v148 = 0;
                      if ( *v88 & 2 )
                        tcscpy_s(&v148, 0x104u, L"Enabled");
                      else
                        tcscpy_s(&v148, 0x104u, L"Disabled");
                      if ( *v88 & 1 )
                      {
                        if ( v148 )
                          wcscat_s(&v148, 0x104u, L", ");
                        tcscpy_s(&v148, 0x104u, L"Default Enabled");
                      }
                      v119 = BytesReturned;
                      v123 = &v148;
                      lParam = 1;
                      v120 = 1;
                      v30(v117, 0x104Cu, 0, &lParam);
                    }
                    v88 += 3;
                    v129 = v129 + 1;
                  }
                  while ( v129 < *v136 );
                  v87 = v136;
                }
              }
              free(v87);
              CloseHandle(OutBuffer);
              CloseHandle(InBuffer);
              v89 = v130;
            }
            else
            {
              v85 = v128;
              CloseHandle(InBuffer);
              v89 = v130;
            }
          }
          else
          {
            v89 = v130;
            if ( *(v136 + 40) & 0x400 )
            {
              lParam = 5;
              v119 = 0x7FFFFFFF;
              v120 = 0;
              v121 = 0;
              v122 = 0;
              v123 = L"Error: Process is Protected";
              v124 = 0;
              v125 = 1;
              if ( SendMessageW(v130, 0x104Du, 0, &lParam) == -1 )
                return 0;
            }
            v85 = v128;
          }
          if ( !v85 )
          {
            v90 = GetDlgItem(hDlg, 1210);
            EnableWindow(v90, 0);
          }
          InvalidateRect(v89, 0, 0);
          v110 = gdwSortableColumnVector[23];
          wParam = 1040;
          v30(v89, 0x1030u, &wParam, TreeListSort);
          v91 = v117;
          v30(v117, 0x101Eu, 0, 0xFFFF);
          v30(v91, 0x101Eu, 1u, 65534);
          v30(v89, 0x101Eu, 0, 0xFFFF);
          v30(v89, 0x101Eu, 1u, 65534);
          return 1;
        case 273:
          if ( arg8 > 40001 )
          {
            if ( arg8 - 40092 > 1 )
              return 0;
            v98 = arg8;
          }
          else
          {
            if ( arg8 != 40001 )
            {
              if ( arg8 == 1210 )
              {
                InBuffer = OpenProcess(0xE0000u, 0, *(*(v4 + 4) + 68));
                if ( InBuffer || (InBuffer = OpenProcess(0x20000u, 0, *(*(v4 + 4) + 68))) != 0 )
                {
                  memset(&a2, 0, 0x10C0u);
                  FormatTex(&v142, L"%s: %d", *(*(v4 + 4) + 60), *(*(v4 + 4) + 68));
                  v139 = 0;
                  tcscpy_s(&v141, 0x40u, L"Process");
                  v140 = InBuffer;
                  v138 = GetCurrentProcessId();
                  ShowHandleProperties(hWnd, &a2);
                  CloseHandle(InBuffer);
                }
                else
                {
                  ErrMsgBox(L"Error opening process", hWnd);
                }
              }
              return 0;
            }
            v98 = 40014;
          }
          v93 = GetParent(hWnd);
          PostMessageW(v93, 0x111u, v98, 0);
          return 0;
        default:
          return 0;
      }
    }
    return sub_1246710(hWnd, arg8);
  }
  if ( uMsg > 0x7F1 )
  {
    if ( uMsg == 2038 )
    {
      InvalidateRect(v136, 0, 0);
    }
    else if ( uMsg == 2039 )
    {
      v104 = v136;
      v103 = 0;
      SendMessageW(*(v4 + 36), 0x1074u, arg8, &v102);
    }
    return 0;
  }
  if ( uMsg == 2033 )
  {
    if ( v4 )
    {
      EnterCriticalSection((v4 + 12));
      *(v4 + 40) = 1;
      LeaveCriticalSection((v4 + 12));
      if ( !InterlockedDecrement(v4) )
      {
        DeleteCriticalSection((v4 + 12));
        free(v4);
      }
    }
    return 0;
  }
  if ( uMsg == 310 || uMsg == 312 )
    return sub_1246710(hWnd, arg8);
  return 0;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12C60B4: using guessed type wchar_t aYes[4];
// 12C60C4: using guessed type wchar_t aLogonSidS[15];
// 12C612C: using guessed type wchar_t aIntegrity[10];
// 12C617C: using guessed type wchar_t aCapability[11];
// 12C61B4: using guessed type wchar_t aErrorProcessIs[28];
// 12C6C70: using guessed type __int128 xmmword_12C6C70;
// 12DD224: using guessed type char gbProcessSecurityUserListSortAscending;
// 12E4E54: using guessed type int gdwOsType;

//----- (01268E00) --------------------------------------------------------
int __stdcall ProcServicesWndProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HWND hListCtrl; // edi
  CResize *v5; // eax
  HWND v6; // eax
  ResizeInfo *v7; // eax
  HWND v8; // eax
  HICON v9; // ST20_4
  HWND v10; // eax
  LONG v11; // eax
  HWND v12; // eax
  void *v13; // ecx
  wchar_t *v14; // eax
  wchar_t *v15; // esi
  int v16; // edx
  wchar_t v17; // cx
  HWND v18; // eax
  DWORD v19; // ebx
  LONG v20; // edx
  int nIndex; // esi
  int v22; // eax
  WCHAR *v23; // eax
  int result; // eax
  LONG v25; // edi
  int v26; // eax
  int v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // ST14_4
  SC_HANDLE v35; // esi
  size_t v36; // esi
  BYTE *v37; // edi
  DWORD v38; // ST1C_4
  HWND v39; // eax
  BOOL v40; // ST20_4
  HWND v41; // eax
  BOOL v42; // eax
  BOOL v43; // ST20_4
  HWND v44; // eax
  BOOL v45; // ST20_4
  HWND v46; // eax
  BOOL v47; // eax
  BOOL v48; // ST20_4
  HWND v49; // eax
  BOOL v50; // eax
  BOOL v51; // ST20_4
  HWND v52; // eax
  HWND v53; // eax
  HWND v54; // eax
  HWND v55; // eax
  HWND v56; // eax
  HWND v57; // eax
  HWND v58; // eax
  SC_HANDLE v59; // esi
  INT_PTR nRet; // eax
  HWND v61; // eax
  WPARAM v62; // [esp-8h] [ebp-13ACh]
  LPARAM v63; // [esp+10h] [ebp-1394h]
  int v64; // [esp+1Ch] [ebp-1388h]
  int v65; // [esp+20h] [ebp-1384h]
  NMHDR nmhdr; // [esp+44h] [ebp-1360h]
  int v67; // [esp+50h] [ebp-1354h]
  size_t pcbBytesNeeded; // [esp+54h] [ebp-1350h]
  LVITEMEXW item; // [esp+58h] [ebp-134Ch]
  void *v70; // [esp+8Ch] [ebp-1318h]
  SC_HANDLE hSCObject; // [esp+90h] [ebp-1314h]
  LONG dwNewLong; // [esp+94h] [ebp-1310h]
  char v73; // [esp+9Bh] [ebp-1309h]
  char a2; // [esp+9Ch] [ebp-1308h]
  DWORD v75; // [esp+C0h] [ebp-12E4h]
  int v76; // [esp+C4h] [ebp-12E0h]
  SC_HANDLE v77; // [esp+C8h] [ebp-12DCh]
  wchar_t v78; // [esp+D4h] [ebp-12D0h]
  wchar_t Dst; // [esp+154h] [ebp-1250h]
  struct _SERVICE_STATUS ServiceStatus; // [esp+115Ch] [ebp-248h]
  int Indent; // [esp+1178h] [ebp-22Ch]
  int v82; // [esp+117Ch] [ebp-228h]
  int v83; // [esp+1180h] [ebp-224h]
  WCHAR ServiceName; // [esp+1184h] [ebp-220h]
  int a3; // [esp+138Ch] [ebp-18h]
  __int16 v86; // [esp+1390h] [ebp-14h]
  int v87; // [esp+13A0h] [ebp-4h]

  dwNewLong = lParam;
  hListCtrl = GetDlgItem(hDlg, IDD_PROCSERVICES_CTRL_LISTVIEW);
  GetWindowLongW(hDlg, GWL_USERDATA);
  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  v73 = 0;
  Indent = 1039;
  v82 = 1044;
  v83 = 1061;
  LOWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  v86 = MulDiv(100, gLogPixelsX, 96);
  if ( msg > 0x111 )
  {
    if ( msg == 307 || msg == 310 || msg == 312 )
      return sub_1246710(hDlg, wParam);
    return 0;
  }
  if ( msg == 273 )
  {
    v70 = wParam;
    if ( wParam <= 40001 )
    {
      if ( wParam != 40001 )
      {
        switch ( wParam )
        {
          case IDD_PROCSERVICES_BUTTON_STOP:
          case IDD_PROCSERVICES_BUTTON_RESUME:
          case IDD_PROCSERVICES_BUTTON_PAUSE:
          case IDD_PROCSERVICES_BUTTON_PAUSE|IDD_SYSINFOPROPSHEET_BUTTON_OK:
          case IDD_PROCSERVICES_BUTTON_RESTART:
            item.iItem = SendMessageW(hListCtrl, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_SELECTED);
            item.pszText = &ServiceName;
            item.iSubItem = 0;
            item.cchTextMax = _MAX_PATH;
            item.mask = 1;
            SendMessageW(hListCtrl, LVM_GETITEMW, 0, &item);
            item.iSubItem = v70;
            nRet = DialogBoxParamW(ghInstance, L"SERVICECONTROL", hDlg, ServiceControlDlgProc, &item);
            if ( nRet == IDOK )
            {
              MessageBoxW(
                hDlg,
                L"The service didn't respond to the control request in a timely manner",
                L"Process Explorer",
                0x10u);
            }
            else if ( nRet == IDCANCEL && wParam == IDD_PROCSERVICES_BUTTON_STOP )
            {
              SendMessageW(hListCtrl, LVM_DELETEITEM, item.iItem, 0);
            }
            nmhdr.hwndFrom = hListCtrl;
            nmhdr.code = PE_LVN_ITEMCHANGED;
            SendMessageW(hDlg, WM_NOTIFY, 0, &nmhdr);
            GetAllServicesName();
            SetFocus(hListCtrl);
            result = 0;
            break;
          case IDD_PROCSERVICES_BUTTON_PERMISSIONS:
            item.iItem = SendMessageW(hListCtrl, 0x100Cu, 0xFFFFFFFF, 2);
            item.pszText = &ServiceName;
            item.iSubItem = 0;
            item.cchTextMax = 260;
            item.mask = 1;
            SendMessageW(hListCtrl, 0x104Bu, 0, &item);
            v59 = OpenServiceW(ghSCManager, &ServiceName, 0x60000u);
            if ( v59 )
            {
              memset(&a2, 0, 0x10C0u);
              tcscpy_s(&Dst, 0x400u, &ServiceName);
              v76 = 0;
              tcscpy_s(&v78, 0x40u, L"Service");
              v77 = v59;
              v75 = GetCurrentProcessId();
              ShowHandleProperties(hDlg, &a2);
              CloseServiceHandle(v59);
            }
            else
            {
              ErrMsgBox(L"Error opening service", hDlg);
            }
            result = 0;
            break;
          default:
            return 0;
        }
        return result;
      }
      v62 = 40014;
LABEL_78:
      v61 = GetParent(hDlg);
      PostMessageW(v61, 0x111u, v62, 0);
      return 0;
    }
    if ( wParam == 40002 )
    {
      SetEvent(ghEventRefreshSearchResult);
      return 0;
    }
    if ( wParam - 40092 <= 1 )
    {
      v62 = wParam;
      goto LABEL_78;
    }
    return 0;
  }
  switch ( msg )
  {
    case 0x2Bu:
      FindDlg_DrawItem(dwNewLong);
      return 0;
    case 0x2Cu:
      return HandleMeasureItem(hDlg, msg, wParam, dwNewLong);
    case 0x4Eu:
      v25 = dwNewLong;
      v26 = *(dwNewLong + 8);
      if ( v26 != -101 && (v26 + 3) > 1 )
        return 0;
      SetDlgItemTextW(hDlg, 1059, gpszTargetName);
      v27 = SendMessageW(*v25, 0x100Cu, 0xFFFFFFFF, 2);
      if ( v27 == -1 )
      {
        v28 = GetDlgItem(hDlg, 1306);
        EnableWindow(v28, 0);
        v29 = GetDlgItem(hDlg, 1213);
        EnableWindow(v29, 0);
        v30 = GetDlgItem(hDlg, 1210);
        EnableWindow(v30, 0);
        v31 = GetDlgItem(hDlg, 1211);
        EnableWindow(v31, 0);
        v32 = GetDlgItem(hDlg, 1212);
        EnableWindow(v32, 0);
        v33 = GetDlgItem(hDlg, 1215);
        EnableWindow(v33, 0);
        return 0;
      }
      item.iItem = v27;
      item.pszText = &ServiceName;
      v34 = *v25;
      item.iSubItem = 0;
      item.cchTextMax = 260;
      item.mask = 1;
      if ( SendMessageW(v34, 0x104Bu, 0, &item) != 1 )
        return 0;
      v35 = OpenServiceW(ghSCManager, &ServiceName, 5u);
      hSCObject = v35;
      if ( !v35 )
      {
        v53 = GetDlgItem(hDlg, 1306);
        EnableWindow(v53, 0);
        v54 = GetDlgItem(hDlg, 1213);
        EnableWindow(v54, 0);
        v55 = GetDlgItem(hDlg, 1215);
        EnableWindow(v55, 0);
        v56 = GetDlgItem(hDlg, 1210);
        EnableWindow(v56, 0);
        v57 = GetDlgItem(hDlg, 1211);
        EnableWindow(v57, 0);
        v58 = GetDlgItem(hDlg, 1212);
        EnableWindow(v58, 0);
        return 0;
      }
      if ( *QueryServiceConfig2W )
      {
        QueryServiceConfig2W(v35, 1u, 0, 0, &pcbBytesNeeded);
        if ( GetLastError() == 122 )
        {
          v36 = pcbBytesNeeded;
          v37 = malloc(pcbBytesNeeded);
          v38 = v36;
          v35 = hSCObject;
          QueryServiceConfig2W(hSCObject, 1u, v37, v38, &pcbBytesNeeded);
          SetDlgItemTextW(hDlg, 1059, *v37);
          free(v37);
          v25 = dwNewLong;
        }
      }
      QueryServiceStatus(v35, &ServiceStatus);
      v39 = GetDlgItem(hDlg, 1306);
      EnableWindow(v39, 1);
      v40 = ServiceStatus.dwCurrentState == 1;
      v41 = GetDlgItem(hDlg, 1213);
      EnableWindow(v41, v40);
      v42 = ServiceStatus.dwCurrentState == 4 && ServiceStatus.dwControlsAccepted & 2;
      v43 = v42;
      v44 = GetDlgItem(hDlg, 1212);
      EnableWindow(v44, v43);
      v45 = ServiceStatus.dwCurrentState == 7;
      v46 = GetDlgItem(hDlg, 1211);
      EnableWindow(v46, v45);
      v47 = (ServiceStatus.dwCurrentState == 4 || ServiceStatus.dwCurrentState == 7)
         && ServiceStatus.dwControlsAccepted & 1;
      v48 = v47;
      v49 = GetDlgItem(hDlg, 1210);
      EnableWindow(v49, v48);
      v50 = (ServiceStatus.dwCurrentState == 4 || ServiceStatus.dwCurrentState == 7)
         && ServiceStatus.dwControlsAccepted & 1;
      v51 = v50;
      v52 = GetDlgItem(hDlg, 1215);
      EnableWindow(v52, v51);
      CloseServiceHandle(hSCObject);
      if ( *(v25 + 8) == -3 )
      {
        SendMessageW(hDlg, 0x111u, 0x51Au, 0);
        return 0;
      }
      return 0;
    case 0x110u:
      v5 = operator new(0x40u);
      v70 = v5;
      v87 = 0;
      if ( v5 )
        hSCObject = CResize::CResize(v5, hDlg);
      else
        hSCObject = 0;
      v87 = -1;
      v6 = GetDlgItem(hDlg, 1036);
      if ( v6 )
      {
        v7 = CResize::InitResizeBuffer(hSCObject, v6, 1);
        *&v7->d21.left = 0i64;
        *&v7->d21.right = doubleOnePointZero;
      }
      v8 = GetDlgItem(hDlg, IDD_PROCSERVICES_BUTTON_STOP);
      if ( v8 )
        CResize::InitResizeBuffer(hSCObject, v8, 1)->d1 = xmmword_12C6C70;
      ResizeTab(hDlg);
      v9 = LoadIconW(ghInstance, 0xEB);
      v10 = GetDlgItem(hDlg, IDD_PROCSERVICES_ICON_ICON);
      SendMessageW(v10, STM_SETIMAGE, 1u, v9);
      SetWindowLongW(hDlg, GWL_USERDATA, dwNewLong);
      v11 = GetWindowLongW(hListCtrl, GWL_STYLE);
      SetWindowLongW(hListCtrl, GWL_STYLE, v11 & 0xFFFFFFFD | 1);
      SendMessageW(hListCtrl, 0x1036u, 0x4020u, 16416);
      v12 = SendMessageW(hListCtrl, 0x104Eu, 0, 0);
      InitToolTips(v12);
      OldListCtrlWndProc = SetWindowLongW(hListCtrl, -4, PEListCtrlWndProc);
      SendMessageW(hListCtrl, WM_SETFONT, ghDefaultFont, 0);
      v13 = *(dwNewLong + 792);
      hSCObject = v13;
      if ( !v13 )
      {
        v13 = *(dwNewLong + 60);
        hSCObject = *(dwNewLong + 60);
      }
      v14 = _wcsdup(v13);
      v15 = v14;
      v16 = (v14 + 1);
      do
      {
        v17 = *v14;
        ++v14;
      }
      while ( v17 );
      _wcsupr_s(v15, ((v14 - v16) >> 1) + 1);
      if ( wcsstr(v15, L"SVCHOST.EXE") )
      {
        InitListCtrl(hListCtrl, &Indent, &a3, 3);
        v73 = 1;
      }
      else
      {
        InitListCtrl(hListCtrl, &Indent, &a3, 2);
      }
      free(v15);
      if ( !*CreateSecurityPage )
      {
        v18 = GetDlgItem(hDlg, 1306);
        ShowWindow(v18, 0);
      }
      GetAllServicesName();
      EnterCriticalSection(&gEnumServiceLock);
      v19 = 0;
      if ( !gdwServiceNameBufferRealSize )
        goto LABEL_29;
      v20 = dwNewLong;
      nIndex = 0;
      break;
    default:
      return 0;
  }
  do
  {
    if ( *&gstrServiceNameBuffer[nIndex + 36] == *(v20 + 68) )
    {
      item.mask = 5;
      item.iItem = 0x7FFFFFFF;
      item.iSubItem = 0;
      item.stateMask = 0;
      item.state = 0;
      item.pszText = *&gstrServiceNameBuffer[nIndex];
      item.lParam = (v19 + 1);
      item.iImage = 0;
      v22 = SendMessageW(hListCtrl, 0x104Du, 0, &item);
      v67 = v22;
      if ( v22 == -1 )
        return 0;
      item.iItem = v22;
      item.mask = 1;
      item.iSubItem = 1;
      item.pszText = *&gstrServiceNameBuffer[nIndex + 4];
      SendMessageW(hListCtrl, LVM_SETITEMW, 0, &item);
      if ( v73 )
      {
        v23 = GetSVCHostsFilePath(hSCObject, *&gstrServiceNameBuffer[nIndex]);
        v70 = v23;
        if ( v23 )
        {
          item.pszText = v23;
          item.mask = 1;
          item.iItem = v67;
          item.iSubItem = 2;
          SendMessageW(hListCtrl, 0x104Cu, 0, &item);
          free(v70);
        }
      }
      v20 = dwNewLong;
    }
    ++v19;
    nIndex += 44;
  }
  while ( v19 < gdwServiceNameBufferRealSize );
LABEL_29:
  LeaveCriticalSection(&gEnumServiceLock);
  SendMessageW(hListCtrl, 0x101Eu, 0, 0xFFFF);
  SendMessageW(hListCtrl, 0x101Eu, 1u, (v73 != 0) + 65534);
  if ( v73 )
    SendMessageW(hListCtrl, 0x101Eu, 2u, 65534);
  v65 = 3;
  v64 = 3;
  SendMessageW(hListCtrl, 0x102Bu, 0, &v63);
  SetFocus(hListCtrl);
  return 1;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12C6C70: using guessed type __int128 xmmword_12C6C70;

//----- (01269A30) --------------------------------------------------------
int __userpurge ProcTcpUdpStackWndProc@<eax>(signed int a1@<ebx>, HWND hWnd, int message, WPARAM wParam, int lParam)
{
  HWND v5; // esi
  int v6; // eax
  HWND v7; // eax
  HWND hListCtrl; // edi
  CResize *pInfo; // eax
  HWND v10; // eax
  void *v11; // eax
  __m128i *v12; // eax
  LONG v13; // ecx
  WPARAM v14; // esi
  UINT v15; // eax
  BOOL v16; // ST44_4
  HWND v17; // eax
  UINT v19; // eax
  HWND v20; // eax
  u_long *v21; // esi
  LRESULT nCount; // eax
  char v23; // al
  char v24; // cl
  HANDLE v25; // eax
  HANDLE v26; // eax
  int v27; // eax
  void *v28; // ecx
  HANDLE v29; // eax
  HANDLE v30; // eax
  int v31; // eax
  int v32; // ecx
  bool v33; // zf
  HWND v34; // ecx
  int v35; // eax
  HANDLESANDDLLSLISTUSERPARAM *v36; // eax
  _DWORD *v37; // edi
  u_long v38; // ecx
  int v39; // eax
  HWND v40; // ecx
  HANDLESANDDLLSLISTUSERPARAM *v41; // eax
  _DWORD *v42; // edx
  size_t v43; // edi
  void *v44; // esi
  int v45; // ST30_4
  HANDLESANDDLLSLISTUSERPARAM *v46; // eax
  void *v47; // ST44_4
  HANDLE v48; // eax
  void *v49; // ST44_4
  HANDLE v50; // eax
  void *v51; // ST44_4
  HANDLE v52; // eax
  void *v53; // ST44_4
  HANDLE v54; // eax
  void *v55; // esi
  void *v56; // eax
  HWND v57; // ecx
  int *v58; // edi
  u_long v59; // edx
  int v60; // ecx
  HANDLESANDDLLSLISTUSERPARAM *v61; // eax
  int *v62; // edi
  int *v63; // eax
  HWND v64; // edx
  int *v65; // ecx
  HANDLESANDDLLSLISTUSERPARAM *v66; // eax
  int *v67; // edi
  HWND v68; // ecx
  int *v69; // edi
  int v70; // ecx
  HANDLESANDDLLSLISTUSERPARAM *v71; // eax
  size_t *v72; // edi
  HWND v73; // ecx
  HANDLESANDDLLSLISTUSERPARAM *v74; // eax
  DWORD v75; // ecx
  HWND v76; // edi
  DWORD v77; // esi
  DWORD v78; // eax
  struct _MIB_TCPTABLE *v79; // eax
  struct _MIB_TCPTABLE *v80; // esi
  int v81; // eax
  struct _MIB_UDPTABLE *v82; // eax
  struct _MIB_UDPTABLE *v83; // edi
  int v84; // eax
  int v85; // eax
  int v86; // ecx
  char *v87; // ecx
  void *v88; // ST40_4
  LPARAM v89; // ecx
  int v90; // eax
  WPARAM v91; // esi
  int v92; // ST44_4
  int v93; // eax
  WPARAM v94; // [esp-8h] [ebp-B4h]
  DWORD v95; // [esp+0h] [ebp-ACh]
  LPARAM v96; // [esp+4h] [ebp-A8h]
  LVITEMW item; // [esp+Ch] [ebp-A0h]
  WPARAM v98; // [esp+40h] [ebp-6Ch]
  DWORD v99; // [esp+44h] [ebp-68h]
  void *pInfo_1; // [esp+48h] [ebp-64h]
  LPVOID v101; // [esp+4Ch] [ebp-60h]
  LPVOID lpMem; // [esp+50h] [ebp-5Ch]
  char v103[5]; // [esp+57h] [ebp-55h]
  LPVOID v104; // [esp+5Ch] [ebp-50h]
  int v105; // [esp+60h] [ebp-4Ch]
  u_long *v106; // [esp+64h] [ebp-48h]
  void *v107; // [esp+68h] [ebp-44h]
  HWND v108; // [esp+6Ch] [ebp-40h]
  LONG dwNewLong; // [esp+70h] [ebp-3Ch]
  LPARAM pUserData; // [esp+74h] [ebp-38h]
  size_t pdwSize; // [esp+78h] [ebp-34h]
  size_t pInfo_2; // [esp+7Ch] [ebp-30h]
  HWND hDlg; // [esp+80h] [ebp-2Ch]
  char a3a[17]; // [esp+87h] [ebp-25h]
  int v115; // [esp+98h] [ebp-14h]
  int v116; // [esp+A8h] [ebp-4h]

  v5 = hWnd;
  hDlg = hWnd;
  dwNewLong = lParam;
  pUserData = GetWindowLongW(hWnd, GWL_USERDATA);
  item.mask = 0;
  memset(&item.iItem, 0, 0x30u);
  v6 = dword_12FD0B0;
  v104 = 0;
  *&v103[1] = 0;
  v101 = 0;
  lpMem = 0;
  v115 = 1343;
  _mm_storeu_si128(&a3a[1], _mm_load_si128(&xmmword_12C6C50));
  if ( !(v6 & 1) )
  {
    dword_12FD0B0 = v6 | 1;
    word_12FD0A4[0] = MulDiv(50, gLogPixelsX, 96);
    word_12FD0A4[1] = MulDiv(100, gLogPixelsX, 96);
    word_12FD0A4[2] = MulDiv(100, gLogPixelsX, 96);
    word_12FD0A4[3] = MulDiv(100, gLogPixelsX, 96);
    word_12FD0A4[4] = MulDiv(100, gLogPixelsX, 96);
  }
  v7 = GetDlgItem(hWnd, 1192);
  hListCtrl = v7;
  v108 = v7;
  if ( message <= WM_TIMER )
  {
    if ( message != WM_TIMER )
    {
      switch ( message )
      {
        case WM_DRAWITEM:
          FindDlg_DrawItem(dwNewLong);
          return 0;
        case WM_MEASUREITEM:
          return HandleMeasureItem(hWnd, message, wParam, dwNewLong);
        case WM_NOTIFY:
          switch ( *(dwNewLong + 8) )
          {
            case 0xFFFFFF4F:
              return CTreeList::OnGetDispInfo(hWnd, wParam, dwNewLong);
            case 0xFFFFFF94:
              return OnTreeListColumnClick(wParam, dwNewLong, v95, v96);
            case 0xFFFFFF9B:
            case 0xFFFFFFFE:
              v16 = SendMessageW(*(pUserData + 4), 0x100Cu, 0xFFFFFFFF, 2) != -1;
              v17 = GetDlgItem(hWnd, 1085);
              EnableWindow(v17, v16);
              return 0;
            case 0xFFFFFFFD:
              SendMessageW(hWnd, WM_COMMAND, IDD_PROCTCPUDPSTACK_BUTTON_STACK, 0);
              break;
            default:
              return 0;
          }
          return 0;
        case WM_INITDIALOG:
          pInfo = operator new(0x40u);
          pInfo_1 = pInfo;
          v116 = 0;
          if ( pInfo )
            pInfo_2 = CResize::CResize(pInfo, hWnd);
          else
            pInfo_2 = 0;
          v116 = -1;
          v10 = GetDlgItem(hWnd, IDD_PROCTCPUDPSTACK_STATIC_THREAD_STACK_OPENED);
          if ( v10 )
            CResize::InitResizeBuffer(pInfo_2, v10, 1)->d1 = xmmword_12C6C70;
          ResizeTab(hWnd);
          SetWindowLongW(hWnd, GWL_USERDATA, dwNewLong);
          if ( gdwOsType < 1 || (v11 = 5, !(*(dwNewLong + 40) & 0x20)) )
            v11 = 4;
          v107 = v11;
          CThreadStackPage::InitListCtrl(hListCtrl, v11, &a3a[1], word_12FD0A4, 1);
          SetWindowLongW(hListCtrl, GWL_WNDPROC, PEListCtrlWndProc);
          SendMessageW(hListCtrl, WM_SETFONT, ghDefaultFont, 0);
          v12 = malloc(0x1Cu);
          v13 = dwNewLong;
          _mm_storeu_si128(v12, 0i64);
          _mm_storel_epi64(v12 + 1, 0i64);
          v12[1].m128i_i32[2] = 0;
          v12->m128i_i32[3] = 0;
          v12->m128i_i32[0] = v13;
          v12->m128i_i32[1] = hListCtrl;
          v12[1].m128i_i32[2] = -1;
          SetWindowLongW(hWnd, GWL_USERDATA, v12);
          SendMessageW(hWnd, WM_TIMER, 0, 1);
          if ( SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0) )
          {
            v14 = 0;
            if ( v107 )
            {
              do
              {
                if ( v14 == 3 )
                  SendMessageW(hListCtrl, 0x101Eu, 3u, word_12FD0A4[3]);
                else
                  SendMessageW(hListCtrl, 0x101Eu, v14, 0xFFFF);
                ++v14;
              }
              while ( v14 < v107 );
            }
            v5 = hDlg;
          }
          CheckDlgButton(v5, IDD_PROCTCPUDP_CHECKBOX_RESOLVE_ADDRESSES, gbResolveAddresses != 0);
          v15 = IsDlgButtonChecked(v5, IDD_PROCTCPUDP_CHECKBOX_RESOLVE_ADDRESSES);
          SetPropW(hListCtrl, L"resolve", (v15 == 1));
          SetFocus(hListCtrl);
          ReleaseCapture();
          return 0;
        case WM_COMMAND:
          if ( wParam <= IDS_TRAYMENU_CLOSE_PROCESS_EXPLORER )
          {
            if ( wParam != IDS_TRAYMENU_CLOSE_PROCESS_EXPLORER )
            {
              if ( wParam == IDD_PROCTHREADS_BUTTON_STACK )
              {
                if ( AllocateAndGetTcpExTableFromStack )
                  DialogBoxParamW(ghInstance2, L"THREADSTACK", hWnd, ThreadStackDlgProc1, pUserData);
                else
                  MessageBoxW(hWnd, L"Stacks not available on this version of Windows", L"Process Explorer", 0x30u);
              }
              else if ( wParam == IDD_PROCTCPUDPSTACK_CHECKBOX_RESOLVE_ADDRESSES && !(wParam >> 16) )
              {
                v19 = IsDlgButtonChecked(hWnd, IDD_PROCTCPUDPSTACK_CHECKBOX_RESOLVE_ADDRESSES);
                SetPropW(hListCtrl, L"resolve", (v19 == 1));
                gbResolveAddresses = IsDlgButtonChecked(hDlg, IDD_PROCTCPUDP_CHECKBOX_RESOLVE_ADDRESSES) == 1;
                goto LABEL_33;
              }
              return 0;
            }
            v94 = 40014;
LABEL_43:
            v20 = GetParent(hWnd);
            PostMessageW(v20, 0x111u, v94, 0);
            return 0;
          }
          if ( wParam != IDS_PROCEXPLORERMENU_REFRESH_NOW )
          {
            if ( wParam - 40092 > 1 )
              return 0;
            v94 = wParam;
            goto LABEL_43;
          }
          SetEvent(ghEventRefreshSearchResult);
          break;
        default:
          return 0;
      }
      return 0;
    }
    v21 = 0;
    a3a[0] = 0;
    v106 = 0;
    if ( !dwNewLong )
    {
      item.mask = LVIF_PARAM;
      nCount = SendMessageW(v7, LVM_GETITEMCOUNT, 0, 0);
      item.iSubItem = 0;
      item.iItem = nCount - 1;
      if ( SendMessageW(hListCtrl, LVM_GETITEMW, 0, &item) )
      {
        do
        {
          LOBYTE(item.lParam->ImgName) = 0;
          v23 = DeleteItemFromListCtrl(a1, hListCtrl, &item, item.lParam, v103);
          v24 = a3a[0];
          if ( v23 )
            v24 = 1;
          a3a[0] = v24;
          if ( v103[0] )
          {
            v21 = (v21 + 1);
            item.lParam->field_8 = 0;
          }
          item.mask = LVIF_PARAM;
          item.iSubItem = 0;
        }
        while ( SendMessageW(hListCtrl, LVM_GETITEMW, 0, &item) );
        v106 = v21;
      }
    }
    if ( !AllocateAndGetTcpExTableFromStack )
    {
      if ( *GetExtendedTcpTable )
      {
        pdwSize = 0;
        if ( GetExtendedTcpTable(0, &pdwSize, 0, 2u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 )
        {
          v55 = 0;
          do
          {
            if ( v55 )
              free(v55);
            v55 = malloc(pdwSize);
          }
          while ( GetExtendedTcpTable(v55, &pdwSize, 0, 2u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 );
          pInfo_2 = v55;
          v33 = v55 == 0;
          v21 = v106;
          if ( !v33 )
          {
            v56 = pInfo_2;
            v57 = 0;
            hDlg = 0;
            if ( *pInfo_2 )
            {
              v58 = (pInfo_2 + 28);
              do
              {
                if ( *v58 == *(*pUserData + 68) )
                {
                  v59 = *(v58 - 2);
                  if ( v59 )
                    v60 = *(v58 - 1);
                  else
                    v60 = 0;
                  v61 = sub_125A070(
                          v108,
                          dwNewLong,
                          0,
                          *(v58 - 5),
                          *(v58 - 4),
                          0,
                          *(v58 - 3),
                          v59,
                          0,
                          v60,
                          *v58,
                          (v58 + 3),
                          0,
                          a3a);
                  v57 = hDlg;
                  if ( v61 )
                    a3a[0] = 1;
                  else
                    v21 = (v21 - 1);
                }
                v56 = pInfo_2;
                v57 = (v57 + 1);
                v58 += 40;
                hDlg = v57;
              }
              while ( v57 < *pInfo_2 );
            }
            free(v56);
          }
        }
        pdwSize = 0;
        if ( GetExtendedUdpTable(0, &pdwSize, 0, 2u, UDP_TABLE_OWNER_MODULE, 0) == 122 )
        {
          v62 = 0;
          do
          {
            if ( v62 )
              free(v62);
            v62 = malloc(pdwSize);
          }
          while ( GetExtendedUdpTable(v62, &pdwSize, 0, 2u, UDP_TABLE_OWNER_MODULE, 0) == 122 );
          pInfo_2 = v62;
          if ( v62 )
          {
            v63 = v62;
            v64 = 0;
            hDlg = 0;
            if ( *v62 )
            {
              v65 = v62 + 4;
              v107 = v62 + 4;
              do
              {
                if ( *v65 == *(*pUserData + 68) )
                {
                  v66 = sub_125A070(
                          v108,
                          dwNewLong,
                          1,
                          2,
                          *(v65 - 2),
                          0,
                          *(v65 - 1),
                          0xFFFFFFFF,
                          0,
                          -1,
                          *v65,
                          (v65 + 6),
                          0,
                          a3a);
                  if ( v66 )
                  {
                    if ( dwNewLong )
                      v66->field_10 = 0;
                    a3a[0] = 1;
                  }
                  else
                  {
                    v21 = (v21 - 1);
                  }
                  v64 = hDlg;
                  v65 = v107;
                }
                v63 = pInfo_2;
                v64 = (v64 + 1);
                v65 += 40;
                hDlg = v64;
                v107 = v65;
              }
              while ( v64 < *pInfo_2 );
            }
            free(v63);
          }
        }
        v67 = 0;
        pdwSize = 0;
        if ( GetExtendedTcpTable(0, &pdwSize, 0, 0x17u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 )
        {
          do
          {
            if ( v67 )
              free(v67);
            v67 = malloc(pdwSize);
          }
          while ( GetExtendedTcpTable(v67, &pdwSize, 0, 0x17u, TCP_TABLE_OWNER_MODULE_ALL, 0) == 122 );
          pInfo_2 = v67;
          if ( v67 )
          {
            v68 = 0;
            hDlg = 0;
            if ( *v67 )
            {
              v69 = v67 + 15;
              do
              {
                if ( *v69 == *(*pUserData + 68) )
                {
                  if ( v69 == 28 )
                    v70 = 0;
                  else
                    v70 = *(v69 - 2);
                  v71 = sub_125A070(
                          v108,
                          dwNewLong,
                          2,
                          *(v69 - 1),
                          0,
                          (v69 - 13),
                          *(v69 - 8),
                          0,
                          (v69 - 7),
                          v70,
                          *v69,
                          (v69 + 3),
                          0,
                          a3a);
                  v68 = hDlg;
                  if ( v71 )
                    a3a[0] = 1;
                  else
                    v21 = (v21 - 1);
                }
                v68 = (v68 + 1);
                v69 += 48;
                hDlg = v68;
              }
              while ( v68 < *pInfo_2 );
              v67 = pInfo_2;
            }
            free(v67);
          }
        }
        v72 = 0;
        pdwSize = 0;
        if ( GetExtendedUdpTable(0, &pdwSize, 0, 0x17u, UDP_TABLE_OWNER_MODULE, 0) == 122 )
        {
          do
          {
            if ( v72 )
              free(v72);
            v72 = malloc(pdwSize);
          }
          while ( GetExtendedUdpTable(v72, &pdwSize, 0, 0x17u, UDP_TABLE_OWNER_MODULE, 0) == 122 );
          if ( v72 )
          {
            v33 = *v72 == 0;
            pInfo_2 = 0;
            if ( !v33 )
            {
              v73 = (v72 + 8);
              hDlg = (v72 + 8);
              do
              {
                if ( *v73 == *(*pUserData + 68) )
                {
                  v74 = sub_125A070(
                          v108,
                          dwNewLong,
                          3,
                          2,
                          0,
                          (v73 - 6),
                          *(v73 - 1),
                          0xFFFFFFFF,
                          0,
                          -1,
                          *v73,
                          (v73 + 6),
                          0,
                          a3a);
                  if ( v74 )
                  {
                    if ( dwNewLong )
                      v74->field_10 = 0;
                    a3a[0] = 1;
                  }
                  else
                  {
                    v21 = (v21 - 1);
                  }
                  v73 = hDlg;
                }
                v73 += 44;
                hDlg = v73;
                ++pInfo_2;
              }
              while ( pInfo_2 < *v72 );
            }
            free(v72);
          }
        }
        hListCtrl = v108;
      }
      else
      {
        pdwSize = 64000;
        hDlg = malloc(0xFA00u);
        v75 = 16;
        if ( gbServiceNotImplemented )
          v75 = 64;
        if ( NtQuerySystemInformation(v75, hDlg, 0xFA00u, &pdwSize) )
        {
          v76 = hDlg;
          do
          {
            free(v76);
            pdwSize *= 2;
            v77 = pdwSize;
            v76 = malloc(pdwSize);
            v78 = 16;
            if ( gbServiceNotImplemented )
              v78 = 64;
          }
          while ( NtQuerySystemInformation(v78, v76, v77, &pdwSize) );
          v21 = v106;
          hDlg = v76;
          hListCtrl = v108;
        }
        pInfo_2 = sub_12739C0(hDlg, *(*pUserData + 68));
        pdwSize = 0;
        pUserData = 0;
        if ( GetTcpTable(0, &pdwSize, 1) == 122 )
        {
          do
          {
            v79 = malloc(pdwSize);
            v80 = v79;
            pUserData = v79;
            v81 = GetTcpTable(v79, &pdwSize, 1);
            v105 = v81;
            if ( v81 )
            {
              free(v80);
              v81 = v105;
              pUserData = 0;
            }
          }
          while ( v81 == 122 );
          v21 = v106;
        }
        pdwSize = 0;
        v107 = 0;
        if ( GetUdpTable(0, &pdwSize, 1) == 122 )
        {
          do
          {
            v82 = malloc(pdwSize);
            v83 = v82;
            v107 = v82;
            v84 = GetUdpTable(v82, &pdwSize, 1);
            v105 = v84;
            if ( v84 )
            {
              free(v83);
              v84 = v105;
              v107 = 0;
            }
          }
          while ( v84 == 122 );
          hListCtrl = v108;
        }
        if ( pUserData )
        {
          v33 = *pUserData == 0;
          v105 = 0;
          if ( !v33 )
          {
            v85 = pUserData + 16;
            v106 = (pUserData + 16);
            do
            {
              if ( sub_125F600(pInfo_2, 0, *(v85 - 8), *(v85 - 4)) )
              {
                if ( *v106 )
                  v86 = v106[1];
                else
                  v86 = 0;
                hListCtrl = v108;
                if ( sub_125A070(
                       v108,
                       dwNewLong,
                       0,
                       *(v106 - 3),
                       *(v106 - 2),
                       0,
                       *(v106 - 1),
                       *v106,
                       0,
                       v86,
                       0,
                       0,
                       0,
                       a3a) )
                {
                  a3a[0] = 1;
                }
                else
                {
                  v21 = (v21 - 1);
                }
              }
              v85 = (v106 + 5);
              ++v105;
              v106 += 5;
            }
            while ( v105 < *pUserData );
          }
        }
        if ( v107 )
        {
          v33 = *v107 == 0;
          v105 = 0;
          if ( !v33 )
          {
            v87 = v107 + 4;
            v106 = (v107 + 4);
            do
            {
              v88 = *v87;
              v108 = *(v87 + 1);
              pInfo_1 = v88;
              if ( sub_125F600(pInfo_2, 1, v88, v108) )
              {
                if ( sub_125A070(hListCtrl, dwNewLong, 1, 2, pInfo_1, 0, v108, 0xFFFFFFFF, 0, -1, 0, 0, 0, a3a) )
                  a3a[0] = 1;
                else
                  v21 = (v21 - 1);
              }
              v87 = (v106 + 2);
              ++v105;
              v106 += 2;
            }
            while ( v105 < *v107 );
          }
        }
        free(hDlg);
        if ( v107 )
          free(v107);
        if ( pUserData )
          free(pUserData);
        if ( pInfo_2 )
          free(pInfo_2);
      }
      goto LABEL_191;
    }
    v104 = 0;
    v101 = 0;
    if ( AllocateAndGetTcpExTable2FromStack )
    {
      v25 = GetProcessHeap();
      if ( AllocateAndGetTcpExTable2FromStack(&v101, 1, v25, 0, 2, 8) )
        v101 = 0;
    }
    else
    {
      v26 = GetProcessHeap();
      v27 = AllocateAndGetTcpExTableFromStack(&v104, 1, v26, 2, 2);
      v28 = v104;
      if ( v27 )
        v28 = 0;
      v104 = v28;
    }
    *&v103[1] = 0;
    lpMem = 0;
    if ( AllocateAndGetUdpExTable2FromStack )
    {
      v29 = GetProcessHeap();
      if ( AllocateAndGetUdpExTable2FromStack(&lpMem, 1, v29, 2, 2, 2) )
        lpMem = 0;
    }
    else
    {
      v30 = GetProcessHeap();
      v31 = AllocateAndGetUdpExTableFromStack(&v103[1], 1, v30, 2, 2);
      v32 = *&v103[1];
      if ( v31 )
        v32 = 0;
      *&v103[1] = v32;
    }
    if ( v104 )
    {
      v33 = *v104 == 0;
      pInfo_2 = 0;
      if ( !v33 )
      {
        v34 = 0;
        hDlg = 0;
        do
        {
          v21 = v106;
          if ( *(v104 + v34 + 24) == *(*pUserData + 68) )
          {
            if ( *(v104 + v34 + 16) )
              v35 = *(v104 + v34 + 20);
            else
              v35 = 0;
            hListCtrl = v108;
            v36 = sub_125A070(
                    v108,
                    dwNewLong,
                    0,
                    *(v104 + v34 + 4),
                    *(v104 + v34 + 8),
                    0,
                    *(v104 + v34 + 12),
                    *(v104 + v34 + 16),
                    0,
                    v35,
                    *(v104 + v34 + 24),
                    0,
                    0,
                    a3a);
            v34 = hDlg;
            if ( v36 )
            {
              a3a[0] = 1;
            }
            else
            {
              v21 = (v21 - 1);
              v106 = v21;
            }
          }
          v34 += 6;
          ++pInfo_2;
          hDlg = v34;
        }
        while ( pInfo_2 < *v104 );
      }
    }
    else if ( v101 )
    {
      v33 = *v101 == 0;
      v37 = v101 + 8;
      hDlg = 0;
      if ( !v33 )
      {
        do
        {
          if ( v37[6] == *(*pUserData + 68) )
          {
            pInfo_2 = *v37 - 28;
            v105 = malloc(pInfo_2);
            memmove_0(v105, v37 + 7, pInfo_2);
            v38 = v37[4];
            if ( v38 )
              v39 = v37[5];
            else
              v39 = 0;
            if ( sub_125A070(v108, dwNewLong, 0, v37[1], v37[2], 0, v37[3], v38, 0, v39, v37[6], v105, pInfo_2, a3a) )
              a3a[0] = 1;
            else
              v21 = (v21 - 1);
          }
          v37 = (v37 + *v37);
          hDlg = (hDlg + 1);
        }
        while ( hDlg < *v101 );
        v106 = v21;
      }
      hListCtrl = v108;
    }
    if ( *&v103[1] )
    {
      v33 = **&v103[1] == 0;
      pInfo_2 = 0;
      if ( !v33 )
      {
        v40 = 0;
        hDlg = 0;
        do
        {
          hListCtrl = v108;
          if ( *(v40 + *&v103[1] + 12) == *(*pUserData + 68) )
          {
            v41 = sub_125A070(
                    v108,
                    dwNewLong,
                    1,
                    2,
                    *(v40 + *&v103[1] + 4),
                    0,
                    *(v40 + *&v103[1] + 8),
                    0xFFFFFFFF,
                    0,
                    -1,
                    *(v40 + *&v103[1] + 12),
                    0,
                    0,
                    a3a);
            if ( v41 )
            {
              if ( dwNewLong )
                v41->field_10 = 0;
              a3a[0] = 1;
            }
            else
            {
              v21 = (v21 - 1);
            }
            v40 = hDlg;
          }
          v40 += 3;
          ++pInfo_2;
          hDlg = v40;
        }
        while ( pInfo_2 < **&v103[1] );
      }
    }
    else
    {
      if ( !lpMem )
      {
LABEL_118:
        if ( v104 )
        {
          v51 = v104;
          v52 = GetProcessHeap();
          HeapFree(v52, 0, v51);
        }
        if ( v101 )
        {
          v53 = v101;
          v54 = GetProcessHeap();
          HeapFree(v54, 0, v53);
        }
LABEL_191:
        if ( a3a[0] || v21 )
        {
          InvalidateRect(hListCtrl, 0, 0);
          InitTreeListSortableHeader(
            hListCtrl,
            gdwSortableColumnVector[22],
            gdwSortableColumnVector[22],
            gbProcessTcpDumpListAscending);
          v99 = gdwSortableColumnVector[22];
          v98 = 1192;
          SendMessageW(hListCtrl, LVM_SORTITEMS, &v98, TreeListSort);
          SendMessageW(hListCtrl, WM_SETREDRAW, 1u, 0);
        }
        return 0;
      }
      v33 = *lpMem == 0;
      v42 = lpMem + 8;
      v107 = lpMem + 8;
      pInfo_2 = 0;
      if ( v33 )
      {
LABEL_116:
        if ( lpMem )
        {
          v49 = lpMem;
          v50 = GetProcessHeap();
          HeapFree(v50, 0, v49);
        }
        goto LABEL_118;
      }
      do
      {
        if ( v42[3] == *(*pUserData + 68) )
        {
          v43 = *v42 - 16;
          v44 = malloc(v43);
          memmove_0(v44, v107 + 16, v43);
          v45 = v43;
          hListCtrl = v108;
          v46 = sub_125A070(
                  v108,
                  dwNewLong,
                  1,
                  2,
                  *(v107 + 1),
                  0,
                  *(v107 + 2),
                  0xFFFFFFFF,
                  0,
                  -1,
                  *(v107 + 3),
                  v44,
                  v45,
                  a3a);
          if ( v46 )
          {
            if ( dwNewLong )
              v46->field_10 = 0;
            v21 = v106;
            a3a[0] = 1;
          }
          else
          {
            v21 = (v106 - 1);
            v106 = (v106 - 1);
          }
          v42 = v107;
        }
        v42 = (v42 + *v42);
        v107 = v42;
        ++pInfo_2;
      }
      while ( pInfo_2 < *lpMem );
    }
    if ( *&v103[1] )
    {
      v47 = *&v103[1];
      v48 = GetProcessHeap();
      HeapFree(v48, 0, v47);
    }
    goto LABEL_116;
  }
  if ( message > WM_CTLCOLORSTATIC )
  {
    if ( message == 1024 )
    {
LABEL_33:
      InvalidateRect(hListCtrl, 0, 0);
    }
    else if ( message == 2033 )
    {
      v89 = pUserData;
      if ( gdwOsType < 1 || (v90 = *pUserData, pInfo_2 = 5, !(*(v90 + 40) & 0x20)) )
        pInfo_2 = 4;
      if ( *(pUserData + 12) )
      {
        CloseHandle(*(pUserData + 12));
        v89 = pUserData;
      }
      if ( *(v89 + 16) )
      {
        RtlDestroyQueryDebugBuffer(*(v89 + 16));
        v89 = pUserData;
      }
      if ( *(v89 + 8) )
      {
        free(*(v89 + 8));
        v89 = pUserData;
      }
      free(v89);
      if ( SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0) && pInfo_2 )
      {
        v91 = 0;
        do
        {
          v92 = gLogPixelsX;
          v93 = SendMessageW(hListCtrl, LVM_GETCOLUMNWIDTH, v91, 0);
          word_12FD0A4[v91++] = MulDiv(v93, 96, v92);
        }
        while ( v91 < pInfo_2 );
        v5 = hDlg;
      }
      DestroyWindow(v5);
    }
    return 0;
  }
  if ( message != WM_CTLCOLORSTATIC && message != WM_CTLCOLOREDIT && message != WM_CTLCOLORDLG )
    return 0;
  return sub_1246710(hWnd, wParam);
}
// 12C6C50: using guessed type __int128 xmmword_12C6C50;
// 12C6C70: using guessed type __int128 xmmword_12C6C70;
// 12DD225: using guessed type char gbProcessTcpDumpListAscending;
// 12E10D8: using guessed type char gbResolveAddresses;
// 12E4E54: using guessed type int gdwOsType;
// 12EABA5: using guessed type char gbServiceNotImplemented;
// 12EF264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 12EF2F8: using guessed type int (__stdcall *AllocateAndGetTcpExTableFromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF2FC: using guessed type int (__stdcall *AllocateAndGetUdpExTableFromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF300: using guessed type int (__stdcall *AllocateAndGetUdpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF304: using guessed type int (__stdcall *AllocateAndGetTcpExTable2FromStack)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12FD0B0: using guessed type int dword_12FD0B0;

//----- (0126ACF0) --------------------------------------------------------
// x显示进程线程属性页面
int __stdcall ProcThreadsWndProc(HWND hWnd, int message, WPARAM wParam, int lParam)
{
  HWND v4; // ebx
  CPropSheetDlg *pPropSheetDlg; // edi
  int v6; // ST20_4
  CResize *pResizer; // eax
  CResize *Resizer; // esi
  HWND hList; // eax
  ResizeInfo *ResizeInfo; // eax
  HWND v11; // eax
  ResizeInfo *v12; // eax
  HWND v13; // ST20_4
  HWND v14; // eax
  ResizeInfo *v15; // eax
  HWND v16; // ST20_4
  HWND v17; // eax
  ResizeInfo *v18; // eax
  HWND v19; // ST20_4
  HWND v20; // eax
  ResizeInfo *v21; // eax
  HWND v22; // ST20_4
  HWND v23; // eax
  ResizeInfo *v24; // eax
  HWND v25; // ST20_4
  HWND v26; // eax
  ResizeInfo *v27; // eax
  HWND v28; // ST20_4
  HWND v29; // eax
  ResizeInfo *v30; // eax
  HWND v31; // ST20_4
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // eax
  ResizeInfo *v35; // eax
  HWND v36; // ST20_4
  __m128i *v37; // ecx
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  HWND v43; // eax
  int v44; // ST24_4
  HWND v45; // eax
  int v46; // ST24_4
  HWND v47; // eax
  _DWORD *v48; // esi
  HCURSOR v49; // eax
  HWND v50; // eax
  LONG v51; // eax
  HWND v52; // eax
  _DWORD *v53; // edi
  int v54; // ecx
  HCURSOR v55; // eax
  HCURSOR v56; // eax
  int v57; // ecx
  HANDLE ProcessHandle; // eax
  int v59; // eax
  int result; // eax
  void *v61; // eax
  HANDLE v62; // eax
  _RTL_PROCESS_MODULES *pSystemModuleInfo; // eax
  _RTL_PROCESS_MODULES *SystemModuleInfo; // eax
  int v65; // eax
  int v66; // eax
  void *v67; // edi
  _IMAGELIST *v68; // ebx
  HICON v69; // eax
  HICON v70; // eax
  int v71; // esi
  LONG v72; // eax
  HANDLE v73; // eax
  void *v74; // ST24_4
  HWND v75; // esi
  HWND (__stdcall *v76)(HWND, int); // edi
  HWND v77; // eax
  HWND v78; // eax
  HWND v79; // eax
  HWND v80; // eax
  HWND v81; // eax
  HCURSOR v82; // esi
  int v83; // eax
  HWND v84; // eax
  HWND v85; // eax
  HWND v86; // eax
  HWND v87; // eax
  HWND v88; // eax
  HWND v89; // eax
  HWND v90; // eax
  BOOL v91; // ST24_4
  HWND v92; // eax
  BOOL v93; // ST24_4
  HWND v94; // eax
  BOOL v95; // eax
  BOOL v96; // ST24_4
  HWND v97; // eax
  BOOL v98; // eax
  BOOL v99; // ST24_4
  HWND v100; // eax
  BOOL v101; // eax
  BOOL v102; // ST24_4
  HWND v103; // eax
  _DWORD *v104; // ecx
  int v105; // edx
  HCURSOR v106; // esi
  unsigned int v107; // edx
  bool v108; // zf
  HWND v109; // ebx
  HCURSOR v110; // ebx
  HWND hWndDlg; // ebx
  HCURSOR v112; // esi
  HWND v113; // eax
  unsigned int v114; // eax
  const WCHAR *v115; // eax
  HWND v116; // esi
  int v117; // eax
  HWND v118; // eax
  void *v119; // esi
  void *v120; // esi
  HWND v121; // eax
  int v122; // eax
  HWND v123; // esi
  void *v124; // eax
  HWND v125; // eax
  void *v126; // ST24_4
  WPARAM v127; // [esp-8h] [ebp-1E98h]
  const WCHAR *v128; // [esp-4h] [ebp-1E94h]
  int v129; // [esp-4h] [ebp-1E94h]
  int v130; // [esp-4h] [ebp-1E94h]
  DWORD v131; // [esp+0h] [ebp-1E90h]
  LPARAM v132; // [esp+4h] [ebp-1E8Ch]
  char v133; // [esp+10h] [ebp-1E80h]
  const WCHAR *v134; // [esp+24Ch] [ebp-1C44h]
  SHELLEXECUTEINFOW pExecInfo; // [esp+2A0h] [ebp-1BF0h]
  NMHDR nmhdr; // [esp+2DCh] [ebp-1BB4h]
  int v137; // [esp+2E8h] [ebp-1BA8h]
  struct _FILETIME LocalFileTime; // [esp+2F0h] [ebp-1BA0h]
  LPARAM dwInitParam; // [esp+2F8h] [ebp-1B98h]
  int v140; // [esp+2FCh] [ebp-1B94h]
  HANDLE hObject; // [esp+300h] [ebp-1B90h]
  int v142; // [esp+304h] [ebp-1B8Ch]
  int v143; // [esp+308h] [ebp-1B88h]
  int v144; // [esp+30Ch] [ebp-1B84h]
  int v145; // [esp+310h] [ebp-1B80h]
  int v146; // [esp+314h] [ebp-1B7Ch]
  int v147; // [esp+318h] [ebp-1B78h]
  int v148; // [esp+31Ch] [ebp-1B74h]
  DWORD ExitCode; // [esp+320h] [ebp-1B70h]
  DWORD ThreadId; // [esp+324h] [ebp-1B6Ch]
  LPARAM lParam1; // [esp+328h] [ebp-1B68h]
  LRESULT v152; // [esp+32Ch] [ebp-1B64h]
  int v153; // [esp+330h] [ebp-1B60h]
  HWND v154; // [esp+348h] [ebp-1B48h]
  int v155; // [esp+35Ch] [ebp-1B34h]
  char ArgList[4]; // [esp+360h] [ebp-1B30h]
  int a3; // [esp+364h] [ebp-1B2Ch]
  HWND hDlg; // [esp+368h] [ebp-1B28h]
  void *pSystemProcessInfo; // [esp+36Ch] [ebp-1B24h]
  DWORD cbSize; // [esp+370h] [ebp-1B20h]
  size_t pdwSizeReturned; // [esp+374h] [ebp-1B1Ch]
  HCURSOR hCursor; // [esp+378h] [ebp-1B18h]
  HWND v163; // [esp+37Ch] [ebp-1B14h]
  char a2[36]; // [esp+380h] [ebp-1B10h]
  DWORD v165; // [esp+3A4h] [ebp-1AECh]
  int v166; // [esp+3A8h] [ebp-1AE8h]
  void *v167; // [esp+3ACh] [ebp-1AE4h]
  __int16 Dst[64]; // [esp+3B8h] [ebp-1AD8h]
  wchar_t v169[2052]; // [esp+438h] [ebp-1A58h]
  struct _SYSTEMTIME SystemTime; // [esp+1440h] [ebp-A50h]
  __m128i v171; // [esp+1450h] [ebp-A40h]
  __m128i v172; // [esp+1460h] [ebp-A30h]
  int v173; // [esp+1470h] [ebp-A20h]
  __int16 DateStr[256]; // [esp+1474h] [ebp-A1Ch]
  __int16 String[1024]; // [esp+1674h] [ebp-81Ch]
  int a4; // [esp+1E74h] [ebp-1Ch]
  __int16 v177; // [esp+1E78h] [ebp-18h]
  __int16 v178; // [esp+1E7Ah] [ebp-16h]
  __int16 v179; // [esp+1E7Ch] [ebp-14h]
  int v180; // [esp+1E8Ch] [ebp-4h]

  v4 = hWnd;
  hDlg = hWnd;
  hCursor = lParam;
  pPropSheetDlg = GetWindowLongW(hWnd, GWL_USERDATA);
  pSystemProcessInfo = 0;
  pdwSizeReturned = pPropSheetDlg;
  lParam1 = 0;
  memset(&v152, 0, 0x30u);
  _mm_storeu_si128(&v172, _mm_load_si128(&xmmword_12C6C60));
  v173 = 1077;
  v6 = gLogPixelsX;
  _mm_storeu_si128(&v171, _mm_load_si128(&xmmword_12C6C40));
  LOWORD(a4) = MulDiv(-50, v6, 96);
  HIWORD(a4) = MulDiv(-50, gLogPixelsX, 96);
  v177 = MulDiv(-75, gLogPixelsX, 96);
  v178 = MulDiv(100, gLogPixelsX, 96);
  v179 = MulDiv(200, gLogPixelsX, 96);
  cbSize = 0;
  if ( message > WM_COMMAND )
  {
    if ( message > WM_CTLCOLORDLG )
    {
      if ( message != WM_CTLCOLORSTATIC )
      {
        if ( message == PMT_MSG_7F1 )
        {
          v126 = pPropSheetDlg->PageData[0].hWnd;
          LOBYTE(pPropSheetDlg->PageData[0].TemplateName[6]) = 1;
          SetEvent(v126);
          InterlockedDecrement(&pPropSheetDlg->PageData[0].TemplateName[8]);
          return 0;
        }
        return 0;
      }
    }
    else if ( message != WM_CTLCOLORDLG )
    {
      if ( message == WM_TIMER )
      {
        if ( pPropSheetDlg )
          SetEvent(pPropSheetDlg->PageData[0].hWnd);
        nmhdr.code = 0xFFFFFFF1;
        v137 = 116;
        SendMessageW(hWnd, WM_NOTIFY, 0, &nmhdr);
        return 1;
      }
      if ( message != WM_CTLCOLOREDIT )
        return 0;
    }
    return sub_1246710(hWnd, wParam);
  }
  if ( message != WM_COMMAND )
  {
    switch ( message )
    {
      case WM_DRAWITEM:
        FindDlg_DrawItem(hCursor);
        return 0;
      case WM_MEASUREITEM:
        return HandleMeasureItem(hWnd, message, wParam, hCursor);
      case WM_NOTIFY:
        v82 = hCursor;
        switch ( *(hCursor + 2) )
        {
          case 0xFFFFFF4F:
            result = CTreeList::OnGetDispInfo(hCursor, wParam, hCursor);
            break;
          case 0xFFFFFF94:
            result = OnTreeListColumnClick(0x414, hCursor, v131, v132);
            break;
          case 0xFFFFFF99:
            result = CTreeList::DeleteItem(1044, hCursor);
            break;
          case 0xFFFFFF9B:
          case 0xFFFFFFF1:
            GetWindowLongW(*&pPropSheetDlg->PageData[0].TemplateName[12], GWL_STYLE);
            v83 = *(v82 + 2);
            if ( v83 != -101 && (v83 != -15 || *(v82 + 3) != 116) )
              return 0;
            v84 = GetDlgItem(hWnd, 1044);
            v152 = SendMessageW(v84, 0x100Cu, 0xFFFFFFFF, 2);
            v153 = 0;
            lParam1 = 4;
            v85 = GetDlgItem(hWnd, 1044);
            SendMessageW(v85, 0x104Bu, 0, &lParam1);
            if ( v152 == -1 )
            {
              FormatTex(String, gpszTargetName);
              SetDlgItemTextW(hWnd, 1086, String);
              SetDlgItemTextW(hWnd, 1077, String);
              SetDlgItemTextW(hWnd, 1080, String);
              SetDlgItemTextW(hWnd, 1081, String);
              SetDlgItemTextW(hWnd, 1082, String);
              SetDlgItemTextW(hWnd, 1078, String);
              SetDlgItemTextW(hWnd, 1079, String);
              SetDlgItemTextW(hWnd, 1083, String);
              SetDlgItemTextW(hWnd, 1339, String);
              SetDlgItemTextW(hWnd, 1340, String);
              SetDlgItemTextW(hWnd, 1088, String);
              SetDlgItemTextW(hWnd, 1343, String);
              v86 = GetDlgItem(hWnd, 1084);
              EnableWindow(v86, 0);
              v87 = GetDlgItem(hWnd, 1085);
              EnableWindow(v87, 0);
              v88 = GetDlgItem(hWnd, 1089);
              EnableWindow(v88, 0);
              v89 = GetDlgItem(hWnd, 1087);
              EnableWindow(v89, 0);
              v90 = GetDlgItem(hWnd, 1018);
              EnableWindow(v90, 0);
              result = 0;
            }
            else
            {
              v91 = *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68) != 0;
              v92 = GetDlgItem(hWnd, IDD_PROCTHREADS_BUTTON_MODULE);
              EnableWindow(v92, v91);
              v93 = *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68) != 0;
              v94 = GetDlgItem(hWnd, 1085);
              EnableWindow(v94, v93);
              v95 = *&pPropSheetDlg->PageData[0].TemplateName[16]
                 && *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68);
              v96 = v95;
              v97 = GetDlgItem(hWnd, 1089);
              EnableWindow(v97, v96);
              v98 = *&pPropSheetDlg->PageData[0].TemplateName[16]
                 && *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68);
              v99 = v98;
              v100 = GetDlgItem(hWnd, 1087);
              EnableWindow(v100, v99);
              v101 = *&pPropSheetDlg->PageData[0].TemplateName[16]
                  && *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68);
              v102 = v101;
              v103 = GetDlgItem(hWnd, 1018);
              EnableWindow(v103, v102);
              v163 = v154;
              pdwSizeReturned = 0;
              pSystemProcessInfo = 0;
              GetAllProcesses(&pSystemProcessInfo, &pdwSizeReturned);
              v104 = pSystemProcessInfo;
              v105 = *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68);
              if ( *(pSystemProcessInfo + 17) != v105 )
              {
                do
                {
                  if ( !*v104 )
                    break;
                  v104 = (v104 + *v104);
                }
                while ( v104[17] != v105 );
              }
              v106 = (v104 + 46);
              if ( LOBYTE(pPropSheetDlg->PageData[0].TemplateName[20]) )
                v106 = (v104 + 34);
              v107 = 0;
              hCursor = v106;
              v108 = v104[1] == 0;
              if ( v104[1] > 0u )
              {
                v109 = v163;
                do
                {
                  if ( !*(v106 + 9) )
                    *(v106 + 9) = v107;
                  if ( *(v109 + 11) == *(v106 + 9) )
                    break;
                  ++v107;
                  v106 += 16;
                }
                while ( v107 < v104[1] );
                v4 = hDlg;
                v108 = v107 == v104[1];
                hCursor = v106;
              }
              if ( !v108 )
              {
                FormatTex(String, L"%d", *(v106 + 9));
                SetDlgItemTextW(v4, 1086, String);
                v110 = hCursor;
                FormatTex(
                  String,
                  L"%I64d:%02I64d:%02I64d.%03I64d",
                  *hCursor / 0x861C46800ui64,
                  *hCursor / 0x23C34600ui64 % 0x3C,
                  *v106 / 10000000i64 % 60,
                  *v106 % 10000000i64 / 10000);
                SetDlgItemTextW(hDlg, 1078, String);
                FormatTex(
                  String,
                  L"%I64d:%02I64d:%02I64d.%03I64d",
                  *(hCursor + 1) / 0x861C46800ui64,
                  *(hCursor + 1) / 0x23C34600ui64 % 0x3C,
                  *(v110 + 1) / 10000000i64 % 60,
                  *(v110 + 1) % 10000000i64 / 10000);
                hWndDlg = hDlg;
                SetDlgItemTextW(hDlg, 1079, String);
                v112 = hCursor;
                if ( *(hCursor + 2)
                  && (FileTimeToLocalFileTime(hCursor + 2, &LocalFileTime),
                      FileTimeToSystemTime(&LocalFileTime, &SystemTime),
                      GetTimeFormatW(0x400u, 0, &SystemTime, 0, String, 512))
                  && GetDateFormatW(0x400u, 0, &SystemTime, 0, DateStr, 128) )
                {
                  wcscat_s(String, 0x400u, L"   ");
                  wcscat_s(String, 0x400u, DateStr);
                }
                else
                {
                  tcscpy_s(String, 0x400u, L"n/a");
                }
                SetDlgItemTextW(hWndDlg, 1077, String);
                if ( *(v112 + 13) != 5 || *(v112 + 14) != 5 )
                  v128 = L"Sus&pend";
                else
                  v128 = L"R&esume";
                v113 = GetDlgItem(hWndDlg, 1018);
                SetWindowTextW(v113, v128);
                switch ( *(v112 + 13) )
                {
                  case 0:
                    tcscpy_s(String, 0x400u, L"Initialized");
                    break;
                  case 1:
                    tcscpy_s(String, 0x400u, L"Ready");
                    break;
                  case 2:
                    tcscpy_s(String, 0x400u, L"Running");
                    break;
                  case 4:
                    tcscpy_s(String, 0x400u, L"Terminated");
                    break;
                  case 5:
                    v114 = *(v112 + 14);
                    if ( v114 >= 0x28 )
                      FormatTex(String, L"Waiting");
                    else
                      FormatTex(String, L"Wait:%s", &aExecutive[64 * v114]);
                    break;
                  case 6:
                    tcscpy_s(String, 0x400u, L"Transition");
                    break;
                  case 7:
                    tcscpy_s(String, 0x400u, L"DeferredReady");
                    break;
                  default:
                    FormatTex(String, L"<Unknown: %d>", *(v112 + 13));
                    break;
                }
                SetDlgItemTextW(hWndDlg, 1083, String);
                if ( *(v112 + 8) )
                {
                  FormatTex(String, L"%d", *(v112 + 11));
                  SetDlgItemTextW(hWndDlg, 1080, String);
                  FormatTex(String, L"%d", *(v112 + 10));
                  SetDlgItemTextW(hWndDlg, 1081, String);
                  v129 = *(v112 + 12);
                  if ( *(v112 + 8) )
                  {
                    FormatTex(String, L"%d", v129);
                    v115 = GetNumberTextFormat(String, 0x400u);
                    SetDlgItemTextW(hWndDlg, 1082, v115);
                  }
                  else
                  {
                    FormatTex(String, L"n/a", v129);
                  }
                  v116 = v163;
                  *ArgList = -1;
                  v155 = -1;
                  v117 = *(v163 + 10);
                  if ( v117 )
                  {
                    NtQueryInformationThread(v117, 22, &v155, 4, &v147);
                    NtQueryInformationThread(*(v116 + 10), 24, ArgList, 4, &v147);
                  }
                  if ( *(v116 + 10) )
                  {
                    FormatTex(String, L"%I64u", *(v116 + 154), *(v116 + 155));
                    GetNumberTextFormat(String, 0x400u);
                  }
                  else
                  {
                    FormatTex(String, L"n/a");
                  }
                  SetDlgItemTextW(hWndDlg, 1088, String);
                  if ( v155 == -1 )
                    FormatTex(String, L"n/a");
                  else
                    sub_1277790(v155, String, 0x400u);
                  SetDlgItemTextW(hWndDlg, 1340, String);
                  if ( *ArgList == -1 )
                    FormatTex(String, L"n/a");
                  else
                    FormatTex(String, L"%d", *ArgList);
                  SetDlgItemTextW(hWndDlg, 1339, String);
                  if ( GetThreadIdealProcessorEx )
                  {
                    v130 = *(v116 + 610);
                    if ( dword_12E10DC <= 1 )
                      FormatTex(String, L"%d", v130);
                    else
                      FormatTex(String, L"[%d]:%d", *(v116 + 304), v130);
                    SetDlgItemTextW(hWndDlg, 1343, String);
                  }
                }
              }
              free(pSystemProcessInfo);
              result = 0;
            }
            break;
          case 0xFFFFFFFD:
            SendMessageW(hWnd, 0x111u, 0x43Du, 0);
            result = 0;
            break;
          default:
            return 0;
        }
        return result;
      case WM_KEYDOWN:
        if ( wParam != 't' )
          return 0;
        SetEvent(*pPropSheetDlg->PageData[0].TemplateName);
        return 0;
      case WM_INITDIALOG:
        if ( GetLogicalProcessorInformationEx )
        {
          // RelationGroup  4
          // Retrieves information about logical processors that share a processor group.
          GetLogicalProcessorInformationEx(RelationGroup, 0, &cbSize);
          dword_12E10DC = cbSize / 0x4C;
        }
        pResizer = operator new(0x40u);
        pdwSizeReturned = pResizer;
        v180 = 0;
        if ( pResizer )
          Resizer = CResize::CResize(pResizer, hWnd);
        else
          Resizer = 0;
        v180 = -1;
        Resizer->m_WidthScale = 80;
        Resizer->m_HeightScale = 50;
        hList = GetDlgItem(hWnd, IDD_PROCTHREADS_CTRL_LISTVIEW);
        if ( hList )
        {
          ResizeInfo = CResize::InitResizeBuffer(Resizer, hList, 1);
          *&ResizeInfo->d21.left = 0i64;
          *&ResizeInfo->d21.right = doubleOnePointZero;
        }
        v11 = GetDlgItem(hWnd, IDD_PROCTHREADS_STATIC_NA4);
        v163 = v11;
        if ( v11 )
        {
          v12 = CResize::InitResizeBuffer(Resizer, v11, 1);
          v13 = v163;
          v12->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v13, 1)->d21 = xmmword_12C6C70;
        }
        v14 = GetDlgItem(hWnd, 1081);
        v163 = v14;
        if ( v14 )
        {
          v15 = CResize::InitResizeBuffer(Resizer, v14, 1);
          v16 = v163;
          v15->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v16, 1)->d21 = xmmword_12C6C70;
        }
        v17 = GetDlgItem(hWnd, 1125);
        v163 = v17;
        if ( v17 )
        {
          v18 = CResize::InitResizeBuffer(Resizer, v17, 1);
          v19 = v163;
          v18->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v19, 1)->d21 = xmmword_12C6C70;
        }
        v20 = GetDlgItem(hWnd, 1126);
        v163 = v20;
        if ( v20 )
        {
          v21 = CResize::InitResizeBuffer(Resizer, v20, 1);
          v22 = v163;
          v21->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v22, 1)->d21 = xmmword_12C6C70;
        }
        v23 = GetDlgItem(hWnd, 1339);
        v163 = v23;
        if ( v23 )
        {
          v24 = CResize::InitResizeBuffer(Resizer, v23, 1);
          v25 = v163;
          v24->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v25, 1)->d21 = xmmword_12C6C70;
        }
        v26 = GetDlgItem(hWnd, 1340);
        v163 = v26;
        if ( v26 )
        {
          v27 = CResize::InitResizeBuffer(Resizer, v26, 1);
          v28 = v163;
          v27->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v28, 1)->d21 = xmmword_12C6C70;
        }
        v29 = GetDlgItem(hWnd, 1085);
        v163 = v29;
        if ( v29 )
        {
          v30 = CResize::InitResizeBuffer(Resizer, v29, 1);
          v31 = v163;
          v30->d1 = xmmword_12C6C70;
          CResize::InitResizeBuffer(Resizer, v31, 1)->d21 = xmmword_12C6C70;
        }
        v32 = GetDlgItem(hWnd, 1089);
        if ( v32 )
          CResize::InitResizeBuffer(Resizer, v32, 1)->d1 = xmmword_12C6C70;
        v33 = GetDlgItem(hWnd, 1087);
        if ( v33 )
          CResize::InitResizeBuffer(Resizer, v33, 1)->d1 = xmmword_12C6C70;
        v34 = GetDlgItem(hWnd, 1343);
        v163 = v34;
        if ( v34 )
        {
          v35 = CResize::InitResizeBuffer(Resizer, v34, 1);
          v36 = v163;
          v35->d1 = 0i64;
          CResize::InitResizeBuffer(Resizer, v36, 1)->d21 = xmmword_12C6C70;
        }
        ResizeTab(hWnd);
        if ( *(hCursor + 40) & 0x20 && gdwOsType >= 1 )
        {
          v37 = &v172;
          v163 = 5;
        }
        else
        {
          v37 = &v171;
          v163 = 4;
        }
        v108 = *(hCursor + 17) == 0;
        a3 = v37;
        if ( v108 )
        {
          v172.m128i_i32[0] = 1638;
          v171.m128i_i32[0] = 1638;
        }
        if ( gdwOsType >= 1 )
        {
          v37->m128i_i32[2] = 1200;
        }
        else
        {
          v38 = GetDlgItem(hWnd, 1338);
          ShowWindow(v38, 0);
          v39 = GetDlgItem(hWnd, 1339);
          ShowWindow(v39, 0);
          v40 = GetDlgItem(hWnd, 1337);
          ShowWindow(v40, 0);
          v41 = GetDlgItem(hWnd, 1340);
          ShowWindow(v41, 0);
          v42 = GetDlgItem(hWnd, 1088);
          ShowWindow(v42, 0);
          v43 = GetDlgItem(hWnd, 1347);
          ShowWindow(v43, 0);
        }
        v44 = GetThreadIdealProcessorEx != 0 ? 5 : 0;
        v45 = GetDlgItem(hWnd, 1342);
        ShowWindow(v45, v44);
        v46 = GetThreadIdealProcessorEx != 0 ? 5 : 0;
        v47 = GetDlgItem(hWnd, 1343);
        ShowWindow(v47, v46);
        v48 = malloc(0x50u);
        pdwSizeReturned = v48;
        memset(v48, 0, 0x50u);
        v49 = hCursor;
        *v48 = 0;
        v48[11] = 0;
        v48[8] = v49;
        v48[5] = CreateEventW(0, 0, 0, 0);
        v50 = GetDlgItem(hWnd, 1044);
        v48[9] = v50;
        SetWindowLongW(v50, -4, PEListCtrlWndProc);
        SetWindowLongW(hWnd, -21, v48);
        v51 = GetWindowLongW(v48[9], -16);
        SetWindowLongW(v48[9], -16, v51 & 0xFFFFFFFD | 9);
        SetWindowLongW(v48[9], -21, 5);
        v52 = GetDlgItem(hWnd, 1341);
        SetWindowTextW(v52, gpszTargetName);
        sub_12592A0(0);
        SendMessageW(v48[9], WM_SETFONT, ghDefaultFont, 0);
        GetAllProcesses(&pSystemProcessInfo, 0);
        v53 = pSystemProcessInfo;
        v54 = *(v48[8] + 68);
        if ( *(pSystemProcessInfo + 17) == v54 )
          goto LABEL_43;
        break;
      default:
        return 0;
    }
    do
    {
      if ( !*v53 )
      {
        free(pSystemProcessInfo);
        return 1;
      }
      v53 = (v53 + *v53);
    }
    while ( v53[17] != v54 );
LABEL_43:
    v55 = LoadCursorW(0, IDC_WAIT);
    v56 = SetCursor(v55);
    v57 = v48[8];
    hCursor = v56;
    ProcessHandle = OpenProcess(0x80000000, 0, *(v57 + 68));
    v48[11] = ProcessHandle;
    if ( ProcessHandle )
    {
      v59 = a3;
    }
    else
    {
      v48[11] = OpenProcess(0x100000u, 0, *(v48[8] + 68));
      v59 = a3;
      *(a3 + 8) = 1092;
    }
    CThreadStackPage::InitListCtrl(v48[9], v163, v59, &a4, 1);
    if ( *SymInitialize )
    {
      EnterCriticalSection(&gStrListLock);
      SymSetOptions(0x10037u);
      v61 = v48[11];
      if ( v61 )
        *(v48 + 72) = SymInitialize(v61, 0, 1);
      if ( !*(v48 + 72) )
      {
        if ( v48[11] )
          CloseHandle(v48[11]);
        v62 = GetCurrentProcess();
        v48[11] = v62;
        *(v48 + 72) = SymInitialize(v62, 0, 1);
      }
    }
    cbSize = 1000;
    pSystemModuleInfo = malloc(0x3E8u);
    v48[10] = pSystemModuleInfo;
    if ( NtQuerySystemInformation(SystemModuleInformation, pSystemModuleInfo, cbSize, &cbSize) )
    {
      do
      {
        free(v48[10]);
        cbSize += 1000;
        SystemModuleInfo = malloc(cbSize);
        v48[10] = SystemModuleInfo;
      }
      while ( NtQuerySystemInformation(SystemModuleInformation, SystemModuleInfo, cbSize, &cbSize) );
    }
    v65 = v48[8];
    v48[12] = 0;
    if ( !(*(v65 + 40) & 0x10) )
    {
      v66 = RtlCreateQueryDebugBuffer(0, 0);
      v48[12] = v66;
      if ( v66 )
      {
        v145 = v53[17];
        v146 = v48[12];
        v67 = _beginthreadex(0, 0, QueryDBGInfoThreadProc, &v145, 0, &ThreadId);
        CloseHandle(v48[4]);
        if ( WaitForSingleObject(v67, 0xFA0u) == 258 )
        {
          LeaveCriticalSection(&gStrListLock);
          TerminateThread(v67, 1u);
        }
        GetExitCodeThread(v67, &ExitCode);
        if ( ExitCode )
        {
          RtlDestroyQueryDebugBuffer(v48[12]);
          v48[12] = 0;
        }
        CloseHandle(v67);
      }
    }
    if ( *SymInitialize )
      LeaveCriticalSection(&gStrListLock);
    free(pSystemProcessInfo);
    v68 = ImageList_Create(16, 16, 1u, 256, 256);
    v69 = LoadIconW(ghInstance, 0xCB);
    ImageList_ReplaceIcon(v68, -1, v69);
    v70 = LoadIconW(ghInstance, 0x71);
    ImageList_ReplaceIcon(v68, -1, v70);
    v71 = pdwSizeReturned;
    v72 = GetWindowLongW(*(pdwSizeReturned + 36), -16);
    SetWindowLongW(*(v71 + 36), -16, v72 | 0x48);
    SendMessageW(*(v71 + 36), 0x1003u, 1u, v68);
    InitTreeListSortableHeader(
      *(v71 + 36),
      gdwProcessThreadSortColumnLast,
      gdwProcessThreadSortColumnLast,
      dword_12E53B4);
    *(v71 + 24) = 0;
    *(v71 + 28) = 2;
    *(v71 + 8) = CreateEventW(0, 0, 1, 0);
    *(v71 + 8) = CreateEventW(0, 0, 1, 0);
    v73 = CreateEventW(0, 0, 1, 0);
    *(v71 + 12) = v73;
    ResetEvent(v73);
    v74 = *(v71 + 8);
    *(v71 + 4) = 0;
    SetEvent(v74);
    *(v71 + 16) = _beginthreadex(0, 0, sub_126C7F0, v71, 0, &ThreadId);
    SetFocus(*(v71 + 36));
    SetCursor(hCursor);
    ReleaseCapture();
    if ( GetCurrentProcessId() != *(*(v71 + 32) + 68) && *(v71 + 44) )
    {
      v75 = hDlg;
      v76 = GetDlgItem;
    }
    else
    {
      v75 = hDlg;
      v76 = GetDlgItem;
      v77 = GetDlgItem(hDlg, 1089);
      EnableWindow(v77, 0);
      v78 = GetDlgItem(v75, 1085);
      EnableWindow(v78, 0);
      v79 = GetDlgItem(v75, 1087);
      EnableWindow(v79, 0);
      v80 = GetDlgItem(v75, 1018);
      EnableWindow(v80, 0);
    }
    if ( !*StackWalk64 )
    {
      v81 = v76(v75, 1085);
      EnableWindow(v81, 0);
    }
    return 1;
  }
  if ( wParam > 1084 )
  {
    if ( wParam > 40001 )
    {
      if ( wParam == 40002 )
      {
        SetEvent(ghEventRefreshSearchResult);
        return 0;
      }
      if ( wParam - 40092 > 1 )
        return 0;
      v127 = wParam;
    }
    else
    {
      if ( wParam != 40001 )
      {
        switch ( wParam )
        {
          case 0x43Du:
            if ( !*StackWalk64 )
              return 0;
            v152 = SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x100Cu, 0xFFFFFFFF, 2);
            if ( v152 == -1 )
              return 0;
            v153 = 0;
            lParam1 = 4;
            if ( !SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x104Bu, 0, &lParam1) )
              return 0;
            v123 = v154;
            v124 = sub_1275870(*(v154 + 11), 74);
            if ( v124 )
            {
              dwInitParam = *(*&pPropSheetDlg->PageData[0].TemplateName[10] + 68);
              v140 = *(v123 + 11);
              v142 = *&pPropSheetDlg->PageData[0].TemplateName[16];
              hObject = v124;
              v144 = *&pPropSheetDlg->PageData[0].TemplateName[18];
              v143 = *&pPropSheetDlg->PageData[0].TemplateName[14];
              DialogBoxParamW(ghInstance2, L"THREADSTACK", hWnd, ThreadStackDlgProc, &dwInitParam);
              if ( hObject )
              {
                CloseHandle(hObject);
                return 0;
              }
              return 0;
            }
            break;
          case 0x43Fu:
            goto LABEL_156;
          case 0x441u:
            v152 = SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x100Cu, 0xFFFFFFFF, 2);
            if ( v152 == -1 )
              return 0;
            v153 = 0;
            lParam1 = 4;
            if ( !SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x104Bu, 0, &lParam1) )
              return 0;
            pdwSizeReturned = v154;
            v120 = sub_1275870(*(v154 + 11), 0x20000);
            if ( v120 )
            {
              memset(a2, 0, 0x10C0u);
              FormatTex(v169, L"Thread %d", *(pdwSizeReturned + 44));
              v166 = 0;
              tcscpy_s(Dst, 0x40u, L"Thread");
              v167 = v120;
              v165 = GetCurrentProcessId();
              ShowHandleProperties(hWnd, a2);
              CloseHandle(v120);
              return 0;
            }
            break;
          default:
            return 0;
        }
        MessageBoxW(
          *&pPropSheetDlg->PageData[0].TemplateName[12],
          L"Unable to access thread",
          L"Process Explorer",
          0x10u);
        return 0;
      }
      v127 = 40014;
    }
    v125 = GetParent(hWnd);
    PostMessageW(v125, 0x111u, v127, 0);
    return 0;
  }
  if ( wParam == 1084 )
  {
    v152 = SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x100Cu, 0xFFFFFFFF, 2);
    if ( v152 != -1 )
    {
      v153 = 0;
      lParam1 = 4;
      if ( SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x104Bu, 0, &lParam1) )
      {
        qmemcpy(&v133, v154, 0x290u);
        if ( v134 )
        {
          memset(&pExecInfo, 0, 0x3Cu);
          pExecInfo.cbSize = 60;
          pExecInfo.lpFile = v134;
          pExecInfo.lpVerb = L"properties";
          pExecInfo.fMask = 12;
          ShellExecuteExW(&pExecInfo);
          SetFocus(*(pdwSizeReturned + 36));
        }
        else
        {
          MessageBoxW(hWnd, L"The module cannot be located", L"Process Explorer", 0x10u);
        }
        return 0;
      }
    }
    return 0;
  }
  if ( wParam != 1018 )
    return 0;
LABEL_156:
  v152 = SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x100Cu, 0xFFFFFFFF, 2);
  if ( v152 == -1 )
    return 0;
  v153 = 0;
  lParam1 = 4;
  if ( !SendMessageW(*&pPropSheetDlg->PageData[0].TemplateName[12], 0x104Bu, 0, &lParam1) )
    return 0;
  v118 = v154;
  pdwSizeReturned = v154;
  if ( wParam == 1087 )
  {
    FormatTex(String, L"Are you sure you want to kill thread %d?", *(v154 + 11));
    if ( MessageBoxW(ghWndNewOwner, String, L"Process Explorer", 0x31u) != 2 )
    {
      v118 = pdwSizeReturned;
      goto LABEL_161;
    }
    return 0;
  }
LABEL_161:
  v119 = sub_1275870(*(v118 + 11), 3);
  if ( !v119 )
  {
    ErrMsgBox(L"Unable to access thread", *&pPropSheetDlg->PageData[0].TemplateName[12]);
    return 0;
  }
  if ( wParam == 1087 )
  {
    if ( !TerminateThread(v119, 0) )
    {
      ErrMsgBox(L"Unable to terminate thread", ghWndNewOwner);
      CloseHandle(v119);
      return 0;
    }
  }
  else
  {
    v121 = GetDlgItem(hWnd, 1018);
    GetWindowTextW(v121, String, 1024);
    v122 = wcscmp(String, L"R&esume");
    if ( v122 )
      v122 = -(v122 < 0) | 1;
    if ( v122 )
    {
      if ( NtSuspendThread(v119, &v148) )
        ErrMsgBox(L"Unable to suspend thread", ghWndNewOwner);
    }
    else if ( NtResumeThread(v119, &v148) )
    {
      ErrMsgBox(L"Unable to resume thread", ghWndNewOwner);
      CloseHandle(v119);
      return 0;
    }
  }
  CloseHandle(v119);
  return 0;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BE398: using guessed type wchar_t aREsume[8];
// 12C5A74: using guessed type wchar_t aWaitS[8];
// 12C5AF4: using guessed type wchar_t aProperties[11];
// 12C6C40: using guessed type __int128 xmmword_12C6C40;
// 12C6C60: using guessed type __int128 xmmword_12C6C60;
// 12C6C70: using guessed type __int128 xmmword_12C6C70;
// 12DE8B8: using guessed type wchar_t aExecutive[10];
// 12E10DC: using guessed type int dword_12E10DC;
// 12E4E54: using guessed type int gdwOsType;
// 12E53B4: using guessed type int dword_12E53B4;
// 12EF23C: using guessed type int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF244: using guessed type int (__stdcall *NtSuspendThread)(_DWORD, _DWORD);
// 12EF248: using guessed type int (__stdcall *NtResumeThread)(_DWORD, _DWORD);
// 12EF258: using guessed type int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD);
// 12EF25C: using guessed type int (__stdcall *RtlCreateQueryDebugBuffer)(_DWORD, _DWORD);
// 12EF264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);

//----- (0126C7F0) --------------------------------------------------------
int __stdcall sub_126C7F0(#1077 *a1)
{
  HWND v1; // edi
  #1077 *v2; // esi
  DWORD v3; // eax
  int v4; // ecx
  LRESULT (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ebx
  int v6; // eax
  int v7; // esi
  char v8; // al
  int v9; // ecx
  struct _FILETIME v10; // rax
  DWORD v11; // ebx
  int v12; // ecx
  int *v13; // eax
  int v14; // eax
  unsigned int *v15; // eax
  DWORD v16; // esi
  SYSTEM_PERFORMANCE_INFORMATION *v17; // edi
  __int64 v18; // rax
  __int64 v19; // kr10_8
  int v20; // ebx
  unsigned int v21; // ecx
  int v22; // esi
  LPARAM v23; // ecx
  int v24; // eax
  void *v25; // eax
  LPARAM v26; // edi
  unsigned int v27; // ecx
  __int64 v28; // rax
  bool v29; // cf
  int v30; // ecx
  int v31; // edx
  double v32; // xmm0_8
  WPARAM v33; // edx
  int v34; // ecx
  double v35; // xmm0_8
  char v36; // dl
  double v37; // xmm1_8
  LPARAM v38; // ecx
  double v39; // xmm1_8
  char v40; // dh
  int v41; // eax
  char v42; // al
  int v43; // eax
  HANDLE v44; // ecx
  #1077 *v45; // esi
  signed int v46; // eax
  void *ProcessHandle; // edx
  const wchar_t *v48; // eax
  HWND v49; // ebx
  HWND v50; // eax
  HWND v51; // eax
  HWND v52; // eax
  HWND v53; // eax
  HANDLE v54; // edi
  int v55; // edi
  HWND v56; // esi
  char v58; // [esp-294h] [ebp-E24h]
  int v59; // [esp-290h] [ebp-E20h]
  int v60; // [esp-28Ch] [ebp-E1Ch]
  int v61; // [esp-288h] [ebp-E18h]
  int v62; // [esp-284h] [ebp-E14h]
  int v63; // [esp-280h] [ebp-E10h]
  int v64; // [esp-27Ch] [ebp-E0Ch]
  int v65; // [esp-278h] [ebp-E08h]
  int v66; // [esp-274h] [ebp-E04h]
  int v67; // [esp-270h] [ebp-E00h]
  int v68; // [esp-26Ch] [ebp-DFCh]
  int v69; // [esp-268h] [ebp-DF8h]
  int v70; // [esp-264h] [ebp-DF4h]
  int v71; // [esp-260h] [ebp-DF0h]
  int v72; // [esp-25Ch] [ebp-DECh]
  int v73; // [esp-258h] [ebp-DE8h]
  int v74; // [esp-254h] [ebp-DE4h]
  int v75; // [esp-250h] [ebp-DE0h]
  int v76; // [esp-24Ch] [ebp-DDCh]
  int v77; // [esp-248h] [ebp-DD8h]
  int v78; // [esp-244h] [ebp-DD4h]
  int v79; // [esp-240h] [ebp-DD0h]
  int v80; // [esp-23Ch] [ebp-DCCh]
  int v81; // [esp-238h] [ebp-DC8h]
  int v82; // [esp-234h] [ebp-DC4h]
  int v83; // [esp-230h] [ebp-DC0h]
  int v84; // [esp-22Ch] [ebp-DBCh]
  int v85; // [esp-228h] [ebp-DB8h]
  int v86; // [esp-224h] [ebp-DB4h]
  int v87; // [esp-220h] [ebp-DB0h]
  int v88; // [esp-21Ch] [ebp-DACh]
  int v89; // [esp-218h] [ebp-DA8h]
  int v90; // [esp-214h] [ebp-DA4h]
  int v91; // [esp-210h] [ebp-DA0h]
  int v92; // [esp-20Ch] [ebp-D9Ch]
  int v93; // [esp-208h] [ebp-D98h]
  int v94; // [esp-204h] [ebp-D94h]
  int v95; // [esp-200h] [ebp-D90h]
  int v96; // [esp-1FCh] [ebp-D8Ch]
  int v97; // [esp-1F8h] [ebp-D88h]
  int v98; // [esp-1F4h] [ebp-D84h]
  int v99; // [esp-1F0h] [ebp-D80h]
  int v100; // [esp-1ECh] [ebp-D7Ch]
  int v101; // [esp-1E8h] [ebp-D78h]
  int v102; // [esp-1E4h] [ebp-D74h]
  int v103; // [esp-1E0h] [ebp-D70h]
  int v104; // [esp-1DCh] [ebp-D6Ch]
  int v105; // [esp-1D8h] [ebp-D68h]
  int v106; // [esp-1D4h] [ebp-D64h]
  int v107; // [esp-1D0h] [ebp-D60h]
  int v108; // [esp-1CCh] [ebp-D5Ch]
  int v109; // [esp-1C8h] [ebp-D58h]
  int v110; // [esp-1C4h] [ebp-D54h]
  int v111; // [esp-1C0h] [ebp-D50h]
  int v112; // [esp-1BCh] [ebp-D4Ch]
  int v113; // [esp-1B8h] [ebp-D48h]
  int v114; // [esp-1B4h] [ebp-D44h]
  int v115; // [esp-1B0h] [ebp-D40h]
  int v116; // [esp-1ACh] [ebp-D3Ch]
  int v117; // [esp-1A8h] [ebp-D38h]
  int v118; // [esp-1A4h] [ebp-D34h]
  int v119; // [esp-1A0h] [ebp-D30h]
  SYSTEM_PERFORMANCE_INFORMATION *v120; // [esp-14h] [ebp-BA4h]
  unsigned __int64 v121; // [esp-10h] [ebp-BA0h]
  int v122; // [esp-8h] [ebp-B98h]
  unsigned int *v123; // [esp-4h] [ebp-B94h]
  LPARAM v124; // [esp+Ch] [ebp-B84h]
  int v125; // [esp+18h] [ebp-B78h]
  int v126; // [esp+1Ch] [ebp-B74h]
  int v127; // [esp+24h] [ebp-B6Ch]
  _OBJECT_ATTRIBUTES ObjectAttr; // [esp+28h] [ebp-B68h]
  SIZE_T NumberOfBytesRead; // [esp+40h] [ebp-B50h]
  DWORD pdwSizeReturned; // [esp+44h] [ebp-B4Ch]
  int v131; // [esp+48h] [ebp-B48h]
  int v132; // [esp+4Ch] [ebp-B44h]
  int v133; // [esp+50h] [ebp-B40h]
  HANDLE Handles; // [esp+54h] [ebp-B3Ch]
  int v135; // [esp+58h] [ebp-B38h]
  size_t v136; // [esp+5Ch] [ebp-B34h]
  int v137; // [esp+60h] [ebp-B30h]
  double v138; // [esp+64h] [ebp-B2Ch]
  HANDLE ThreadHandle; // [esp+6Ch] [ebp-B24h]
  LPARAM lParam; // [esp+70h] [ebp-B20h]
  int v141; // [esp+74h] [ebp-B1Ch]
  int v142; // [esp+78h] [ebp-B18h]
  LPARAM v143; // [esp+90h] [ebp-B00h]
  WPARAM wParam; // [esp+A4h] [ebp-AECh]
  WPARAM v145; // [esp+A8h] [ebp-AE8h]
  _DWORD v146[2]; // [esp+ACh] [ebp-AE4h]
  WPARAM v147; // [esp+B4h] [ebp-ADCh]
  WPARAM v148; // [esp+B8h] [ebp-AD8h]
  WPARAM v149; // [esp+BCh] [ebp-AD4h]
  unsigned int Buffer; // [esp+C0h] [ebp-AD0h]
  unsigned int v151; // [esp+C4h] [ebp-ACCh]
  int v152; // [esp+C8h] [ebp-AC8h]
  HANDLE hHandle; // [esp+CCh] [ebp-AC4h]
  HWND hDlg; // [esp+D0h] [ebp-AC0h]
  int v155; // [esp+D4h] [ebp-ABCh]
  int v156; // [esp+D8h] [ebp-AB8h]
  char ArgList[4]; // [esp+DCh] [ebp-AB4h]
  HWND hWnd; // [esp+E0h] [ebp-AB0h]
  void *ppBuffer; // [esp+E4h] [ebp-AACh]
  char *v160; // [esp+E8h] [ebp-AA8h]
  #1077 *v161; // [esp+ECh] [ebp-AA4h]
  int a5; // [esp+F3h] [ebp-A9Dh]
  char v163; // [esp+FBh] [ebp-A95h]
  int v164; // [esp+FCh] [ebp-A94h]
  int v165; // [esp+100h] [ebp-A90h]
  int v166; // [esp+10Ch] [ebp-A84h]
  int v167; // [esp+110h] [ebp-A80h]
  int v168; // [esp+124h] [ebp-A6Ch]
  int v169; // [esp+128h] [ebp-A68h]
  int v170; // [esp+12Ch] [ebp-A64h]
  __int64 v171; // [esp+33Ch] [ebp-854h]
  int v172; // [esp+34Ch] [ebp-844h]
  int v173; // [esp+350h] [ebp-840h]
  int v174; // [esp+35Ch] [ebp-834h]
  unsigned __int64 CycleTime; // [esp+364h] [ebp-82Ch]
  __int64 v176; // [esp+36Ch] [ebp-824h]
  int v177; // [esp+374h] [ebp-81Ch]
  void *v178; // [esp+378h] [ebp-818h]
  ULONG v179; // [esp+37Ch] [ebp-814h]
  unsigned int v180; // [esp+380h] [ebp-810h]
  wchar_t *v181; // [esp+384h] [ebp-80Ch]
  WCHAR String; // [esp+38Ch] [ebp-804h]

  v1 = *(a1 + 9);
  v161 = a1;
  hWnd = v1;
  ppBuffer = 0;
  v136 = 0;
  lParam = 0;
  memset(&v141, 0, 0x30u);
  MulDiv(-50, gLogPixelsX, 96);
  MulDiv(-100, gLogPixelsX, 96);
  MulDiv(-100, gLogPixelsX, 96);
  MulDiv(100, gLogPixelsX, 96);
  v2 = v161;
  v123 = -1;
  v122 = 0;
  hHandle = 0;
  Handles = *(v161 + 2);
  v135 = *(v161 + 3);
  v163 = 1;
  v3 = WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF);
  SendMessageW = ::SendMessageW;
  if ( *(v2 + 24) )
    goto LABEL_95;
  LOBYTE(v4) = a5;
  v148 = v145;
  *(&a5 + 1) = v4;
  v149 = wParam;
  while ( 1 )
  {
    v155 = 0;
    v156 = 0;
    *ArgList = 0;
    if ( v3 )
      goto LABEL_85;
    BYTE1(a5) = 0;
    hDlg = GetParent(v1);
    if ( !v163 )
    {
      lParam = 4;
      v6 = SendMessageW(v1, 4100, 0, 0);
      v142 = 0;
      v141 = v6 - 1;
      if ( SendMessageW(v1, 0x104Bu, 0, &lParam) )
      {
        v7 = v156;
        do
        {
          v8 = DeleteItemFromListCtrl(SendMessageW, v1, &lParam, v143, &a5);
          v9 = BYTE1(a5);
          if ( v8 )
            v9 = 1;
          *(&a5 + 1) = v9;
          if ( a5 )
          {
            if ( *(v143 + 12) != 1 )
              --*(v143 + 20);
            ++v7;
          }
          lParam = 4;
          v142 = 0;
        }
        while ( SendMessageW(v1, 0x104Bu, 0, &lParam) );
        v156 = v7;
        v2 = v161;
      }
    }
    v10 = GetAllProcesses(&ppBuffer, &v136);
    v11 = v10.dwLowDateTime;
    *ArgList = v10.dwHighDateTime;
    v160 = ppBuffer;
    v12 = *(*(v2 + 8) + 68);
    if ( *(ppBuffer + 17) != v12 )
      break;
LABEL_19:
    *&v122 = gSystemInfo.dwNumberOfProcessors;
    v121 = __PAIR__(v10.dwHighDateTime, v11) - *(v2 + 7);
    v147 = v121 * gSystemInfo.dwNumberOfProcessors >> 32;
    v152 = v121 * gSystemInfo.dwNumberOfProcessors;
    if ( !(v121 * gSystemInfo.dwNumberOfProcessors) )
    {
      v152 = 1;
      v147 = 0;
    }
    v15 = *ArgList;
    *(v2 + 14) = v11;
    *(v2 + 15) = v15;
    if ( GetProcessorSystemCycleTime )
    {
      v16 = 8 * gSystemInfo.dwNumberOfProcessors;
      v17 = malloc(8 * gSystemInfo.dwNumberOfProcessors);
      NtQuerySystemInformation(0x6Cu, v17, v16, &pdwSizeReturned);
      LODWORD(v18) = sub_125E4B0(0, ppBuffer, v17, 0);
      v2 = v161;
      v120 = v17;
      v19 = v18 - *(v161 + 8);
      v148 = (v18 - *(v161 + 8)) >> 32;
      v149 = v19;
      *(v161 + 16) = v18;
      *(v2 + 17) = HIDWORD(v18);
      free(v120);
      v1 = hWnd;
    }
    v20 = (v160 + 184);
    if ( *(v2 + 52) )
      v20 = (v160 + 136);
    v21 = 0;
    *ArgList = *(v160 + 1);
    v151 = 0;
    if ( *ArgList )
    {
      while ( 1 )
      {
        if ( *(v2 + 24) )
          goto LABEL_94;
        if ( !*(v20 + 36) )
          *(v20 + 36) = v21;
        v22 = 0;
        if ( ::SendMessageW(v1, 0x1004u, 0, 0) )
          break;
LABEL_61:
        if ( *(v161 + 24) )
        {
          v2 = v161;
          goto LABEL_94;
        }
        if ( v22 == ::SendMessageW(v1, 0x1004u, 0, 0) )
        {
          BYTE1(a5) = 1;
          memset(&v164, 0, 0x290u);
          v165 = 3;
          v132 = *(v20 + 36);
          v131 = 0;
          ObjectAttr.Length = 24;
          ObjectAttr.RootDirectory = 0;
          ObjectAttr.Attributes = 0;
          ObjectAttr.ObjectName = 0;
          ObjectAttr.SecurityDescriptor = 0;
          ObjectAttr.SecurityQualityOfService = 0;
          v43 = NtOpenThread(&ThreadHandle, 72, &ObjectAttr, &v131);
          v44 = 0;
          if ( !v43 )
            v44 = ThreadHandle;
          v168 = v44;
          if ( QueryThreadCycleTime && v44 )
            QueryThreadCycleTime(v44, &CycleTime);
          v45 = v161;
          v169 = *(v20 + 36);
          v172 = *(v20 + 48);
          v123 = *(v161 + 10);
          v173 = 0;
          v122 = *(v161 + 12);
          v170 = *(v20 + 28);
          sub_125DD60(0, 0, &v164, *(v161 + 11), *(v20 + 28), *(v20 + 28) >> 31, v122, v123);
          v176 = *v20 + *(v20 + 8);
          v46 = 2;
          if ( v163 )
            v46 = 0;
          v167 = 0;
          v166 = v46;
          v177 = *(v45 + 8);
          v171 = 0i64;
          v181 = 0;
          if ( GetThreadIdealProcessorEx )
            GetThreadIdealProcessorEx(v168, &v174);
          if ( *(*(v45 + 8) + 40) & 0x20 && gdwOsType >= 1 )
          {
            if ( !NtQueryInformationThread(v168, 0, &v127, 28, 0) )
            {
              ProcessHandle = *(v45 + 11);
              v179 = ObjectAttr.Length;
              v178 = ProcessHandle;
              ReadProcessMemory(ProcessHandle, (ObjectAttr.Length + gdwSomeFunctionVA), &Buffer, 4u, &NumberOfBytesRead);
              v180 = Buffer;
              if ( Buffer )
              {
                if ( sub_127EFB0(Buffer) )
                {
                  v48 = sub_127EFB0(Buffer);
                  v181 = _wcsdup(v48);
                }
              }
            }
          }
          else
          {
            v180 = -1;
          }
          v123 = v45;
          qmemcpy(&v58, &v164, 0x290u);
          v1 = hWnd;
          sub_1237E70(
            hWnd,
            v58,
            v59,
            v60,
            v61,
            v62,
            v63,
            v64,
            v65,
            v66,
            v67,
            v68,
            v69,
            v70,
            v71,
            v72,
            v73,
            v74,
            v75,
            v76,
            v77,
            v78,
            v79,
            v80,
            v81,
            v82,
            v83,
            v84,
            v85,
            v86,
            v87,
            v88,
            v89,
            v90,
            v91,
            v92,
            v93,
            v94,
            v95,
            v96,
            v97,
            v98,
            v99,
            v100,
            v101,
            v102,
            v103,
            v104,
            v105,
            v106,
            v107,
            v108,
            v109,
            v110,
            v111,
            v112,
            v113,
            v114,
            v115,
            v116,
            v117,
            v118,
            v119);
          v2 = v161;
          SetEvent(*(v161 + 5));
        }
        else
        {
          v2 = v161;
        }
        v20 += 64;
        v21 = v151 + 1;
        v151 = v21;
        if ( v21 >= *(v160 + 1) )
          goto LABEL_82;
      }
      while ( 1 )
      {
        lParam = 4;
        v141 = v22;
        v142 = 0;
        ::SendMessageW(v1, 0x104Bu, 0, &lParam);
        v23 = v143;
        if ( *(v143 + 44) == *(v20 + 36) )
          break;
        if ( ++v22 >= ::SendMessageW(v1, 0x1004u, 0, 0) )
          goto LABEL_61;
      }
      v24 = *(v20 + 48) - *(v143 + 592);
      if ( v24 != *(v143 + 584) || 0 != *(v143 + 588) )
      {
        if ( v24 <= 0 )
          *(v143 + 584) = 0;
        else
          *(v143 + 584) = v24;
        *(v23 + 588) = 0;
        v23 = v143;
        BYTE1(a5) = 1;
      }
      *(v23 + 592) = *(v20 + 48);
      *(v143 + 596) = 0;
      if ( QueryThreadCycleTime )
      {
        v25 = *(v143 + 40);
        if ( v25 )
        {
          QueryThreadCycleTime(v25, v146);
          if ( ((*v146 - *(v143 + 616)) >> 32) < 0
            || (*v146 < *(v143 + 616) || (*v146 - *(v143 + 616)) >> 32 == 0) && v146[0] == *(v143 + 616) )
          {
            *(v143 + 600) = 0;
            *(v143 + 604) = 0;
          }
          else
          {
            *(v143 + 600) = *v146 - *(v143 + 616);
          }
          BYTE1(a5) = 1;
        }
      }
      *(v143 + 616) = v146[0];
      *(v143 + 620) = v146[1];
      v26 = v143;
      v27 = *v20 + *(v20 + 8);
      v28 = *v20 + *(v20 + 8);
      v137 = HIDWORD(v28);
      v29 = v27 < *(v143 + 624);
      v30 = v27 - *(v143 + 624);
      v133 = v28;
      v31 = HIDWORD(v28) - (v29 + *(v143 + 628));
      if ( GetProcessorSystemCycleTime && *(v143 + 40) )
      {
        v32 = *(v143 + 600);
        v33 = v148;
        v34 = v149;
      }
      else
      {
        v32 = __PAIR__(v31, v30);
        v33 = v147;
        v34 = v152;
      }
      v138 = v32 * 100.0;
      v35 = __PAIR__(v33, v34);
      v36 = 0;
      v37 = v138;
      ++v155;
      *(v143 + 624) = v133;
      *(v26 + 628) = v137;
      v38 = v143;
      v39 = v37 / v35;
      v40 = *(v143 + 24);
      if ( v40 )
      {
        v41 = *(v143 + 28);
        if ( v41 < gdwHighlightDuration )
        {
          *(v143 + 16) = 2;
          *(v38 + 20) = v41;
LABEL_59:
          v1 = hWnd;
          if ( v39 != *(v143 + 576) )
          {
            *(v143 + 576) = v39;
            BYTE1(a5) = 1;
          }
          goto LABEL_61;
        }
        if ( v40 )
        {
          v36 = 1;
          *(v143 + 24) = 0;
        }
      }
      v42 = BYTE1(a5);
      *(v38 + 16) = 0;
      if ( v36 )
        v42 = 1;
      BYTE1(a5) = v42;
      goto LABEL_59;
    }
LABEL_82:
    SendMessageW = ::SendMessageW;
    if ( *(v2 + 24) )
      goto LABEL_95;
    if ( v155 == v156 )
    {
      LOBYTE(v4) = BYTE1(a5);
LABEL_85:
      if ( !v4 )
        goto LABEL_87;
    }
    InvalidateRect(v1, 0, 0);
    v145 = gdwProcessThreadSortColumnLast;
    wParam = 1044;
    SendMessageW(v1, 0x1030u, &wParam, TreeListSort);
    SendMessageW(v1, 0xBu, 1u, 0);
    v123 = *ArgList;
    FormatTex(&String, L"%d", *ArgList);
    SetDlgItemTextW(hDlg, 1348, &String);
LABEL_87:
    if ( v163 )
    {
      SendMessageW(v1, 0x101Eu, 3u, 65534);
      v126 = 3;
      v125 = 3;
      SendMessageW(v1, 0x102Bu, 0, &v124);
      hHandle = _beginthreadex(0, 0, sub_126D400, v2, 0, 0);
      v163 = 0;
    }
    if ( *(v2 + 4) )
      goto LABEL_95;
    v3 = WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF);
    if ( *(v2 + 24) )
      goto LABEL_95;
    LOBYTE(v4) = BYTE1(a5);
  }
  v13 = v160;
  while ( 1 )
  {
    v14 = *v13;
    if ( !v14 )
      break;
    v160 += v14;
    v13 = v160;
    if ( *(v160 + 17) == v12 )
      goto LABEL_19;
  }
  FormatTex(&String, L"n/a");
  v49 = hDlg;
  SetDlgItemTextW(hDlg, 1086, &String);
  SetDlgItemTextW(v49, 1077, &String);
  SetDlgItemTextW(v49, 1080, &String);
  SetDlgItemTextW(v49, 1081, &String);
  SetDlgItemTextW(v49, 1082, &String);
  SetDlgItemTextW(v49, 1078, &String);
  SetDlgItemTextW(v49, 1079, &String);
  SetDlgItemTextW(v49, 1083, &String);
  SetDlgItemTextW(v49, 1339, &String);
  SetDlgItemTextW(v49, 1340, &String);
  SetDlgItemTextW(v49, 1343, &String);
  InvalidateRect(v1, 0, 1);
  v123 = 0;
  v50 = GetDlgItem(v49, 1084);
  EnableWindow(v50, v123);
  v123 = 0;
  v51 = GetDlgItem(v49, 1085);
  EnableWindow(v51, v123);
  v123 = 0;
  v52 = GetDlgItem(v49, 1087);
  EnableWindow(v52, v123);
  v123 = 0;
  v53 = GetDlgItem(v49, 1018);
  EnableWindow(v53, v123);
  v2 = v161;
LABEL_94:
  SendMessageW = ::SendMessageW;
LABEL_95:
  free(ppBuffer);
  if ( *(v2 + 4) || InterlockedDecrement(v2 + 7) )
  {
    v56 = hWnd;
    InvalidateRect(hWnd, 0, 1);
    SendMessageW(v56, 0xBu, 1u, 0);
  }
  else
  {
    v54 = hHandle;
    if ( hHandle )
    {
      SetEvent(*(v2 + 5));
      WaitForSingleObject(v54, 0xFFFFFFFF);
    }
    v55 = *v2;
    while ( v55 )
    {
      *v2 = v55;
      v55 = *(v55 + 652);
      if ( *(*v2 + 40) )
        CloseHandle(*(*v2 + 40));
      if ( *(*v2 + 572) )
        free(*(*v2 + 572));
      if ( *(*v2 + 648) )
        free(*(*v2 + 648));
      free(*v2);
    }
    if ( *(v2 + 11) )
    {
      CloseHandle(*(v2 + 11));
      if ( *SymCleanup )
        SymCleanup(*(v2 + 11));
    }
    CloseHandle(*(v2 + 5));
    CloseHandle(*(v2 + 2));
    CloseHandle(*(v2 + 3));
    if ( *(v2 + 12) )
      RtlDestroyQueryDebugBuffer(*(v2 + 12));
    if ( *(v2 + 10) )
      free(*(v2 + 10));
    free(v2);
  }
  return 0;
}
// 128C710: using guessed type int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD);
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E4E54: using guessed type int gdwOsType;
// 12E5534: using guessed type int gdwHighlightDuration;
// 12EB1CC: using guessed type int gdwSomeFunctionVA;
// 12EF23C: using guessed type int (__stdcall *NtQueryInformationThread)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12EF254: using guessed type int (__stdcall *NtOpenThread)(_DWORD, _DWORD, _DWORD, _DWORD);
// 12EF258: using guessed type int (__stdcall *GetThreadIdealProcessorEx)(_DWORD, _DWORD);
// 12EF264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);

//----- (0126D400) --------------------------------------------------------
int __stdcall sub_126D400(int a1)
{
  HWND v1; // edi
  HWND v2; // eax
  void *v3; // ST1C_4
  unsigned int v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // esi
  HWND v9; // eax
  HWND v10; // ST14_4
  HWND v11; // eax
  LPARAM lParam; // [esp+8h] [ebp-844h]
  int v13; // [esp+Ch] [ebp-840h]
  int v14; // [esp+10h] [ebp-83Ch]
  int v15; // [esp+28h] [ebp-824h]
  HWND hDlg; // [esp+3Ch] [ebp-810h]
  int v17; // [esp+40h] [ebp-80Ch]
  HWND hWnd; // [esp+44h] [ebp-808h]
  WCHAR String; // [esp+48h] [ebp-804h]

  v17 = a1;
  lParam = 0;
  memset(&v13, 0, 0x30u);
  v1 = *(a1 + 36);
  hWnd = v1;
  v2 = GetParent(v1);
  v3 = *(a1 + 20);
  hDlg = v2;
  WaitForSingleObject(v3, 0xFFFFFFFF);
  if ( !*(a1 + 24) )
  {
    do
    {
      v4 = SendMessageW(v1, 0x1004u, 0, 0);
      while ( 1 )
      {
        v5 = 0;
        if ( !v4 )
          break;
        while ( 1 )
        {
          lParam = 4;
          v13 = v5;
          v14 = 0;
          if ( SendMessageW(v1, 0x104Bu, 0, &lParam) )
            break;
LABEL_7:
          if ( ++v5 >= v4 )
            goto LABEL_8;
        }
        v6 = v15;
        if ( *(v15 + 36) )
        {
          v1 = hWnd;
          goto LABEL_7;
        }
        FormatTex(&String, L"Loading symbols for %s...", v15 + 52);
        v9 = GetDlgItem(hDlg, 1341);
        SetWindowTextW(v9, &String);
        sub_125DD60(1, 0, v15, *(v17 + 44), *(v6 + 48), *(v6 + 48) >> 31, *(v17 + 48), *(v17 + 40));
        InvalidateRect(hWnd, 0, 0);
        v10 = hDlg;
        *(v6 + 36) = 1;
        v11 = GetDlgItem(v10, 1341);
        SetWindowTextW(v11, gpszTargetName);
        v1 = hWnd;
      }
LABEL_8:
      v7 = v17;
      WaitForSingleObject(*(v17 + 20), 0xFFFFFFFF);
    }
    while ( !*(v7 + 24) );
  }
  return 0;
}

//----- (0126D5B0) --------------------------------------------------------
BOOL __stdcall ProcWMIProvidersWndProc(HWND hDlg, int a2, WPARAM wParam, int a4)
{
  HWND v4; // edi
  CResize *v5; // eax
  CResize *v6; // esi
  HWND v7; // eax
  ResizeInfo *v8; // eax
  LONG v9; // eax
  HWND v10; // eax
  int *v11; // esi
  LONG v12; // eax
  HWND v14; // eax
  WPARAM v15; // [esp-8h] [ebp-ACh]
  LPARAM v16; // [esp+10h] [ebp-94h]
  int v17; // [esp+1Ch] [ebp-88h]
  int v18; // [esp+20h] [ebp-84h]
  void *v19; // [esp+44h] [ebp-60h]
  LPARAM lParam; // [esp+48h] [ebp-5Ch]
  LONG v21; // [esp+4Ch] [ebp-58h]
  int v22; // [esp+50h] [ebp-54h]
  int v23; // [esp+54h] [ebp-50h]
  int v24; // [esp+58h] [ebp-4Ch]
  int v25; // [esp+5Ch] [ebp-48h]
  int v26; // [esp+64h] [ebp-40h]
  int v27; // [esp+68h] [ebp-3Ch]
  LONG dwNewLong; // [esp+7Ch] [ebp-28h]
  int Indent; // [esp+80h] [ebp-24h]
  int v30; // [esp+84h] [ebp-20h]
  int v31; // [esp+88h] [ebp-1Ch]
  int a3; // [esp+8Ch] [ebp-18h]
  __int16 v33; // [esp+90h] [ebp-14h]
  int v34; // [esp+A0h] [ebp-4h]

  dwNewLong = a4;
  v4 = GetDlgItem(hDlg, 40753);
  GetWindowLongW(hDlg, -21);
  lParam = 0;
  memset(&v21, 0, 0x30u);
  Indent = 40754;
  v30 = 40755;
  v31 = 40756;
  LOWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a3) = MulDiv(100, gLogPixelsX, 96);
  v33 = MulDiv(100, gLogPixelsX, 96);
  switch ( a2 )
  {
    case 43:
      FindDlg_DrawItem(dwNewLong);
      return 0;
    case 44:
      return HandleMeasureItem(hDlg, a2, wParam, dwNewLong);
    case 272:
      v5 = operator new(0x40u);
      v19 = v5;
      v34 = 0;
      if ( v5 )
        v6 = CResize::CResize(v5, hDlg);
      else
        v6 = 0;
      v34 = -1;
      v7 = GetDlgItem(hDlg, 40753);
      if ( v7 )
      {
        v8 = CResize::InitResizeBuffer(v6, v7, 1);
        *&v8->d21.left = 0i64;
        *&v8->d21.right = doubleOnePointZero;
      }
      ResizeTab(hDlg);
      SetWindowLongW(hDlg, -21, dwNewLong);
      v9 = GetWindowLongW(v4, -16);
      SetWindowLongW(v4, -16, v9 & 0xFFFFFFFD | 1);
      SendMessageW(v4, 0x1036u, 0x4020u, 16416);
      v10 = SendMessageW(v4, 0x104Eu, 0, 0);
      InitToolTips(v10);
      OldListCtrlWndProc = SetWindowLongW(v4, -4, PEListCtrlWndProc);
      SendMessageW(v4, 0x30u, ghDefaultFont, 0);
      InitListCtrl(v4, &Indent, &a3, 3);
      v11 = *(dwNewLong + 868);
      if ( !v11 )
        goto LABEL_10;
      break;
    case 273:
      switch ( wParam )
      {
        case IDS_PROCEXPLORERMENU_EXIT:
          v15 = 40014;
          goto LABEL_15;
        case IDS_PROCEXPLORERMENU_REFRESH_NOW:
          SetEvent(ghEventRefreshSearchResult);
          break;
        case IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT|0x8:
        case IDS_PROCEXPLORERMENU_SHOW_COLUMN_HEATMAPS|0x4:
          v15 = wParam;
LABEL_15:
          v14 = GetParent(hDlg);
          PostMessageW(v14, WM_COMMAND, v15, 0);
          break;
        default:
          return 0;
      }
      return 0;
    default:
      return 0;
  }
  while ( 1 )
  {
    lParam = 5;
    v21 = 0x7FFFFFFF;
    v22 = 0;
    v24 = 0;
    v23 = 0;
    v25 = *v11;
    v26 = 0;
    v27 = 1;
    v12 = SendMessageW(v4, 0x104Du, 0, &lParam);
    dwNewLong = v12;
    if ( v12 == -1 )
      break;
    v21 = v12;
    lParam = 1;
    v22 = 1;
    v25 = v11[1];
    SendMessageW(v4, 0x104Cu, 0, &lParam);
    v21 = dwNewLong;
    lParam = 1;
    v22 = 2;
    v25 = v11[2];
    SendMessageW(v4, 0x104Cu, 0, &lParam);
    v11 = v11[3];
    if ( !v11 )
    {
LABEL_10:
      SendMessageW(v4, 0x101Eu, 0, 0xFFFF);
      SendMessageW(v4, 0x101Eu, 1u, 0xFFFF);
      SendMessageW(v4, 0x101Eu, 2u, 0xFFFF);
      v18 = 3;
      v17 = 3;
      SendMessageW(v4, 0x102Bu, 0, &v16);
      SetFocus(v4);
      return 1;
    }
  }
  return 0;
}
// 12BCB30: using guessed type double doubleOnePointZero;

//----- (0126DA70) --------------------------------------------------------
char __cdecl sub_126DA70(void *a1, int a2, _DWORD *a3, int a4)
{
  struct _SYSTEM_HANDLE_INFORMATION *v4; // eax
  ULONG v5; // edi
  int v6; // edi
  int v7; // ebx
  HANDLE v8; // esi
  _DWORD *v9; // edi
  struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleTableEntry; // [esp+4h] [ebp-818h]
  BOOL Result; // [esp+14h] [ebp-808h]
  wchar_t szTargetName; // [esp+18h] [ebp-804h]

  HandleTableEntry.Object = a4;
  *&HandleTableEntry.ObjectTypeIndex = a3;
  if ( !*IsProcessInJob || !a1 )
    return 0;
  if ( !a3 )
  {
    if ( IsProcessInJob(a1, 0, &Result) && Result == 1 )
      return 1;
    return 0;
  }
  v4 = gpSystemHandleInformation;
  if ( gpSystemHandleInformation )
    v5 = gpSystemHandleInformation->NumberOfHandles;
  else
    v5 = 0;
  v6 = v5 - 1;
  if ( v6 < 0 )
    return 0;
  while ( 1 )
  {
    GetTopSystemHandleInfo(v4, v6, &HandleTableEntry);
    v7 = *&HandleTableEntry.UniqueProcessId;
    HandleTableEntry.GrantedAccess = *(*&HandleTableEntry.UniqueProcessId + 18);
    if ( _wcsicmp(&word_12F05D8[64 * HandleTableEntry.GrantedAccess], L"Job") )
      goto LABEL_13;
    v8 = DuplicateProcessHandle(*(v7 + 4), *(v7 + 8), 0x80000000);
    if ( v8 )
    {
      if ( IsProcessInJob(a1, v8, &Result) && Result == 1 )
        break;
    }
    CloseHandle(v8);
LABEL_13:
    if ( --v6 < 0 )
      return 0;
    v4 = gpSystemHandleInformation;
  }
  sub_125C750(&word_12F05D8[64 * HandleTableEntry.GrantedAccess], v7, &szTargetName, 0x400u, 0);
  v9 = HandleTableEntry.Object;
  if ( HandleTableEntry.Object )
    *v9 = _wcsdup(&szTargetName);
  **&HandleTableEntry.ObjectTypeIndex = v8;
  return 1;
}

//----- (0126DC00) --------------------------------------------------------
HANDLE __cdecl PEOpenProcess(DWORD dwDesiredAccess, int a2, DWORD dwProcessId)
{
  HANDLE ProcessHandle; // eax
  DWORD BytesReturned; // [esp+0h] [ebp-8h]
  HANDLE OutBuffer; // [esp+4h] [ebp-4h]

  ProcessHandle = OpenProcess(dwDesiredAccess, 0, dwProcessId);
  OutBuffer = ProcessHandle;
  if ( !ProcessHandle )
  {
    if ( GetLastError() == ERROR_ACCESS_DENIED )
      DeviceIoControl(theDriver, 0x8335003C, &dwProcessId, 4u, &OutBuffer, 4u, &BytesReturned, 0);
    ProcessHandle = OutBuffer;
  }
  return ProcessHandle;
}

//----- (0126DC50) --------------------------------------------------------
BOOL __cdecl sub_126DC50(HWND a1, int a2)
{
  int v2; // ebx
  int v3; // edi
  int v4; // ebx
  int v5; // edi
  int v6; // eax
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  HWND v9; // esi
  HWND v10; // eax
  HWND v11; // esi
  LONG v12; // ecx
  int v13; // edx
  HWND v14; // eax
  HWND v15; // eax
  LONG v16; // edi
  LONG v17; // esi
  __int128 v19; // [esp+Ch] [ebp-74h]
  DWORD dwProcessId; // [esp+1Ch] [ebp-64h]
  int v21; // [esp+20h] [ebp-60h]
  LONG v22; // [esp+24h] [ebp-5Ch]
  HWND hWnd; // [esp+28h] [ebp-58h]
  LONG v24; // [esp+2Ch] [ebp-54h]
  WINDOWPLACEMENT wndpl; // [esp+30h] [ebp-50h]
  struct tagRECT v26; // [esp+5Ch] [ebp-24h]
  struct tagRECT Rect; // [esp+6Ch] [ebp-14h]

  hWnd = a1;
  v2 = GetSystemMetrics(78);
  v3 = GetSystemMetrics(79);
  if ( v2 )
  {
    v21 = GetSystemMetrics(76);
    v4 = v21 + v2;
    v6 = GetSystemMetrics(77);
    v5 = v6 + v3;
    v22 = v6;
  }
  else
  {
    v22 = 0;
    v21 = 0;
    v4 = GetSystemMetrics(0);
    v5 = GetSystemMetrics(1);
  }
  v24 = v5;
  if ( *(a2 + 4) )
    v7 = _mm_loadu_si128(&gWindowPlacement[3].rcNormalPosition);
  else
    v7 = _mm_loadu_si128(&gWindowPlacement[2].rcNormalPosition);
  _mm_storeu_si128(&Rect, v7);
  _mm_storeu_si128(&v19, v7);
  memset(&wndpl, 0, 0x2Cu);
  v8 = _mm_loadu_si128(&v19);
  v9 = hWnd;
  wndpl.length = 44;
  _mm_storeu_si128(&wndpl.rcNormalPosition, v8);
  wndpl.showCmd = 0;
  SetWindowPlacement(v9, &wndpl);
  GetWindowRect(v9, &Rect);
  v10 = GetDesktopWindow();
  v11 = FindWindowExW(v10, 0, 0x8002, 0);
  if ( v11 )
  {
    do
    {
      GetWindowThreadProcessId(v11, &dwProcessId);
      if ( dwProcessId == GetCurrentProcessId() && v11 != hWnd )
      {
        GetWindowRect(v11, &v26);
        v12 = Rect.top;
        if ( v26.top == Rect.top )
        {
          v13 = Rect.left;
          if ( v26.left == Rect.left )
          {
            if ( Rect.top + 20 > v5 - 50 || Rect.left + 20 > v4 - 50 )
              goto LABEL_17;
            Rect.bottom += 20;
            Rect.right += 20;
            Rect.top += 20;
            v11 = 0;
            Rect.left += 20;
          }
        }
      }
      v14 = GetDesktopWindow();
      v15 = FindWindowExW(v14, v11, 0x8002, 0);
      v5 = v24;
      v11 = v15;
    }
    while ( v15 );
  }
  v12 = Rect.top;
  v13 = Rect.left;
LABEL_17:
  v16 = Rect.right;
  if ( Rect.right > v4 )
  {
    v16 = v4;
    v13 += v4 - Rect.right;
    Rect.right = v4;
    Rect.left = v13;
  }
  if ( v13 < v21 )
  {
    v13 = v21;
    Rect.left = v21;
  }
  v17 = Rect.bottom;
  if ( Rect.bottom > v24 )
  {
    v17 = v24;
    v12 += v24 - Rect.bottom;
    Rect.bottom = v24;
    Rect.top = v12;
  }
  if ( v12 < v22 )
  {
    v12 = v22;
    Rect.top = v22;
  }
  return MoveWindow(hWnd, v13, v12, v16 - v13, v17 - v12, 0);
}

//----- (0126DE20) --------------------------------------------------------
int __thiscall sub_126DE20(int *this, int a2)
{
  int *v2; // edi
  _DWORD *v3; // edx
  int v4; // eax
  int result; // eax

  v2 = this;
  v3 = (*this - 16);
  if ( v3[2] >= a2 || a2 <= 0 || (v4 = (*(**v3 + 8))(v3, a2, 1)) == 0 )
    ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException();
  result = v4 + 16;
  *v2 = result;
  return result;
}

//----- (0126DE60) --------------------------------------------------------
_PSAPI_WORKING_SET_INFORMATION *__cdecl GetProcessWorkingSet(DWORD dwProcessId)
{
  int idx; // ecx
  _PSAPI_WORKING_SET_INFORMATION *pBuffer; // esi
  DWORD cbSize; // edi
  int uId; // eax
  HANDLE hProcess; // ebx

  idx = 0;
  pBuffer = 0;
  cbSize = 0;
  if ( gdwDllsListColumnCount <= 0 )
    return pBuffer;
  while ( 1 )
  {
    uId = gdwIdMapForDllsListColumn[idx];
    if ( uId == 1115 || uId == 1116 || uId == 1317 || uId == 1118 )
      break;
    if ( ++idx >= gdwDllsListColumnCount )
      return 0;
  }
  // PROCESS_QUERY_INFORMATION|PROCESS_VM_READ
  hProcess = OpenProcess(0x410u, FALSE, dwProcessId);
  if ( !hProcess )
    return pBuffer;
  while ( 1 )
  {
    // Retrieves information about the pages currently added to the working set of the specified process.
    if ( QueryWorkingSet(hProcess, pBuffer, cbSize) )
    {
      if ( !pBuffer )
        goto __error;
      if ( cbSize >= 4 * pBuffer->NumberOfEntries )
        goto __exit;
    }
    if ( pBuffer )
      free(pBuffer);
__error:
    if ( GetLastError() != ERROR_BAD_LENGTH )
      break;
    cbSize += 0x4000;
    pBuffer = malloc(cbSize);
  }
  pBuffer = 0;
__exit:
  CloseHandle(hProcess);
  return pBuffer;
}

//----- (0126DF20) --------------------------------------------------------
char __usercall sub_126DF20@<al>(signed int a1@<edx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, WPARAM wParam)
{
  char v9; // bh
  char v10; // bl
  signed int v11; // esi
  int v12; // ecx
  bool v13; // al
  bool v14; // al
  bool v15; // al
  bool v16; // al
  bool v17; // zf
  WPARAM v18; // ebx
  int v19; // edx
  bool v20; // cf
  int v21; // ecx
  int v22; // esi
  bool v23; // al
  char v24; // al
  unsigned int v25; // edx
  bool v26; // cl
  char v27; // al
  unsigned int v28; // edx
  unsigned int v29; // ecx
  signed int v30; // eax
  unsigned __int64 v31; // kr20_8
  unsigned __int64 v32; // kr10_8
  bool v33; // al
  char v34; // al
  int v35; // ecx
  int v36; // ecx
  bool v37; // al
  char v38; // al
  HANDLE v40; // esi
  unsigned int v41; // edx
  unsigned int v42; // ecx
  unsigned int v43; // ecx
  unsigned __int64 v44; // kr18_8
  bool v45; // al
  signed int v46; // ecx
  unsigned __int8 v47; // al
  int v48; // ecx
  char v49; // al
  int v50; // ecx
  char v51; // al
  char v52; // al
  char v53; // al
  char v54; // al
  char v55; // al
  char v56; // al
  DWORD v57; // eax
  char v58; // al
  char v59; // bl
  DWORD v60; // eax
  char v61; // al
  char v62; // cl
  char v63; // al
  char v64; // cl
  char v65; // al
  char v66; // cl
  int v67; // esi
  int v68; // ecx
  int v69; // edx
  int v70; // eax
  unsigned int v71; // eax
  unsigned __int64 v72; // kr38_8
  int v73; // esi
  char v74; // al
  signed int v75; // ecx
  int v76; // esi
  char v77; // al
  signed int v78; // ecx
  HWND v79; // esi
  char v80; // al
  int v81; // edx
  HWND v82; // ecx
  unsigned __int8 v83; // al
  HWND v84; // ST34_4
  int v85; // edx
  unsigned __int8 v86; // al
  HWND v87; // ecx
  HWND v88; // ST34_4
  int v89; // edx
  unsigned __int8 v90; // al
  HWND v91; // ecx
  HWND v92; // ST34_4
  unsigned int v93; // edx
  unsigned __int8 v94; // al
  HWND v95; // ecx
  HWND v96; // ST34_4
  char v97; // al
  int v98; // esi
  HWND v99; // ecx
  unsigned __int8 v100; // al
  char v101; // al
  unsigned int v102; // edx
  HWND v103; // ecx
  unsigned __int8 v104; // al
  int v105; // ecx
  HWND v106; // ST34_4
  char v107; // al
  int v108; // esi
  HWND v109; // ecx
  unsigned __int8 v110; // al
  char v111; // al
  unsigned int v112; // edx
  HWND v113; // ecx
  unsigned __int8 v114; // al
  int v115; // ecx
  HWND v116; // ST34_4
  char v117; // al
  int v118; // esi
  HWND v119; // ecx
  unsigned __int8 v120; // al
  char v121; // al
  unsigned int v122; // edx
  HWND v123; // ecx
  unsigned __int8 v124; // al
  int v125; // ecx
  HWND v126; // ST34_4
  char v127; // al
  signed int v128; // ecx
  int v129; // esi
  unsigned int v130; // ecx
  char v131; // al
  signed int v132; // ecx
  unsigned int v133; // eax
  unsigned int v134; // eax
  char v135; // al
  signed int v136; // ecx
  unsigned int v137; // eax
  unsigned int v138; // eax
  char v139; // al
  signed int v140; // ecx
  unsigned int v141; // ecx
  int v142; // ecx
  int v143; // eax
  bool v144; // dl
  HWND v145; // ST34_4
  char v146; // al
  unsigned int v147; // edx
  signed int v148; // ecx
  int v149; // edx
  int v150; // eax
  bool v151; // cl
  HWND v152; // ST34_4
  char v153; // al
  unsigned int v154; // edx
  signed int v155; // ecx
  int v156; // edx
  int v157; // ecx
  bool v158; // al
  HWND v159; // ST34_4
  char v160; // al
  HWND v161; // ecx
  int v162; // eax
  bool v163; // al
  char v164; // al
  signed int v165; // ecx
  int v166; // edx
  int v167; // ecx
  bool v168; // al
  HWND v169; // ST34_4
  char v170; // al
  HWND v171; // ecx
  int v172; // eax
  bool v173; // al
  char v174; // al
  signed int v175; // ecx
  int v176; // edx
  int v177; // ecx
  bool v178; // al
  HWND v179; // ST34_4
  char v180; // al
  HWND v181; // ecx
  int v182; // eax
  bool v183; // al
  char v184; // al
  signed int v185; // ecx
  int v186; // edx
  int v187; // ecx
  bool v188; // al
  HWND v189; // ST34_4
  char v190; // al
  HWND v191; // esi
  HWND v192; // ecx
  unsigned int v193; // eax
  unsigned int v194; // eax
  unsigned __int64 v195; // kr60_8
  bool v196; // dl
  char v197; // al
  char v198; // cl
  int v199; // esi
  unsigned int v200; // ecx
  char v201; // al
  signed int v202; // ecx
  unsigned int v203; // eax
  unsigned int v204; // eax
  char v205; // al
  signed int v206; // ecx
  unsigned int v207; // eax
  unsigned int v208; // eax
  char v209; // al
  signed int v210; // ecx
  unsigned int v211; // ecx
  int v212; // ecx
  int v213; // eax
  bool v214; // dl
  HWND v215; // ST34_4
  char v216; // al
  unsigned int v217; // edx
  signed int v218; // ecx
  int v219; // edx
  int v220; // eax
  bool v221; // cl
  HWND v222; // ST34_4
  char v223; // al
  unsigned int v224; // edx
  signed int v225; // ecx
  int v226; // edx
  int v227; // ecx
  bool v228; // al
  HWND v229; // ST34_4
  char v230; // al
  HWND v231; // ecx
  int v232; // eax
  bool v233; // al
  char v234; // al
  signed int v235; // ecx
  int v236; // edx
  int v237; // ecx
  bool v238; // al
  HWND v239; // ST34_4
  char v240; // al
  HWND v241; // ecx
  int v242; // eax
  bool v243; // al
  char v244; // al
  signed int v245; // ecx
  int v246; // edx
  int v247; // ecx
  bool v248; // al
  HWND v249; // ST34_4
  char v250; // al
  HWND v251; // ecx
  int v252; // eax
  bool v253; // al
  char v254; // al
  signed int v255; // ecx
  int v256; // edx
  int v257; // ecx
  bool v258; // al
  HWND v259; // ST34_4
  char v260; // al
  HWND v261; // esi
  HWND v262; // ecx
  unsigned int v263; // eax
  unsigned int v264; // eax
  unsigned __int64 v265; // kr88_8
  bool v266; // dl
  char v267; // cl
  UINT_PTR MaximumWorkingSetSize; // [esp+8h] [ebp-88Ch]
  UINT_PTR MinimumWorkingSetSize; // [esp+Ch] [ebp-888h]
  unsigned int v270; // [esp+10h] [ebp-884h]
  int pBuffer; // [esp+14h] [ebp-880h]
  int v272; // [esp+18h] [ebp-87Ch]
  unsigned int v273; // [esp+1Ch] [ebp-878h]
  ULONG pulRet; // [esp+20h] [ebp-874h]
  int v275; // [esp+24h] [ebp-870h]
  int v276; // [esp+28h] [ebp-86Ch]
  int v277; // [esp+2Ch] [ebp-868h]
  HANDLE hProcess; // [esp+30h] [ebp-864h]
  _DWORD v279[2]; // [esp+34h] [ebp-860h]
  int v280; // [esp+3Ch] [ebp-858h]
  char v281; // [esp+40h] [ebp-854h]
  char v282; // [esp+41h] [ebp-853h]
  char v283; // [esp+42h] [ebp-852h]
  char v284; // [esp+43h] [ebp-851h]
  int v285; // [esp+48h] [ebp-84Ch]
  unsigned int v286; // [esp+4Ch] [ebp-848h]
  bool v287; // [esp+53h] [ebp-841h]
  int v288; // [esp+54h] [ebp-840h]
  HWND hWnd[2]; // [esp+58h] [ebp-83Ch]
  int v290; // [esp+60h] [ebp-834h]
  int v291; // [esp+64h] [ebp-830h]
  int v292; // [esp+68h] [ebp-82Ch]
  int v293; // [esp+6Ch] [ebp-828h]
  int v294; // [esp+70h] [ebp-824h]
  int v295; // [esp+74h] [ebp-820h]
  __int64 v296; // [esp+78h] [ebp-81Ch]
  __int64 v297; // [esp+80h] [ebp-814h]
  __int64 v298; // [esp+88h] [ebp-80Ch]
  ULONG64 ProcessorCycleTimes[256]; // [esp+90h] [ebp-804h]

  LOBYTE(a1) = 0;
  v9 = 0;
  v280 = a2;
  v10 = 0;
  v11 = 0;
  hProcess = a3;
  v288 = a1;
  v283 = 0;
  v282 = 0;
  v281 = 0;
  v284 = 0;
  v287 = 0;
  *v279 = 0i64;
  if ( gdwProcessListColumnCount <= 0 )
    goto LABEL_279;
  BYTE1(a1) = 0;
  v287 = gdwOsType >= 1;
  do
  {
    v12 = gdwIDMapProcesListForSelectColumn[v11];
    v13 = v12 == 1066 || v12 == 1067;
    v283 |= v13;
    v9 |= v12 == 1092;
    v14 = QueryProcessCycleTime || v12 == 1055 || v12 == 1195 || v12 == 1200 || v12 == 7;
    v10 |= v14;
    v281 |= v287;
    v15 = gdwOsType >= 1 && v12 == 1339;
    BYTE1(a1) |= v15;
    v16 = v12 == 1116 || v12 == 1317 || v12 == 1118;
    ++v11;
    LOBYTE(a1) = v16 | a1;
  }
  while ( v11 < gdwProcessListColumnCount );
  v284 = BYTE1(a1);
  v17 = a1 == 0;
  v282 = a1;
  LOBYTE(a1) = v288;
  v287 = v10;
  if ( v17 )
  {
LABEL_279:
    if ( *(a8 + 928) )
    {
      free(*(a8 + 928));
      LOBYTE(a1) = v288;
      *(a8 + 928) = 0;
      *(a8 + 932) = 0;
    }
  }
  v17 = v9 == 0;
  v18 = wParam;
  if ( v17 )
  {
    *(a8 + 1336) = 0;
    *(a8 + 1340) = 0;
  }
  else
  {
    v286 = sub_125A500(v280);
    v20 = v286 < *(a8 + 1344);
    v21 = v286 - *(a8 + 1344);
    v276 = v19;
    v22 = v19 - (v20 + *(a8 + 1348));
    if ( v19 - (v20 + *(a8 + 1348)) < 0 || v19 <= v20 + *(a8 + 1348) && !v21 )
    {
      *hWnd = 0i64;
      v22 = 0;
      v21 = 0;
    }
    v23 = v21 != *(a8 + 1336) || v22 != *(a8 + 1340);
    *(a8 + 1336) = v21;
    *(a8 + 1340) = v22;
    v24 = ColumnIDIsIllegal(v23, ghWndTreeListView, 1092, wParam);
    v25 = v286;
    LOBYTE(v288) = v24;
    v26 = v286 != *(a8 + 1344) || v276 != *(a8 + 1348);
    *(a8 + 1348) = v276;
    *(a8 + 1344) = v25;
    v27 = ColumnIDIsIllegal(v26, ghWndTreeListView, 1091, wParam);
    a1 = v288;
    LOBYTE(a1) = v27 | v288;
    v288 = a1;
  }
  if ( !*(a8 + 68) )
  {
    if ( v287 && QueryIdleProcessorCycleTime )
    {
      if ( gdwOsType < 2 || (v28 = *(v280 + 24), v29 = *(v280 + 28), !*(v280 + 24)) )
      {
        pulRet = 8 * gSystemInfo.dwNumberOfProcessors;
        QueryIdleProcessorCycleTime(&pulRet, ProcessorCycleTimes);
        v30 = 0;
        v29 = v279[1];
        v28 = v279[0];
        if ( gSystemInfo.dwNumberOfProcessors <= 0 )
          goto LABEL_50;
        do
        {
          v31 = __PAIR__(HIDWORD(ProcessorCycleTimes[v30]), ProcessorCycleTimes[v30]) + __PAIR__(v29, v28);
          v29 = v31 >> 32;
          v28 = v31;
          ++v30;
        }
        while ( v30 < gSystemInfo.dwNumberOfProcessors );
      }
      v279[0] = v28;
      v279[1] = v29;
LABEL_50:
      v32 = __PAIR__(v29, v28) - *(a8 + 1360);
      v33 = v32 != *(a8 + 1352);
      *(a8 + 1352) = v32;
      v34 = ColumnIDIsIllegal(v33, ghWndTreeListView, 1200, wParam);
      v35 = v288;
      LOBYTE(v35) = v34 | v288;
      v288 = v35;
      v36 = v279[1];
      v37 = v279[0] != *(a8 + 1360) || v279[1] != *(a8 + 1364);
      *(a8 + 1360) = v279[0];
      *(a8 + 1364) = v36;
      v38 = ColumnIDIsIllegal(v37, ghWndTreeListView, 1195, wParam);
      return v38 | v288;
    }
    return a1;
  }
  v40 = hProcess;
  if ( v287 && QueryIdleProcessorCycleTime )
  {
    if ( !hProcess && !*(v280 + 24) )
      return a1;
    if ( gdwOsType >= 2 && (v41 = *(v280 + 24), v42 = *(v280 + 28), *(v280 + 24)) )
    {
      v279[0] = *(v280 + 24);
      v279[1] = v42;
    }
    else
    {
      QueryProcessCycleTime(hProcess, v279);
      v42 = v279[1];
      v41 = v279[0];
    }
    v44 = __PAIR__(v42, v41) - *(a8 + 1360);
    v43 = (__PAIR__(v42, v41) - *(a8 + 1360)) >> 32;
    v45 = __PAIR__(v43, v44) != *(a8 + 1352);
    *(a8 + 1352) = __PAIR__(v43, v44);
    v17 = ColumnIDIsIllegal(v45, ghWndTreeListView, 1200, wParam) == 0;
    v46 = v288;
    v47 = 1;
    if ( !v17 )
      v46 = 1;
    v286 = v46;
    v48 = v279[1];
    if ( v279[0] == *(a8 + 1360) && v279[1] == *(a8 + 1364) )
      v47 = 0;
    *(a8 + 1360) = v279[0];
    *(a8 + 1364) = v48;
    v17 = ColumnIDIsIllegal(v47, ghWndTreeListView, 1195, wParam) == 0;
    a1 = v286;
    if ( !v17 )
      a1 = 1;
    v288 = a1;
  }
  if ( !v40 )
    return a1;
  if ( wParam != -1 && GetProcessWorkingSetSize(v40, &MinimumWorkingSetSize, &MaximumWorkingSetSize) )
  {
    v17 = MinimumWorkingSetSize == *(a8 + 912);
    *(a8 + 912) = MinimumWorkingSetSize;
    v49 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1341, wParam);
    v50 = v288;
    LOBYTE(v50) = v49 | v288;
    v17 = MaximumWorkingSetSize == *(a8 + 916);
    v288 = v50;
    *(a8 + 916) = MaximumWorkingSetSize;
    v51 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1342, wParam);
    LOBYTE(v288) = v51 | v288;
  }
  v52 = sub_1233340(
          v40,
          __PAIR__(a5, a4) / gSystemInfo.dwNumberOfProcessors,
          (__PAIR__(a5, a4) / gSystemInfo.dwNumberOfProcessors) >> 32,
          a6,
          a7,
          a8,
          wParam);
  LOBYTE(v288) = v52 | v288;
  if ( v282 )
  {
    sub_125EB20(v40, (a8 + 928), (a8 + 932), &v286, &v277, &v273, &v275);
    if ( wParam != -1 )
    {
      v17 = v286 == *(a8 + 936);
      *(a8 + 936) = v286;
      v53 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1115, wParam);
      LOBYTE(v288) = v53 | v288;
      v17 = v277 == *(a8 + 940);
      *(a8 + 940) = v277;
      v54 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1116, wParam);
      LOBYTE(v288) = v54 | v288;
      v17 = v273 == *(a8 + 944);
      *(a8 + 944) = v273;
      v55 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1317, wParam);
      LOBYTE(v288) = v55 | v288;
      v17 = v275 == *(a8 + 948);
      *(a8 + 948) = v275;
      v56 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1118, wParam);
      LOBYTE(v288) = v56 | v288;
    }
  }
  if ( v283 )
  {
    v57 = GetGuiResources(v40, 0);
    v17 = v57 == *(a8 + 1380);
    *(a8 + 1380) = v57;
    v58 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1066, wParam);
    v59 = v288;
    if ( v58 )
      v59 = 1;
    v60 = GetGuiResources(v40, 1u);
    v17 = v60 == *(a8 + 1376);
    *(a8 + 1376) = v60;
    v61 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1067, wParam);
    v62 = v59;
    v18 = wParam;
    if ( v61 )
      v62 = 1;
    LOBYTE(v288) = v62;
  }
  if ( v284 )
  {
    pBuffer = -1;
    NtQueryInformationProcess(v40, 39, &pBuffer, 4u, &pulRet);
    v17 = pBuffer == *(a8 + 872);
    *(a8 + 872) = pBuffer;
    v63 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1339, v18);
    v64 = v288;
    if ( v63 )
      v64 = 1;
    LOBYTE(v288) = v64;
  }
  if ( v281 )
  {
    v272 = -1;
    NtQueryInformationProcess(v40, 33, &v272, 4u, &pulRet);
    v17 = v272 == *(a8 + 952);
    *(a8 + 952) = v272;
    v65 = ColumnIDIsIllegal(!v17, ghWndTreeListView, 1340, v18);
    v66 = v288;
    if ( v65 )
      v66 = 1;
    LOBYTE(v288) = v66;
  }
  if ( NtQueryInformationProcess(v40, 2, &v290, 0x30u, &pulRet) )
    return v288;
  v67 = v296 - *(a8 + 968);
  v68 = (v296 - *(a8 + 968)) >> 32;
  v285 = v292 - *(a8 + 992);
  v69 = (v297 - *(a8 + 1000)) >> 32;
  v270 = v297 - *(a8 + 1000);
  hWnd[1] = (v294 - *(a8 + 1024));
  v70 = (v298 - *(a8 + 1032)) >> 32;
  v273 = v298 - *(a8 + 1032);
  v276 = v67;
  v277 = v70;
  v72 = __PAIR__(v68, v67) + __PAIR__(v69, v270) + __PAIR__(v70, v273);
  v71 = (__PAIR__(v68, v67) + __PAIR__(v69, v270) + __PAIR__(v70, v273)) >> 32;
  hProcess = v72;
  v280 = v68;
  v73 = v290 - *(a8 + 960);
  v275 = v69;
  v286 = v71;
  v74 = ColumnIDIsIllegal(v73 != *(a8 + 976), ghWndTreeListView, 1326, v18);
  v75 = v288;
  *(a8 + 976) = v73;
  v76 = v285;
  if ( v74 )
    v75 = 1;
  v288 = v75;
  v77 = ColumnIDIsIllegal(v285 != *(a8 + 1008), ghWndTreeListView, 1328, v18);
  v78 = v288;
  *(a8 + 1008) = v76;
  v79 = hWnd[1];
  if ( v77 )
    v78 = 1;
  v285 = v78;
  v80 = ColumnIDIsIllegal(hWnd[1] != *(a8 + 1040), ghWndTreeListView, 1335, v18);
  v81 = v280;
  v17 = v80 == 0;
  v82 = v285;
  v83 = 1;
  if ( !v17 )
    v82 = 1;
  *(a8 + 1040) = v79;
  hWnd[1] = v82;
  if ( v276 == *(a8 + 984) && v81 == *(a8 + 988) )
    v83 = 0;
  v84 = ghWndTreeListView;
  *(a8 + 984) = v276;
  *(a8 + 988) = v81;
  v17 = ColumnIDIsIllegal(v83, v84, 1327, v18) == 0;
  v85 = v275;
  v86 = 1;
  v87 = LOBYTE(hWnd[1]);
  if ( !v17 )
    v87 = 1;
  hWnd[1] = v87;
  if ( v270 == *(a8 + 1016) && v275 == *(a8 + 1020) )
    v86 = 0;
  v88 = ghWndTreeListView;
  *(a8 + 1016) = v270;
  *(a8 + 1020) = v85;
  v17 = ColumnIDIsIllegal(v86, v88, 1329, v18) == 0;
  v89 = v277;
  v90 = 1;
  v91 = LOBYTE(hWnd[1]);
  if ( !v17 )
    v91 = 1;
  hWnd[1] = v91;
  if ( v273 == *(a8 + 1048) && v277 == *(a8 + 1052) )
    v90 = 0;
  v92 = ghWndTreeListView;
  *(a8 + 1048) = v273;
  *(a8 + 1052) = v89;
  v17 = ColumnIDIsIllegal(v90, v92, 1332, v18) == 0;
  v93 = v286;
  v94 = 1;
  v95 = LOBYTE(hWnd[1]);
  if ( !v17 )
    v95 = 1;
  hWnd[1] = v95;
  if ( hProcess == *(a8 + 1056) && v286 == *(a8 + 1060) )
    v94 = 0;
  v96 = ghWndTreeListView;
  *(a8 + 1056) = hProcess;
  *(a8 + 1060) = v93;
  v97 = ColumnIDIsIllegal(v94, v96, 1333, v18);
  v98 = v290;
  v17 = v97 == 0;
  v99 = LOBYTE(hWnd[1]);
  v100 = 1;
  if ( !v17 )
    v99 = 1;
  hWnd[1] = v99;
  if ( v290 == *(a8 + 960) && !v291 )
    v100 = 0;
  v285 = v291;
  v101 = ColumnIDIsIllegal(v100, ghWndTreeListView, 1068, v18);
  v102 = v296;
  v17 = v101 == 0;
  v103 = LOBYTE(hWnd[1]);
  v104 = 1;
  if ( !v17 )
    v103 = 1;
  *(a8 + 960) = v98;
  hWnd[1] = v103;
  v105 = HIDWORD(v296);
  if ( __PAIR__(HIDWORD(v296), v102) == *(a8 + 968) )
    v104 = 0;
  v106 = ghWndTreeListView;
  *(a8 + 968) = v102;
  *(a8 + 972) = v105;
  v107 = ColumnIDIsIllegal(v104, v106, 1069, v18);
  v108 = v292;
  v17 = v107 == 0;
  v109 = LOBYTE(hWnd[1]);
  v110 = 1;
  if ( !v17 )
    v109 = 1;
  hWnd[1] = v109;
  if ( v292 == *(a8 + 992) && !v293 )
    v110 = 0;
  v285 = v293;
  v111 = ColumnIDIsIllegal(v110, ghWndTreeListView, 1070, v18);
  v112 = v297;
  v17 = v111 == 0;
  v113 = LOBYTE(hWnd[1]);
  v114 = 1;
  if ( !v17 )
    v113 = 1;
  *(a8 + 992) = v108;
  hWnd[1] = v113;
  v115 = HIDWORD(v297);
  if ( __PAIR__(HIDWORD(v297), v112) == *(a8 + 1000) )
    v114 = 0;
  v116 = ghWndTreeListView;
  *(a8 + 1000) = v112;
  *(a8 + 1004) = v115;
  v117 = ColumnIDIsIllegal(v114, v116, 1071, v18);
  v118 = v294;
  v17 = v117 == 0;
  v119 = LOBYTE(hWnd[1]);
  v120 = 1;
  if ( !v17 )
    v119 = 1;
  hWnd[1] = v119;
  if ( v294 == *(a8 + 1024) && !v295 )
    v120 = 0;
  v285 = v295;
  v121 = ColumnIDIsIllegal(v120, ghWndTreeListView, 1072, v18);
  v122 = v298;
  v17 = v121 == 0;
  v123 = LOBYTE(hWnd[1]);
  v124 = 1;
  if ( !v17 )
    v123 = 1;
  *(a8 + 1024) = v118;
  hWnd[1] = v123;
  v125 = HIDWORD(v298);
  if ( __PAIR__(HIDWORD(v298), v122) == *(a8 + 1032) )
    v124 = 0;
  v126 = ghWndTreeListView;
  *(a8 + 1032) = v122;
  *(a8 + 1036) = v125;
  v127 = ColumnIDIsIllegal(v124, v126, 1073, v18);
  v128 = LOBYTE(hWnd[1]);
  if ( v127 )
    v128 = 1;
  v280 = v128;
  v129 = *sub_1275820(&dword_12FBA70, &v277, (a8 + 68));
  if ( v129 != dword_12FBA70._Left )
  {
    v130 = (*(v129 + 48) - *(a8 + 1072)) >> 32;
    hWnd[1] = (*(v129 + 48) - *(a8 + 1072));
    v131 = ColumnIDIsIllegal(__PAIR__(v130, hWnd[1]) != *(a8 + 1088), ghWndTreeListView, 1610, v18);
    v132 = v280;
    if ( v131 )
      v132 = 1;
    *(a8 + 1088) = hWnd[1];
    v133 = *(v129 + 60);
    v285 = v132;
    v134 = (__PAIR__(v133, *(v129 + 56)) - *(a8 + 1104)) >> 32;
    hWnd[1] = (*(v129 + 56) - *(a8 + 1104));
    v135 = ColumnIDIsIllegal(__PAIR__(v134, hWnd[1]) != *(a8 + 1120), ghWndTreeListView, 1612, v18);
    v136 = v285;
    if ( v135 )
      v136 = 1;
    *(a8 + 1120) = hWnd[1];
    v137 = *(v129 + 68);
    v285 = v136;
    v138 = (__PAIR__(v137, *(v129 + 64)) - *(a8 + 1136)) >> 32;
    hWnd[1] = (*(v129 + 64) - *(a8 + 1136));
    v139 = ColumnIDIsIllegal(__PAIR__(v138, hWnd[1]) != *(a8 + 1152), ghWndTreeListView, 1614, v18);
    v140 = v285;
    if ( v139 )
      v140 = 1;
    *(a8 + 1152) = hWnd[1];
    v285 = v140;
    v141 = *(v129 + 24);
    v20 = v141 < *(a8 + 1080);
    v142 = v141 - *(a8 + 1080);
    hWnd[1] = ghWndTreeListView;
    v143 = *(v129 + 28) - (v20 + *(a8 + 1084));
    v144 = v142 != *(a8 + 1096) || v143 != *(a8 + 1100);
    v145 = hWnd[1];
    *(a8 + 1100) = v143;
    *(a8 + 1096) = v142;
    v146 = ColumnIDIsIllegal(v144, v145, 1616, v18);
    v147 = *(v129 + 32);
    v148 = v285;
    if ( v146 )
      v148 = 1;
    v20 = v147 < *(a8 + 1112);
    v149 = v147 - *(a8 + 1112);
    hWnd[1] = ghWndTreeListView;
    v150 = *(v129 + 36) - (v20 + *(a8 + 1116));
    v285 = v148;
    v151 = v149 != *(a8 + 1128) || v150 != *(a8 + 1132);
    v152 = hWnd[1];
    *(a8 + 1132) = v150;
    *(a8 + 1128) = v149;
    v153 = ColumnIDIsIllegal(v151, v152, 1619, v18);
    v154 = *(v129 + 40);
    v155 = v285;
    if ( v153 )
      v155 = 1;
    v20 = v154 < *(a8 + 1144);
    v156 = v154 - *(a8 + 1144);
    v285 = v155;
    v157 = *(v129 + 44) - (v20 + *(a8 + 1148));
    hWnd[1] = ghWndTreeListView;
    v158 = v156 != *(a8 + 1160) || v157 != *(a8 + 1164);
    v159 = hWnd[1];
    *(a8 + 1160) = v156;
    *(a8 + 1164) = v157;
    v160 = ColumnIDIsIllegal(v158, v159, 1621, v18);
    v161 = v285;
    if ( v160 )
      v161 = 1;
    v162 = *(v129 + 48);
    hWnd[1] = v161;
    v285 = v162;
    v163 = v162 != *(a8 + 1072) || *(v129 + 52);
    v164 = ColumnIDIsIllegal(v163, ghWndTreeListView, 1609, v18);
    v165 = LOBYTE(hWnd[1]);
    if ( v164 )
      v165 = 1;
    *(a8 + 1072) = v285;
    v166 = *(v129 + 24);
    v286 = v165;
    v167 = *(v129 + 28);
    hWnd[1] = ghWndTreeListView;
    v168 = v166 != *(a8 + 1080) || v167 != *(a8 + 1084);
    v169 = hWnd[1];
    *(a8 + 1080) = v166;
    *(a8 + 1084) = v167;
    v170 = ColumnIDIsIllegal(v168, v169, 1617, v18);
    v171 = v286;
    if ( v170 )
      v171 = 1;
    v172 = *(v129 + 56);
    hWnd[1] = v171;
    v285 = v172;
    v173 = v172 != *(a8 + 1104) || *(v129 + 60);
    v174 = ColumnIDIsIllegal(v173, ghWndTreeListView, 1611, v18);
    v175 = LOBYTE(hWnd[1]);
    if ( v174 )
      v175 = 1;
    *(a8 + 1104) = v285;
    v176 = *(v129 + 32);
    v286 = v175;
    v177 = *(v129 + 36);
    hWnd[1] = ghWndTreeListView;
    v178 = v176 != *(a8 + 1112) || v177 != *(a8 + 1116);
    v179 = hWnd[1];
    *(a8 + 1112) = v176;
    *(a8 + 1116) = v177;
    v180 = ColumnIDIsIllegal(v178, v179, 1618, v18);
    v181 = v286;
    if ( v180 )
      v181 = 1;
    v182 = *(v129 + 64);
    hWnd[1] = v181;
    v285 = v182;
    v183 = v182 != *(a8 + 1136) || *(v129 + 68);
    v184 = ColumnIDIsIllegal(v183, ghWndTreeListView, 1613, v18);
    v185 = LOBYTE(hWnd[1]);
    if ( v184 )
      v185 = 1;
    *(a8 + 1136) = v285;
    v186 = *(v129 + 40);
    v286 = v185;
    v187 = *(v129 + 44);
    hWnd[1] = ghWndTreeListView;
    v188 = v186 != *(a8 + 1144) || v187 != *(a8 + 1148);
    v189 = hWnd[1];
    *(a8 + 1144) = v186;
    *(a8 + 1148) = v187;
    v190 = ColumnIDIsIllegal(v188, v189, 1620, v18);
    v191 = ghWndTreeListView;
    v192 = v286;
    if ( v190 )
      v192 = 1;
    v193 = *(a8 + 1132);
    hWnd[1] = v192;
    v195 = *(a8 + 1160) + *(a8 + 1096) + __PAIR__(v193, *(a8 + 1128));
    v194 = v195 >> 32;
    v196 = __PAIR__(v194, v195) != *(a8 + 1168);
    *(a8 + 1168) = __PAIR__(v194, v195);
    v197 = ColumnIDIsIllegal(v196, v191, 1622, v18);
    v198 = hWnd[1];
    if ( v197 )
      v198 = 1;
    LOBYTE(v280) = v198;
  }
  v199 = *sub_1275820(&dword_12FBA78, &v277, (a8 + 68));
  if ( v199 == dword_12FBA78._Left )
    return v280;
  v200 = (*(v199 + 48) - *(a8 + 1176)) >> 32;
  hWnd[1] = (*(v199 + 48) - *(a8 + 1176));
  v201 = ColumnIDIsIllegal(__PAIR__(v200, hWnd[1]) != *(a8 + 1192), ghWndTreeListView, 1624, v18);
  v202 = v280;
  if ( v201 )
    v202 = 1;
  *(a8 + 1192) = hWnd[1];
  v203 = *(v199 + 60);
  v285 = v202;
  v204 = (__PAIR__(v203, *(v199 + 56)) - *(a8 + 1208)) >> 32;
  hWnd[1] = (*(v199 + 56) - *(a8 + 1208));
  v205 = ColumnIDIsIllegal(__PAIR__(v204, hWnd[1]) != *(a8 + 1224), ghWndTreeListView, 1626, v18);
  v206 = v285;
  if ( v205 )
    v206 = 1;
  *(a8 + 1224) = hWnd[1];
  v207 = *(v199 + 68);
  v285 = v206;
  v208 = (__PAIR__(v207, *(v199 + 64)) - *(a8 + 1240)) >> 32;
  hWnd[1] = (*(v199 + 64) - *(a8 + 1240));
  v209 = ColumnIDIsIllegal(__PAIR__(v208, hWnd[1]) != *(a8 + 1256), ghWndTreeListView, 1628, v18);
  v210 = v285;
  if ( v209 )
    v210 = 1;
  *(a8 + 1256) = hWnd[1];
  v285 = v210;
  v211 = *(v199 + 24);
  v20 = v211 < *(a8 + 1184);
  v212 = v211 - *(a8 + 1184);
  hWnd[1] = ghWndTreeListView;
  v213 = *(v199 + 28) - (v20 + *(a8 + 1188));
  v214 = v212 != *(a8 + 1200) || v213 != *(a8 + 1204);
  v215 = hWnd[1];
  *(a8 + 1204) = v213;
  *(a8 + 1200) = v212;
  v216 = ColumnIDIsIllegal(v214, v215, 1631, v18);
  v217 = *(v199 + 32);
  v218 = v285;
  if ( v216 )
    v218 = 1;
  v20 = v217 < *(a8 + 1216);
  v219 = v217 - *(a8 + 1216);
  hWnd[1] = ghWndTreeListView;
  v220 = *(v199 + 36) - (v20 + *(a8 + 1220));
  v285 = v218;
  v221 = v219 != *(a8 + 1232) || v220 != *(a8 + 1236);
  v222 = hWnd[1];
  *(a8 + 1236) = v220;
  *(a8 + 1232) = v219;
  v223 = ColumnIDIsIllegal(v221, v222, 1633, v18);
  v224 = *(v199 + 40);
  v225 = v285;
  if ( v223 )
    v225 = 1;
  v20 = v224 < *(a8 + 1248);
  v226 = v224 - *(a8 + 1248);
  v285 = v225;
  v227 = *(v199 + 44) - (v20 + *(a8 + 1252));
  hWnd[1] = ghWndTreeListView;
  v228 = v226 != *(a8 + 1264) || v227 != *(a8 + 1268);
  v229 = hWnd[1];
  *(a8 + 1264) = v226;
  *(a8 + 1268) = v227;
  v230 = ColumnIDIsIllegal(v228, v229, 1635, v18);
  v231 = v285;
  if ( v230 )
    v231 = 1;
  v232 = *(v199 + 48);
  hWnd[1] = v231;
  v285 = v232;
  v233 = v232 != *(a8 + 1176) || *(v199 + 52);
  v234 = ColumnIDIsIllegal(v233, ghWndTreeListView, 1623, v18);
  v235 = LOBYTE(hWnd[1]);
  if ( v234 )
    v235 = 1;
  *(a8 + 1176) = v285;
  v236 = *(v199 + 24);
  v286 = v235;
  v237 = *(v199 + 28);
  hWnd[1] = ghWndTreeListView;
  v238 = v236 != *(a8 + 1184) || v237 != *(a8 + 1188);
  v239 = hWnd[1];
  *(a8 + 1184) = v236;
  *(a8 + 1188) = v237;
  v240 = ColumnIDIsIllegal(v238, v239, 1630, v18);
  v241 = v286;
  if ( v240 )
    v241 = 1;
  v242 = *(v199 + 56);
  hWnd[1] = v241;
  v285 = v242;
  v243 = v242 != *(a8 + 1208) || *(v199 + 60);
  v244 = ColumnIDIsIllegal(v243, ghWndTreeListView, 1625, v18);
  v245 = LOBYTE(hWnd[1]);
  if ( v244 )
    v245 = 1;
  *(a8 + 1208) = v285;
  v246 = *(v199 + 32);
  v286 = v245;
  v247 = *(v199 + 36);
  hWnd[1] = ghWndTreeListView;
  v248 = v246 != *(a8 + 1216) || v247 != *(a8 + 1220);
  v249 = hWnd[1];
  *(a8 + 1216) = v246;
  *(a8 + 1220) = v247;
  v250 = ColumnIDIsIllegal(v248, v249, 1632, v18);
  v251 = v286;
  if ( v250 )
    v251 = 1;
  v252 = *(v199 + 64);
  hWnd[1] = v251;
  v285 = v252;
  v253 = v252 != *(a8 + 1240) || *(v199 + 68);
  v254 = ColumnIDIsIllegal(v253, ghWndTreeListView, 1627, v18);
  v255 = LOBYTE(hWnd[1]);
  if ( v254 )
    v255 = 1;
  *(a8 + 1240) = v285;
  v256 = *(v199 + 40);
  v286 = v255;
  v257 = *(v199 + 44);
  hWnd[1] = ghWndTreeListView;
  v258 = v256 != *(a8 + 1248) || v257 != *(a8 + 1252);
  v259 = hWnd[1];
  *(a8 + 1248) = v256;
  *(a8 + 1252) = v257;
  v260 = ColumnIDIsIllegal(v258, v259, 1634, v18);
  v261 = ghWndTreeListView;
  v262 = v286;
  if ( v260 )
    v262 = 1;
  v263 = *(a8 + 1268);
  hWnd[1] = v262;
  v265 = *(a8 + 1200) + *(a8 + 1232) + __PAIR__(v263, *(a8 + 1264));
  v264 = v265 >> 32;
  v266 = __PAIR__(v264, v265) != *(a8 + 1272);
  *(a8 + 1272) = __PAIR__(v264, v265);
  v17 = ColumnIDIsIllegal(v266, v261, 1636, v18) == 0;
  v267 = hWnd[1];
  if ( !v17 )
    v267 = 1;
  return v267;
}
// 12E4E54: using guessed type int gdwOsType;
// 12EF2E0: using guessed type int (__stdcall *QueryProcessCycleTime)(_DWORD, _DWORD);
// 126DF20: using guessed type ULONG64 ProcessorCycleTimes[256];

//----- (0126F7C0) --------------------------------------------------------
int __thiscall sub_126F7C0(CDataInfo *this)
{
  int result; // eax

  this->field_C = this->field_0;
  this->field_30 = this->field_18;
  this->field_34 = this->field_1C;
  this->field_10 = this->field_4;
  this->field_38 = this->field_20;
  this->field_3C = this->field_24;
  this->field_14 = this->field_8;
  this->field_40 = this->field_28;
  result = this->field_2C;
  this->field_44 = result;
  this->field_0 = 0;
  this->field_4 = 0;
  this->field_8 = 0;
  this->field_18 = 0;
  this->field_1C = 0;
  this->field_20 = 0;
  this->field_24 = 0;
  this->field_28 = 0;
  this->field_2C = 0;
  this->field_48 = 0;
  this->field_4C = 0;
  this->field_50 = 0;
  this->field_54 = 0;
  this->field_58 = 0;
  this->field_5C = 0;
  this->field_60 = 0;
  return result;
}

//----- (0126F870) --------------------------------------------------------
char __usercall sub_126F870@<al>(int a1@<ebx>, int a2, int a3, int a4, DWORD dwProcessId, int a6, int a7, int a8)
{
  HANDLE ProcessHandle; // edi
  SIZE_T (__stdcall *VirtualQueryEx)(HANDLE, LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T); // esi
  SIZE_T v10; // ebx
  unsigned int v11; // kr00_4
  size_t v12; // eax
  unsigned int v13; // ebx
  WCHAR *v14; // edi
  unsigned int v15; // kr04_4
  char *BaseAddress; // eax
  LVITEMUSERDATA *v17; // esi
  char v18; // al
  signed int v19; // ecx
  HANDLE v20; // esi
  PIMAGE_NT_HEADERS v21; // ecx
  WORD v22; // ax
  PIMAGE_NT_HEADERS v23; // eax
  PVOID v24; // eax
  LVITEMUSERDATA *v26; // [esp-188h] [ebp-1774h]
  wchar_t *v27; // [esp-10h] [ebp-15FCh]
  int v28; // [esp-Ch] [ebp-15F8h]
  TCHAR *v29; // [esp-8h] [ebp-15F4h]
  HANDLESANDDLLSLISTUSERPARAM *v30; // [esp-4h] [ebp-15F0h]
  FILETIME CreationTime; // [esp+Ch] [ebp-15E0h]
  FILETIME LastAccessTime; // [esp+14h] [ebp-15D8h]
  MEMORY_BASIC_INFORMATION Buffer; // [esp+1Ch] [ebp-15D0h]
  SIZE_T NumberOfBytesRead; // [esp+38h] [ebp-15B4h]
  FILETIME LocalFileTime; // [esp+3Ch] [ebp-15B0h]
  int v36; // [esp+44h] [ebp-15A8h]
  wchar_t *v37; // [esp+48h] [ebp-15A4h]
  _DWORD *v38; // [esp+4Ch] [ebp-15A0h]
  FILETIME LastWriteTime; // [esp+50h] [ebp-159Ch]
  int v40; // [esp+58h] [ebp-1594h]
  HWND hWnd; // [esp+5Ch] [ebp-1590h]
  int *a1a; // [esp+60h] [ebp-158Ch]
  SIZE_T v43; // [esp+64h] [ebp-1588h]
  HANDLE v44; // [esp+68h] [ebp-1584h]
  MEMORY_BASIC_INFORMATION mbi; // [esp+6Ch] [ebp-1580h]
  int v46; // [esp+88h] [ebp-1564h]
  char v47; // [esp+8Fh] [ebp-155Dh]
  HANDLESANDDLLSLISTUSERPARAM RowInfo; // [esp+90h] [ebp-155Ch]
  LVITEMUSERDATA pUserData; // [esp+148h] [ebp-14A4h]
  SYSTEMTIME SystemTime; // [esp+2D0h] [ebp-131Ch]
  TCHAR Base[2048]; // [esp+2E0h] [ebp-130Ch]
  TCHAR DateStr[64]; // [esp+12E0h] [ebp-30Ch]
  TCHAR TimeStr[64]; // [esp+1360h] [ebp-28Ch]
  WCHAR szFileName[260]; // [esp+13E0h] [ebp-20Ch]

  hWnd = a2;
  LOBYTE(a1) = 0;
  v36 = a4;
  a1a = a6;
  v37 = a7;
  v40 = dwProcessId;
  v38 = a8;
  v46 = a1;
  ProcessHandle = OpenProcess(0x410u, 0, dwProcessId);
  v44 = ProcessHandle;
  if ( !ProcessHandle )
    return a1;
  VirtualQueryEx = ::VirtualQueryEx;
  mbi.BaseAddress = 0;
  if ( !::VirtualQueryEx(ProcessHandle, 0, &mbi, 0x1Cu) )
    goto __quit;
  while ( !a3 || *a3 != 1 )
  {
    v10 = mbi.RegionSize;
    v47 = 0;
    v43 = mbi.RegionSize;
    Buffer.BaseAddress = mbi.BaseAddress + mbi.RegionSize;
    if ( VirtualQueryEx(ProcessHandle, mbi.BaseAddress + mbi.RegionSize, &Buffer, 0x1Cu) )
    {
      do
      {
        if ( Buffer.AllocationBase != mbi.AllocationBase )
          break;
        Buffer.BaseAddress = Buffer.BaseAddress + Buffer.RegionSize;
        v10 = Buffer.BaseAddress - mbi.AllocationBase;
      }
      while ( VirtualQueryEx(ProcessHandle, Buffer.BaseAddress, &Buffer, 0x1Cu) );
      v43 = v10;
    }
    if ( mbi.Type != MEM_MAPPED && mbi.Type != 0x1000000 )
      goto LABEL_63;
    szFileName[0] = 0;
    if ( GetMappedFileNameW(ProcessHandle, mbi.BaseAddress, szFileName, _MAX_PATH) )
    {
      sub_1260DD0(szFileName);
    }
    else
    {
      if ( !gbShowUnnamedHandles )
        goto LABEL_64;
      v47 = 1;
      tcscpy_s(szFileName, _MAX_PATH, L"<Pagefile Backed>");
    }
    if ( !a3 )
    {
      v17 = gpUserDataInVerifySignature;
      if ( gpUserDataInVerifySignature )
      {
        while ( 1 )
        {
          if ( v17->field_24 == mbi.BaseAddress && v17->field_38 == v10 )
          {
            v30 = szFileName;
            v29 = v17->szPathName;
            if ( !_wcsicmp(v29, szFileName) )
              break;
          }
          v17 = v17->Prev;
          if ( !v17 )
            goto LABEL_33;
        }
        v30 = v17;
        ++*v38;
        v18 = sub_1278A20(v30);
        v19 = v46;
        if ( v18 )
          v19 = 1;
        mbi.BaseAddress = mbi.BaseAddress + v10;
        v46 = v19;
        sub_125C400(a1a, v17);
        BaseAddress = mbi.BaseAddress;
        VirtualQueryEx = ::VirtualQueryEx;
        goto LABEL_66;
      }
LABEL_33:
      memset(&pUserData, 0, 0x188u);
      if ( v47 )
        pUserData.field_2C |= 8u;
      pUserData.szPathName = _wcsdup(szFileName);
      tcscpy_s(&pUserData.szTargetName[65], 0x41u, gpszTargetName);
      v10 = v43;
      pUserData.field_24 = mbi.BaseAddress;
      LOBYTE(pUserData.FileMapping) = mbi.Type == 0x1000000;
      pUserData.field_38 = v43;
      LOWORD(pUserData.field_3C) = 1;
      pUserData.ImageBase = 0;
      pUserData.VerInfo = 0;
      pUserData.ImageDesc = 0;
      GetImageVersionInfo(szFileName, &pUserData.szTargetName[65], 0x41u, &pUserData.VerInfo, &pUserData.ImageDesc);
      if ( mbi.Type == 0x40000 )
        pUserData.field_2C |= 2u;
      tcscpy_s(pUserData.szTargetName, 0x41u, gpszTargetName);
      pUserData.CreationTime = 0i64;
      v20 = CreateFile(szFileName, 0x80000000, 7u, 0, 3u, 0, 0);
      if ( v20 != -1 )
      {
        GetFileTime(v20, &CreationTime, &LastAccessTime, &LastWriteTime);
        CloseHandle(v20);
        pUserData.CreationTime = LastWriteTime;
        FileTimeToLocalFileTime(&LastWriteTime, &LocalFileTime);
        FileTimeToSystemTime(&LocalFileTime, &SystemTime);
        GetDateFormatW(0x400u, 1u, &SystemTime, 0, DateStr, 64);
        GetTimeFormatW(0x400u, 2u, &SystemTime, 0, TimeStr, 64);
        v30 = TimeStr;
        v29 = DateStr;
        FormatString(pUserData.szTargetName, L"%s %s", DateStr, TimeStr);
      }
      if ( a3 )
      {
        RowInfo.field_B0 = 0;
        RowInfo.ImgName = _wcsdup(v37);
        RowInfo.szFileName = _wcsdup(szFileName);
        RowInfo.ProcessId = v40;
        RowInfo.field_AC = mbi.BaseAddress;
        RowInfo.field_10 = 0;
        tcscpy_s(RowInfo.szText, 0x40u, L"DLL");
        InsertRowToDllList(hWnd, &RowInfo);
LABEL_62:
        VirtualQueryEx = ::VirtualQueryEx;
LABEL_63:
        ProcessHandle = v44;
LABEL_64:
        BaseAddress = mbi.BaseAddress + v10;
        goto LABEL_65;
      }
      pUserData.ImageBase = 0;
      if ( *ImageNtHeader )
      {
        if ( !(pUserData.field_2C & 2) )
        {
          if ( ReadProcessMemory(ProcessHandle, mbi.AllocationBase, Base, 0x1000u, &NumberOfBytesRead) )
          {
            if ( *Base == 23117 )
            {
              v21 = ImageNtHeader(Base);
              if ( v21 )
              {
                if ( v21->FileHeader.Characteristics & 0x100
                  && (v22 = v21->FileHeader.Machine, v22 != -31132)
                  && v22 != 512 )
                {
                  LOBYTE(pUserData.FileMapping) = 1;
                  v23 = ImageNtHeader(Base);
                  if ( v23 )
                  {
                    pUserData.ImageBase = v23->OptionalHeader.ImageBase;
                    v24 = v23->OptionalHeader.ImageBase;
                    goto LABEL_52;
                  }
                }
                else
                {
                  LOBYTE(pUserData.FileMapping) = 2;
                  pUserData.ImageBase = v21->OptionalHeader.ImageBase;
                  v24 = v21->OptionalHeader.ImageBase;
LABEL_52:
                  if ( v24 != mbi.AllocationBase && mbi.Type == 0x1000000 )
                    pUserData.field_2C |= 1u;
                }
              }
            }
          }
        }
      }
      sub_125C400(a1a, &pUserData);
      v28 = pUserData.szPathName;
      pUserData.field_14 = 0;
      v27 = *(v36 + 88);
      pUserData.field_15C = sub_122BB70(v27, pUserData.szPathName);
      if ( gdwProcessIdSearching == v40 )
      {
        pUserData.field_10 = 2;
      }
      else
      {
        LOBYTE(pUserData.field_18) = 0;
        pUserData.field_10 = 0;
      }
      if ( mbi.Type == 0x1000000
        && OpenExeFromFile(
             pUserData.szPathName,
             &pUserData.StamptTime,
             &pUserData.FileMapping,
             &pUserData.FileMapping + 2) )
      {
        pUserData.field_2C |= 4u;
      }
      qmemcpy(&v26, &pUserData, 0x188u);
      VerifySignature(hWnd, v26);
      LOBYTE(v46) = 1;
      goto LABEL_62;
    }
    v11 = wcslen(szFileName);
    v12 = wcslen(gszTextToFind);
    if ( v11 >= v12 )
    {
      v13 = 0;
      if ( v11 - v12 != -1 )
      {
        v14 = szFileName;
        while ( _wcsnicmp(v14, gszTextToFind, v12) )
        {
          ++v13;
          ++v14;
          v15 = wcslen(szFileName);
          v12 = wcslen(gszTextToFind);
          if ( v13 >= v15 - v12 + 1 )
          {
            ProcessHandle = v44;
            goto LABEL_22;
          }
        }
        ProcessHandle = v44;
        goto LABEL_33;
      }
    }
LABEL_22:
    BaseAddress = mbi.BaseAddress + v43;
    VirtualQueryEx = ::VirtualQueryEx;
LABEL_65:
    mbi.BaseAddress = BaseAddress;
LABEL_66:
    if ( !VirtualQueryEx(ProcessHandle, BaseAddress, &mbi, 0x1Cu) )
      break;
  }
  LOBYTE(a1) = v46;
__quit:
  CloseHandle(ProcessHandle);
  return a1;
}
// 12E10BC: using guessed type int gdwProcessIdSearching;
// 12E96CA: using guessed type char gbShowUnnamedHandles;

//----- (0126FFD0) --------------------------------------------------------
// 控制服务的对话框
BOOL __stdcall ServiceControlDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  HANDLE hServiceHandle; // edi
  __int16 uServiceCmd; // cx
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v7; // eax
  HWND v8; // eax
  HANDLE v9; // eax
  bool State; // zf
  HANDLE v11; // eax
  HWND v12; // eax
  HANDLE v13; // eax
  HWND ProcessHandle; // eax
  HWND v16; // eax
  SC_HANDLE v17; // eax
  DWORD v18; // esi
  QUERY_SERVICE_CONFIGW *pQueryServiceConfig; // ebx
  DWORD v20; // ST0C_4
  SC_HANDLE ServiceHandle; // esi
  HANDLE v22; // ebx
  HANDLE status; // eax
  DWORD pcbBytesNeeded; // [esp+14h] [ebp-2Ch]
  HANDLE uID; // [esp+18h] [ebp-28h]
  SC_HANDLE hService; // [esp+1Ch] [ebp-24h]
  _SERVICE_STATUS ServiceStatus; // [esp+20h] [ebp-20h]

  if ( msg != 0x110 )
  {
    if ( msg == WM_COMMAND )
    {
      if ( wParam == 1 )
      {
        v13 = GetPropW(hWnd, L"hService");
        CloseServiceHandle(v13);
        EndDialog(hWnd, 0);
      }
    }
    else if ( msg == WM_TIMER )
    {
      hServiceHandle = GetPropW(hWnd, L"hService");
      if ( !hServiceHandle )
        goto LABEL_9;
      QueryServiceStatus(hServiceHandle, &ServiceStatus);
      uServiceCmd = GetPropW(hWnd, L"Command");
      switch ( uServiceCmd )
      {
        case IDD_PROCSERVICES_BUTTON_STOP:
        case IDD_PROCSERVICES_BUTTON_RESTART:
          if ( ServiceStatus.dwCurrentState != 1 )
            goto LABEL_9;
          if ( uServiceCmd != IDD_PROCSERVICES_BUTTON_RESTART )
            goto LABEL_16;
          SetPropW(hWnd, L"Command", 1213);
          StartServiceW(hServiceHandle, 0, 0);
          goto LABEL_9;
        case IDD_PROCSERVICES_BUTTON_RESUME:
        case IDD_PROCSERVICES_BUTTON_PAUSE|IDD_SYSINFOPROPSHEET_BUTTON_OK:
          State = ServiceStatus.dwCurrentState == 4;
          break;
        case IDD_PROCSERVICES_BUTTON_PAUSE:
          State = ServiceStatus.dwCurrentState == 7;
          break;
        default:
          goto LABEL_9;
      }
      if ( State )
      {
LABEL_16:
        v11 = GetPropW(hWnd, L"hService");
        CloseServiceHandle(v11);
        SetPropW(hWnd, L"hService", 0);
        v12 = GetDlgItem(hWnd, IDD_SERVICECONTROL_CTRL_PROGRESS);
        SendMessageW = ::SendMessageW;
        ::SendMessageW(v12, PBM_SETPOS, 38u, 0);
      }
      else
      {
LABEL_9:
        SendMessageW = ::SendMessageW;
      }
      v7 = GetDlgItem(hWnd, IDD_SERVICECONTROL_CTRL_PROGRESS);
      SendMessageW(v7, PBM_STEPIT, 0, 0);
      v8 = GetDlgItem(hWnd, IDD_SERVICECONTROL_CTRL_PROGRESS);
      if ( (SendMessageW)(v8, TBM_SETRANGEMAX, 0, 0) == 40 )
      {
        if ( GetPropW(hWnd, L"hService") )
        {
          v9 = GetPropW(hWnd, L"hService");
          CloseServiceHandle(v9);
          EndDialog(hWnd, IDOK);
        }
        else
        {
          EndDialog(hWnd, IDCANCEL);
        }
      }
      return 1;
    }
    return 0;
  }
  // WM_INITDIALOG
  uID = *(lParam + 8);
  switch ( uID )
  {
    case IDD_PROCSERVICES_BUTTON_STOP:
      SetDlgItemTextW(
        hWnd,
        IDD_SERVICECONTROL_STATIC_PE_ATTEMPTING_TO,
        L"Process Explorer is attempting to stop the following service...");
      hService = SERVICE_STOP;
      break;
    case IDD_PROCSERVICES_BUTTON_RESUME:
      SetDlgItemTextW(
        hWnd,
        IDD_SERVICECONTROL_STATIC_PE_ATTEMPTING_TO,
        L"Process Explorer is attempting to resume the following service...");
      hService = 64;
      break;
    case IDD_PROCSERVICES_BUTTON_PAUSE:
      SetDlgItemTextW(
        hWnd,
        IDD_SERVICECONTROL_STATIC_PE_ATTEMPTING_TO,
        L"Process Explorer is attempting to pause the following service...");
      hService = SERVICE_PAUSE_CONTINUE;
      break;
    case IDD_PROCSERVICES_BUTTON_PAUSE|IDD_SYSINFOPROPSHEET_BUTTON_OK:
      SetDlgItemTextW(
        hWnd,
        IDD_SERVICECONTROL_STATIC_PE_ATTEMPTING_TO,
        L"Process Explorer is attempting to start the following service...");
      hService = SERVICE_WIN32_OWN_PROCESS;
      break;
    case IDD_PROCSERVICES_BUTTON_RESTART:
      SetDlgItemTextW(
        hWnd,
        IDD_SERVICECONTROL_STATIC_PE_ATTEMPTING_TO,
        L"Process Explorer is attempting to restart the following service...");
      hService = SERVICE_WIN32;
      break;
    default:
      hService = uID;
      break;
  }
  ProcessHandle = GetDlgItem(hWnd, IDD_SERVICECONTROL_CTRL_PROGRESS);
  ::SendMessageW(ProcessHandle, PBM_SETRANGE, 0, 0x280000);
  v16 = GetDlgItem(hWnd, IDD_SERVICECONTROL_CTRL_PROGRESS);
  ::SendMessageW(v16, PBM_SETSTEP, 1u, 0);
  v17 = OpenServiceW(ghSCManager, *(lParam + 20), hService | 5);
  hService = v17;
  if ( !v17 )
  {
    ErrMsgBox(L"Error opening service for control", ghWndNewOwner);
    EndDialog(hWnd, 0);
    return 0;
  }
  QueryServiceConfigW(v17, 0, 0, &pcbBytesNeeded);
  v18 = pcbBytesNeeded;
  pQueryServiceConfig = malloc(pcbBytesNeeded);
  v20 = v18;
  ServiceHandle = hService;
  QueryServiceConfigW(hService, pQueryServiceConfig, v20, &pcbBytesNeeded);
  SetDlgItemTextW(hWnd, IDD_SERVICECONTROL_STATIC_STATIC, pQueryServiceConfig->lpDisplayName);
  free(pQueryServiceConfig);
  v22 = uID;
  switch ( uID )
  {
    case IDD_PROCSERVICES_BUTTON_STOP:
    case IDD_PROCSERVICES_BUTTON_RESTART:
      status = ControlService(ServiceHandle, 1u, &ServiceStatus);
      break;
    case IDD_PROCSERVICES_BUTTON_RESUME:
      status = ControlService(ServiceHandle, 3u, &ServiceStatus);
      break;
    case IDD_PROCSERVICES_BUTTON_PAUSE:
      status = ControlService(ServiceHandle, 2u, &ServiceStatus);
      break;
    case IDD_PROCSERVICES_BUTTON_PAUSE|IDD_SYSINFOPROPSHEET_BUTTON_OK:
      status = StartServiceW(ServiceHandle, 0, 0);
      break;
    default:
      status = uID;
      break;
  }
  if ( !status )
  {
    ErrMsgBox(L"Error sending control to service", ghWndNewOwner);
    EndDialog(hWnd, 0);
    CloseServiceHandle(ServiceHandle);
    return 0;
  }
  SetPropW(hWnd, L"command", v22);
  SetPropW(hWnd, L"hService", hService);
  SetTimer(hWnd, 1u, 500u, 0);
  GetAllServicesName();
  return 1;
}

//----- (01270400) --------------------------------------------------------
BOOL __cdecl SetDlgItemULong(HWND hDlg, int nIDDlgItem, int ArgList, int nValue)
{
  TCHAR szText[50]; // [esp+4h] [ebp-68h]

  FormatULong64(szText, L"%I64d", ArgList, nValue);
  GetNumberTextFormat(szText, 50u);
  return SetDlgItemTextW(hDlg, nIDDlgItem, szText);
}

//----- (01270460) --------------------------------------------------------
BOOL __cdecl SetDlgItemULong64(HWND hDlg, int nIDDlgItem, ULONG64 value)
{
  WCHAR String; // [esp+4h] [ebp-68h]

  FormatULong64(&String, L"%I64d", value / 1024);
  GetNumberTextFormat(&String, 0x32u);
  wcscat_s(&String, 0x32u, L" KB");
  return SetDlgItemTextW(hDlg, nIDDlgItem, &String);
}

//----- (012704E0) --------------------------------------------------------
BOOL (__stdcall *__thiscall sub_12704E0(_DWORD *this, int a2, int a3))(HWND hWnd, LPRECT lpRect)
{
  HWND pHwnds; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  pHwnds = a2;
  v5 = a3;
  return CResize::Update(this, 2, &pHwnds);
}

//----- (01270510) --------------------------------------------------------
void (__stdcall *__thiscall sub_1270510(_DWORD *this, int a2, int a3, int a4))(HWND hWnd, LPRECT lpRect)
{
  HWND pHwnds; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]

  pHwnds = a2;
  v6 = a3;
  v7 = a4;
  return CResize::Update(this, 3, &pHwnds);
}

//----- (01270550) --------------------------------------------------------
BOOL __thiscall CResize::Update(CResize *this, int nWndCount, HWND *pHwnds)
{
  BOOL GetWindowRect; // eax
  int idx; // esi
  int index; // esi
  ResizeInfo *v6; // eax
  double res; // [esp+0h] [ebp-40h]
  CResize *pResize; // [esp+8h] [ebp-38h]
  double dbHeight; // [esp+Ch] [ebp-34h]
  double dbLeft; // [esp+14h] [ebp-2Ch]
  RECT rwWinodw; // [esp+1Ch] [ebp-24h]
  RECT Rect; // [esp+2Ch] [ebp-14h]

  GetWindowRect = ::GetWindowRect;
  idx = 0;
  pResize = this;
  dbLeft = 0.0;
  for ( dbHeight = 0.0; idx < nWndCount; dbHeight = (Rect.bottom - Rect.top) + dbHeight )
  {
    (GetWindowRect)(pHwnds[idx++], &Rect);
    GetWindowRect = ::GetWindowRect;
  }
  for ( index = 0; index < nWndCount; dbLeft = *&Rect.right )
  {
    (GetWindowRect)(pHwnds[index], &rwWinodw);
    *&Rect.right = (rwWinodw.bottom - rwWinodw.top) / dbHeight + dbLeft;
    res = (rwWinodw.bottom - rwWinodw.top) / dbHeight + dbLeft;
    if ( *&Rect.right >= 0.99999 )
      res = doubleOnePointZero;
    v6 = CResize::InitResizeBuffer(pResize, pHwnds[index++], 1);
    *&v6->d21.left = dbLeft;
    *&v6->d21.right = res;
    GetWindowRect = ::GetWindowRect;
  }
  return GetWindowRect;
}
/* Orphan comments:
xmm0 = float(eax*1000.0）
*/
// 12BCB30: using guessed type double doubleOnePointZero;

//----- (01270640) --------------------------------------------------------
BOOL __stdcall sub_1270640(int a1, int a2, DWORD BytesReturned, LPVOID lpOutBuffer, DWORD nOutBufferSize, int a6)
{
  BOOL result; // eax
  DWORD v7; // esi
  int InBuffer; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  if ( a2 >= gSystemInfo.lpMaximumApplicationAddress )
  {
    v7 = nOutBufferSize;
    InBuffer = dword_12EAB88;
    v9 = a2;
    result = DeviceIoControl(theDriver, 0x83350024, &InBuffer, 8u, lpOutBuffer, nOutBufferSize, &BytesReturned, 0);
    if ( result )
    {
      *a6 = v7;
      result = 1;
    }
    else
    {
      *a6 = 0;
    }
  }
  else
  {
    result = 1;
    *a6 = 0;
  }
  return result;
}
// 12EAB88: using guessed type int dword_12EAB88;

//----- (012706C0) --------------------------------------------------------
int __cdecl sub_12706C0(char a1, int a2, int a3)
{
  int v3; // esi
  HANDLE v4; // ebx
  int result; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  int v9; // ebx
  _DWORD *v10; // eax
  int v11; // edx
  _DWORD *v12; // ecx
  int v13; // esi
  _DWORD *v14; // edi
  _DWORD *v15; // ebx
  int *v16; // esi
  HANDLE v17; // esi
  int v18; // [esp+8h] [ebp-3Ch]
  int v19; // [esp+Ch] [ebp-38h]
  int v20; // [esp+10h] [ebp-34h]
  int v21; // [esp+14h] [ebp-30h]
  int v22; // [esp+18h] [ebp-2Ch]
  int v23; // [esp+1Ch] [ebp-28h]
  int v24; // [esp+20h] [ebp-24h]
  int v25; // [esp+24h] [ebp-20h]
  HANDLE v26; // [esp+28h] [ebp-1Ch]
  HANDLE hObject; // [esp+2Ch] [ebp-18h]
  int v28; // [esp+30h] [ebp-14h]
  int v29; // [esp+34h] [ebp-10h]
  int v30; // [esp+38h] [ebp-Ch]
  int *v31; // [esp+3Ch] [ebp-8h]
  char v32; // [esp+43h] [ebp-1h]

  v3 = a2;
  v32 = 0;
  v4 = OpenProcess(0x800u, 0, *(a2 + 68));
  v26 = v4;
  if ( !v4 )
    return GetLastError();
  if ( NtSuspendProcess )
  {
    if ( a1 )
      v6 = NtSuspendProcess(v4);
    else
      v6 = NtResumeProcess(v4);
    CloseHandle(v4);
    return v6;
  }
  if ( GetVersion() <= 4u )
  {
    v32 = 1;
    v7 = a2 + 136;
  }
  else
  {
    v7 = a2 + 184;
  }
  v8 = *(a2 + 4);
  v9 = 0;
  v30 = 0;
  if ( v8 )
  {
    v10 = (v7 + 56);
    v11 = v8;
    v12 = (v7 + 52);
    do
    {
      if ( *v12 == 5 && *v10 == 5 )
        ++v9;
      v12 += 16;
      v10 += 16;
      --v11;
    }
    while ( v11 );
    v30 = v9;
  }
  if ( a1 )
  {
    if ( v8 == v9 )
      goto LABEL_43;
  }
  else if ( v8 != v9 )
  {
    goto LABEL_43;
  }
  if ( v32 )
    v13 = a2 + 136;
  else
    v13 = a2 + 184;
  v28 = 0;
  if ( v8 )
  {
    v14 = (v13 + 56);
    v15 = (v13 + 52);
    v16 = (v13 + 36);
    v31 = v16;
    while ( 1 )
    {
      v25 = *v16;
      v24 = 0;
      v18 = 24;
      v19 = 0;
      v21 = 0;
      v20 = 0;
      v22 = 0;
      v23 = 0;
      if ( !NtOpenThread(&hObject, 2, &v18, &v24) )
        break;
LABEL_40:
      v16 += 16;
      v15 += 16;
      v31 = v16;
      v14 += 16;
      if ( ++v28 >= *(a2 + 4) )
      {
        v9 = v30;
        v3 = a2;
        goto LABEL_43;
      }
    }
    v17 = hObject;
    if ( !hObject )
    {
LABEL_39:
      v16 = v31;
      goto LABEL_40;
    }
    if ( a1 )
    {
      if ( a3 && (a3 != 1 || *v15 == 5 && *v14 == 5) )
        goto LABEL_38;
      NtSuspendThread(hObject, &v29);
      if ( *v14 == 5 || !v29 )
        goto LABEL_38;
      ++v30;
    }
    NtResumeThread(v17, &v29);
LABEL_38:
    CloseHandle(v17);
    goto LABEL_39;
  }
  v3 = a2;
LABEL_43:
  CloseHandle(v26);
  if ( a1 && *(v3 + 4) == v9 )
    result = 1904;
  else
    result = 0;
  return result;
}
// 12EF244: using guessed type int (__stdcall *NtSuspendThread)(_DWORD, _DWORD);
// 12EF248: using guessed type int (__stdcall *NtResumeThread)(_DWORD, _DWORD);
// 12EF24C: using guessed type int (__stdcall *NtSuspendProcess)(_DWORD);
// 12EF250: using guessed type int (__stdcall *NtResumeProcess)(_DWORD);
// 12EF254: using guessed type int (__stdcall *NtOpenThread)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (012708B0) --------------------------------------------------------
int __stdcall Real_SymLoadModuleExW(int hProcess, int hFile, int ImageName, int ModuleName, __int64 BaseOfDll, int DllSize)
{
  return SymLoadModuleExW(hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize, 0, 0);
}

//----- (012708E0) --------------------------------------------------------
int __stdcall Proxy_SymLoadModule64(int hProcess, int hFile, LPCWSTR pszImageName, LPCWSTR pszModuleName, int BaseOfDll, int BaseOfDll_4, int SizeOfDll)
{
  TCHAR *ModuleName; // esi
  TCHAR *ImageName; // eax
  int v9; // ebx
  int v10; // edx
  int v11; // edx
  int v13; // [esp+10h] [ebp-14h]
  int v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+20h] [ebp-4h]

  ModuleName = sub_1259E00(&v13, pszModuleName);
  v15 = 0;
  ImageName = sub_1259E00(&v14, pszImageName);
  LOBYTE(v15) = 1;
  v9 = pfnSymLoadModule64(hProcess, hFile, *ImageName, *ModuleName, __PAIR__(BaseOfDll_4, BaseOfDll), SizeOfDll);
  v10 = v14 - 16;
  LOBYTE(v15) = 0;
  if ( _InterlockedDecrement((v14 - 16 + 12)) <= 0 )
    (*(**v10 + 4))(v10);
  v11 = v13 - 16;
  v15 = -1;
  if ( _InterlockedDecrement((v13 - 16 + 12)) <= 0 )
    (*(**v11 + 4))(v11);
  return v9;
}

//----- (012709B0) --------------------------------------------------------
int __stdcall SysInfoCPUPageWndProc(HWND hWnd, int a2, HDC hdc, int a4)
{
  int v4; // esi
  HWND v5; // edi
  LONG v6; // eax
  void *v7; // eax
  unsigned int v8; // edx
  int *v9; // eax
  CResize *v10; // edi
  HWND v11; // eax
  DWORD v12; // ecx
  signed int v13; // esi
  int v14; // ecx
  HWND v15; // eax
  void *v16; // ecx
  int v17; // esi
  int v18; // eax
  HMENU v19; // esi
  int v20; // edi
  char v21; // al
  int v22; // ecx
  const WCHAR *v23; // eax
  const WCHAR *v24; // eax
  CResize *v25; // eax
  CResize *v26; // esi
  HWND v27; // eax
  ResizeInfo *v28; // eax
  HWND v29; // eax
  ResizeInfo *v30; // eax
  double v31; // xmm1_8
  void (__stdcall *v32)(HWND, UINT, WPARAM, LPARAM); // esi
  int v33; // esi
  HWND v34; // eax
  ResizeInfo *v35; // eax
  HWND v36; // eax
  double v37; // xmm0_8
  double *v38; // eax
  HWND v39; // eax
  int result; // eax
  signed int v41; // esi
  _SYSTEM_PROCESS_INFORMATION *v42; // eax
  ULONG v43; // edx
  ULONG v44; // ecx
  CResize *v45; // edi
  const WCHAR *v46; // eax
  const WCHAR *v47; // eax
  const WCHAR *v48; // eax
  DWORD v49; // esi
  DWORD v50; // eax
  __m128i v51; // xmm6
  __m128i v52; // xmm7
  char *v53; // eax
  __m128i v54; // xmm5
  __m128i v55; // xmm4
  char *v56; // ecx
  __m128i v57; // xmm2
  __m128i v58; // xmm4
  __m128i v59; // xmm5
  __m128i v60; // xmm4
  __m128i v61; // xmm5
  _SYSTEM_PROCESS_INFORMATION *v62; // ecx
  int v63; // edx
  _SYSTEM_PROCESS_INFORMATION *v64; // edi
  char *v65; // ecx
  _DWORD *v66; // eax
  DWORD v67; // edx
  int v68; // esi
  int v69; // ST58_4
  int v70; // esi
  char *v71; // esi
  int v72; // esi
  int v73; // eax
  HWND v74; // esi
  HWND v75; // eax
  HWND v76; // eax
  HWND v77; // eax
  HWND v78; // eax
  HWND v79; // eax
  HWND v80; // eax
  signed int v81; // edi
  HWND v82; // eax
  signed int v83; // eax
  int v84; // ST2C_4
  HWND v85; // eax
  signed int i; // esi
  signed int v87; // eax
  int v88; // ST2C_4
  HWND v89; // eax
  double v90; // [esp+Ch] [ebp-3B4h]
  int nHeight; // [esp+10h] [ebp-3B0h]
  double v92; // [esp+14h] [ebp-3ACh]
  int v93; // [esp+18h] [ebp-3A8h]
  signed int v94; // [esp+20h] [ebp-3A0h]
  double v95; // [esp+24h] [ebp-39Ch]
  int v96; // [esp+28h] [ebp-398h]
  int v97; // [esp+2Ch] [ebp-394h]
  DWORD pdwSizeReturned; // [esp+30h] [ebp-390h]
  double v99; // [esp+34h] [ebp-38Ch]
  void *v100[2]; // [esp+3Ch] [ebp-384h]
  double v101; // [esp+44h] [ebp-37Ch]
  HWND hWndParent; // [esp+4Ch] [ebp-374h]
  int v103; // [esp+50h] [ebp-370h]
  int v104; // [esp+54h] [ebp-36Ch]
  _SYSTEM_PROCESS_INFORMATION *ppBuffer; // [esp+58h] [ebp-368h]
  CResize *pResize; // [esp+5Ch] [ebp-364h]
  int pBuffer; // [esp+60h] [ebp-360h]
  int v108; // [esp+188h] [ebp-238h]
  struct tagRECT Rect; // [esp+198h] [ebp-228h]
  WCHAR String; // [esp+1A8h] [ebp-218h]
  int v111; // [esp+3BCh] [ebp-4h]

  v4 = 0;
  v5 = hWnd;
  hWndParent = hWnd;
  HIDWORD(v99) = 0;
  pResize = 0;
  if ( a2 <= 0x133 )
  {
    if ( a2 != 307 )
    {
      switch ( a2 )
      {
        case 36:
          *(a4 + 8) = 2 * gScreenWidth;
          result = 0;
          break;
        case 272:
          v6 = GetWindowLongW(hWnd, -16);
          SetWindowLongW(hWnd, -16, v6 | 0x2000000);
          gpSystemProcessorPerfInfo = malloc(48 * gSystemInfo.dwNumberOfProcessors);
          v7 = malloc(24 * gSystemInfo.dwNumberOfProcessors);
          v8 = gdwLogicalProcessorInformationCount;
          gSystemInterruptInfo = v7;
          if ( gdwLogicalProcessorInformationCount > 0 )
          {
            v9 = &gLogicalProcessorInformation->field_4;
            v10 = 0;
            do
            {
              if ( *v9 )
              {
                if ( *v9 == 3 )
                  v10 = (v10 + 1);
              }
              else
              {
                ++v4;
              }
              v9 += 6;
              --v8;
            }
            while ( v8 );
            pResize = v10;
            v5 = hWndParent;
            HIDWORD(v99) = v4;
          }
          if ( gSystemInfo.dwNumberOfProcessors <= 1 )
          {
            v22 = 0;
            v103 = v100[1];
            pResize = 0;
            ppBuffer = v100[1];
          }
          else
          {
            v11 = GetDlgItem(v5, 2000);
            GetWindowRect(v11, &Rect);
            v12 = gSystemInfo.dwNumberOfProcessors;
            if ( gSystemInfo.dwNumberOfProcessors > 8 )
              v12 = 8 * (gSystemInfo.dwNumberOfProcessors / 8 > 16) + 8;
            ppBuffer = ((v12 + gSystemInfo.dwNumberOfProcessors - 1) / v12);
            v13 = 4;
            v14 = (v12 * ppBuffer - gSystemInfo.dwNumberOfProcessors) / -2 + v12;
            v103 = v14;
            if ( gSystemInfo.dwNumberOfProcessors > 0x10 )
              v13 = 3;
            v94 = v13;
            if ( gSystemInfo.dwNumberOfProcessors > 0x20 )
              v94 = --v13;
            v97 = (Rect.right - v13 * (v14 - 1) - Rect.left) / v103;
            nHeight = (Rect.bottom - v13 * (&ppBuffer[-1].Threads[0].WaitReason + 7) - Rect.top) / ppBuffer;
            v15 = GetDlgItem(v5, 2000);
            GetWindowRect(v15, &Rect);
            MapWindowPoints(0, v5, &Rect, 2u);
            v16 = Rect.left;
            v100[1] = Rect.left;
            v104 = 0;
            if ( gSystemInfo.dwNumberOfProcessors > 0 )
            {
              v17 = 1;
              HIDWORD(v101) = 1;
              do
              {
                v93 = 0;
                v96 = v17 % v103;
                if ( !(v17 % v103) )
                  v93 = Rect.right - v16 - v97;
                v18 = sub_1243F20(gLogicalProcessorInformation, gdwLogicalProcessorInformationCount, v17 - 1);
                v19 = (v17 + 2000);
                v20 = v18;
                CreateWindowExW(
                  0,
                  L"Static",
                  0,
                  0x40000000u,
                  Rect.left,
                  Rect.top,
                  v93 + v97,
                  nHeight,
                  hWndParent,
                  v19,
                  ghInstance,
                  0);
                CreateGraphWindowInDlg(hWndParent, v19, gpProcessorsInfo[v20]);
                Rect.left += v97;
                v21 = sub_1243F20(gLogicalProcessorInformation, gdwLogicalProcessorInformationCount, SHIDWORD(v101));
                if ( sub_12436B0(gLogicalProcessorInformation, gdwLogicalProcessorInformationCount, v20, v21) )
                {
                  v16 = (Rect.left + 2);
                  v104 = v94 + v104 - 2;
                }
                else
                {
                  v16 = (v94 + v104 + Rect.left);
                  v104 = 0;
                }
                Rect.left = v16;
                if ( !v96 )
                {
                  v16 = v100[1];
                  Rect.left = v100[1];
                  Rect.top += nHeight + 2;
                }
                v17 = HIDWORD(v101) + 1;
                HIDWORD(v101) = v17;
              }
              while ( v17 - 1 < gSystemInfo.dwNumberOfProcessors );
              v5 = hWndParent;
            }
            v22 = HIDWORD(v99);
          }
          stprintf(&String, L"%d", v22);
          v23 = GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1665, v23);
          stprintf(&String, L"%d", pResize);
          v24 = GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1666, v24);
          CreateGraphWindowInDlg(v5, IDC_PAGE_SUMETW_CPU_USAGE_CHART, gpGraphClassData[1]);
          CreateGraphWindowInDlg(v5, IDC_CPU_PAGE_CPU_GRAPH, gpGraphClassData[1]);
          v25 = operator new(0x40u);
          v100[1] = v25;
          v111 = 0;
          if ( v25 )
          {
            v26 = CResize::CResize(v25, v5);
            pResize = v26;
          }
          else
          {
            v26 = 0;
            pResize = 0;
          }
          v111 = -1;
          v26->m_WidthScale = 100;
          v26->m_HeightScale = 20;
          v27 = GetDlgItem(v5, 2000);
          if ( v27 )
          {
            v28 = CResize::InitResizeBuffer(v26, v27, 1);
            *&v28->d1.left = 0i64;
            *&v28->d1.right = doubleOnePointZero;
          }
          v29 = GetDlgItem(v5, 1114);
          if ( v29 )
          {
            v30 = CResize::InitResizeBuffer(v26, v29, 1);
            v31 = doubleOnePointZero;
            *&v30->d1.left = 0i64;
            *&v30->d1.right = doubleOnePointZero;
          }
          else
          {
            v31 = doubleOnePointZero;
          }
          v32 = SendMessageW;
          if ( gSystemInfo.dwNumberOfProcessors <= 1 )
          {
            v39 = GetDlgItem(v5, 1301);
            ShowWindow(v39, 0);
          }
          else
          {
            *v100 = 0.0;
            v95 = 0.0;
            if ( gSystemInfo.dwNumberOfProcessors > 0 )
            {
              v33 = 2001;
              v92 = v31 / v103;
              v90 = v31 / ppBuffer;
              do
              {
                v34 = GetDlgItem(v5, v33);
                v101 = v90 + v95;
                if ( v90 + v95 >= 0.99999 )
                  v101 = doubleOnePointZero;
                v35 = CResize::InitResizeBuffer(pResize, v34, 1);
                *&v35->d21.left = v95;
                *&v35->d21.right = v101;
                v36 = GetDlgItem(v5, v33);
                v37 = *v100 + v92;
                v99 = *v100 + v92;
                v101 = *v100 + v92;
                if ( *v100 + v92 >= 0.99999 )
                  v101 = doubleOnePointZero;
                if ( v36 )
                {
                  v38 = CResize::InitResizeBuffer(pResize, v36, 1);
                  *v38 = *v100;
                  v38[1] = v101;
                  v37 = v99;
                }
                *v100 = v37;
                if ( !((v33 - 2000) % v103) )
                {
                  *v100 = 0.0;
                  v95 = v90 + v95;
                }
                ++v33;
              }
              while ( v33 - 2001 < gSystemInfo.dwNumberOfProcessors );
              v32 = SendMessageW;
            }
            CheckDlgButton(v5, 1301, gbShowAllCpus != 0);
            v32(v5, 0x464u, 0, 0);
          }
          ResizeTab(v5);
          NtQuerySystemInformation(2u, gSystemPerfInfo, 0x138u, &pdwSizeReturned);
          v32(v5, 0x113u, 0, 0);
          result = 1;
          break;
        case 273:
          if ( hdc != 1301 || hdc >> 16 )
            return 0;
          gbShowAllCpus = gbShowAllCpus == 0;
          SendMessageW(hWnd, 0x464u, 0, 0);
          result = 0;
          break;
        case 275:
          ppBuffer = 0;
          GetAllProcesses(&ppBuffer, 0);
          NtQuerySystemInformation(2u, &pBuffer, 0x138u, &pdwSizeReturned);
          NtQuerySystemInformation(
            8u,
            gpSystemProcessorPerfInfo,
            48 * gSystemInfo.dwNumberOfProcessors,
            &pdwSizeReturned);
          NtQuerySystemInformation(
            SystemConfigurationInformation|0x10,
            gSystemInterruptInfo,
            24 * gSystemInfo.dwNumberOfProcessors,
            &pdwSizeReturned);
          v41 = 1;
          v42 = ppBuffer;
          v43 = ppBuffer->HandleCount;
          pResize = ppBuffer->NumberOfThreads;
          HIDWORD(v101) = v43;
          v44 = ppBuffer->NextEntryOffset;
          if ( ppBuffer->NextEntryOffset )
          {
            v45 = pResize;
            do
            {
              v43 += *(&v42->HandleCount + v44);
              v42 = (v42 + v44);
              ++v41;
              v45 = (v45 + v42->NumberOfThreads);
              v44 = v42->NextEntryOffset;
            }
            while ( v42->NextEntryOffset );
            pResize = v45;
            v5 = hWndParent;
            HIDWORD(v101) = v43;
          }
          free(ppBuffer);
          stprintf(&String, L"%d", HIDWORD(v101));
          v46 = GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1096, v46);
          stprintf(&String, L"%d", pResize);
          v47 = GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1097, v47);
          stprintf(&String, L"%d", v41);
          v48 = GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1098, v48);
          v49 = 0;
          v103 = 0;
          v104 = 0;
          v50 = gSystemInfo.dwNumberOfProcessors;
          if ( gSystemInfo.dwNumberOfProcessors && gSystemInfo.dwNumberOfProcessors >= 8 )
          {
            v51 = 0i64;
            v52 = 0i64;
            v53 = gSystemInterruptInfo + 52;
            v54 = 0i64;
            v55 = 0i64;
            v56 = gpSystemProcessorPerfInfo + 136;
            do
            {
              v57 = _mm_cvtsi32_si128(*(v56 + 12));
              v56 += 384;
              v53 += 192;
              v49 += 8;
              v51 = _mm_add_epi32(
                      v51,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 120)), _mm_cvtsi32_si128(*(v56 - 96))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 108)), v57)));
              v52 = _mm_add_epi32(
                      v52,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 60)), _mm_cvtsi32_si128(*(v53 - 48))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 54)), _mm_cvtsi32_si128(*(v53 - 42)))));
              v54 = _mm_add_epi32(
                      v54,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 72)), _mm_cvtsi32_si128(*(v56 - 48))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v56 - 60)), _mm_cvtsi32_si128(*(v56 - 36)))));
              v55 = _mm_add_epi32(
                      v55,
                      _mm_unpacklo_epi32(
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 36)), _mm_cvtsi32_si128(*(v53 - 24))),
                        _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v53 - 30)), _mm_cvtsi32_si128(*(v53 - 18)))));
            }
            while ( v49 < gSystemInfo.dwNumberOfProcessors - (gSystemInfo.dwNumberOfProcessors & 7) );
            v50 = gSystemInfo.dwNumberOfProcessors;
            v58 = _mm_add_epi32(v55, v52);
            v59 = _mm_add_epi32(v54, v51);
            v60 = _mm_add_epi32(v58, _mm_srli_si128(v58, 8));
            v61 = _mm_add_epi32(v59, _mm_srli_si128(v59, 8));
            v103 = _mm_cvtsi128_si32(_mm_add_epi32(v60, _mm_srli_si128(v60, 4)));
            v104 = _mm_cvtsi128_si32(_mm_add_epi32(v61, _mm_srli_si128(v61, 4)));
          }
          v62 = 0;
          v63 = 0;
          ppBuffer = 0;
          pResize = 0;
          HIDWORD(v99) = 0;
          if ( v49 >= v50 )
          {
            v71 = v103;
          }
          else
          {
            if ( v50 - v49 >= 2 )
            {
              v64 = 0;
              v65 = gSystemInterruptInfo + 24 * v49 + 4;
              v66 = gpSystemProcessorPerfInfo + 48 * v49 + 40;
              v67 = ((gSystemInfo.dwNumberOfProcessors - v49 - 2) >> 1) + 1;
              v100[1] = (v49 + 2 * v67);
              v68 = 0;
              do
              {
                v64 = (v64 + *v66);
                v66 += 24;
                v68 += *(v66 - 12);
                v65 += 48;
                ppBuffer = v64;
                pResize = (pResize + *(v65 - 12));
                HIDWORD(v99) += *(v65 - 6);
                --v67;
              }
              while ( v67 );
              v5 = hWndParent;
              v62 = ppBuffer;
              v69 = v68;
              v49 = v100[1];
              v63 = v69;
            }
            if ( v49 >= gSystemInfo.dwNumberOfProcessors )
            {
              v70 = v103;
            }
            else
            {
              v104 += *(gpSystemProcessorPerfInfo + 12 * v49 + 10);
              v5 = hWndParent;
              v70 = *(gSystemInterruptInfo + 6 * v49 + 1) + v103;
              v62 = ppBuffer;
            }
            v104 += v62 + v63;
            v71 = pResize + HIDWORD(v99) + v70;
            v103 = v71;
          }
          stprintf(&String, L"%u", v108 - dword_1305220);
          GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1082, &String);
          if ( dword_1305234 )
            v72 = &v71[-dword_1305234];
          else
            v72 = 0;
          stprintf(&String, L"%u", v72);
          GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1084, &String);
          if ( dword_1305238 )
            v73 = v104 - dword_1305238;
          else
            v73 = 0;
          stprintf(&String, L"%u", v73);
          GetNumberTextFormat(&String, 0x104u);
          SetDlgItemTextW(v5, 1083, &String);
          dword_1305234 = v103;
          qmemcpy(gSystemPerfInfo, &pBuffer, 0x138u);
          v74 = hWndParent;
          dword_1305238 = v104;
          v75 = GetDlgItem(hWndParent, 1158);
          SendMessageW(v75, 0x400u, 0, 0);
          v76 = GetDlgItem(v74, 2000);
          SendMessageW(v76, 0x400u, 0, 0);
          v77 = GetDlgItem(v74, 1161);
          SendMessageW(v77, 0x400u, 0, 0);
          v78 = GetDlgItem(v74, 1159);
          SendMessageW(v78, 0x400u, 0, 0);
          v79 = GetDlgItem(v74, 1637);
          SendMessageW(v79, 0x400u, 0, 0);
          v80 = GetDlgItem(v74, 1333);
          SendMessageW(v80, 0x400u, 0, 0);
          if ( gSystemInfo.dwNumberOfProcessors <= 1 )
            return 0;
          v81 = 0;
          if ( gSystemInfo.dwNumberOfProcessors <= 0 )
            return 0;
          do
          {
            v82 = GetDlgItem(v74, v81 + 2001);
            SendMessageW(v82, 0x400u, 0, 0);
            ++v81;
          }
          while ( v81 < gSystemInfo.dwNumberOfProcessors );
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
    return sub_1246710(hWnd, hdc);
  }
  if ( a2 == 310 || a2 == 312 )
    return sub_1246710(hWnd, hdc);
  if ( a2 == 1124 )
  {
    v83 = 5;
    if ( gbShowAllCpus )
      v83 = 0;
    v84 = v83;
    v85 = GetDlgItem(hWnd, 2000);
    ShowWindow(v85, v84);
    for ( i = 1; i < (gSystemInfo.dwNumberOfProcessors + 1); ++i )
    {
      v87 = 0;
      if ( gbShowAllCpus )
        v87 = 5;
      v88 = v87;
      v89 = GetDlgItem(hWnd, i + 2000);
      ShowWindow(v89, v88);
    }
  }
  return 0;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12E4E28: using guessed type int gScreenWidth;
// 12E96D8: using guessed type char gbShowAllCpus;
// 13050F8: using guessed type __int16 gSystemPerfInfo[148];
// 1305220: using guessed type int dword_1305220;
// 1305234: using guessed type int dword_1305234;
// 1305238: using guessed type int dword_1305238;

//----- (012718B0) --------------------------------------------------------
int __stdcall SysInfoGPUPageWndProc(HWND hWnd, int a2, HDC hdc, int a4)
{
  LONG v4; // eax
  signed int v5; // eax
  int v6; // ST44_4
  HWND v7; // eax
  CResize *v8; // eax
  CResize *v9; // esi
  HWND v10; // eax
  ResizeInfo *v11; // eax
  HWND v12; // eax
  ResizeInfo *v13; // eax
  HWND v14; // eax
  ResizeInfo *v15; // eax
  HWND v16; // eax
  ResizeInfo *v17; // eax
  HWND v18; // eax
  ResizeInfo *v19; // eax
  HWND v20; // eax
  ResizeInfo *v21; // eax
  HWND v22; // ST44_4
  HWND v23; // ST40_4
  HWND v24; // eax
  HWND v25; // ST44_4
  HWND v26; // ST40_4
  HWND v27; // eax
  HWND v28; // ST44_4
  HWND v29; // ST40_4
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  HWND v34; // eax
  HWND v35; // eax
  HWND v37; // eax
  HWND v38; // eax
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  int j; // esi
  HWND v44; // eax
  const WCHAR *v45; // eax
  const WCHAR *v46; // eax
  const WCHAR *v47; // eax
  const WCHAR *v48; // eax
  signed int v49; // eax
  int v50; // ST44_4
  HWND v51; // eax
  int i; // esi
  signed int v53; // eax
  int v54; // ST44_4
  HWND v55; // eax
  int v56[2]; // [esp+14h] [ebp-218h]
  wchar_t Dst; // [esp+1Ch] [ebp-210h]
  int v58; // [esp+228h] [ebp-4h]

  if ( a2 > 0x133 )
  {
    if ( a2 != 310 && a2 != 312 )
    {
      if ( a2 == 1124 )
      {
        v49 = 5;
        if ( gbShowAllGpus )
          v49 = 0;
        v50 = v49;
        v51 = GetDlgItem(hWnd, 2501);
        ShowWindow(v51, v50);
        for ( i = 1; i < gdwAdapterRuntingTime + 1; ++i )
        {
          v53 = 0;
          if ( gbShowAllGpus )
            v53 = 5;
          v54 = v53;
          v55 = GetDlgItem(hWnd, i + 2501);
          ShowWindow(v55, v54);
        }
      }
      return 0;
    }
  }
  else if ( a2 != 307 )
  {
    switch ( a2 )
    {
      case 36:
        *(a4 + 8) = 2 * gScreenWidth;
        return 0;
      case 272:
        v4 = GetWindowLongW(hWnd, -16);
        SetWindowLongW(hWnd, -16, v4 | 0x2000000);
        v5 = 0;
        if ( gdwAdapterRuntingTime > 1 )
          v5 = 5;
        v6 = v5;
        v7 = GetDlgItem(hWnd, 1210);
        ShowWindow(v7, v6);
        CreateGraphWindowInDlg(hWnd, 1651, gpGraphClassData[2]);
        CreateGraphWindowInDlg(hWnd, 2501, gpGraphClassData[2]);
        CreateGraphWindowInDlg(hWnd, 1160, gpGraphClassData[4]);
        CreateGraphWindowInDlg(hWnd, 2601, gpGraphClassData[4]);
        CreateGraphWindowInDlg(hWnd, 1162, gpGraphClassData[3]);
        CreateGraphWindowInDlg(hWnd, 2602, gpGraphClassData[3]);
        v8 = operator new(0x40u);
        v58 = 0;
        if ( v8 )
          v9 = CResize::CResize(v8, hWnd);
        else
          v9 = 0;
        v58 = -1;
        v9->m_WidthScale = 100;
        v9->m_HeightScale = 0;
        v10 = GetDlgItem(hWnd, IDC_SYSTEMINFOGPU_STATIC_STATIC1);
        if ( v10 )
        {
          v11 = CResize::InitResizeBuffer(v9, v10, 1);
          *&v11->d1.left = 0i64;
          *&v11->d1.right = doubleOnePointZero;
        }
        v12 = GetDlgItem(hWnd, 1649);
        if ( v12 )
        {
          v13 = CResize::InitResizeBuffer(v9, v12, 1);
          *&v13->d1.left = 0i64;
          *&v13->d1.right = doubleOnePointZero;
        }
        v14 = GetDlgItem(hWnd, 2601);
        if ( v14 )
        {
          v15 = CResize::InitResizeBuffer(v9, v14, 1);
          *&v15->d1.left = 0i64;
          *&v15->d1.right = doubleOnePointZero;
        }
        v16 = GetDlgItem(hWnd, 1115);
        if ( v16 )
        {
          v17 = CResize::InitResizeBuffer(v9, v16, 1);
          *&v17->d1.left = 0i64;
          *&v17->d1.right = doubleOnePointZero;
        }
        v18 = GetDlgItem(hWnd, 2602);
        if ( v18 )
        {
          v19 = CResize::InitResizeBuffer(v9, v18, 1);
          *&v19->d1.left = 0i64;
          *&v19->d1.right = doubleOnePointZero;
        }
        v20 = GetDlgItem(hWnd, 1116);
        if ( v20 )
        {
          v21 = CResize::InitResizeBuffer(v9, v20, 1);
          *&v21->d1.left = 0i64;
          *&v21->d1.right = doubleOnePointZero;
        }
        v22 = GetDlgItem(hWnd, 1161);
        v23 = GetDlgItem(hWnd, 1159);
        v24 = GetDlgItem(hWnd, 1157);
        sub_1270510(v9, v24, v23, v22);
        v25 = GetDlgItem(hWnd, 1162);
        v26 = GetDlgItem(hWnd, 1160);
        v27 = GetDlgItem(hWnd, 1651);
        sub_1270510(v9, v27, v26, v25);
        v28 = GetDlgItem(hWnd, 2602);
        v29 = GetDlgItem(hWnd, 2601);
        v30 = GetDlgItem(hWnd, 2501);
        sub_1270510(v9, v30, v29, v28);
        v31 = GetDlgItem(hWnd, 1157);
        *&CResize::InitResizeBuffer(v9, v31, 1)->d21.right = doubleFourPointZero;
        v32 = GetDlgItem(hWnd, 1159);
        *&CResize::InitResizeBuffer(v9, v32, 1)->d21.right = doubleFourPointZero;
        v33 = GetDlgItem(hWnd, 1161);
        *&CResize::InitResizeBuffer(v9, v33, 1)->d21.right = doubleFourPointZero;
        v34 = GetDlgItem(hWnd, 1210);
        if ( v34 )
          CResize::InitResizeBuffer(v9, v34, 1)->d1 = 0i64;
        if ( gdwAdapterRuntingTime <= 1 )
        {
          v35 = GetDlgItem(hWnd, 1648);
          ShowWindow(v35, 0);
        }
        ResizeTab(hWnd);
        SendMessageW(hWnd, 0x113u, 0, 0);
        return 1;
      case 273:
        if ( hdc == 1210 )
        {
          DialogBoxParamW(ghInstance2, L"SYSTEMINFOGPUNODES", hWnd, SystemInfoGPUnodesDlgProc, 0);
          return 0;
        }
        if ( hdc == 1648 && !(hdc >> 16) )
        {
          gbShowAllGpus = gbShowAllGpus == 0;
          SendMessageW(hWnd, 0x464u, 0, 0);
          return 0;
        }
        break;
      case 275:
        if ( !IsWindowVisible(hWnd) )
          return 0;
        v37 = GetDlgItem(hWnd, 1651);
        SendMessageW(v37, 0x400u, 0, 0);
        v38 = GetDlgItem(hWnd, 2501);
        SendMessageW(v38, 0x400u, 0, 0);
        v39 = GetDlgItem(hWnd, 1160);
        SendMessageW(v39, 0x400u, 0, 0);
        v40 = GetDlgItem(hWnd, 2601);
        SendMessageW(v40, 0x400u, 0, 0);
        v41 = GetDlgItem(hWnd, 1162);
        SendMessageW(v41, 0x400u, 0, 0);
        v42 = GetDlgItem(hWnd, 2602);
        SendMessageW(v42, 0x400u, 0, 0);
        if ( gdwAdapterRuntingTime > 1 )
        {
          for ( j = 0; j < gdwAdapterRuntingTime; ++j )
          {
            v44 = GetDlgItem(hWnd, j + 2502);
            SendMessageW(v44, 0x400u, 0, 0);
          }
        }
        GetPalletteInfo(gpGraphClassData[3], v56, 0);
        VLogEntry(&Dst, L"%u", *v56);
        v45 = GetNumberTextFormat(&Dst, 0x100u);
        SetDlgItemTextW(hWnd, 1104, v45);
        VLogEntry(&Dst, L"%u", *&gpGraphClassData[3]->dbTotalPageFile);
        v46 = GetNumberTextFormat(&Dst, 0x100u);
        SetDlgItemTextW(hWnd, 1105, v46);
        GetPalletteInfo(gpGraphClassData[4], v56, 0);
        VLogEntry(&Dst, L"%d", *v56);
        v47 = GetNumberTextFormat(&Dst, _MAX_EXT);
        SetDlgItemTextW(hWnd, 1660, v47);
        VLogEntry(&Dst, L"%d", *&gpGraphClassData[4]->dbTotalPageFile);
        v48 = GetNumberTextFormat(&Dst, _MAX_EXT);
        SetDlgItemTextW(hWnd, 1661, v48);
        return 0;
      default:
        return 0;
    }
    return 0;
  }
  return sub_1246710(hWnd, hdc);
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCB38: using guessed type double doubleFourPointZero;
// 12E4E28: using guessed type int gScreenWidth;
// 12E96D9: using guessed type char gbShowAllGpus;

//----- (01272010) --------------------------------------------------------
int __stdcall SysInfoIOPageWndProc(HWND hDlg, int a2, HDC hdc, int a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  LONG v11; // eax
  CResize *v12; // eax
  CResize *pResize; // esi
  HWND v14; // edi
  HWND v15; // esi
  HWND v16; // edi
  HWND v17; // esi
  HWND v18; // edi
  HWND v19; // esi
  CResize *v20; // esi
  HWND v21; // eax
  HWND v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  DWORD pdwSizeReturned; // [esp+10h] [ebp-15Ch]
  void *pResizeObj; // [esp+14h] [ebp-158h]
  SYSTEM_PERFORMANCE_INFORMATION SystemPerfInfo; // [esp+18h] [ebp-154h]
  int hWnd[3]; // [esp+150h] [ebp-1Ch]
  int v29; // [esp+168h] [ebp-4h]

  if ( a2 > 0x133 )
  {
    if ( a2 != 310 && a2 != 312 )
      return 0;
    return sub_1246710(hDlg, hdc);
  }
  if ( a2 == 307 )
    return sub_1246710(hDlg, hdc);
  if ( a2 == 36 )
  {
    *(a4 + 8) = 2 * gScreenWidth;
    return 0;
  }
  if ( a2 != WM_INITDIALOG )
  {
    if ( a2 == 275 )
    {
      NtQuerySystemInformation(2u, &SystemPerfInfo, 0x138u, &pdwSizeReturned);
      SetDlgItemULong(
        hDlg,
        IDC_SYSTEMINFOIOETW_STATIC_STATIC1,
        SystemPerfInfo.IoReadOperationCount - gSystemPerfInforInited.IoReadOperationCount,
        0);
      SetDlgItemULong64(
        hDlg,
        IDC_SYSTEMINFOIOETW_STATIC_STATIC16,
        SystemPerfInfo.IoReadTransferCount.QuadPart - gSystemPerfInforInited.IoReadTransferCount.QuadPart);
      SetDlgItemULong(
        hDlg,
        1177,
        SystemPerfInfo.IoWriteOperationCount - gSystemPerfInforInited.IoWriteOperationCount,
        0);
      SetDlgItemULong64(
        hDlg,
        1192,
        SystemPerfInfo.IoWriteTransferCount.QuadPart - gSystemPerfInforInited.IoWriteTransferCount.QuadPart);
      SetDlgItemULong(
        hDlg,
        1178,
        SystemPerfInfo.IoOtherOperationCount - gSystemPerfInforInited.IoOtherOperationCount,
        0);
      SetDlgItemULong64(
        hDlg,
        1194,
        SystemPerfInfo.IoOtherTransferCount.QuadPart - gSystemPerfInforInited.IoOtherTransferCount.QuadPart);
      qmemcpy(&gSystemPerfInforInited, &SystemPerfInfo, sizeof(gSystemPerfInforInited));
      SetDlgItemULong(hDlg, 1180, gDataInfo2.field_10, 0);
      SetDlgItemULong64(hDlg, 1196, *&gDataInfo2.field_38);
      SetDlgItemULong(hDlg, 1181, gDataInfo2.field_C, 0);
      SetDlgItemULong64(hDlg, 1198, *&gDataInfo2.field_30);
      SetDlgItemULong(hDlg, 1182, gDataInfo2.field_14, 0);
      SetDlgItemULong64(hDlg, 1200, *&gDataInfo2.field_40);
      SetDlgItemULong(hDlg, 1186, gDataInfo3.field_10, 0);
      SetDlgItemULong64(hDlg, 1202, *&gDataInfo3.field_38);
      SetDlgItemULong(hDlg, 1187, gDataInfo3.field_C, 0);
      SetDlgItemULong64(hDlg, 1204, *&gDataInfo3.field_30);
      SetDlgItemULong(hDlg, 1188, gDataInfo3.field_14, 0);
      SetDlgItemULong64(hDlg, 1206, *&gDataInfo3.field_40);
      if ( gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
      {
        v4 = GetDlgItem(hDlg, IDC_SYSTEMINFOIO_STATIC_STATIC1);
        SendMessageW(v4, 0x400u, 0, 0);
        v5 = GetDlgItem(hDlg, 1330);
        SendMessageW(v5, 0x400u, 0, 0);
      }
      if ( gptrNetGraphData.GraphData )
      {
        v6 = GetDlgItem(hDlg, 1351);
        SendMessageW(v6, 0x400u, 0, 0);
        v7 = GetDlgItem(hDlg, 1335);
        SendMessageW(v7, 0x400u, 0, 0);
      }
      if ( gptrDiskGraphData.GraphData )
      {
        v8 = GetDlgItem(hDlg, 1337);
        SendMessageW(v8, 0x400u, 0, 0);
        v9 = GetDlgItem(hDlg, 1338);
        SendMessageW(v9, 0x400u, 0, 0);
        return 0;
      }
    }
    return 0;
  }
  v11 = GetWindowLongW(hDlg, GWL_STYLE);
  SetWindowLongW(hDlg, GWL_STYLE, v11 | WS_CLIPCHILDREN);
  v12 = operator new(0x40u);
  pResizeObj = v12;
  v29 = 0;
  if ( v12 )
  {
    pResize = CResize::CResize(v12, hDlg);
    pResizeObj = pResize;
  }
  else
  {
    pResize = 0;
    pResizeObj = 0;
  }
  v29 = -1;
  if ( gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
  {
    CreateGraphWindowInDlg(hDlg, IDC_SYSTEMINFOIO_STATIC_STATIC1, gptrIOGraphData__3UCSimpleGraphData__A.GraphData);
    CreateGraphWindowInDlg(hDlg, IDC_SYSTEMINFOIO_STATIC_STATIC2, gptrIOGraphData__3UCSimpleGraphData__A.GraphData);
  }
  if ( IsBuiltinAndAnministrative() )
  {
    if ( gptrNetGraphData.GraphData )
    {
      CreateGraphWindowInDlg(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC6, gptrNetGraphData.GraphData);
      CreateGraphWindowInDlg(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC7, gptrNetGraphData.GraphData);
    }
    if ( gptrDiskGraphData.GraphData )
    {
      CreateGraphWindowInDlg(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC8, gptrDiskGraphData.GraphData);
      CreateGraphWindowInDlg(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC9, gptrDiskGraphData.GraphData);
    }
    pResize->m_WidthScale = 93;
    pResize->m_HeightScale = 20;
    v14 = GetDlgItem(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC9);
    v15 = GetDlgItem(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC7);
    hWnd[0] = GetDlgItem(hDlg, IDC_SYSTEMINFOIOETW_STATIC_STATIC5);
    hWnd[1] = v15;
    hWnd[2] = v14;
    CResize::Update(pResizeObj, 3, hWnd);
    v16 = GetDlgItem(hDlg, 1336);
    v17 = GetDlgItem(hDlg, 1352);
    hWnd[0] = GetDlgItem(hDlg, 1331);
    hWnd[1] = v17;
    hWnd[2] = v16;
    CResize::Update(pResizeObj, 3, hWnd);
    v18 = GetDlgItem(hDlg, 1337);
    v19 = GetDlgItem(hDlg, 1351);
    hWnd[0] = GetDlgItem(hDlg, 1332);
    hWnd[1] = v19;
    v20 = pResizeObj;
    hWnd[2] = v18;
    CResize::Update(pResizeObj, 3, hWnd);
    v21 = GetDlgItem(hDlg, 1183);
    if ( v21 )
      CResize::InitResizeBuffer(pResizeObj, v21, 1)->d1 = 0i64;
    v22 = GetDlgItem(hDlg, 1331);
    *&CResize::InitResizeBuffer(v20, v22, 1)->d21.right = doubleFourPointZero;
    v23 = GetDlgItem(hDlg, 1352);
    *&CResize::InitResizeBuffer(v20, v23, 1)->d21.right = doubleFourPointZero;
    v24 = GetDlgItem(hDlg, 1336);
    *&CResize::InitResizeBuffer(v20, v24, 1)->d21.right = doubleFourPointZero;
  }
  else
  {
    pResize->m_WidthScale = 93;
    pResize->m_HeightScale = 20;
  }
  ResizeTab(hDlg);
  NtQuerySystemInformation(ProcessIoCounters, &gSystemPerfInforInited, 0x138u, &pdwSizeReturned);
  SendMessageW(hDlg, WM_TIMER, 0, 0);
  return 1;
}
// 12BCB38: using guessed type double doubleFourPointZero;
// 12E4E28: using guessed type int gScreenWidth;

//----- (012725E0) --------------------------------------------------------
int __stdcall SysInfoMemoryPageWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  LONG v4; // eax
  signed int v5; // eax
  int ArgList_4; // ST34_4
  HWND v7; // eax
  signed int v8; // eax
  int v9; // ST34_4
  HWND v10; // eax
  CResize *v11; // eax
  CResize *v12; // esi
  HWND v13; // eax
  ResizeInfo *v14; // eax
  HWND v15; // eax
  ResizeInfo *v16; // eax
  HWND v17; // esi
  HWND v18; // esi
  HWND v19; // esi
  CResize *v20; // esi
  HWND v21; // eax
  HWND v22; // eax
  const WCHAR *v24; // eax
  void (__stdcall *SetDlgItemTextW)(HWND, int, LPCWSTR); // esi
  const WCHAR *v26; // eax
  const WCHAR *v27; // eax
  const WCHAR *v28; // eax
  DWORD v29; // eax
  const WCHAR *v30; // eax
  const WCHAR *v31; // eax
  const WCHAR *v32; // eax
  const WCHAR *v33; // eax
  const WCHAR *v34; // eax
  const WCHAR *v35; // eax
  const WCHAR *v36; // eax
  const WCHAR *v37; // eax
  unsigned int idx; // esi
  const WCHAR *v39; // eax
  char *v40; // ecx
  const WCHAR *v41; // eax
  const WCHAR *v42; // ST34_4
  const WCHAR *v43; // ST34_4
  const WCHAR *v44; // eax
  const WCHAR *v45; // eax
  HWND v46; // eax
  HWND v47; // eax
  HWND v48; // eax
  HWND v49; // eax
  double ArgList; // [esp+30h] [ebp-450h]
  double ArgLista; // [esp+30h] [ebp-450h]
  DWORD pdwSizeReturned; // [esp+44h] [ebp-43Ch]
  HWND pHwnds; // [esp+48h] [ebp-438h]
  void *v54; // [esp+4Ch] [ebp-434h]
  HWND hDlg; // [esp+50h] [ebp-430h]
  struct _MEMORYSTATUSEX MemoryStatus; // [esp+54h] [ebp-42Ch]
  SYSTEM_PERFORMANCE_INFORMATION SystemPerfInfo; // [esp+94h] [ebp-3ECh]
  struct _MEMORYSTATUS MemoryStatus2; // [esp+1CCh] [ebp-2B4h]
  int v59; // [esp+1ECh] [ebp-294h]
  int v60; // [esp+1F0h] [ebp-290h]
  int v61; // [esp+1F4h] [ebp-28Ch]
  int v62; // [esp+1F8h] [ebp-288h]
  int v63[16]; // [esp+200h] [ebp-280h]
  int v64; // [esp+240h] [ebp-240h]
  _DWORD pBuffer[4]; // [esp+244h] [ebp-23Ch]
  __int128 v66; // [esp+254h] [ebp-22Ch]
  int v67; // [esp+264h] [ebp-21Ch]
  __int16 szText[260]; // [esp+268h] [ebp-218h]
  int v69; // [esp+47Ch] [ebp-4h]

  hDlg = hWnd;
  if ( message > WM_TIMER )
  {
    if ( message == WM_CTLCOLOREDIT || message == WM_CTLCOLORDLG || message == WM_CTLCOLORSTATIC )
      return sub_1246710(hWnd, wParam);
    return 0;
  }
  if ( message != WM_TIMER )
  {
    switch ( message )
    {
      case WM_GETMINMAXINFO:
        *(lParam + 8) = 2 * gScreenWidth;
        return 0;
      case WM_KEYDOWN:
        if ( wParam == 116 )
        {
          PostMessageW(hWnd, WM_TIMER, 1u, 0);
          return 0;
        }
        break;
      case WM_INITDIALOG:
        v4 = GetWindowLongW(hWnd, GWL_STYLE);
        SetWindowLongW(hWnd, GWL_STYLE, v4 | WS_CLIPCHILDREN);
        CreateGraphWindowInDlg(hWnd, IDD_PAGE_MEMORY_SYSTEM_CHART, gpGraphClassData[0]);
        CreateGraphWindowInDlg(hWnd, IDD_PAGE_MEMORY_SYSTEM_GRAPH, gpGraphClassData[0]);
        CreateGraphWindowInDlg(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_GRAPH, gpGraphClassData[5]);
        CreateGraphWindowInDlg(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_CHART, gpGraphClassData[5]);
        v5 = 0;
        if ( gdwOsType >= 3 )
          v5 = 5;
        ArgList_4 = v5;
        v7 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_PAGEFILEMODIFIED_NAME);
        ShowWindow(v7, ArgList_4);
        v8 = 0;
        if ( gdwOsType >= 3 )
          v8 = 5;
        v9 = v8;
        v10 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_PAGEFILEMODIFIED_VALUE);
        ShowWindow(v10, v9);
        v11 = operator new(0x40u);
        v54 = v11;
        v69 = 0;
        if ( v11 )
        {
          v12 = CResize::CResize(v11, hWnd);
          hDlg = v12;
        }
        else
        {
          v12 = 0;
          hDlg = 0;
        }
        v69 = -1;
        v12->m_WidthScale = 100;
        v12->m_HeightScale = 20;
        v13 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_SYSTEM_GRAPH);
        if ( v13 )
        {
          v14 = CResize::InitResizeBuffer(v12, v13, 1);
          *&v14->d1.left = 0i64;
          *&v14->d1.right = doubleOnePointZero;
        }
        v15 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_GRAPH);
        if ( v15 )
        {
          v16 = CResize::InitResizeBuffer(v12, v15, 1);
          *&v16->d1.left = 0i64;
          *&v16->d1.right = doubleOnePointZero;
        }
        v17 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_GRAPH);
        pHwnds = GetDlgItem(hWnd, IDD_PAGE_MEMORY_SYSTEM_GRAPH);
        v54 = v17;
        CResize::Update(hDlg, 2, &pHwnds);
        v18 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY);
        pHwnds = GetDlgItem(hWnd, IDD_PAGE_MEMORY_SYSTEM);
        v54 = v18;
        CResize::Update(hDlg, 2, &pHwnds);
        v19 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_CHART);
        pHwnds = GetDlgItem(hWnd, IDD_PAGE_MEMORY_SYSTEM_CHART);
        v54 = v19;
        v20 = hDlg;
        CResize::Update(hDlg, 2, &pHwnds);
        v21 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_SYSTEM);
        *&CResize::InitResizeBuffer(v20, v21, 1)->d21.right = doubleFourPointZero;
        v22 = GetDlgItem(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY);
        *&CResize::InitResizeBuffer(v20, v22, 1)->d21.right = doubleFourPointZero;
        ResizeTab(hWnd);
        NtQuerySystemInformation(2u, &gSystemPerfInforInitedFromMemoryPage, 0x138u, &pdwSizeReturned);
        SendMessageW(hWnd, WM_TIMER, 0, 0);
        return 1;
    }
    return 0;
  }
  // WM_TIMER处理
  sub_125CE20(&stru_1305378, &stru_1305380);
  NtQuerySystemInformation(2u, &SystemPerfInfo, 0x138u, &pdwSizeReturned);
  v67 = 0;
  _mm_storeu_si128(pBuffer, 0i64);
  _mm_storeu_si128(&v66, 0i64);
  NtQuerySystemInformation(0x15u, pBuffer, 0x24u, &pdwSizeReturned);
  memset(&v59, 0, 0x58u);
  NtQuerySystemInformation(0x50u, &v59, 0x58u, &pdwSizeReturned);
  stprintf(szText, L"%d", SystemPerfInfo.CommitLimit * (gSystemInfo.dwPageSize >> 10));
  v24 = GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW = ::SetDlgItemTextW;
  ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_COMMIT_LIMIT_VALUE, v24);
  ArgList = SystemPerfInfo.CommittedPages * 100.0 / SystemPerfInfo.CommitLimit;
  if ( gbShowCpuFractions )
    stprintf(szText, L"%02.2f%%", ArgList);
  else
    stprintf(szText, L"%0.0f%%", ArgList);
  ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_COMMIT_CURRENT_LIMIT_RATIO_VALUE, szText);
  stprintf(szText, L"%u", SystemPerfInfo.CommittedPages * (gSystemInfo.dwPageSize >> 10));
  v26 = GetNumberTextFormat(szText, 0x104u);
  ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_COMMIT_CURRENT_VALUE, v26);
  stprintf(szText, L"%u", SystemPerfInfo.PeakCommitment * (gSystemInfo.dwPageSize >> 10));
  v27 = GetNumberTextFormat(szText, 0x104u);
  ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_COMMIT_PEAK_VALUE, v27);
  ArgLista = SystemPerfInfo.PeakCommitment * 100.0 / SystemPerfInfo.CommitLimit;
  if ( gbShowCpuFractions )
    stprintf(szText, L"%02.2f%%", ArgLista);
  else
    stprintf(szText, L"%0.0f%%", ArgLista);
  ::SetDlgItemTextW(hWnd, 1111, szText);
  stprintf(szText, L"%u", SystemPerfInfo.AvailablePages * (gSystemInfo.dwPageSize >> 10));
  v28 = GetNumberTextFormat(szText, 0x104u);
  ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_AVAILABLE_VALUE, v28);
  v29 = gSystemInfo.dwPageSize >> 10;
  if ( DWORD1(v66) )
    v54 = (DWORD1(v66) * v29);
  else
    v54 = (v29
         * (SystemPerfInfo.ResidentPagedPoolPage
          + SystemPerfInfo.ResidentSystemCachePage
          + SystemPerfInfo.ResidentSystemDriverPage
          + SystemPerfInfo.ResidentSystemCodePage));
  if ( *GlobalMemoryStatusEx )
  {
    MemoryStatus.dwLength = 64;
    GlobalMemoryStatusEx(&MemoryStatus);
    stprintf(szText, L"%I64d", MemoryStatus.ullTotalPhys >> 10);
  }
  else
  {
    MemoryStatus2.dwLength = 32;
    GlobalMemoryStatus(&MemoryStatus2);
    stprintf(szText, L"%d", MemoryStatus2.dwTotalPhys >> 10);
  }
  v30 = GetNumberTextFormat(szText, 0x104u);
  ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_TOTAL_VALUE, v30);
  if ( gdwOsType < 1 )
  {
    stprintf(szText, L"%d", v54);
    v43 = GetNumberTextFormat(szText, 0x104u);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_CACHE_WS_VALUE, v43);
  }
  else
  {
    stprintf(szText, L"%u", SystemPerfInfo.ResidentSystemDriverPage * (gSystemInfo.dwPageSize >> 10));
    v31 = GetNumberTextFormat(szText, 0x104u);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_DRIVER_WS_VALUE, v31);
    stprintf(szText, L"%u", SystemPerfInfo.ResidentSystemCodePage * (gSystemInfo.dwPageSize >> 10));
    v32 = GetNumberTextFormat(szText, 0x104u);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_KERNEL_WS_VALUE, v32);
    stprintf(szText, L"%u", SystemPerfInfo.ResidentSystemCachePage * (gSystemInfo.dwPageSize >> 10));
    v33 = GetNumberTextFormat(szText, 0x104u);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_CACHE_WS_VALUE, v33);
    stprintf(szText, L"%u", v59 * (gSystemInfo.dwPageSize >> 10));
    v34 = GetNumberTextFormat(szText, 0x104u);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_ZEROED_VALUE, v34);
    stprintf(szText, L"%u", v60 * (gSystemInfo.dwPageSize >> 10));
    v35 = GetNumberTextFormat(szText, _MAX_PATH);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_FREE_VALUE, v35);
    stprintf(szText, L"%u", v61 * (gSystemInfo.dwPageSize >> 10));
    v36 = GetNumberTextFormat(szText, _MAX_PATH);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_MODIFIED_VALUE, v36);
    stprintf(szText, L"%u", v62 * (gSystemInfo.dwPageSize >> 10));
    v37 = GetNumberTextFormat(szText, _MAX_PATH);
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_MODIFIEDNOWRITE_VALUE, v37);
    v54 = 0;
    idx = 0;
    do
    {
      stprintf(szText, L"%u", v63[idx] * (gSystemInfo.dwPageSize >> 10));
      v39 = GetNumberTextFormat(szText, _MAX_PATH);
      ::SetDlgItemTextW(hWnd, idx + IDD_PAGE_MEMORY_PAGING_LISTS_STANDBY_PRORITY_0_VALUE, v39);
      v40 = v54 + v63[idx++];
      v54 = v40;
    }
    while ( idx < 8 );
    stprintf(szText, L"%u", v40 * (gSystemInfo.dwPageSize >> 10));
    v41 = GetNumberTextFormat(szText, _MAX_PATH);
    SetDlgItemTextW = ::SetDlgItemTextW;
    ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_STANDBY_VALUE, v41);
    if ( gdwOsType >= 3 )
    {
      stprintf(szText, L"%u", v64 * (gSystemInfo.dwPageSize >> 10));
      v42 = GetNumberTextFormat(szText, _MAX_PATH);
      ::SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_LISTS_PAGEFILEMODIFIED_VALUE, v42);
    }
  }
  if ( stru_1305378.QuadPart )
  {
    stprintf(szText, L"%I64u", stru_1305378.QuadPart >> 10);
    GetNumberTextFormat(szText, _MAX_PATH);
    SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_KERNEL_MEMORY_NONPAGED_LIMIT_VALUE, szText);
  }
  stprintf(szText, L"%u", SystemPerfInfo.NonPagedPoolPages * (gSystemInfo.dwPageSize >> 10));
  GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_KERNEL_MEMORY_NONPAGED_VALUE, szText);
  stprintf(szText, L"%u", SystemPerfInfo.ResidentPagedPoolPage * (gSystemInfo.dwPageSize >> 10));
  v44 = GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_KERNEL_MEMORY_PAGED_WS_VALUE, v44);
  stprintf(szText, L"%u", SystemPerfInfo.PagedPoolPages * (gSystemInfo.dwPageSize >> 10));
  v45 = GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_KERNEL_MEMORY_PAGED_VIRTUAL_VALUE, v45);
  if ( stru_1305380.QuadPart )
  {
    stprintf(szText, L"%I64u", stru_1305380.QuadPart >> 10);
    GetNumberTextFormat(szText, 0x104u);
    SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_KERNEL_MEMORY_PAGED_LIMIT_VALUE, szText);
  }
  stprintf(szText, L"%u", SystemPerfInfo.PageFaultCount - gSystemPerfInforInitedFromMemoryPage.PageFaultCount);
  GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_PAGE_FAULT_DELTA_VALUE, szText);
  stprintf(szText, L"%u", SystemPerfInfo.PageReadIoCount - gSystemPerfInforInitedFromMemoryPage.PageReadIoCount);
  GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_PAGE_READ_DELTA_VALUE, szText);
  stprintf(
    szText,
    L"%u",
    SystemPerfInfo.DirtyPagesWriteCount - gSystemPerfInforInitedFromMemoryPage.DirtyPagesWriteCount);
  GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_PAING_FILE_WRITE_DELTA_VALUE, szText);
  stprintf(
    szText,
    L"%u",
    SystemPerfInfo.MappedPagesWriteCount - gSystemPerfInforInitedFromMemoryPage.MappedPagesWriteCount);
  GetNumberTextFormat(szText, 0x104u);
  SetDlgItemTextW(hWnd, IDD_PAGE_MEMORY_PAGING_MAPPED_FILE_WRITE_DELTA_VALUE, szText);
  qmemcpy(&gSystemPerfInforInitedFromMemoryPage, &SystemPerfInfo, sizeof(gSystemPerfInforInitedFromMemoryPage));
  v46 = GetDlgItem(hDlg, IDD_PAGE_MEMORY_SYSTEM_CHART);
  SendMessageW(v46, 0x400u, 0, 0);
  v47 = GetDlgItem(hDlg, IDD_PAGE_MEMORY_SYSTEM_GRAPH);
  SendMessageW(v47, 0x400u, 0, 0);
  v48 = GetDlgItem(hDlg, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_CHART);
  SendMessageW(v48, 0x400u, 0, 0);
  v49 = GetDlgItem(hDlg, IDD_PAGE_MEMORY_PHYSICAL_MEMORY_GRAPH);
  SendMessageW(v49, 0x400u, 0, 0);
  return 0;
}
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCB38: using guessed type double doubleFourPointZero;
// 12BCDC0: using guessed type double gdbMaxValue;
// 12C67B8: using guessed type wchar_t a022f_0[9];
// 12E4E28: using guessed type int gScreenWidth;
// 12E4E54: using guessed type int gdwOsType;
// 12E96C9: using guessed type char gbShowCpuFractions;
// 1305240: using guessed type SYSTEM_PERFORMANCE_INFORMATION gSystemPerfInforInitedFromMemoryPage;
// 1305378: using guessed type LARGE_INTEGER stru_1305378;
// 1305380: using guessed type LARGE_INTEGER stru_1305380;
// 12725E0: using guessed type int var_280[16];

//----- (01273260) --------------------------------------------------------
int __stdcall SysInfoSummaryPageWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // eax
  HWND v19; // eax
  LONG dwStyle; // eax
  CResize *v22; // eax
  CResize *pResize_1; // ebx
  HWND hGraphCtrl; // eax
  ResizeInfo *v25; // eax
  HWND v26; // eax
  ResizeInfo *v27; // eax
  HWND v28; // eax
  ResizeInfo *v29; // eax
  HWND v30; // eax
  ResizeInfo *v31; // eax
  HWND v32; // ST5C_4
  HWND v33; // ST58_4
  HWND v34; // ebx
  HWND v35; // edi
  HWND v36; // esi
  HWND v37; // ST58_4
  HWND v38; // ST5C_4
  HWND v39; // ebx
  HWND v40; // edi
  HWND v41; // esi
  HWND v42; // ST58_4
  HWND v43; // ST5C_4
  HWND v44; // ebx
  HWND v45; // edi
  HWND v46; // esi
  CResize *v47; // edi
  HWND v48; // ebx
  HWND (__stdcall *GetDlgItem)(HWND, int); // esi
  HWND v50; // eax
  HWND v51; // eax
  HWND v52; // ebx
  HWND v53; // edi
  HWND v54; // esi
  HWND v55; // ebx
  HWND v56; // edi
  HWND v57; // esi
  HWND v58; // ebx
  HWND v59; // edi
  HWND v60; // esi
  HWND v61; // eax
  HWND v62; // eax
  HWND v63; // eax
  HWND v64; // eax
  CResize *pResize; // [esp+18h] [ebp-30h]
  HWND pHwnds; // [esp+20h] [ebp-28h]
  HWND v67; // [esp+24h] [ebp-24h]
  HWND v68; // [esp+28h] [ebp-20h]
  HWND v69; // [esp+2Ch] [ebp-1Ch]
  HWND v70; // [esp+30h] [ebp-18h]
  HWND v71; // [esp+34h] [ebp-14h]
  int v72; // [esp+44h] [ebp-4h]

  if ( message > WM_CTLCOLOREDIT )
  {
    if ( message != WM_CTLCOLORDLG && message != WM_CTLCOLORSTATIC )
      return 0;
    return sub_1246710(hWnd, wParam);
  }
  if ( message == WM_CTLCOLOREDIT )
    return sub_1246710(hWnd, wParam);
  if ( message == WM_GETMINMAXINFO )
  {
    *(lParam + 8) = 2 * gScreenWidth;
    return 0;
  }
  if ( message != WM_INITDIALOG )
  {
    if ( message == WM_TIMER )
    {
      v4 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_CPU_USAGE_CHART);
      SendMessageW(v4, 0x400u, 0, 0);
      v5 = ::GetDlgItem(hWnd, IDC_CPU_PAGE_CPU_GRAPH);
      SendMessageW(v5, 0x400u, 0, 0);
      v6 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_CHART);
      SendMessageW(v6, 0x400u, 0, 0);
      v7 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_GRAPH);
      SendMessageW(v7, 0x400u, 0, 0);
      v8 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_CHART);
      SendMessageW(v8, 0x400u, 0, 0);
      v9 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_GRAPH);
      SendMessageW(v9, 0x400u, 0, 0);
      v10 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_CHART);
      SendMessageW(v10, 0x400u, 0, 0);
      v11 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_GRAPH);
      SendMessageW(v11, 0x400u, 0, 0);
      v12 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_CHART);
      SendMessageW(v12, 0x400u, 0, 0);
      v13 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_GRAPH);
      SendMessageW(v13, WM_USER, 0, 0);
      if ( gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
      {
        v14 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO_CHART);
        SendMessageW(v14, 0x400u, 0, 0);
        v15 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO_GRAPH);
        SendMessageW(v15, 0x400u, 0, 0);
      }
      if ( gptrNetGraphData.GraphData )
      {
        v16 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_NETWORK_CHART);
        SendMessageW(v16, 0x400u, 0, 0);
        v17 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_NETWORK_GRAPH);
        SendMessageW(v17, 0x400u, 0, 0);
      }
      if ( gptrDiskGraphData.GraphData )
      {
        v18 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_DISK_CHART);
        SendMessageW(v18, 0x400u, 0, 0);
        v19 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_DISK_GRAPH);
        SendMessageW(v19, 0x400u, 0, 0);
        return 0;
      }
    }
    return 0;
  }
  dwStyle = GetWindowLongW(hWnd, GWL_STYLE);
  SetWindowLongW(hWnd, GWL_STYLE, dwStyle | WS_CLIPCHILDREN);
  v22 = operator new(0x40u);
  v72 = 0;
  if ( v22 )
  {
    pResize_1 = CResize::CResize(v22, hWnd);
    pResize = pResize_1;
  }
  else
  {
    pResize_1 = 0;
    pResize = 0;
  }
  v72 = -1;
  CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_CPU_USAGE_CHART, gpGraphClassData[1]);
  CreateGraphWindowInDlg(hWnd, IDC_CPU_PAGE_CPU_GRAPH, gpGraphClassData[1]);
  CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_CHART, gpGraphClassData[0]);
  CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_GRAPH, gpGraphClassData[0]);
  CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_GRAPH, gpGraphClassData[5]);
  CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_CHART, gpGraphClassData[5]);
  hGraphCtrl = ::GetDlgItem(hWnd, IDC_CPU_PAGE_CPU_GRAPH);
  if ( hGraphCtrl )
  {
    v25 = CResize::InitResizeBuffer(pResize_1, hGraphCtrl, 1);
    *&v25->d1.left = 0i64;
    *&v25->d1.right = doubleOnePointZero;
  }
  v26 = ::GetDlgItem(hWnd, IDC_CPU_PAGE_CPU_NAME);
  if ( v26 )
  {
    v27 = CResize::InitResizeBuffer(pResize_1, v26, 1);
    *&v27->d1.left = 0i64;
    *&v27->d1.right = doubleOnePointZero;
  }
  v28 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_GRAPH);
  if ( v28 )
  {
    v29 = CResize::InitResizeBuffer(pResize_1, v28, 1);
    *&v29->d1.left = 0i64;
    *&v29->d1.right = doubleOnePointZero;
  }
  v30 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_GRAPH);
  if ( v30 )
  {
    v31 = CResize::InitResizeBuffer(pResize_1, v30, 1);
    *&v31->d1.left = 0i64;
    *&v31->d1.right = doubleOnePointZero;
  }
  if ( gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
  {
    CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_IO_CHART, gptrIOGraphData__3UCSimpleGraphData__A.GraphData);
    CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_IO_GRAPH, gptrIOGraphData__3UCSimpleGraphData__A.GraphData);
  }
  if ( IsBuiltinAndAnministrative() )
  {
    if ( gptrNetGraphData.GraphData )
    {
      CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_NETWORK_CHART, gptrNetGraphData.GraphData);
      CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_NETWORK_GRAPH, gptrNetGraphData.GraphData);
    }
    if ( gptrDiskGraphData.GraphData )
    {
      CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_DISK_CHART, gptrDiskGraphData.GraphData);
      CreateGraphWindowInDlg(hWnd, IDC_PAGE_SUMETW_DISK_GRAPH, gptrDiskGraphData.GraphData);
    }
    pResize_1->m_WidthScale = 93;
    pResize_1->m_HeightScale = 10;
    v32 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_DISK_GRAPH);
    v33 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_NETWORK_GRAPH);
    v34 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO_GRAPH);
    v35 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_GRAPH);
    v36 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_GRAPH);
    pHwnds = ::GetDlgItem(hWnd, IDC_CPU_PAGE_CPU_GRAPH);
    v70 = v33;
    v71 = v32;
    v67 = v36;
    v68 = v35;
    v69 = v34;
    CResize::Update(pResize, 6, &pHwnds);
    v37 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_DISK);
    v38 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_NETWORK);
    v39 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO);
    v40 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY);
    v41 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT);
    pHwnds = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_CPU_USAGE);
    v70 = v38;
    v71 = v37;
    v67 = v41;
    v68 = v40;
    v69 = v39;
    CResize::Update(pResize, 6, &pHwnds);
    v42 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_DISK_CHART);
    v43 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_NETWORK_CHART);
    v44 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO_CHART);
    v45 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_CHART);
    v46 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_CHART);
    pHwnds = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_CPU_USAGE_CHART);
    v70 = v43;
    v71 = v42;
    v68 = v45;
    v47 = pResize;
    v67 = v46;
    v69 = v44;
    CResize::Update(pResize, 6, &pHwnds);
    v48 = hWnd;
    GetDlgItem = ::GetDlgItem;
    v50 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_NETWORK);
    *&CResize::InitResizeBuffer(pResize, v50, 1)->d21.right = doubleFourPointZero;
    v51 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_DISK);
    *&CResize::InitResizeBuffer(pResize, v51, 1)->d21.right = doubleFourPointZero;
  }
  else
  {
    pResize_1->m_WidthScale = 93;
    pResize_1->m_HeightScale = 10;
    v52 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO_GRAPH);
    v53 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_GRAPH);
    v54 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_GRAPH);
    v68 = ::GetDlgItem(hWnd, IDW_GRAPHCTRL);
    v69 = v54;
    v70 = v53;
    v71 = v52;
    CResize::Update(pResize, 4, &v68);
    v55 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO);
    v56 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY);
    v57 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT);
    v68 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_CPU_USAGE);
    v69 = v57;
    v70 = v56;
    v71 = v55;
    CResize::Update(pResize, 4, &v68);
    v58 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_IO_CHART);
    v59 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_PHYSICAL_MEMORY_CHART);
    v60 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_SYSTEM_COMMIT_CHART);
    v68 = ::GetDlgItem(hWnd, IDC_PAGE_SUMETW_CPU_USAGE_CHART);
    v70 = v59;
    v47 = pResize;
    v69 = v60;
    v71 = v58;
    CResize::Update(pResize, 4, &v68);
    v48 = hWnd;
    GetDlgItem = ::GetDlgItem;
  }
  v61 = GetDlgItem(v48, IDC_PAGE_SUMETW_CPU_USAGE);
  *&CResize::InitResizeBuffer(v47, v61, 1)->d21.right = doubleFourPointZero;
  v62 = GetDlgItem(v48, IDC_PAGE_SUMETW_SYSTEM_COMMIT);
  *&CResize::InitResizeBuffer(v47, v62, 1)->d21.right = doubleFourPointZero;
  v63 = GetDlgItem(v48, IDC_PAGE_SUMETW_PHYSICAL_MEMORY);
  *&CResize::InitResizeBuffer(v47, v63, 1)->d21.right = doubleFourPointZero;
  v64 = GetDlgItem(v48, IDC_PAGE_SUMETW_IO);
  *&CResize::InitResizeBuffer(v47, v64, 1)->d21.right = doubleFourPointZero;
  ResizeTab(v48);
  SendMessageW(v48, WM_TIMER, 0, 0);
  return 1;
}
// 128C6CC: using guessed type int (__stdcall *)(_DWORD, _DWORD);
// 12BCB30: using guessed type double doubleOnePointZero;
// 12BCB38: using guessed type double doubleFourPointZero;
// 12E4E28: using guessed type int gScreenWidth;

//----- (012739C0) --------------------------------------------------------
_DWORD *__cdecl sub_12739C0(_DWORD *a1, int a2)
{
  ULONG *v2; // esi
  _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *v3; // ebx
  _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *v4; // edi
  _DWORD *v5; // eax
  unsigned int v6; // edi
  int v8; // [esp+4h] [ebp-14h]
  int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  int v11; // [esp+10h] [ebp-8h]
  _DWORD *v12; // [esp+14h] [ebp-4h]

  v12 = 0;
  v11 = 0;
  if ( sub_125D9D0(a1) )
  {
    v2 = a1 + 4;
    v3 = (a1 + 2);
    do
    {
      if ( gbServiceNotImplemented )
      {
        v4 = v3;
      }
      else
      {
        v4 = &gTopSystemHandleInfo;
        gTopSystemHandleInfo.CreatorBackTraceIndex = *(v2 - 5);
        gTopSystemHandleInfo.GrantedAccess = *v2;
        LOBYTE(gTopSystemHandleInfo.HandleAttributes) = *(v2 - 7);
        gTopSystemHandleInfo.HandleValue = *(v2 - 3);
        gTopSystemHandleInfo.Object = *(v2 - 1);
        gTopSystemHandleInfo.ObjectTypeIndex = *(v2 - 8);
        gTopSystemHandleInfo.UniqueProcessId = *(v2 - 6);
      }
      if ( v4->UniqueProcessId == a2
        && !_wcsicmp(&word_12F05D8[64 * v4->ObjectTypeIndex], L"File")
        && sub_125C4F0(v4, &v8, &v10, &v9) )
      {
        v5 = malloc(0x890u);
        v5[11] = v10;
        v5[146] = v9;
        v5[10] = v8;
        v5[547] = v12;
        v12 = v5;
      }
      ++v3;
      v2 += 4;
      v6 = ++v11;
    }
    while ( v6 < sub_125D9D0(a1) );
  }
  sub_125C4F0(0, 0, 0, 0);
  return v12;
}
// 12EABA5: using guessed type char gbServiceNotImplemented;

//----- (01273AF0) --------------------------------------------------------
BOOL __stdcall ThreadStackDlgProc1(HWND hWnd, UINT uMsg, WPARAM wParam, NMLISTVIEW *lParam)
{
  HWND v4; // edi
  HICON v5; // eax
  CResize *pThreadStackInfo; // eax
  HWND hListCtrl3; // ebx
  CPropSheetDlg *v8; // ST14_4
  HWND hListCtrl2; // eax
  UINT code; // eax
  HWND v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  int v15; // esi
  HWND hList; // eax
  CPropSheetDlg *iItem; // eax
  HGLOBAL v18; // ebx
  wchar_t *v19; // edi
  unsigned int v20; // esi
  rsize_t v21; // esi
  LRESULT v22; // esi
  HWND hListCtrl; // edi
  LVITEMW item; // [esp+10h] [ebp-268h]
  struct tagPOINT Point; // [esp+44h] [ebp-234h]
  int a3; // [esp+4Ch] [ebp-22Ch]
  int v27; // [esp+50h] [ebp-228h]
  int v28; // [esp+54h] [ebp-224h]
  int a4; // [esp+58h] [ebp-220h]
  HWND hListCtrl1; // [esp+5Ch] [ebp-21Ch]
  CPropSheetDlg *pPropSheet; // [esp+60h] [ebp-218h]
  HGLOBAL hMem; // [esp+64h] [ebp-214h]
  wchar_t Src; // [esp+68h] [ebp-210h]
  int v34; // [esp+274h] [ebp-4h]

  v4 = hWnd;
  hMem = hWnd;
  pPropSheet = lParam;
  a3 = 43;
  v27 = 44;
  LOWORD(a4) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a4) = MulDiv(100, gLogPixelsX, 96);
  if ( uMsg > WM_COMMAND )
  {
    if ( uMsg == PMT_MSG_7F1 )
    {
      GetWindowRect(hWnd, &gRectThreadStack);
      gnTheadStackWindowWidth = gRectThreadStack.right - gRectThreadStack.left;
      gnTheadStackWindowHeight = gRectThreadStack.bottom - gRectThreadStack.top;
      DestroyWindow(hWnd);
    }
    return 0;
  }
  if ( uMsg == WM_COMMAND )
  {
    if ( wParam > IDC_THREADSTACK_COPY )
    {
      if ( wParam == 40631 )
      {
        v22 = 0;
        hListCtrl = GetDlgItem(hWnd, IDC_THREAD_STACK__LISTCTRL);
        if ( SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0) > 0 )
        {
          do
          {
            item.stateMask = 2;
            item.state = 2;
            SendMessageW(hListCtrl, LVM_SETITEMSTATE, v22++, &item);
          }
          while ( v22 < SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0) );
        }
      }
    }
    else if ( wParam == IDC_THREADSTACK_COPY )
    {
      v15 = 0;
      hList = GetDlgItem(hWnd, IDC_THREAD_STACK__LISTCTRL);
      hListCtrl1 = hList;
      iItem = SendMessageW(hList, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
      v18 = hMem;
      pPropSheet = iItem;
      if ( iItem != -1 )
      {
        v19 = 0;
        do
        {
          item.iSubItem = 1;
          item.pszText = &Src;
          item.cchTextMax = 256;
          SendMessageW(hListCtrl1, LVM_GETITEMTEXTW, iItem, &item);
          v20 = wcslen(&Src) + v15 + 2;
          v28 = v20;
          if ( v19 )
          {
            v18 = GlobalReAlloc(v18, 2 * v20 + 2, 0);
            v19 = GlobalLock(v18);
          }
          else
          {
            v18 = GlobalAlloc(0x2002u, 2 * v20 + 2);
            v19 = GlobalLock(v18);
            *v19 = 0;
          }
          v21 = v20 + 1;
          wcscat_s(v19, v21, &Src);
          wcscat_s(v19, v21, L"\r\n");
          GlobalUnlock(v18);
          iItem = SendMessageW(hListCtrl1, LVM_GETNEXTITEM, pPropSheet, 2);
          v15 = v28;
          pPropSheet = iItem;
        }
        while ( iItem != -1 );
        v4 = hMem;
      }
      if ( OpenClipboard(v4) )
      {
        EmptyClipboard();
        SetClipboardData(0xDu, v18);
        CloseClipboard();
      }
      SetFocus(hListCtrl1);
    }
    else if ( wParam - 1 <= 1 )
    {
      ghWndThreadStack = 0;
      EndDialog(hWnd, 0);
    }
    return 0;
  }
  if ( uMsg == WM_NOTIFY )
  {
    code = lParam->hdr.code;
    if ( code == LVN_ITEMCHANGED || code + 3 <= 1 )
    {
      v12 = GetDlgItem(hWnd, IDC_THREAD_STACK__LISTCTRL);
      if ( SendMessageW(v12, LVM_GETNEXTITEM, 0xFFFFFFFF, 2) == -1 )
      {
        v14 = GetDlgItem(hWnd, IDC_THREADSTACK_COPY);
        EnableWindow(v14, 0);
      }
      else
      {
        v13 = GetDlgItem(hWnd, IDC_THREADSTACK_COPY);
        EnableWindow(v13, 1);
      }
    }
    return 0;
  }
  if ( uMsg != WM_INITDIALOG )
    return 0;
  // WM_INITDIALOG消息处理
  v5 = LoadIconW(ghInstance, 0x65);
  SendMessageW(hWnd, WM_SETICON, 0, v5);
  pThreadStackInfo = operator new(0x40u);
  hMem = pThreadStackInfo;
  v34 = 0;
  if ( pThreadStackInfo )
    CResize::CResize(pThreadStackInfo, hWnd);
  v34 = -1;
  hListCtrl3 = GetDlgItem(hWnd, IDC_THREAD_STACK__LISTCTRL);
  CThreadStackPage::InitListCtrl(hListCtrl3, 2, &a3, &a4, 0);
  v8 = pPropSheet;
  hListCtrl2 = GetDlgItem(hWnd, IDC_THREAD_STACK__LISTCTRL);
  sub_125B490(hListCtrl2, v8);
  SendMessageW(hListCtrl3, LVM_SETCOLUMNWIDTH, 0, 0xFFFF);
  SendMessageW(hListCtrl3, LVM_SETCOLUMNWIDTH, 1u, 0xFFFF);
  item.stateMask = 3;
  item.state = 3;
  SendMessageW(hListCtrl3, LVM_SETITEMSTATE, 0, &item);
  SetFocus(hListCtrl3);
  if ( gnTheadStackWindowWidth )
  {
    MoveWindow(hWnd, gRectThreadStack.left, gRectThreadStack.top, gnTheadStackWindowWidth, gnTheadStackWindowHeight, 0);
  }
  else
  {
    GetCursorPos(&Point);
    SetPropSheetRect(hWnd, Point.x - 350, Point.y - 220);
  }
  ghWndThreadStack = hWnd;
  SetFocus(hListCtrl3);
  ShowWindow(hWnd, 1);
  return 1;
}

//----- (01273FC0) --------------------------------------------------------
BOOL __stdcall ThreadStackDlgProc(HWND hWnd, UINT uMsg, WPARAM a3, LPARAM dwNewLong)
{
  LONG v4; // edi
  HICON v5; // eax
  HWND v6; // esi
  CResize *v7; // eax
  HWND v8; // esi
  LONG v9; // eax
  HWND v10; // eax
  HWND v11; // esi
  HWND v12; // eax
  int v14; // eax
  HWND v15; // ebx
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // eax
  HWND v19; // ebx
  HWND v20; // eax
  HWND v21; // ebx
  MixedModeStackWalker *v22; // esi
  wchar_t *v23; // ebx
  HWND v24; // eax
  LRESULT v25; // eax
  void *v26; // edi
  unsigned int v27; // esi
  rsize_t v28; // esi
  LRESULT v29; // esi
  HWND v30; // edi
  MixedModeStackWalker *v31; // esi
  wchar_t *v32; // ebx
  HWND v33; // eax
  LRESULT v34; // eax
  unsigned int v35; // esi
  rsize_t v36; // esi
  HWND v37; // ebx
  HWND hParent; // eax
  HWND v39; // eax
  LPCONTEXT v40; // esi
  void *v41; // eax
  MixedModeStackWalker *pStackInfo; // ebx
  int v43; // edx
  bool v44; // cf
  _DWORD *v45; // esi
  int v46; // eax
  int v47; // ST20_4
  HWND v48; // edi
  LRESULT v49; // eax
  int i; // eax
  int v51; // eax
  int v52; // ebx
  signed int v53; // edi
  int *v54; // esi
  int v55; // eax
  LPCONTEXT v56; // ecx
  int v57; // eax
  CONTEXT *v58; // ebx
  signed int v59; // esi
  int v60; // eax
  HWND v61; // esi
  HWND v62; // eax
  HWND v63; // eax
  int v64; // ecx
  DWORD v65; // eax
  char *v66; // esi
  unsigned int *v67; // ST20_4
  int v68; // eax
  int v69; // eax
  int v70; // ST20_4
  int v71; // eax
  HWND v72; // esi
  LRESULT v73; // eax
  HWND v74; // esi
  HWND v75; // eax
  HWND v76; // esi
  HWND v77; // edi
  HWND v78; // eax
  int v79; // [esp+0h] [ebp-EC0h]
  char v80[52]; // [esp+10h] [ebp-EB0h]
  char v81[604]; // [esp+44h] [ebp-E7Ch]
  DWORD BytesReturned; // [esp+2A0h] [ebp-C20h]
  LPARAM lParam; // [esp+2A4h] [ebp-C1Ch]
  int v84; // [esp+2ACh] [ebp-C14h]
  int v85; // [esp+2B0h] [ebp-C10h]
  int v86; // [esp+2B4h] [ebp-C0Ch]
  WCHAR *v87; // [esp+2B8h] [ebp-C08h]
  int v88[7]; // [esp+2BCh] [ebp-C04h]
  int Indent; // [esp+2D8h] [ebp-BE8h]
  int v90; // [esp+2DCh] [ebp-BE4h]
  int v91; // [esp+2E0h] [ebp-BE0h]
  unsigned int v92; // [esp+2E4h] [ebp-BDCh]
  int v93; // [esp+2E8h] [ebp-BD8h]
  int v94; // [esp+2ECh] [ebp-BD4h]
  int a3a; // [esp+2F0h] [ebp-BD0h]
  LPARAM v96; // [esp+2F4h] [ebp-BCCh]
  WPARAM wParam; // [esp+2F8h] [ebp-BC8h]
  int v98; // [esp+2FCh] [ebp-BC4h]
  int v99; // [esp+300h] [ebp-BC0h]
  int v100; // [esp+304h] [ebp-BBCh]
  WCHAR *v101; // [esp+308h] [ebp-BB8h]
  int v102; // [esp+310h] [ebp-BB0h]
  char *v103; // [esp+314h] [ebp-BACh]
  int v104; // [esp+328h] [ebp-B98h]
  PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine; // [esp+32Ch] [ebp-B94h]
  char *v106; // [esp+330h] [ebp-B90h]
  char ArgList[4]; // [esp+334h] [ebp-B8Ch]
  void *v108; // [esp+338h] [ebp-B88h]
  char *v109; // [esp+33Ch] [ebp-B84h]
  int v110; // [esp+340h] [ebp-B80h]
  LONG v111; // [esp+344h] [ebp-B7Ch]
  MixedModeStackWalker *v112; // [esp+348h] [ebp-B78h]
  char *v113; // [esp+34Ch] [ebp-B74h]
  LPCONTEXT lpContext; // [esp+350h] [ebp-B70h]
  HWND hListCtrl; // [esp+354h] [ebp-B6Ch]
  MixedModeStackWalker *pStackInfo_1; // [esp+358h] [ebp-B68h]
  HWND hDlg; // [esp+35Ch] [ebp-B64h]
  struct _tagSTACKFRAME64 StackFrame; // [esp+360h] [ebp-B60h]
  char v119; // [esp+468h] [ebp-A58h]
  char v120; // [esp+49Ch] [ebp-A24h]
  struct tagRECT Rect; // [esp+6F8h] [ebp-7C8h]
  DWORD OutBuffer; // [esp+708h] [ebp-7B8h]
  DWORD v123; // [esp+70Ch] [ebp-7B4h]
  DWORD v124; // [esp+710h] [ebp-7B0h]
  char v125; // [esp+723h] [ebp-79Dh]
  WCHAR String; // [esp+CACh] [ebp-214h]
  int *v127; // [esp+EB0h] [ebp-10h]
  int v128; // [esp+EBCh] [ebp-4h]

  v127 = &v79;
  hDlg = hWnd;
  v4 = GetWindowLongW(hWnd, GWL_USERDATA);
  v106 = 0;
  v111 = v4;
  v113 = 0;
  lpContext = (&v125 & 0xFFFFFFF0);
  v96 = 0;
  memset(&wParam, 0, 0x30u);
  hListCtrl = GetDlgItem(hWnd, IDC_THREAD_STACK__LISTCTRL);
  Indent = 43;
  v90 = 44;
  LOWORD(a3a) = MulDiv(100, gLogPixelsX, 96);
  HIWORD(a3a) = MulDiv(100, gLogPixelsX, 96);
  ReadMemoryRoutine = 0;
  if ( uMsg > WM_COMMAND )
  {
    if ( uMsg == 0x7F1 )
    {
      DestroyWindow(hDlg);
      return 0;
    }
    if ( uMsg != 2042 )
      return 0;
    memset(v80, 0, 0x290u);
    if ( NtSuspendThread(*(v4 + 8), &v110) )
    {
      v37 = hDlg;
      EndDialog(hDlg, 0);
      MessageBoxW(v37, L"Error accessing thread.", L"Process Explorer", 0x10u);
      hParent = GetParent(v37);
      SetFocus(hParent);
      v39 = GetDlgItem(v37, IDC_THREAD_STACK_BUTTON_REFRESH);
      EnableWindow(v39, 0);
      return 0;
    }
    v40 = lpContext;
    GetThreadContext(*(v4 + 8), lpContext);
    EnterCriticalSection(&gStrListLock);
    *ArgList = 0;
    v112 = 0;
    v128 = 1;
    v41 = operator new(0x28u);
    v108 = v41;
    LOBYTE(v128) = 2;
    if ( v41 )
      pStackInfo = MixedModeStackWalker::MixedModeStackWalker(v41);
    else
      pStackInfo = 0;
    pStackInfo_1 = pStackInfo;
    LOBYTE(v128) = 1;
    v112 = pStackInfo;
    if ( sub_1248940(pStackInfo, v4) == 1 && sub_1248D10(pStackInfo, *(v4 + 4)) == 1 )
    {
      v91 = 0;
      v92 = 0;
      v93 = 0;
      v94 = 0;
      LOBYTE(v128) = 3;
      v109 = sub_124B0A0(pStackInfo, *(v4 + 4), &v91);
      if ( v109 == 1 )
      {
        v43 = 0;
        v113 = 0;
        if ( v92 > 0 )
        {
          v44 = v92 > 0;
          while ( 1 )
          {
            if ( !v44 )
              AtlThrow(-2147024809);
            v45 = *(v91 + 4 * v43);
            v108 = v45;
            if ( v45 )
              (*(*v45 + 4))(v45);
            LOBYTE(v128) = 4;
            v46 = wcscmp(sub_1247F60(v45), L"0x0");
            if ( v46 )
              v46 = -(v46 < 0) | 1;
            if ( v46 )
            {
              v47 = *ArgList;
              v96 = 5;
              wParam = 0x7FFFFFFF;
              v98 = 0;
              v100 = 0;
              v99 = 0;
              ++*ArgList;
              VLogEntry(&String, L"%d", v47);
              v48 = hListCtrl;
              v101 = &String;
              v102 = 0;
              v103 = v113 + 1;
              v49 = SendMessageW(hListCtrl, 0x104Du, 0, &v96);
              if ( v49 == -1 )
              {
                LOBYTE(v128) = 3;
                if ( v45 )
                  (*(*v45 + 8))(v45);
                sub_1259F20(&v91);
LABEL_77:
                v128 = -1;
                if ( pStackInfo )
                  (*(pStackInfo->field_0 + 8))(pStackInfo);
                return 0;
              }
              v96 = 1;
              wParam = v49;
              v98 = 1;
              v101 = sub_1247F60(v45);
              SendMessageW(v48, 0x104Cu, 0, &v96);
            }
            LOBYTE(v128) = 3;
            if ( v45 )
              (*(*v45 + 8))(v45);
            v43 = (v113 + 1);
            v113 = v43;
            v44 = v43 < v92;
            if ( v43 >= v92 )
            {
              v4 = v111;
              v40 = lpContext;
              break;
            }
          }
        }
      }
      LOBYTE(v128) = 1;
      sub_1259F20(&v91);
      if ( v109 )
      {
LABEL_104:
        NtResumeThread(*(v4 + 8), &v110);
        LeaveCriticalSection(&gStrListLock);
        if ( !&v113[v106] )
        {
          v74 = hDlg;
          EndDialog(hDlg, 0);
          MessageBoxW(
            0,
            L"Cannot access stack information. The stack may be swapped out, Process Explorer cannot access the support in"
             " the Windows Debugging Tools, or you previously ran an old version of Process Explorer and must reboot.",
            L"Process Explorer",
            0x10u);
          v75 = GetParent(v74);
          SetFocus(v75);
          goto LABEL_77;
        }
        v76 = hListCtrl;
        SendMessageW(hListCtrl, 0x101Eu, 0, 0xFFFF);
        SendMessageW(v76, 0x101Eu, 1u, 0xFFFF);
        v86 = 3;
        v85 = 3;
        SendMessageW(v76, 0x102Bu, 0, &lParam);
        SetFocus(v76);
        v77 = hDlg;
        if ( gWindowPlacement[5].rcNormalPosition.right == gWindowPlacement[5].rcNormalPosition.left )
          GetWindowRect(hDlg, &Rect);
        else
          _mm_storeu_si128(&Rect, _mm_loadu_si128(&gWindowPlacement[5].rcNormalPosition));
        v78 = GetDlgItem(v77, IDC_THREAD_STACK_BUTTON_REFRESH);
        EnableWindow(v78, 1);
        ghWndThreadStack = v77;
        SetFocus(hListCtrl);
        ShowWindow(v77, 1);
        v128 = -1;
        if ( pStackInfo )
          (*(pStackInfo->field_0 + 8))(pStackInfo);
        return 1;
      }
    }
    for ( i = 0; ; i = v104 + 1 )
    {
LABEL_67:
      v104 = i;
      if ( i >= 2 )
        goto LABEL_104;
      v106 = v113;
      v108 = v113;
      memset(v40, 0, 0x2CCu);
      v51 = v104;
      v40->ContextFlags = 65537;
      if ( v51 )
      {
        if ( v51 != 1 )
          goto LABEL_87;
        v58 = lpContext;
        v59 = 0;
        do
        {
          if ( GetThreadContext(*(v4 + 8), v58) )
            break;
          NtResumeThread(*(v4 + 8), &v110);
          CloseHandle(*(v4 + 8));
          v60 = sub_1275870(*(v4 + 4), 74);
          *(v4 + 8) = v60;
          if ( !v60 )
            break;
          NtSuspendThread(v60, &v110);
          ++v59;
        }
        while ( v59 < 2 );
        v40 = lpContext;
        ReadMemoryRoutine = 0;
      }
      else
      {
        v52 = v111;
        v53 = 0;
        v54 = (v111 + 8);
        do
        {
          if ( DeviceIoControl(theDriver, 0x83350028, v54, 4u, &OutBuffer, 0xCu, &BytesReturned, 0) )
            break;
          NtResumeThread(*v54, &v110);
          CloseHandle(*v54);
          v55 = sub_1275870(*(v52 + 4), 2);
          *v54 = v55;
          if ( !v55 )
            break;
          NtSuspendThread(v55, &v110);
          Sleep(0x64u);
          ++v53;
        }
        while ( v53 < 2 );
        v56 = lpContext;
        v4 = v111;
        ReadMemoryRoutine = sub_1270640;
        lpContext->Eip = OutBuffer;
        v56->Esp = v123;
        v56->Ebp = v124;
        v57 = *v54;
        v40 = v56;
        dword_12EAB88 = v57;
      }
      pStackInfo = pStackInfo_1;
LABEL_87:
      if ( !*(v4 + 8) )
      {
        v61 = hDlg;
        EndDialog(hDlg, 0);
        MessageBoxW(0, L"Error opening thread for stack trace.", L"Process Explorer", 0x10u);
        v62 = GetParent(v61);
        SetFocus(v62);
        v63 = GetDlgItem(v61, 1210);
        EnableWindow(v63, 0);
        goto LABEL_77;
      }
      memset(&StackFrame, 0, 0x108u);
      v64 = v40->Eip;
      StackFrame.AddrStack.Offset = v40->Esp;
      v65 = v40->Ebp;
      v66 = 0;
      StackFrame.AddrPC.Offset = v64;
      StackFrame.AddrPC.Mode = 3;
      StackFrame.AddrStack.Mode = 3;
      StackFrame.AddrFrame.Offset = v65;
      StackFrame.AddrFrame.Mode = 3;
      StackFrame.AddrBStore.Offset = v65;
      StackFrame.AddrBStore.Mode = 3;
      while ( 1 )
      {
        v109 = v66;
        v113 = v66;
        if ( v66 >= 100 )
          break;
        v67 = *(v4 + 16);
        LOBYTE(v128) = 5;
        sub_125DD60(1, v64, &v119, *(v4 + 12), 0, 0, *(v4 + 20), v67);
        if ( !StackWalk64(
                0x14Cu,
                *(v4 + 12),
                *(v4 + 8),
                &StackFrame,
                lpContext,
                ReadMemoryRoutine,
                SymFunctionTableAccess64,
                SymGetModuleBase64,
                0) )
        {
          v40 = lpContext;
          i = v104 + 1;
          LOBYTE(v128) = 1;
          goto LABEL_67;
        }
        v128 = 1;
        if ( !StackFrame.AddrPC.Offset )
          break;
        sub_125DD60(1, StackFrame.AddrPC.Offset, &v119, *(v4 + 12), 0, 0, *(v4 + 20), *(v4 + 16));
        v68 = wcscmp(&v120, L"0x0");
        if ( v68 )
          v68 = -(v68 < 0) | 1;
        if ( v68 )
        {
          v69 = wcscmp(&v120, v81);
          if ( v69 )
            v69 = -(v69 < 0) | 1;
          if ( v69 )
          {
            v70 = *ArgList;
            v96 = 5;
            wParam = 0x7FFFFFFF;
            v98 = 0;
            v100 = 0;
            v99 = 0;
            ++*ArgList;
            VLogEntry(&String, L"%d", v70);
            v101 = &String;
            v71 = (v66 + 1);
            v102 = 0;
            v72 = hListCtrl;
            v103 = v71;
            v73 = SendMessageW(hListCtrl, 0x104Du, 0, &v96);
            if ( v73 == -1 )
              goto LABEL_77;
            wParam = v73;
            v101 = &v120;
            v96 = 1;
            v98 = 1;
            SendMessageW(v72, 0x104Cu, 0, &v96);
            qmemcpy(v80, &v119, 0x290u);
            v4 = v111;
            v66 = v113;
          }
        }
        v64 = StackFrame.AddrPC.Offset;
        ++v66;
      }
      v40 = lpContext;
    }
  }
  if ( uMsg == WM_COMMAND )
  {
    if ( a3 > 40083 )
    {
      if ( a3 != 40084 )
      {
        if ( a3 == 40631 )
        {
          v29 = 0;
          v30 = GetDlgItem(hDlg, 1087);
          if ( SendMessageW(v30, 0x1004u, 0, 0) > 0 )
          {
            do
            {
              v86 = 2;
              v85 = 2;
              SendMessageW(v30, 0x102Bu, v29++, &lParam);
            }
            while ( v29 < SendMessageW(v30, 0x1004u, 0, 0) );
          }
        }
        return 0;
      }
      v31 = 0;
      wParam = -1;
      v32 = 0;
      v33 = GetDlgItem(hDlg, 1087);
      pStackInfo_1 = v33;
      v34 = SendMessageW(v33, 0x100Cu, wParam, 0);
      v26 = pStackInfo_1;
      for ( wParam = v34; v34 != -1; wParam = v34 )
      {
        v84 = 1;
        v87 = &String;
        v88[0] = 256;
        SendMessageW(pStackInfo_1, 0x1073u, v34, &lParam);
        v35 = &v31->field_0 + wcslen(&String) + 2;
        v112 = v35;
        if ( v32 )
        {
          v26 = GlobalReAlloc(v26, 2 * v35 + 2, 0);
          v32 = GlobalLock(v26);
        }
        else
        {
          v26 = GlobalAlloc(0x2002u, 2 * v35 + 2);
          v32 = GlobalLock(v26);
          *v32 = 0;
        }
        v36 = v35 + 1;
        wcscat_s(v32, v36, &String);
        wcscat_s(v32, v36, L"\r\n");
        GlobalUnlock(v26);
        v34 = SendMessageW(pStackInfo_1, 0x100Cu, wParam, 0);
        v31 = v112;
      }
    }
    else
    {
      if ( a3 != 40083 )
      {
        if ( a3 > 0 )
        {
          if ( a3 <= 2 )
          {
            v21 = hDlg;
            GetWindowPlacement(hDlg, &gWindowPlacement[5]);
            ghWndThreadStack = 0;
            EndDialog(v21, 0);
          }
          else if ( a3 == 1210 )
          {
            v19 = hDlg;
            v20 = GetDlgItem(hDlg, 1210);
            EnableWindow(v20, 0);
            SendMessageW(hListCtrl, 0x1009u, 0, 0);
            SendMessageW(v19, 0x7FAu, 0, 0);
          }
        }
        return 0;
      }
      v22 = 0;
      wParam = -1;
      v23 = 0;
      v24 = GetDlgItem(hDlg, 1087);
      pStackInfo_1 = v24;
      v25 = SendMessageW(v24, 0x100Cu, wParam, 2);
      v26 = pStackInfo_1;
      for ( wParam = v25; v25 != -1; wParam = v25 )
      {
        v84 = 1;
        v87 = &String;
        v88[0] = 256;
        SendMessageW(pStackInfo_1, 0x1073u, v25, &lParam);
        v27 = &v22->field_0 + wcslen(&String) + 2;
        v112 = v27;
        if ( v23 )
        {
          v26 = GlobalReAlloc(v26, 2 * v27 + 2, 0);
          v23 = GlobalLock(v26);
        }
        else
        {
          v26 = GlobalAlloc(0x2002u, 2 * v27 + 2);
          v23 = GlobalLock(v26);
          *v23 = 0;
        }
        v28 = v27 + 1;
        wcscat_s(v23, v28, &String);
        wcscat_s(v23, v28, L"\r\n");
        GlobalUnlock(v26);
        v25 = SendMessageW(pStackInfo_1, 0x100Cu, wParam, 2);
        v22 = v112;
      }
    }
    if ( OpenClipboard(hDlg) )
    {
      EmptyClipboard();
      SetClipboardData(0xDu, v26);
      CloseClipboard();
    }
    SetFocus(pStackInfo_1);
    return 0;
  }
  if ( uMsg == 78 )
  {
    v14 = *(dwNewLong + 8);
    if ( v14 == -101 || (v14 + 3) <= 1 )
    {
      v15 = hDlg;
      v16 = GetDlgItem(hDlg, 1087);
      if ( SendMessageW(v16, 0x100Cu, 0xFFFFFFFF, 2) == -1 )
      {
        v18 = GetDlgItem(v15, 40083);
        EnableWindow(v18, 0);
      }
      else
      {
        v17 = GetDlgItem(v15, 40083);
        EnableWindow(v17, 1);
      }
    }
    return 0;
  }
  if ( uMsg != 272 )
    return 0;
  v5 = LoadIconW(ghInstance, 0x65);
  v6 = hDlg;
  SendMessageW(hDlg, 0x80u, 0, v5);
  v7 = operator new(0x40u);
  v108 = v7;
  v128 = 0;
  if ( v7 )
    CResize::CResize(v7, v6);
  v8 = hListCtrl;
  v9 = GetWindowLongW(hListCtrl, -16);
  SetWindowLongW(v8, -16, v9 & 0xFFFFFFFD | 1);
  SetWindowLongW(hListCtrl, -21, 2);
  SendMessageW(hListCtrl, 0x1036u, 0x4020u, 16416);
  v10 = SendMessageW(hListCtrl, 0x104Eu, 0, 0);
  InitToolTips(v10);
  OldListCtrlWndProc = SetWindowLongW(hListCtrl, -4, PEListCtrlWndProc);
  SendMessageW(hListCtrl, 0x30u, ghDefaultFont, 0);
  InitListCtrl(hListCtrl, &Indent, &a3a, 2);
  SetWindowLongW(hDlg, -21, dwNewLong);
  VLogEntry(&String, L"Stack for thread %d", *(dwNewLong + 4));
  v11 = hDlg;
  SetWindowTextW(hDlg, &String);
  gWindowPlacement[5].showCmd = 5;
  SetWindowPlacement(v11, &gWindowPlacement[5]);
  if ( GetCurrentProcessId() == *dwNewLong )
  {
    EndDialog(v11, 0);
    MessageBoxW(0, L"Thread stack not available for Process Explorer.", L"Process Explorer", 0x10u);
    v12 = GetParent(v11);
    SetFocus(v12);
    return 0;
  }
  SendMessageW(v11, 0x7FAu, 0, 0);
  return 1;
}
// 12C5208: using guessed type wchar_t a0x0[4];
// 12EAB88: using guessed type int dword_12EAB88;
// 12EF244: using guessed type int (__stdcall *NtSuspendThread)(_DWORD, _DWORD);
// 12EF248: using guessed type int (__stdcall *NtResumeThread)(_DWORD, _DWORD);

//----- (01275020) --------------------------------------------------------
void __noreturn ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException()
{
  AtlThrow(E_OUTOFMEMORY);
}

//----- (01275030) --------------------------------------------------------
MACRO_BOOL __stdcall EnumWindowsCallback(HWND hWnd, LPARAM dwPid)
{
  HWND hWndParent; // eax
  DWORD dwProcessId; // [esp+8h] [ebp-208h]
  TCHAR szText[256]; // [esp+Ch] [ebp-204h]

  if ( GetParent(hWnd) )
  {
    if ( !GetParent(hWnd) )
      return TRUE;
    hWndParent = GetParent(hWnd);
    if ( IsWindowVisible(hWndParent) )
      return TRUE;
  }
  if ( !IsWindowVisible(hWnd) )
    return TRUE;
  GetWindowThreadProcessId(hWnd, &dwProcessId);
  if ( dwProcessId != dwPid )
    return TRUE;
  GetWindowTextW(hWnd, szText, 256);
  if ( !*szText )
    return TRUE;
  if ( gbWindowFound )
  {
    *gszWindowNameFound = 0;
  }
  else
  {
    gbWindowFound = 1;
    wcsncpy_s(gszWindowNameFound, gdwWindowNameFoundSize, szText, 0xFFFFFFFF);
    ghWndFound = hWnd;
  }
  return FALSE;
}
// 12FBA5C: using guessed type char gbWindowFound;

//----- (01275140) --------------------------------------------------------
signed int __usercall sub_1275140@<eax>(int a1@<ebx>, int a2, _BYTE *pnFlags)
{
  HANDLE hSnapshot; // eax
  int v5; // [esp+4h] [ebp-234h]
  PROCESSENTRY32W pe; // [esp+8h] [ebp-230h]

  pe.dwSize = 0;
  memset(&pe.cntUsage, 0, 0x228u);
  if ( ghSnapshot != INVALID_HANDLE_VALUE )
    CloseHandle(ghSnapshot);
  hSnapshot = CreateToolhelp32Snapshot_0(TH32CS_SNAPPROCESS, 0);
  ghSnapshot = hSnapshot;
  if ( hSnapshot == INVALID_HANDLE_VALUE )
    return 0;
  pe.dwSize = sizeof(PROCESSENTRY32W);
  if ( !Process32FirstW_0(hSnapshot, &pe) )
    return 0;
  do
  {
    if ( pnFlags && *pnFlags == 1 )
      break;
    sub_126F870(a1, a2, pnFlags, 0, pe.th32ProcessID, 0, pe.szExeFile, &v5);
  }
  while ( Process32NextW_0(ghSnapshot, &pe) );
  return 1;
}

//----- (01275230) --------------------------------------------------------
errno_t __cdecl sub_1275230(wchar_t *Dst, rsize_t SizeInWords, int a3)
{
  return wcsncpy_s(Dst, SizeInWords, *(a3 + 4), *a3 >> 1);
}

//----- (01275250) --------------------------------------------------------
int __cdecl sub_1275250(int *a1)
{
  int v1; // eax
  __m128i v2; // xmm0
  int v3; // ST0C_4
  _DWORD *v4; // ecx
  int v5; // eax
  unsigned __int8 v6; // cf
  int result; // eax
  int v8; // eax
  int v9; // [esp+0h] [ebp-70h]
  __int128 v10; // [esp+8h] [ebp-68h]
  __int128 v11; // [esp+18h] [ebp-58h]
  __int128 v12; // [esp+28h] [ebp-48h]
  __int128 v13; // [esp+38h] [ebp-38h]
  __int128 v14; // [esp+48h] [ebp-28h]
  __int128 v15; // [esp+58h] [ebp-18h]
  _DWORD *v16; // [esp+68h] [ebp-8h]

  *&v13 = 0i64;
  *(&v13 + 1) = 0i64;
  *&v14 = 0i64;
  v1 = *a1;
  *(&v14 + 1) = 0i64;
  *&v15 = 0i64;
  *(&v15 + 1) = 0i64;
  v2 = _mm_loadu_si128(&v13);
  v9 = v1;
  v3 = byte_12FBC00;
  _mm_storeu_si128(&v10, v2);
  _mm_storeu_si128(&v11, _mm_loadu_si128(&v14));
  _mm_storeu_si128(&v12, _mm_loadu_si128(&v15));
  sub_1259C10(&dword_12FBA78, &v16, 0, &v9, v3);
  v4 = v16;
  if ( a1[2] == 10 )
  {
    v8 = a1[8];
    v6 = __CFADD__(v8, v16[6]);
    v16[6] += v8;
    result = a1[9];
    v4[7] += result + v6;
    v6 = __CFADD__(v4[12]++, 1);
    v4[13] += v6;
  }
  else
  {
    v5 = a1[8];
    if ( a1[2] == 11 )
    {
      v6 = __CFADD__(v5, v16[8]);
      v16[8] += v5;
      result = a1[9];
      v4[9] += result + v6;
      v6 = __CFADD__(v4[14]++, 1);
      v4[15] += v6;
    }
    else
    {
      v6 = __CFADD__(v5, v16[10]);
      v16[10] += v5;
      result = a1[9];
      v4[11] += result + v6;
      v6 = __CFADD__(v4[16]++, 1);
      v4[17] += v6;
    }
  }
  return result;
}
// 12FBC00: using guessed type char byte_12FBC00;

//----- (01275310) --------------------------------------------------------
int __cdecl sub_1275310(int *a1)
{
  int v1; // eax
  __m128i v2; // xmm0
  int v3; // ST0C_4
  _DWORD *v4; // ecx
  int result; // eax
  unsigned __int8 v6; // cf
  int v7; // [esp+0h] [ebp-70h]
  __int128 v8; // [esp+8h] [ebp-68h]
  __int128 v9; // [esp+18h] [ebp-58h]
  __int128 v10; // [esp+28h] [ebp-48h]
  __int128 v11; // [esp+38h] [ebp-38h]
  __int128 v12; // [esp+48h] [ebp-28h]
  __int128 v13; // [esp+58h] [ebp-18h]
  _DWORD *v14; // [esp+68h] [ebp-8h]

  *&v11 = 0i64;
  *(&v11 + 1) = 0i64;
  *&v12 = 0i64;
  v1 = *a1;
  *(&v12 + 1) = 0i64;
  *&v13 = 0i64;
  *(&v13 + 1) = 0i64;
  v2 = _mm_loadu_si128(&v11);
  v7 = v1;
  v3 = byte_12FBC00;
  _mm_storeu_si128(&v8, v2);
  _mm_storeu_si128(&v9, _mm_loadu_si128(&v12));
  _mm_storeu_si128(&v10, _mm_loadu_si128(&v13));
  sub_1259C10(&dword_12FBA70, &v14, 0, &v7, v3);
  v4 = v14;
  if ( a1[2] == 2 )
  {
    result = a1[7];
    v6 = __CFADD__(result, v14[8]);
    v14[8] += result;
    v4[9] += v6;
    ++*(v4 + 7);
  }
  else
  {
    result = a1[7];
    if ( a1[2] == 3 )
    {
      v6 = __CFADD__(result, v14[6]);
      v14[6] += result;
      v4[7] += v6;
      ++*(v4 + 6);
    }
    else
    {
      v6 = __CFADD__(result, v14[10]);
      v14[10] += result;
      v4[11] += v6;
      ++*(v4 + 8);
    }
  }
  return result;
}
// 12FBC00: using guessed type char byte_12FBC00;

//----- (012753D0) --------------------------------------------------------
void __cdecl InsertNodeToTail(wchar_t *str1, StrNode *pNode, wchar_t *str2)
{
  StrNode *pStrNode; // esi

  EnterCriticalSection(&gStrListLock);
  if ( !StrInList(str1) )
  {
    pStrNode = malloc(0x10u);
    pStrNode->strText = _wcsdup(str1);
    pStrNode->pPrev = pNode;
    pStrNode->strText2 = _wcsdup(str2);
    pStrNode->pNext = gStrList;
    gStrList = pStrNode;
  }
  LeaveCriticalSection(&gStrListLock);
}
// 12EB1DC: using guessed type int gStrList;

//----- (01275440) --------------------------------------------------------
_DWORD *sub_1275440()
{
  _DWORD *result; // eax

  result = operator new(0x48u);
  JUMPOUT(result, 0, std::bad_alloc::bad_alloc);
  *result = result;
  if ( result != -4 )
    result[1] = result;
  if ( result != -8 )
    result[2] = result;
  *(result + 6) = 257;
  return result;
}

//----- (01275470) --------------------------------------------------------
_DWORD *__thiscall sub_1275470(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edx

  v1 = this;
  v2 = operator new(0x48u);
  if ( !v2 )
    std::bad_alloc::bad_alloc();
  *v2 = *v1;
  if ( v2 != -4 )
    v2[1] = *v1;
  if ( v2 != -8 )
    v2[2] = *v1;
  return v2;
}

//----- (012754B0) --------------------------------------------------------
CMapNode *__thiscall sub_12754B0(CMapNode *this, CMapNode *pNode)
{
  CMapNode *_Right; // esi
  CMapNode *_Left; // eax

  _Right = pNode->_Right;
  pNode->_Right = _Right->_Left;
  if ( !_Right->_Left->_isnil )
    _Right->_Left->_Parent = pNode;
  _Right->_Parent = pNode->_Parent;
  _Left = this->_Left;
  if ( pNode == this->_Left->_Parent )
  {
    _Left->_Parent = _Right;
    _Right->_Left = pNode;
    pNode->_Parent = _Right;
  }
  else
  {
    _Left = pNode->_Parent;
    if ( pNode == _Left->_Left )
      _Left->_Left = _Right;
    else
      _Left->_Right = _Right;
    _Right->_Left = pNode;
    pNode->_Parent = _Right;
  }
  return _Left;
}

//----- (01275510) --------------------------------------------------------
CSysProcItem **__thiscall sub_1275510(CSysProcItem *this, CSysProcItem **a2, CSysProcItem *_Left, CSysProcItem *_Right)
{
  CSysProcItem *Left; // eax
  CSysProcItem **v5; // edi
  CSysProcItem **result; // eax
  CMapNode *BottomLeft; // ecx
  CSysProcItem *i; // edx
  CSysProcItem *v9; // eax
  __int64 var4; // [esp+8h] [ebp-4h]

  Left = _Left;
  v5 = &this->_Left;
  if ( _Left != this->_Left->_Left || _Right != this->_Left )
  {
    for ( ; _Left != _Right; Left = _Left )
    {
      BottomLeft = Left;
      if ( !Left->_Isnil )
      {
        i = Left->_Right;
        if ( i->_Isnil )
        {
          for ( i = Left->_Parent; !i->_Isnil; i = i->_Parent )
          {
            if ( Left != i->_Right )
              break;
            Left = i;
          }
        }
        else
        {
          v9 = i->_Left;
          if ( !i->_Left->_Isnil )
          {
            do
            {
              i = v9;
              v9 = v9->_Left;
            }
            while ( !v9->_Isnil );
          }
        }
        _Left = i;
      }
      sub_12755B0(v5, &var4, BottomLeft);
    }
    *a2 = Left;
    result = a2;
  }
  else
  {
    sub_124E620(this);
    result = a2;
    *a2 = (*v5)->_Left;
  }
  return result;
}

//----- (012755B0) --------------------------------------------------------
CMapNode *__thiscall sub_12755B0(CMapNode *this, CMapNode *a2, CMapNode *left)
{
  CMapNode *v3; // ebx
  CMapNode *v4; // ecx
  CMapNode *tmp; // edi
  CMapNode *v6; // edx
  CMapNode *v7; // esi
  CMapNode *v8; // eax
  CMapNode *v9; // edx
  CMapNode *v10; // eax
  CMapNode *v11; // eax
  CMapNode *i; // edx
  CMapNode *v13; // eax
  char v14; // cl
  CMapNode *v15; // ecx
  CMapNode *v16; // eax
  CMapNode *v17; // ecx
  CMapNode *result; // eax
  CMapNode *_Left; // [esp+10h] [ebp-4h]

  v3 = this;
  _Left = left;
  sub_1214CE0(&left);
  v4 = _Left;
  if ( _Left->_Left->_isnil )
  {
    tmp = _Left->_Right;
  }
  else if ( _Left->_Right->_isnil )
  {
    tmp = _Left->_Left;
  }
  else
  {
    v6 = left;
    tmp = left->_Right;
    if ( left != _Left )
    {
      _Left->_Left->_Parent = left;
      v6->_Left = _Left->_Left;
      if ( v6 == _Left->_Right )
      {
        v7 = v6;
      }
      else
      {
        v7 = v6->_Parent;
        if ( !tmp->_isnil )
          tmp->_Parent = v7;
        v7->_Left = tmp;
        v6->_Right = _Left->_Right;
        _Left->_Right->_Parent = v6;
      }
      if ( v3->_Left->_Parent == _Left )
      {
        v3->_Left->_Parent = v6;
      }
      else
      {
        v13 = _Left->_Parent;
        if ( v13->_Left == _Left )
          v13->_Left = v6;
        else
          v13->_Right = v6;
      }
      v6->_Parent = _Left->_Parent;
      v14 = v6->_Color;
      v6->_Color = _Left->_Color;
      _Left->_Color = v14;
      v4 = _Left;
      goto LABEL_37;
    }
  }
  v7 = _Left->_Parent;
  if ( !tmp->_isnil )
    tmp->_Parent = v7;
  if ( v3->_Left->_Parent == _Left )
  {
    v3->_Left->_Parent = tmp;
  }
  else if ( v7->_Left == _Left )
  {
    v7->_Left = tmp;
  }
  else
  {
    v7->_Right = tmp;
  }
  v8 = v3->_Left;
  if ( v3->_Left->_Left == _Left )
  {
    if ( tmp->_isnil )
    {
      v9 = v7;
    }
    else
    {
      v10 = tmp->_Left;
      v9 = tmp;
      if ( !tmp->_Left->_isnil )
      {
        do
        {
          v9 = v10;
          v10 = v10->_Left;
        }
        while ( !v10->_isnil );
      }
      v8 = v3->_Left;
    }
    v8->_Left = v9;
  }
  if ( v3->_Left->_Right == _Left )
  {
    if ( tmp->_isnil )
    {
      v3->_Left->_Right = v7;
    }
    else
    {
      v11 = tmp->_Right;
      for ( i = tmp; !v11->_isnil; v11 = v11->_Right )
        i = v11;
      v3->_Left->_Right = i;
    }
  }
LABEL_37:
  if ( v4->_Color != 1 )
    goto LABEL_62;
  if ( tmp == v3->_Left->_Parent )
    goto LABEL_61;
  while ( tmp->_Color == 1 )
  {
    v15 = v7->_Left;
    if ( tmp == v7->_Left )
    {
      v15 = v7->_Right;
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_12754B0(v3, v7);
        v15 = v7->_Right;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
      {
        if ( v15->_Right->_Color == 1 )
        {
          v15->_Left->_Color = 1;
          v15->_Color = 0;
          sub_1282BB0(v3, v15);
          v15 = v7->_Right;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Right->_Color = 1;
        sub_12754B0(v3, v7);
        break;
      }
    }
    else
    {
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_1282BB0(v3, v7);
        v15 = v7->_Left;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
      {
        if ( v15->_Left->_Color == 1 )
        {
          v15->_Right->_Color = 1;
          v15->_Color = 0;
          sub_12754B0(v3, v15);
          v15 = v7->_Left;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Left->_Color = 1;
        sub_1282BB0(v3, v7);
        break;
      }
    }
    v15->_Color = 0;
LABEL_55:
    tmp = v7;
    v7 = v7->_Parent;
    if ( tmp == v3->_Left->_Parent )
      break;
  }
  v4 = _Left;
LABEL_61:
  tmp->_Color = 1;
LABEL_62:
  j__free(v4);
  v16 = v3->_Parent;
  v17 = left;
  if ( v16 )
    v3->_Parent = (v16 - 1);
  result = a2;
  a2->_Left = v17;
  return result;
}

//----- (01275820) --------------------------------------------------------
_DWORD *__thiscall sub_1275820(int *this, _DWORD *a2, unsigned int *a3)
{
  int v3; // esi
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // eax
  _DWORD *result; // eax
  int v8; // [esp+14h] [ebp+Ch]

  v3 = *this;
  v4 = v3;
  v5 = *(v3 + 4);
  while ( !*(v5 + 13) )
  {
    if ( *(v5 + 16) >= *a3 )
    {
      v4 = v5;
      v5 = *v5;
    }
    else
    {
      v5 = *(v5 + 8);
    }
  }
  if ( v4 == v3 || (v6 = *a3, v8 = v4, v6 < *(v4 + 16)) )
    v8 = v3;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (01275870) --------------------------------------------------------
int __cdecl sub_1275870(int a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  int v5; // [esp+0h] [ebp-20h]
  int v6; // [esp+4h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  int v11; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v12 = a1;
  v11 = 0;
  v5 = 24;
  v6 = 0;
  v8 = 0;
  v7 = 0;
  v9 = 0;
  v10 = 0;
  v2 = NtOpenThread(&a1, a2, &v5, &v11);
  v3 = 0;
  if ( !v2 )
    v3 = a1;
  return v3;
}
// 12EF254: using guessed type int (__stdcall *NtOpenThread)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (012758D0) --------------------------------------------------------
char __usercall DeleteItemFromListCtrl@<al>(signed int a1@<ebx>, HWND hWnd, LVITEMW *pItem, LVITEMUSERDATA2 *pUserData, int ResultReturned)
{
  int v5; // ecx
  int v6; // eax
  int dwTotalHighlightDuration; // ecx
  int v8; // eax
  HWND v9; // ecx
  int v10; // eax
  int iItem; // eax
  WPARAM nItem; // eax
  char result; // al
  bool isHandlesList; // zf
  LVITEMEXW lvItem; // [esp+Ch] [ebp-50h]
  LVFINDINFOW FindInfo; // [esp+40h] [ebp-1Ch]
  int v17; // [esp+58h] [ebp-4h]
  int ResultReturneda; // [esp+70h] [ebp+14h]

  LOBYTE(a1) = 0;
  v17 = a1;
  pUserData->m_Counter = gnCounter;
  pUserData->field_C = pUserData->isHandlesList;
  *ResultReturned = 0;
  v5 = gdwHighlightDuration;
  if ( gdwRefreshRateOfSearch )
    v5 = gdwRefreshRateOfSearch;
  v6 = pUserData->isHandlesList;
  pUserData->dwTotalHighlightDuration += v5;
  dwTotalHighlightDuration = pUserData->dwTotalHighlightDuration;
  if ( v6 == 2 )
  {
    a1 = 0;
    if ( dwTotalHighlightDuration >= gdwHighlightDuration )
      a1 = 1;
    v17 = a1;
  }
  if ( v6 == 4 )
  {
LABEL_31:
    --pItem->iItem;
    return a1;
  }
  if ( v6 == 1 )
  {
    if ( dwTotalHighlightDuration >= gdwHighlightDuration )
    {
      v8 = pUserData->field_4;
      v9 = hWnd;
      pUserData->isHandlesList = 4;
      ResultReturneda = v8;
      if ( pItem->iItem != -1
        || (FindInfo.lParam = pItem->lParam,
            FindInfo.flags = 1,
            v10 = SendMessageW(hWnd, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo),
            v9 = hWnd,
            pItem->iItem = v10,
            v10 != -1) )
      {
        SendMessageW(v9, WM_SETREDRAW, 0, 0);
        LOBYTE(v17) = 1;
        pItem->mask = LVCF_SUBITEM;
        SendMessageW(hWnd, LVM_GETITEMW, 0, pItem);
        SendMessageW(hWnd, LVM_DELETEITEM, pItem->iItem, 0);
        if ( pItem->state & 2 )
        {
          iItem = pItem->iItem;
          lvItem.mask = 3;
          lvItem.state = 3;
          if ( iItem )
            nItem = iItem - 1;
          else
            nItem = 0;
          SendMessageW(hWnd, LVM_SETITEMSTATE, nItem, &lvItem);
        }
      }
      if ( !ResultReturneda )
      {
        SendMessageW(ghWndNewOwner, PMT_MSG_7EF, 0, pUserData);
        --pItem->iItem;
        return 1;
      }
      LOBYTE(a1) = v17;
    }
    goto LABEL_31;
  }
  if ( v6 != 2 || dwTotalHighlightDuration >= gdwHighlightDuration )
  {
    LOBYTE(pUserData->field_18) = 0;
    pUserData->isHandlesList = 0;
  }
  else
  {
    LOBYTE(pUserData->field_18) = 1;
    pUserData->field_1C = dwTotalHighlightDuration;
  }
  if ( pUserData->field_4 != 2 )
  {
    pUserData->isHandlesList = 1;
    pUserData->dwTotalHighlightDuration = 0;
    *ResultReturned = 1;
    result = a1;
    --pItem->iItem;
    return result;
  }
  if ( FindSystemHandleInfo(pItem->lParam) )
    goto LABEL_31;
  isHandlesList = hWnd == ghWndHandlesListCtrl;
  pUserData->isHandlesList = 1;
  if ( isHandlesList )
    LOBYTE(a1) = 1;
  pUserData->dwTotalHighlightDuration = 0;
  *ResultReturned = 1;
  result = a1;
  --pItem->iItem;
  return result;
}
// 12E5534: using guessed type int gdwHighlightDuration;
// 12EA11C: using guessed type int gnCounter;

//----- (01275AB0) --------------------------------------------------------
BOOL __cdecl DeviceIoControl_0(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize)
{
  DWORD v5; // ecx
  DWORD BytesReturned; // [esp+0h] [ebp-4h]

  BytesReturned = v5;
  return DeviceIoControl(
           theDriver,
           dwIoControlCode,
           lpInBuffer,
           nInBufferSize,
           lpOutBuffer,
           nOutBufferSize,
           &BytesReturned,
           0) != 0;
}

//----- (01275AE0) --------------------------------------------------------
int __stdcall CGraph::GraphWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  LONG pWindowInfo_1; // esi
  HWND hWndTooltip_1; // eax
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // ecx
  HWND hWndTooltip_2; // ebx
  UINT msg; // eax
  int msgid; // eax
  int v10; // eax
  HDC v11; // ebx
  int v12; // eax
  int result; // eax
  int v14; // eax
  HWND hWndTooltip; // esi
  int v16; // eax
  HWND v17; // eax
  wchar_t *v18; // esi
  __int32 mouseevent; // eax
  int v20; // eax
  HWND v21; // eax
  __int16 v22; // ah^1
  struct tagPOINT Point; // [esp+14h] [ebp-890h]
  NMHDR lParam_1; // [esp+1Ch] [ebp-888h]
  __int16 v25; // [esp+824h] [ebp-80h]
  __int16 v26; // [esp+826h] [ebp-7Eh]
  LONG v27; // [esp+828h] [ebp-7Ch]
  TTTOOLINFOW ToolInfo; // [esp+830h] [ebp-74h]
  int v29; // [esp+85Ch] [ebp-48h]
  struct tagPAINTSTRUCT Paint; // [esp+860h] [ebp-44h]

  lParam_1.hwndFrom = lParam;
  pWindowInfo_1 = GetWindowLongW(hWnd, GWL_USERDATA);
  hWndTooltip_1 = GetPropW(hWnd, L"Balloon");
  SendMessageW = ::SendMessageW;
  hWndTooltip_2 = hWndTooltip_1;
  msg = message;
  if ( hWndTooltip_2 )
  {
    if ( message != WM_LBUTTONDOWN )
    {
      msg = message;
      if ( message - 0x200 <= 0xD )
      {
        ToolInfo.rect.right = message;
        ToolInfo.rect.bottom = wParam;
        ToolInfo.hinst = lParam_1.hwndFrom;
        ToolInfo.rect.top = hWnd;
        *&ToolInfo.lpszText = 0i64;
        v29 = 0;
        ::SendMessageW(hWndTooltip_2, TTM_RELAYEVENT, 0, &ToolInfo.rect.top);
        msg = message;
        SendMessageW = ::SendMessageW;
      }
    }
  }
  if ( msg > WM_NOTIFY )
  {
    mouseevent = msg - WM_MOUSEMOVE;
    if ( mouseevent )
    {
      v20 = mouseevent - 1;
      if ( v20 )
      {
        if ( v20 == 0x1FF )
        {
          if ( !*(pWindowInfo_1 + 2132) )
            SendMessageW(hWndTooltip_2, TTM_UPDATE, 0, 0);
          InvalidateRect(hWnd, 0, 0);
          UpdateWindow(hWnd);
        }
      }
      else
      {
        KillTimer(hWnd, 0);
        *(pWindowInfo_1 + 2132) = *(pWindowInfo_1 + 2132) == 0;
        v21 = *(pWindowInfo_1 + 80);
        if ( v21 )
          ::SendMessageW(v21, 0x422u, 0, 0);
        if ( GetParent(hWnd) == ghWndRebar )
        {
          if ( hWnd == ghWndGraphCPUUsage )
          {
            gdwDefaultSysInfoPage = 1;
          }
          else if ( hWnd == ghWndGraphMemory || hWnd == ghWndGraphPhysicalMemory )
          {
            gdwDefaultSysInfoPage = 2;
          }
          else
          {
            gdwDefaultSysInfoPage = (hWnd == ghWndGPUGraphCtrl) + 3;
          }
          OnShowSystemInformation();
        }
      }
      return DefWindowProcW(hWnd, message, wParam, lParam_1.hwndFrom);
    }
    if ( hWndTooltip_2 )
    {
      v22 = HIWORD(lParam_1.hwndFrom);
      if ( SLOWORD(lParam_1.hwndFrom) == *(pWindowInfo_1 + 2136) )
      {
        if ( SHIWORD(lParam_1.hwndFrom) == *(pWindowInfo_1 + 2140) )
          return DefWindowProcW(hWnd, message, wParam, lParam_1.hwndFrom);
        v22 = HIWORD(lParam_1.hwndFrom);
      }
      *(pWindowInfo_1 + 2136) = SLOWORD(lParam_1.hwndFrom);
      *(pWindowInfo_1 + 2140) = v22;
      SendMessageW(hWndTooltip_2, 0x41Du, 0, 0);
      *(pWindowInfo_1 + 2132) = 0;
    }
    return DefWindowProcW(hWnd, message, wParam, lParam_1.hwndFrom);
  }
  if ( msg == WM_NOTIFY )
  {
    if ( *lParam_1.hwndFrom == hWndTooltip_2 )
    {
      v16 = *(lParam_1.hwndFrom + 2);
      if ( v16 == -530 )
      {
        GetCursorPos(&Point);
        if ( WindowFromPoint(Point) == hWnd && (v17 = GetParent(hWnd), IsFocusWindow(v17)) )
        {
          lParam_1.idFrom = hWnd;
          v27 = pWindowInfo_1;
          GetCursorPos(&Point);
          ScreenToClient(hWnd, &Point);
          v25 = Point.x;
          v26 = Point.y;
          sub_12324C0(&lParam_1.idFrom);
          if ( LOWORD(lParam_1.code) )
          {
            v18 = (pWindowInfo_1 + 84);
            tcscpy_s(v18, 0x400u, &lParam_1.code);
            *(lParam_1.hwndFrom + 3) = v18;
          }
        }
        else
        {
          ::SendMessageW(hWndTooltip_2, TTM_POP, 0, 0);
        }
      }
      else if ( v16 == -521 )
      {
        return 0;
      }
    }
    return DefWindowProcW(hWnd, message, wParam, lParam_1.hwndFrom);
  }
  msgid = msg - 1;
  if ( msgid )
  {
    v10 = msgid - 4;
    if ( v10 )
    {
      if ( v10 == 10 )
      {
        v11 = BeginPaint(hWnd, &Paint);
        GetClientRect(hWnd, &ToolInfo.hinst);
        v12 = GetDlgCtrlID(hWnd);
        if ( v12 == 1330
          || v12 == 1159
          || v12 == 1333
          || v12 == 1335
          || v12 == 1338
          || v12 == 2601
          || v12 == 2602
          || v12 == 2603
          || v12 >= 2000 && v12 < 2500
          || v12 >= 2501 && v12 < 2600 )
        {
          PEDrawIcon(pWindowInfo_1, v11, &ToolInfo.hinst, 0xFFFFFFFF, 0, 0.0);
          EndPaint(hWnd, &Paint);
          result = 0;
        }
        else
        {
          sub_1231470(pWindowInfo_1, v11, &ToolInfo.hinst);
          EndPaint(hWnd, &Paint);
          result = 0;
        }
        return result;
      }
    }
    else
    {
      ToolInfo.cbSize = 48;
      ToolInfo.uFlags = 0;
      _mm_storeu_si128(&ToolInfo.hwnd, 0i64);
      _mm_storeu_si128(&ToolInfo.rect.right, 0i64);
      ToolInfo.hwnd = hWnd;
      *&ToolInfo.lParam = 0i64;
      GetClientRect(hWnd, &ToolInfo.rect);
      ::SendMessageW(hWndTooltip_2, TTM_NEWTOOLRECTW, 0, &ToolInfo);
    }
    return DefWindowProcW(hWnd, message, wParam, lParam_1.hwndFrom);
  }
  SetWindowLongW(hWnd, GWL_USERDATA, *lParam_1.hwndFrom);
  v14 = GetDlgCtrlID(hWnd);
  if ( v14 == 1159
    || v14 == 1330
    || v14 == 1333
    || v14 == 1335
    || v14 == 1338
    || v14 == 2601
    || v14 == 2602
    || v14 == 2603
    || v14 >= 2000 && v14 < 2500
    || (v14 - 2501) <= 0x62 )
  {
    hWndTooltip = CreateWindowExW(
                    WS_EX_TOPMOST,
                    L"tooltips_class32",
                    0,
                    // WS_POPUP|TTS_NOANIMATE|TTS_NOFADE|TTS_ALWAYSTIP|TTS_NOPREFIX
                    0x80000033,
                    0,
                    0,
                    0,
                    0,
                    hWnd,
                    NULL,
                    ghInstance,
                    NULL);
    ToolInfo.cbSize = 48;
    ToolInfo.uFlags = TTF_TRANSPARENT;
    _mm_storeu_si128(&ToolInfo.hwnd, 0i64);
    _mm_storeu_si128(&ToolInfo.rect.right, 0i64);
    ToolInfo.hwnd = hWnd;
    *&ToolInfo.lParam = 0i64;
    ToolInfo.lpszText = -1;
    ::SendMessageW(hWndTooltip, TTM_ADDTOOLW, 0, &ToolInfo);
    SetPropW(hWnd, L"Balloon", hWndTooltip);
    InitToolTips(hWndTooltip);
  }
  return 1;
}

//----- (01276020) --------------------------------------------------------
char __cdecl sub_1276020(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  bool v4; // zf
  int v5; // edi
  int v6; // ecx
  char i; // dl

  LOBYTE(v1) = SendMessageW(ghWndTreeListView, 0xBu, 0, 0);
  v2 = a1;
  v3 = a1;
  if ( a1 )
  {
    do
    {
      v4 = *(v3 + 68) == 0;
      *(v3 + 48) = 0;
      *(v3 + 84) = 0;
      if ( !v4 )
      {
        v1 = a1;
        while ( *(v1 + 68) != *(v3 + 76) || *(v1 + 624) > *(v3 + 624) )
        {
          v1 = *(v1 + 1456);
          if ( !v1 )
            goto LABEL_9;
        }
        *(v3 + 84) = v1;
      }
LABEL_9:
      v3 = *(v3 + 1456);
    }
    while ( v3 );
    if ( a1 )
    {
      do
      {
        v5 = 0;
        v6 = *(v2 + 84);
        for ( i = (*(v2 + 40) >> 1) & 1; v6; ++v5 )
        {
          LOBYTE(v1) = -((*(v6 + 40) & 4) != 0);
          ++*(v6 + 48);
          v6 = *(v6 + 84);
          i &= v1;
        }
        *(v2 + 80) = v5;
        if ( (!i || *(v2 + 40) & 1 && byte_12E96D6) && *(v2 + 44) != -1 )
        {
          if ( !i )
            *(v2 + 40) &= 0xFFFFFFFD;
          LOBYTE(v1) = DeleteItemFromTreeList(ghWndTreeListView, v2);
        }
        v2 = *(v2 + 1456);
      }
      while ( v2 );
    }
  }
  return v1;
}
// 12E96D6: using guessed type char byte_12E96D6;

//----- (01276110) --------------------------------------------------------
volatile signed __int32 *__cdecl ShowHandleProperties(HWND a1, void *a2)
{
  signed int v2; // edi
  CAtlStringMgr *v3; // ecx
  int v4; // eax
  HINSTANCE v5; // ecx
  int v6; // esi
  unsigned int v7; // eax
  const PROPSHEETPAGEW *psPage2; // eax
  int v9; // edi
  int v10; // ecx
  char *v11; // ecx
  __int16 v12; // ax
  int v13; // ecx
  signed int v14; // edi
  bool v15; // zf
  HWND v16; // edi
  const wchar_t *v17; // eax
  volatile signed __int32 *v18; // esi
  volatile signed __int32 *result; // eax
  PROPSHEETPAGEW psPage; // [esp+Ch] [ebp-4C8h]
  PROPSHEETHEADERW psheader; // [esp+74h] [ebp-460h]
  int v22[2]; // [esp+A8h] [ebp-42Ch]
  char *v23; // [esp+B0h] [ebp-424h]
  HWND v24; // [esp+B4h] [ebp-420h]
  int v25; // [esp+B8h] [ebp-41Ch]
  ISecurityInformation *pSecurityInfo; // [esp+BCh] [ebp-418h]
  __int16 Dst[520]; // [esp+C0h] [ebp-414h]

  v24 = a1;
  v2 = 0;
  v3 = ATL::CAtlStringMgr::GetInstance();
  if ( !v3 )
    AtlThrow(E_FAIL);
  v4 = (v3->vtptr->GetNilString)();
  v5 = ghInstance;
  v6 = v4 + 16;
  v25 = v4 + 16;
  if ( *(a2 + 10) )
  {
    psPage.hIcon = 0;
    psPage.pfnCallback = 0;
    v2 = 1;
    psPage.dwSize = 0x34;
    psPage.dwFlags = PSP_USETITLE;
    psPage.hInstance = ghInstance;
    psPage.pszTemplate = L"HANDLEINFO";
    psPage.pfnDlgProc = HanldeInfoDlgProc;
    psPage.pszTitle = L"Details";
    psPage.lParam = a2;
  }
  if ( *CreateSecurityPage )
  {
    if ( _wcsicmp(a2 + 0x1C, L"ObjDirectory") )
    {
      if ( _wcsicmp(a2 + 0x1C, L"Device") )
      {
        if ( _wcsicmp(a2 + 0x1C, L"Process") )
        {
          if ( _wcsicmp(a2 + 0x1C, L"Service") )
            v9 = _wcsicmp(a2 + 0x1C, L"Thread") != 0 ? 1 : 5;
          else
            v9 = 4;
        }
        else
        {
          v9 = 3;
        }
      }
      else
      {
        v9 = 2;
      }
    }
    else
    {
      v9 = 0;
    }
    if ( a2 == -184 )
    {
      v10 = 0;
    }
    else
    {
      v11 = a2 + 184;
      v23 = a2 + 186;
      do
      {
        v12 = *v11;
        v11 += 2;
      }
      while ( v12 );
      v10 = (v11 - v23) >> 1;
    }
    sub_122C620(&v25, a2 + 184, v10);
    v13 = wcscmp(a2 + 0x1C, L"ObjDirectory");
    if ( v13 )
      v13 = -(v13 < 0) | 1;
    v6 = v25;
    sub_122AA20(a2, v25, &pSecurityInfo, v9, v13 == 0);
    v14 = 0;
    psheader.dwFlags = 128;
    if ( *(a2 + 10) )
    {
      v22[0] = CreatePropertySheetPageW(&psPage);
      v14 = 1;
    }
    v22[v14] = CreateSecurityPage(pSecurityInfo);
    psheader.nPages = v14 + 1;
    psPage2 = v22;
  }
  else
  {
    v7 = 52 * v2;
    psheader.dwFlags = 136;
    *(&psPage.dwSize + v7) = 52;
    *(&psPage.dwFlags + v7) = 8;
    *(&psPage.hInstance + v7) = v5;
    (&psPage.pszTemplate)[v7 / 4] = L"SECURITY";
    *(&psPage.pfnDlgProc + v7) = SecurityPageProc;
    *(&psPage.pszTitle + v7) = L"Security";
    *(&psPage.lParam + v7) = a2;
    *(&psPage.pfnCallback + v7) = 0;
    psheader.nPages = v2 + 1;
    psPage2 = &psPage;
  }
  v15 = *(a2 + 10) == 0;
  v16 = v24;
  psheader.ppsp = psPage2;
  psheader.hInstance = ghInstance2;
  v17 = L"Properties";
  if ( v15 )
    v17 = L"Permissions";
  psheader.dwSize = 52;
  psheader.hwndParent = v24;
  sub_1234BB0(Dst, L"%s %s", a2 + 184, v17);
  psheader.nStartPage = 0;
  psheader.hwndParent = v16;
  psheader.pszCaption = Dst;
  psheader.pfnCallback = 0;
  PropertySheetW(&psheader);
  if ( *CreateSecurityPage )
    sub_122AA10(pSecurityInfo);
  v18 = (v6 - 16);
  result = v18 + 3;
  if ( _InterlockedDecrement(v18 + 3) <= 0 )
    result = (*(**v18 + 4))(v18);
  return result;
}
// 12C2AE8: using guessed type wchar_t aSecurity_1[9];
// 12C5140: using guessed type wchar_t aHandleinfo[11];
// 12C5158: using guessed type wchar_t aDetails[8];
// 12C5168: using guessed type wchar_t aSecurity_0[9];
// 12C51A8: using guessed type wchar_t aProperties_0[11];
// 12C51C0: using guessed type wchar_t aPermissions[12];
// 1276110: using guessed type int var_42C[2];

//----- (01276450) --------------------------------------------------------
int __cdecl StartProcessPropSheet(TREELISTITEMPARAM *a1)
{
  InterlockedIncrement(&a1->t00[9]);
  return _beginthread(ProcessPropSheetThreadProc, 0, a1);
}

//----- (01276480) --------------------------------------------------------
BOOL __cdecl LaunchDllPropDlg(HACCEL hAccTable)
{
  HCURSOR v1; // eax
  CPropSheetDlg *v2; // eax
  CPropSheetDlg *pPropSheetData; // esi
  HWND hWndPropSheet; // ebx
  BOOL result; // eax
  int v6; // edi
  HWND v7; // eax
  HWND v8; // esi
  struct tagMSG Msg; // [esp+8h] [ebp-20h]
  CPropSheetDlg *v10; // [esp+24h] [ebp-4h]
  HACCEL hAccTablea; // [esp+30h] [ebp+8h]

  InterlockedIncrement(&gnLock);
  v1 = LoadCursorW(0, IDC_APPSTARTING);
  SetCursor(v1);
  v2 = malloc(16776u);
  pPropSheetData = v2;
  v10 = v2;
  memset(v2, 0, 0x4188u);
  pPropSheetData->TreeListItemData = hAccTable;
  hWndPropSheet = CreateDialogParamW(ghInstance2, L"PROCPROPSHEET", ghWndNewOwner, DllPropDlgProc, pPropSheetData);
  hAccTablea = LoadAcceleratorsW(ghInstance2, L"DLLPROPERTIES");
  for ( result = GetMessageW(&Msg, 0, 0, 0); result; result = GetMessageW(&Msg, 0, 0, 0) )
  {
    v6 = pPropSheetData + 524 * pPropSheetData->TabIndex;
    v7 = *(v6 + 8);
    if ( v7 && TranslateAcceleratorW(v7, hAccTablea, &Msg) )
      continue;
    v8 = GetPropW(hWndPropSheet, L"FindWindow");
    if ( !v8 )
    {
LABEL_8:
      if ( !IsDialogMessageW(*(v6 + 8), &Msg) && !IsDialogMessageW(hWndPropSheet, &Msg) )
      {
        TranslateMessage(&Msg);
        DispatchMessageW(&Msg);
      }
      goto LABEL_11;
    }
    if ( IsDialogMessageW(v8, &Msg) )
    {
      if ( Msg.message != WM_COMMAND || LOWORD(Msg.wParam) != 0x9C4Eu )
        goto LABEL_11;
    }
    else if ( Msg.message != 273 || LOWORD(Msg.wParam) != 0x9C4Eu )
    {
      goto LABEL_8;
    }
    PostMessageW(v8, WM_COMMAND, IDABORT, 0);
    SetPropW(hWndPropSheet, L"FindWindow", 0);
LABEL_11:
    pPropSheetData = v10;
  }
  return result;
}

//----- (01276600) --------------------------------------------------------
LRESULT __stdcall CDriver::Close(HDRVR hDriver, LONG lParam1, LONG lParam2)
{
  LRESULT result; // eax

  result = theDriver;
  if ( theDriver != INVALID_HANDLE_VALUE )
    result = CloseHandle(theDriver);
  return result;
}

//----- (01276620) --------------------------------------------------------
bool GetProcessDEPStatus()
{
  DWORD v1; // eax
  HANDLE hProcess2; // esi
  HANDLE hProcess; // eax
  int status; // edi
  int nProcessFlags; // [esp+0h] [ebp-8h]
  int dwRet; // [esp+4h] [ebp-4h]

  if ( gdwOsType >= WINDOWS_8 || gdwOsType >= WINDOWS_7 )
    return TRUE;
  if ( gdwOsType >= WINDOWS_VISTA )
    return FALSE;
  v1 = GetCurrentProcessId();
  hProcess2 = OpenProcess(PROCESS_QUERY_INFORMATION, 0, v1);
  if ( !hProcess2 )
    return FALSE;
  hProcess = GetCurrentProcess();
  status = NtQueryInformationProcess(hProcess, ProcessExecuteFlags, &nProcessFlags, 4u, &dwRet);
  CloseHandle(hProcess2);
  return !status || status == STATUS_INVALID_PARAMETER;
}
// 12E4E54: using guessed type int gdwOsType;

//----- (012766B0) --------------------------------------------------------
BOOL __stdcall FindDialogDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, NMLISTVIEW *lParam)
{
  BOOL result; // eax
  int v5; // ecx
  char v6; // al
  HWND hWndFrom; // ST08_4
  HANDLESANDDLLSLISTUSERPARAM *v8; // eax
  void *v9; // eax
  HWND v10; // ST08_4
  #1077 *v11; // eax
  int v12; // eax
  int v13; // edx
  LVITEMUSERDATA *v14; // eax
  FINDDLGLISTITEMPARAM *v15; // eax
  CResize *v16; // eax
  HWND v17; // eax
  LONG v18; // eax
  HWND v19; // eax
  _IMAGELIST *hImageList; // edi
  LONG v21; // eax
  HCURSOR hwnd; // esi
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  WPARAM iItem; // esi
  int v33; // ST14_4
  int v34; // eax
  LRESULT v35; // eax
  LVITEMW itemState; // [esp+Ch] [ebp-2A4h]
  LVITEMW lvItem; // [esp+40h] [ebp-270h]
  LVFINDINFOW FindInfo; // [esp+74h] [ebp-23Ch]
  HCURSOR hCursor; // [esp+8Ch] [ebp-224h]
  HANDLESANDDLLSLISTUSERPARAM *v40; // [esp+90h] [ebp-220h]
  int uIDs[4]; // [esp+94h] [ebp-21Ch]
  __int16 Dst[256]; // [esp+A4h] [ebp-20Ch]
  __int16 nWidths[2]; // [esp+2A4h] [ebp-Ch]
  COLUMNWIDTH v44; // [esp+2A8h] [ebp-8h]

  hCursor = hWnd;
  if ( !(sbInited_0 & 1) )
  {
    sbInited_0 |= 1u;
    gdwFindDlgListColumnWidths.width1 = MulDiv(75, gLogPixelsX, 96);
    gdwFindDlgListColumnWidths.width2 = MulDiv(-1, gLogPixelsX, 96);
    gdwFindDlgListColumDefnWidths.width1 = MulDiv(50, gLogPixelsX, 96);
    gdwFindDlgListColumDefnWidths.width2 = MulDiv(150, gLogPixelsX, 96);
  }
  lvItem.mask = 0;
  memset(&lvItem.iItem, 0, 0x30u);
  _mm_storeu_si128(uIDs, _mm_load_si128(&xmmword_12C6C30));
  if ( uMsg > WM_INITDIALOG )
  {
    if ( uMsg > FDM_STARTSORT )
    {
      // 清除处理
      if ( uMsg == PMT_MSG_7F1 )
      {
        ghDlgFindDialog = NULL;
        ghWndListCtrlInFindDialog = NULL;
        GetWindowRect(hWnd, &gRectFindDialog);
        gcxFindDlg = gRectFindDialog.right - gRectFindDialog.left;
        gcyFindDlg = gRectFindDialog.bottom - gRectFindDialog.top;
      }
      return 0;
    }
    if ( uMsg == FDM_STARTSORT )
    {
      SendMessageW(ghWndListCtrlInFindDialog, LVM_SORTITEMS, gnItemSortedInFindDlg, SortInFindDlgCallback);
      v35 = SendMessageW(ghWndListCtrlInFindDialog, LVM_GETITEMCOUNT, 0, 0);
      VLogEntry(Dst, L"%d matching items.", v35);
      SetDlgItemTextW(hWnd, IDD_FINDDIALOG_STATIC_SEARCH_TEXT, Dst);
      return 1;
    }
    if ( uMsg != WM_COMMAND )
    {
      if ( uMsg == FDM_ENDSORT )
      {
        CloseHandle(ghSearchThreadHandle);
        ghSearchThreadHandle = 0;
        v23 = GetDlgItem(hWnd, IDD_FINDDIALOG_EDITTEXT_SEARCH);
        EnableWindow(v23, 1);
        v24 = GetDlgItem(hWnd, IDD_FINDDIALOG_EDITTEXT_EDIT);
        EnableWindow(v24, 1);
        v25 = GetDlgItem(hWnd, IDD_FINDDIALOG_BUTTON_CANCEL);
        EnableWindow(v25, 0);
        SendMessageW(hWnd, 0x465u, 0, 0);
        v26 = GetDlgItem(hWnd, IDD_FINDDIALOG_EDITTEXT_SEARCH);
        SetFocus(v26);
        return 1;
      }
      return 0;
    }
    // WM_COMMAND
    if ( wParam == IDD_FINDDIALOG_BUTTON_CANCEL )
    {
      gbCancelFindInFindDlg = 1;
      return 0;
    }
    if ( wParam == IDCANCEL )
    {
      v31 = GetDlgItem(hWnd, IDD_FINDDIALOG_BUTTON_CANCEL);
      if ( IsWindowEnabled(v31) )
      {
        SendMessageW(hWnd, WM_COMMAND, IDD_FINDDIALOG_BUTTON_CANCEL, 0);
        return 1;
      }
    }
    else if ( wParam != IDOK )
    {
      if ( wParam == IDD_FINDDIALOG_EDITTEXT_SEARCH )
      {
        gdwSelectedItemInFindDialog = -1;
        GetDlgItemTextW(hWnd, IDD_FINDDIALOG_EDITTEXT_EDIT, gszTextToFind, 256);
        if ( wcslen(gszTextToFind) )
        {
          InitTreeListSortableHeader(
            ghWndListCtrlInFindDialog,
            gnItemSortedInFindDlg,
            gnItemSortedInFindDlg,
            gbFINDDLGLISTAscending);
          v27 = GetDlgItem(hWnd, IDD_FINDDIALOG_EDITTEXT_SEARCH);
          EnableWindow(v27, 0);
          v28 = GetDlgItem(hWnd, IDD_FINDDIALOG_EDITTEXT_EDIT);
          EnableWindow(v28, 0);
          v29 = GetDlgItem(hWnd, IDD_FINDDIALOG_BUTTON_CANCEL);
          EnableWindow(v29, 1);
          v30 = GetDlgItem(hWnd, IDD_FINDDIALOG_BUTTON_CANCEL);
          SetFocus(v30);
          if ( ghSearchThreadHandle )
          {
            WaitForSingleObject(ghSearchThreadHandle, INFINITE);
            CloseHandle(ghSearchThreadHandle);
          }
          gbCancelFindInFindDlg = 0;
          SendMessageW(ghWndListCtrlInFindDialog, LVM_DELETEALLITEMS, 0, 0);
          SetDlgItemTextW(hWnd, 1349, L"Searching...");
          ghSearchThreadHandle = _beginthreadex(0, 0, SearchThreadProc, &gbCancelFindInFindDlg, 0, 0);
        }
      }
      return 0;
    }
    ShowWindow(hWnd, 0);
    gbCancelFindInFindDlg = 1;
    SendMessageW(ghWndListCtrlInFindDialog, LVM_DELETEALLITEMS, 0, 0);
    iItem = 0;
    do
    {
      v33 = gLogPixelsX;
      v34 = SendMessageW(ghWndListCtrlInFindDialog, LVM_GETCOLUMNWIDTH, iItem, 0);
      *(&gdwFindDlgListColumnWidths.width1 + iItem++) = MulDiv(v34, 96, v33);
    }
    while ( iItem < 4 );
    tcscpy_s(gszTextToFindCopy, 256u, gszTextToFind);
    return 1;
  }
  if ( uMsg != WM_INITDIALOG )
  {
    switch ( uMsg )
    {
      case WM_CLOSE:
        SendMessageW(hWnd, WM_COMMAND, 2u, 0);
        return 1;
      case WM_SHOWWINDOW:
        if ( wParam == SW_PARENTCLOSING )
        {
          SetDlgItemTextW(hWnd, IDD_FINDDIALOG_STATIC_SEARCH_TEXT, gpszTargetName);
          InitTreeList(ghWndListCtrlInFindDialog, ghDefaultFont);
          SendMessageW(ghWndListCtrlInFindDialog, LVM_DELETEALLITEMS, 0, 0);
          SetDlgItemTextW(hWnd, IDD_FINDDIALOG_STATIC_SUBSTRING, L"Handle or DLL substring:");
          gdwRefreshRateOfSearchCopy = gdwRefreshRateOfSearch;
          gdwRefreshRateOfSearch = 0;
          SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, L"Paused");
          return 1;
        }
        gdwRefreshRateOfSearch = gdwRefreshRateOfSearchCopy;
        SetEvent(ghEventRefreshSearchResult);
        if ( !gdwRefreshRateOfSearchCopy )
          return 1;
        SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, gpszTargetName);
        return 1;
      case WM_DRAWITEM:
        FindDlg_DrawItem(lParam);
        return 0;
      case WM_MEASUREITEM:
        return HandleMeasureItem(hWnd, uMsg, wParam, lParam);
      case WM_NOTIFY:
        switch ( lParam->hdr.code )
        {
          case LVN_COLUMNCLICK:
            v5 = lParam->iSubItem;
            if ( v5 == gnItemSortedInFindDlg )
            {
              v6 = gbFINDDLGLISTAscending == 0;
              gbFINDDLGLISTAscending = gbFINDDLGLISTAscending == 0;
            }
            else
            {
              v6 = gbFINDDLGLISTAscending;
            }
            InitTreeListSortableHeader(lParam->hdr.hwndFrom, gnItemSortedInFindDlg, v5, v6);
            gnItemSortedInFindDlg = lParam->iSubItem;
            SendMessageW(lParam->hdr.hwndFrom, 0x1030u, gnItemSortedInFindDlg, SortInFindDlgCallback);
            return 0;
          case LVN_DELETEITEM:
            lvItem.iItem = lParam->iItem;
            hWndFrom = lParam->hdr.hwndFrom;
            lvItem.iSubItem = 0;
            lvItem.mask = 4;
            SendMessageW(hWndFrom, LVM_GETITEMW, 0, &lvItem);
            v8 = lvItem.lParam;
            if ( lvItem.lParam->ImgName )
            {
              free(lvItem.lParam->ImgName);
              v8 = lvItem.lParam;
            }
            v9 = v8->szFileName;
            if ( v9 )
              free(v9);
            return 0;
          case LVN_ITEMCHANGED:
          case LVN_SETDISPINFO|0x94:
          case LVN_GETDISPINFO|0x94:
            if ( gdwSelectedItemInFindDialog == SendMessageW(lParam->hdr.hwndFrom, LVM_GETNEXTITEM, 0xFFFFFFFF, 2) )
              return 0;
            gdwSelectedItemInFindDialog = SendMessageW(lParam->hdr.hwndFrom, LVM_GETNEXTITEM, 0xFFFFFFFF, 2);
            if ( gdwSelectedItemInFindDialog == -1 )
              return 0;
            hCursor = SetCursor(::hCursor);
            v10 = lParam->hdr.hwndFrom;
            lvItem.iItem = gdwSelectedItemInFindDialog;
            lvItem.iSubItem = 0;
            lvItem.mask = 4;
            if ( SendMessageW(v10, LVM_GETITEMW, 0, &lvItem) != 1 )
              goto LABEL_41;
            v11 = gpTreeListParamList;
            v40 = lvItem.lParam;
            if ( !gpTreeListParamList )
              goto LABEL_27;
            while ( *(v11 + 17) != lvItem.lParam->ProcessId )
            {
              v11 = *(v11 + 364);
              if ( !v11 )
              {
LABEL_27:
                MessageBoxW(
                  hWnd,
                  L"The selected process is not in the displayed process list.",
                  L"Process Explorer",
                  0x30u);
                return 0;
              }
            }
            FindInfo.lParam = v11;
            FindInfo.flags = 1;
            lvItem.iItem = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
            itemState.stateMask = 3;
            itemState.state = 3;
            SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, lvItem.iItem, &itemState);
            SendMessageW(ghWndTreeListView, LVM_ENSUREVISIBLE, lvItem.iItem, 0);
            g_dwProcessId = v40->ProcessId;
            if ( !gbShowLowerpane )
              OnShowLowerPane(0);
            v12 = v40;
            if ( v40->field_B0 )
            {
              if ( gbShowDllView )
              {
                OnViewHandles(0);
                v12 = v40;
              }
              SearchHandles(hWnd, ghWndHandlesListCtrl, *(v12 + 168), 0);
              SendMessageW(ghWndNewOwner, PMT_MSG_7E8, 0x66u, 0);
            }
            else
            {
              if ( !gbShowDllView )
              {
                OnViewDlls(0);
                v12 = v40;
              }
              SearchDlls(hWnd, ghWndDllsListCtrl, *(v12 + 168), 0);
              SendMessageW(ghWndNewOwner, PMT_MSG_7E8, 0x68u, 0);
            }
            v13 = v40->field_B0;
            if ( !v13 )
            {
              v14 = gpUserDataInVerifySignature;
              if ( gpUserDataInVerifySignature )
              {
                while ( v14->field_24 != v40->field_AC )
                {
                  v14 = v14->Prev;
                  if ( !v14 )
                    goto LABEL_41;
                }
                FindInfo.lParam = v14;
                FindInfo.flags = 1;
                lvItem.iItem = SendMessageW(ghWndDllsListCtrl, 0x1053u, 0xFFFFFFFF, &FindInfo);
                itemState.stateMask = 3;
                itemState.state = 3;
                SendMessageW(ghWndDllsListCtrl, LVM_SETITEMSTATE, lvItem.iItem, &itemState);
                SendMessageW(ghWndDllsListCtrl, LVM_ENSUREVISIBLE, lvItem.iItem, 0);
                if ( lParam->hdr.code == -3 )
                {
                  SetFocus(ghWndDllsListCtrl);
                  PostMessageW(hWnd, WM_COMMAND, IDCANCEL, 0);
                  SetCursor(hCursor);
                  return 0;
                }
              }
              goto LABEL_41;
            }
            v15 = gpUserDataInFindDlg;
            if ( !gpUserDataInFindDlg )
              goto LABEL_41;
            while ( v15->value2C != v13 )
            {
              v15 = v15->Prev;
              if ( !v15 )
              {
                SetCursor(hCursor);
                return 0;
              }
            }
            FindInfo.lParam = v15;
            FindInfo.flags = 1;
            lvItem.iItem = SendMessageW(ghWndHandlesListCtrl, LVM_FINDITEMW, 0xFFFFFFFF, &FindInfo);
            itemState.stateMask = 3;
            itemState.state = 3;
            SendMessageW(ghWndHandlesListCtrl, LVM_SETITEMSTATE, lvItem.iItem, &itemState);
            SendMessageW(ghWndHandlesListCtrl, LVM_ENSUREVISIBLE, lvItem.iItem, 0);
            if ( lParam->hdr.code != -3 )
            {
LABEL_41:
              SetCursor(hCursor);
              return 0;
            }
            PostMessageW(hWnd, WM_COMMAND, IDCANCEL, 0);
            SetFocus(ghWndHandlesListCtrl);
            SetCursor(hCursor);
            break;
          default:
            return 0;
        }
        break;
      default:
        return 0;
    }
    return 0;
  }
  // WM_INITDIALOG
  v16 = operator new(0x40u);
  if ( v16 )
    CResize::CResize(v16, hWnd);
  ghIconMainOfFindDialg = LoadIconW(ghInstance, 0x65);
  SendMessageW(hWnd, 0x80u, 0, ghIconMainOfFindDialg);
  v17 = GetDlgItem(hWnd, 1001);
  ghWndListCtrlInFindDialog = v17;
  v18 = GetWindowLongW(v17, -16);
  SetWindowLongW(ghWndListCtrlInFindDialog, -16, v18 & 0xFFFFFFFD | 1);
  SetWindowLongW(ghWndListCtrlInFindDialog, -21, 3);
  SendMessageW(ghWndListCtrlInFindDialog, LVM_SETEXTENDEDLISTVIEWSTYLE, 0x4020u, 16416);
  v19 = SendMessageW(ghWndListCtrlInFindDialog, 0x104Eu, 0, 0);
  InitToolTips(v19);
  OldListCtrlWndProc = SetWindowLongW(ghWndListCtrlInFindDialog, -4, PEListCtrlWndProc);
  SendMessageW(ghWndListCtrlInFindDialog, 0x30u, ghDefaultFont, 0);
  hImageList = ImageList_Create(16, 16, 1u, 256, 256);
  ghIconMainOfFindDialg = LoadIconW(ghInstance, IDR_ICON_TRIANGLE);
  ImageList_ReplaceIcon(hImageList, -1, ghIconMainOfFindDialg);
  ghIconMainOfFindDialg = LoadIconW(ghInstance, IDR_ICON_TRIANGLE_1);
  ImageList_ReplaceIcon(hImageList, -1, ghIconMainOfFindDialg);
  v21 = GetWindowLongW(ghWndListCtrlInFindDialog, GWL_STYLE);
  SetWindowLongW(ghWndListCtrlInFindDialog, GWL_STYLE, v21 | LVS_SHAREIMAGELISTS);
  SendMessageW(ghWndListCtrlInFindDialog, LVM_SETIMAGELIST, 1u, hImageList);
  if ( gdwFindDlgListColumnWidths.width2 == -1 )
    gdwFindDlgListColumnWidths.width2 = MulDiv(40, gLogPixelsX, 96);
  *nWidths = gdwFindDlgListColumnWidths;
  v44 = gdwFindDlgListColumDefnWidths;
  InitListCtrl(ghWndListCtrlInFindDialog, uIDs, nWidths, 4);
  SendMessageW(ghWndListCtrlInFindDialog, LVM_SETCOLUMNWIDTH, 3u, 65534);
  hwnd = hCursor;
  SetDlgItemTextW(hCursor, IDD_FINDDIALOG_EDITTEXT_EDIT, gszTextToFindCopy);
  if ( gcxFindDlg )
  {
    MoveWindow(hwnd, gRectFindDialog.left, gRectFindDialog.top, gcxFindDlg, gcyFindDlg, FALSE);
    ShowWindow(hwnd, SW_SHOWNORMAL);
    result = 1;
  }
  else
  {
    if ( gWindowPlacement[NormalWindow].rcNormalPosition.right )
      SetWindowPlacement(hwnd, &gWindowPlacement[NormalWindow]);
    ShowWindow(hwnd, SW_NORMAL);
    result = 1;
  }
  return result;
}
// 12C0D80: using guessed type wchar_t aPaused[7];
// 12C6C30: using guessed type __int128 xmmword_12C6C30;
// 12DE8B0: using guessed type char gbFINDDLGLISTAscending;
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;
// 13054C8: using guessed type int sbInited_0;
// 13054D0: using guessed type int gdwSelectedItemInFindDialog;
// 13054D4: using guessed type int gdwRefreshRateOfSearchCopy;
// 13054F0: using guessed type int ghIconMainOfFindDialg;
// 13054F4: using guessed type char gbCancelFindInFindDlg;
// 1305720: using guessed type int gdwStatusBarCount;

//----- (01277400) --------------------------------------------------------
void __cdecl sub_1277400(signed __int64 a1, double *a2, __int64 *a3, _QWORD *a4)
{
  double v4; // xmm0_8
  double v5; // xmm1_8
  double v6; // xmm3_8
  DWORD v7; // ecx
  double v8; // xmm4_8
  double v9; // xmm5_8
  double v10; // xmm1_8
  __int64 v11; // xmm1_8
  struct _FILETIME SystemTimeAsFileTime; // [esp+28h] [ebp-84h]
  __int64 v13; // [esp+30h] [ebp-7Ch]
  __int64 dbMaxValue; // [esp+38h] [ebp-74h]
  double v15; // [esp+40h] [ebp-6Ch]
  struct _MEMORYSTATUSEX v16; // [esp+48h] [ebp-64h]
  struct _MEMORYSTATUS Buffer; // [esp+88h] [ebp-24h]

  *&v13 = 0.0;
  Buffer.dwLength = 32;
  GlobalMemoryStatus(&Buffer);
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  if ( *GlobalMemoryStatusEx )
  {
    v16.dwLength = 64;
    GlobalMemoryStatusEx(&v16);
    if ( a1 )
    {
      *&dbMaxValue = a1;
      v15 = a1 / v16.ullTotalPageFile * 100.0;
      goto LABEL_11;
    }
    *&gpGraphClassData[0]->dbTotalPageFile = v16.ullTotalPageFile * 0.0009765625;
    *&gpGraphClassData[5]->dbTotalPageFile = v16.ullTotalPhys * 0.0009765625;
    *&dbMaxValue = (v16.ullTotalPhys - v16.ullAvailPhys) * 0.0009765625;
    *&v13 = (v16.ullTotalPageFile - v16.ullAvailPageFile);
    v15 = *&v13 * 100.0;
    v4 = v16.ullTotalPageFile;
    v5 = *&v13 * 100.0;
    v6 = *&v13 * 0.0009765625;
    v7 = Buffer.dwTotalPageFile;
    v8 = (v16.ullTotalPhys - v16.ullAvailPhys) * 0.0009765625;
    v9 = gdbMaxValue;
  }
  else
  {
    if ( a1 )
    {
      v15 = a1 / Buffer.dwTotalPageFile * 100.0;
      goto LABEL_11;
    }
    v9 = gdbMaxValue;
    *&gpGraphClassData[0]->dbTotalPageFile = Buffer.dwTotalPageFile * 0.0009765625;
    *&gpGraphClassData[5]->dbTotalPageFile = Buffer.dwTotalPhys * 0.0009765625;
    v7 = Buffer.dwTotalPageFile;
    v8 = (Buffer.dwTotalPhys - Buffer.dwAvailPhys) * 0.0009765625;
    *&dbMaxValue = (Buffer.dwTotalPhys - Buffer.dwAvailPhys) * 0.0009765625;
    v10 = (Buffer.dwTotalPageFile - Buffer.dwAvailPageFile);
    v6 = v10 * 0.0009765625;
    v4 = Buffer.dwTotalPageFile;
    v5 = v10 * 100.0;
  }
  *&v13 = v6;
  v15 = v5 / v4;
  if ( v6 < 0.0 )
  {
    v15 = v9;
    *&v13 = (v7 >> 10);
  }
  UpdateText(gpGraphClassData[5], SystemTimeAsFileTime, *&v8, 0i64, 0);
  UpdateText(gpGraphClassData[0], SystemTimeAsFileTime, v13, 0i64, 0);
LABEL_11:
  v11 = dbMaxValue;
  if ( a2 )
    *a2 = *&v13;
  if ( a3 )
    *a3 = v11;
  if ( a4 )
    *a4 = *&gpGraphClassData[5]->dbTotalPageFile;
}
// 12BCDC0: using guessed type double gdbMaxValue;

//----- (01277720) --------------------------------------------------------
int __cdecl sub_1277720(int a1, wchar_t *Dst, rsize_t SizeInWords)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+8h] [ebp+8h]

  v3 = *(a1 + 636);
  v5 = v3;
  if ( v3 == -1 )
    return tcscpy_s(Dst, SizeInWords, L"n/a");
  if ( v3 & 1 )
    result = tcscpy_s(Dst, SizeInWords, L"Enabled");
  else
    result = tcscpy_s(Dst, SizeInWords, L"Disabled");
  if ( v5 & 8 )
    result = wcscat_s(Dst, SizeInWords, L" (permanent)");
  return result;
}

//----- (01277790) --------------------------------------------------------
int __cdecl sub_1277790(int a1, wchar_t *Dst, size_t SizeInWords)
{
  int result; // eax

  if ( a1 == -1 )
    return swprintf_s(Dst, SizeInWords, gpszTargetName);
  switch ( a1 )
  {
    case 0:
      result = swprintf_s(Dst, SizeInWords, L"Very Low");
      break;
    case 1:
      result = swprintf_s(Dst, SizeInWords, L"Low");
      break;
    case 2:
      result = swprintf_s(Dst, SizeInWords, L"Normal");
      break;
    case 3:
      result = swprintf_s(Dst, SizeInWords, L"High");
      break;
    case 4:
      result = swprintf_s(Dst, SizeInWords, L"Critical");
      break;
    default:
      result = swprintf_s(Dst, SizeInWords, L"%d", a1);
      break;
  }
  return result;
}

//----- (01277850) --------------------------------------------------------
void *__cdecl GetSystemHandlesInfo(int ReturnedLength)
{
  int v1; // eax
  DWORD dwBufLen; // esi
  _SYSTEM_HANDLE_INFORMATION *pbuffer; // eax
  DWORD v4; // eax
  void *result; // eax
  DWORD Len; // esi
  _SYSTEM_HANDLE_INFORMATION *Buffer; // eax
  DWORD Tpye; // eax
  size_t v9; // esi
  DWORD BufferLength; // esi
  struct _SYSTEM_HANDLE_INFORMATION *pBuf; // eax
  DWORD SysemInfoClass; // eax
  size_t dwBufferLength; // esi
  DWORD dwType; // eax
  _SYSTEM_HANDLE_INFORMATION *pbuf; // [esp-Ch] [ebp-14h]
  _SYSTEM_HANDLE_INFORMATION *Buf; // [esp-Ch] [ebp-14h]
  struct _SYSTEM_HANDLE_INFORMATION *pBuffer; // [esp-Ch] [ebp-14h]

  if ( ReturnedLength )
  {
    if ( gpSystemHandleInformation )
      free(gpSystemHandleInformation);
    BufferLength = gdwSystemHandleInfoLength2;
    pBuf = malloc(gdwSystemHandleInfoLength2);
    gpSystemHandleInformation = pBuf;
    pBuffer = pBuf;
    SysemInfoClass = SystemHandleInformation;
    if ( gbServiceNotImplemented )
      SysemInfoClass = SystemExtendedHandleInformation;
    result = NtQuerySystemInformation(SysemInfoClass, pBuffer, BufferLength, &ReturnedLength);
    if ( result )
    {
      while ( result != STATUS_ACCESS_DENIED )
      {
        free(gpSystemHandleInformation);
        gdwSystemHandleInfoLength2 *= 2;
        dwBufferLength = gdwSystemHandleInfoLength2;
        gpSystemHandleInformation = malloc(gdwSystemHandleInfoLength2);
        memset(gpSystemHandleInformation, 0, dwBufferLength);
        dwType = SystemHandleInformation;
        if ( gbServiceNotImplemented )
          dwType = SystemExtendedHandleInformation;
        result = NtQuerySystemInformation(dwType, gpSystemHandleInformation, dwBufferLength, &ReturnedLength);
        if ( !result )
          return result;
      }
      result = memset(gpSystemHandleInformation, 0, gdwSystemHandleInfoLength2);
    }
  }
  else
  {
    // 第一次来取数据，所以要自动调整内存大小
    if ( gpSystemHandleInformation2Copy )
      free(gpSystemHandleInformation2Copy);
    v1 = g_dwProcessId;
    gpSystemHandleInformation2Copy = 0;
    if ( gdwProcessIdOfSystemHandleInformation == g_dwProcessId )
    {
      gpSystemHandleInformation2Copy = gpSystemHandleInformation2;
    }
    else
    {
      if ( gpSystemHandleInformation2 )
      {
        free(gpSystemHandleInformation2);
        v1 = g_dwProcessId;
      }
      gdwProcessIdOfSystemHandleInformation = v1;
    }
    dwBufLen = gdwSystemHandleInfoLength2;
    pbuffer = malloc(gdwSystemHandleInfoLength2);
    gpSystemHandleInformation2 = pbuffer;
    pbuf = pbuffer;
    v4 = SystemHandleInformation;
    if ( gbServiceNotImplemented )
      v4 = SystemExtendedHandleInformation;
    result = NtQuerySystemInformation(v4, pbuf, dwBufLen, &ReturnedLength);
    if ( result )
    {
      while ( result != STATUS_ACCESS_DENIED )
      {
        if ( result == STATUS_INSUFFICIENT_RESOURCES )
        {
          MessageBoxW(0, L"Insufficient system resources to get handle information.", L"Process Explorer", 0x10u);
          v9 = gdwSystemHandleInfoLength2;
          memset(gpSystemHandleInformation2, 0, gdwSystemHandleInfoLength2);
          return memset(gpSystemHandleInformation2, 0, v9);
        }
        free(gpSystemHandleInformation2);
        gdwSystemHandleInfoLength2 *= 2;
        Len = gdwSystemHandleInfoLength2;
        Buffer = malloc(gdwSystemHandleInfoLength2);
        gpSystemHandleInformation2 = Buffer;
        Buf = Buffer;
        Tpye = SystemHandleInformation;
        if ( gbServiceNotImplemented )
          Tpye = SystemExtendedHandleInformation;
        result = NtQuerySystemInformation(Tpye, Buf, Len, &ReturnedLength);
        if ( !result )
          return result;
      }
      result = memset(gpSystemHandleInformation2, 0, gdwSystemHandleInfoLength2);
    }
  }
  return result;
}
// 12E10C0: using guessed type int gdwProcessIdOfSystemHandleInformation;
// 12EABA5: using guessed type char gbServiceNotImplemented;

//----- (01277A70) --------------------------------------------------------
signed int InitDriver()
{
  int v0; // eax
  HMODULE v1; // eax
  DWORD pBuffer; // esi
  unsigned int *v3; // esi
  signed int result; // eax
  int status; // eax
  HMODULE v6; // eax
  HMODULE v7; // eax
  HMODULE v8; // eax
  char v9; // cl
  HMODULE v10; // eax
  HMODULE v11; // eax
  HMODULE v12; // eax
  HMODULE v13; // eax
  unsigned int index; // edx
  REGUSERINFO *pRegUserInfo; // ecx
  wchar_t chKeyName; // ax
  unsigned int nOffset; // edx
  REGUSERINFO *v18; // ecx
  wchar_t v19; // ax
  double ullTotalPageFile; // xmm0_8
  void (__stdcall *GlobalMemoryStatus)(LPMEMORYSTATUS); // esi
  CGraphData *v22; // eax
  HDRVR v23; // [esp+0h] [ebp-90h]
  LONG v24; // [esp+4h] [ebp-8Ch]
  LONG v25; // [esp+8h] [ebp-88h]
  HDRVR v26; // [esp+Ch] [ebp-84h]
  unsigned int InBuffer; // [esp+10h] [ebp-80h]
  struct _MEMORYSTATUSEX ms; // [esp+14h] [ebp-7Ch]
  struct _MEMORYSTATUS MemStatus; // [esp+54h] [ebp-3Ch]
  CPPEH_RECORD ms_exc; // [esp+78h] [ebp-18h]

  InBuffer = 152;
  ghInstance2 = ghInstance;
  v0 = GetSystemMetrics(SM_CXVIRTUALSCREEN);
  gScreenWidth = v0;
  if ( !v0 )
    v0 = GetSystemMetrics(SM_CXSCREEN);
  gScreenWidth = v0 / 2;
  v1 = GetModuleHandle(L"kernel32.dll");
  *GetLongPathNameW = GetProcAddress(v1, "GetLongPathNameW");
  pBuffer = gSystemInfo.dwNumberOfProcessors;
  gpSysProcessorPerfInfo = malloc(sizeof(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * gSystemInfo.dwNumberOfProcessors);
  gpInterruptInfo = malloc(sizeof(_SYSTEM_INTERRUPT_INFORMATION) * pBuffer);
  gpProcessorCycleTimeInfo = malloc(8 * pBuffer);
  TmAdjustPrivilege(L"SeDebugPrivilege");
  TmAdjustPrivilege(L"SeBackupPrivilege");
  TmAdjustPrivilege(L"SeSecurityPrivilege");
  if ( CDriver::Load() == FALSE )
    goto LABEL_7;
  v3 = VirtualAlloc(0, 4u, MEM_COMMIT, PAGE_READWRITE);
  ms_exc.registration.TryLevel = 0;
  if ( !DeviceIoControl_0(IoCtrlID_QueryVersion, &InBuffer, 4u, v3, 4u) || *v3 < InBuffer )
  {
    CDriver::Close(v23, v24, v25);
    if ( CDriver::Load() )
    {
      if ( DeviceIoControl_0(IoCtrlID_QueryVersion, &InBuffer, 4u, v3, 4u) && *v3 >= InBuffer )
        goto LABEL_16;
      MessageBoxW(
        0,
        L"Driver version mismatch. You must reboot before you can run this version of Process Explorer.",
        L"Process Explorer",
        0x10u);
    }
    CDriver::Close(v26, InBuffer, ms.dwLength);
LABEL_16:
    ms_exc.registration.TryLevel = -2;
    return 0;
  }
  ms_exc.registration.TryLevel = -2;
  VirtualFree(v3, 4u, MEM_DECOMMIT);
LABEL_7:
  if ( LoadSystemCalls() )
  {
    status = NtQuerySystemInformation(SystemExtendedHandleInformation, 0, 0, 0);
    if ( status == STATUS_INVALID_INFO_CLASS || (gbServiceNotImplemented = 1, status == STATUS_NOT_IMPLEMENTED) )
      gbServiceNotImplemented = 0;
    ghSCManager = OpenSCManagerW(0, 0, SERVICE_LOCAL);
    *EnumServicesStatusExW = 0;
    if ( ghSCManager )
    {
      v6 = GetModuleHandle(L"advapi32.dll");
      *EnumServicesStatusExW = GetProcAddress(v6, "EnumServicesStatusExW");
      v7 = GetModuleHandle(L"advapi32.dll");
      *QueryServiceConfig2W = GetProcAddress(v7, "QueryServiceConfig2W");
    }
    if ( IsWinServer() )
    {
      v8 = GetModuleHandle(L"kernel32.dll");
      *ProcessIdToSessionId = GetProcAddress(v8, "ProcessIdToSessionId");
      v9 = gbSessionValid;
      if ( *ProcessIdToSessionId )
        v9 = 1;
      gbSessionValid = v9;
    }
    v10 = LoadLibraryW(L"winsta.dll");
    WinStationGetProcessSid = GetProcAddress(v10, "WinStationGetProcessSid");
    v11 = GetModuleHandle(L"kernel32.dll");
    *IsProcessInJob = GetProcAddress(v11, "IsProcessInJob");
    v12 = GetModuleHandle(L"kernel32.dll");
    *QueryInformationJobObject = GetProcAddress(v12, "QueryInformationJobObject");
    v13 = GetModuleHandle(L"kernel32.dll");
    *SetProcessAffinityMask = GetProcAddress(v13, "SetProcessAffinityMask");
    InitializeCriticalSection(&gEnumServiceLock);
    sub_1278790();
    index = 0;
    do
    {
      pRegUserInfo = &gstrRegistryUser[index + 2];
      do
      {
        chKeyName = pRegUserInfo->szKeyName[0];
        pRegUserInfo = (pRegUserInfo + 2);
      }
      while ( chKeyName );
      gstrRegistryUser[index + 2].dwValue = (pRegUserInfo - &gstrRegistryUser[index + 2].szKeyName[1]) >> 1;
      ++index;
    }
    while ( index < 4 );
    nOffset = 0;
    do
    {
      v18 = &gstrRegistryUser[nOffset];
      do
      {
        v19 = v18->szKeyName[0];
        v18 = (v18 + 2);
      }
      while ( v19 );
      gstrRegistryUser[nOffset].dwValue = (v18 - &gstrRegistryUser[nOffset].szKeyName[1]) >> 1;
      ++nOffset;
    }
    while ( nOffset < 2 );
    sub_124B8A0();
    if ( gdwOsType >= 1 )
      sub_1246750(&dword_12EAFA8, 0, &dword_12EAFB0, &dword_12EAFAC);
    gpGraphClassData[GraphIndex_CPU] = InitProcessorScreenData(1, 2, 1);
    gpGraphClassData[GraphIndex_CPU]->Index = 0;
    gpGraphClassData[GraphIndex_CPU]->Color = 0x3C943C;
    *&gpGraphClassData[GraphIndex_CPU]->dbTotalPageFile = gdbMaxValue;
    if ( gpGraphClassData[GraphIndex_CPU]->field_1C == 2 )
    {
      gpGraphClassData[GraphIndex_CPU]->field_48 = 255;
      *&gpGraphClassData[GraphIndex_CPU]->field_40 = gdbMaxValue;
    }
    gpGraphClassData[0] = InitProcessorScreenData(1, 1, 0);
    gpGraphClassData[0]->Index = 1;
    gpGraphClassData[0]->Color = 0xAAAA;
    if ( *GlobalMemoryStatusEx )
    {
      ms.dwLength = 64;
      GlobalMemoryStatusEx(&ms);
      ullTotalPageFile = ms.ullTotalPageFile;
      GlobalMemoryStatus = ::GlobalMemoryStatus;
    }
    else
    {
      MemStatus.dwLength = 32;
      GlobalMemoryStatus = ::GlobalMemoryStatus;
      ::GlobalMemoryStatus(&MemStatus);
      ullTotalPageFile = MemStatus.dwTotalPageFile;
    }
    *&gpGraphClassData[0]->dbTotalPageFile = ullTotalPageFile * 0.0009765625;
    MemStatus.dwLength = 32;
    GlobalMemoryStatus(&MemStatus);
    v22 = InitProcessorScreenData(2, 1, 0);
    gpGraphClassData[GraphIndex_PhysicalMemory] = v22;
    v22->Index = 3;
    gpGraphClassData[5]->Color = 0x4080FF;
    *&gpGraphClassData[GraphIndex_PhysicalMemory]->dbTotalPageFile = MemStatus.dwTotalPhys;
    CSimpleGraphData::Init(&gptrIOGraphData__3UCSimpleGraphData__A);
    CSimpleGraphData::Init(&gptrNetGraphData);
    CSimpleGraphData::Init(&gptrDiskGraphData);
    sub_125E920();
    result = 1;
  }
  else
  {
    if ( theDriver != -1 )
      CloseHandle(theDriver);
    result = 0;
  }
  return result;
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12E4E28: using guessed type int gScreenWidth;
// 12E4E54: using guessed type int gdwOsType;
// 12EA38A: using guessed type char gbSessionValid;
// 12EABA5: using guessed type char gbServiceNotImplemented;
// 12EAFA8: using guessed type int dword_12EAFA8;
// 12EAFAC: using guessed type int dword_12EAFAC;
// 12EAFB0: using guessed type int dword_12EAFB0;

//----- (01277F90) --------------------------------------------------------
LRESULT __cdecl InsertJobToList(HWND hWnd, LPCTSTR lpszText, LPCTSTR lpszSubitemText)
{
  LRESULT result; // eax
  LVITEMW item; // [esp+0h] [ebp-34h]

  memset(&item.iItem, 0, 0x30u);
  item.pszText = lpszText;
  item.mask = 5;
  item.iItem = 0x7FFFFFFF;
  item.iSubItem = 0;
  item.stateMask = 0;
  item.state = 0;
  item.iImage = 0;
  item.lParam = 1;
  result = SendMessageW(hWnd, LVM_INSERTITEMW, 0, &item);
  if ( result != -1 )
  {
    item.iItem = result;
    item.pszText = lpszSubitemText;
    item.mask = 1;
    item.iSubItem = 1;
    result = SendMessageW(hWnd, LVM_SETITEMW, 0, &item);
  }
  return result;
}

//----- (01278030) --------------------------------------------------------
char __cdecl sub_1278030(int ArgList, DWORD dwProcessId)
{
  char result; // al
  HANDLE v3; // eax
  void *v4; // esi
  WCHAR Text; // [esp+4h] [ebp-804h]

  if ( gbConfirmKill
    && (FormatTex(&Text, L"Are you sure you want to kill %s?", ArgList),
        MessageBoxW(ghWndNewOwner, &Text, L"Process Explorer", 0x31u) == 2) )
  {
    SetFocus(ghWndTreeListView);
    result = 0;
  }
  else
  {
    v3 = OpenProcess(1u, 0, dwProcessId);
    v4 = v3;
    if ( v3 )
    {
      if ( TerminateProcess(v3, 1u) )
      {
        CloseHandle(v4);
        Sleep(0xFAu);
        result = 1;
      }
      else
      {
        ErrMsgBox(L"Error terminating process", ghWndNewOwner);
        CloseHandle(v4);
        result = 0;
      }
    }
    else
    {
      ErrMsgBox(L"Error opening process", ghWndNewOwner);
      result = 0;
    }
  }
  return result;
}
// 12E96D4: using guessed type char gbConfirmKill;

//----- (01278140) --------------------------------------------------------
void __cdecl sub_1278140(int ArgList, int a2)
{
  #1077 *i; // esi
  #1077 *v3; // eax
  HANDLE v4; // eax
  void *v5; // edi
  HWND v6; // edi
  DWORD v7; // eax
  WCHAR Buffer[2]; // [esp+0h] [ebp-A08h]
  WCHAR Text; // [esp+4h] [ebp-A04h]
  WCHAR Dst; // [esp+804h] [ebp-204h]

  if ( gbConfirmKill
    && (FormatTex(&Text, L"Are you sure you want to kill %s and its descendants?", ArgList),
        MessageBoxW(ghWndNewOwner, &Text, L"Process Explorer", 0x31u) == 2) )
  {
    SetFocus(ghWndTreeListView);
  }
  else
  {
    for ( i = gpTreeListParamList; i; i = *(i + 364) )
    {
      v3 = i;
      if ( i )
      {
        while ( *(v3 + 17) != a2 )
        {
          v3 = *(v3 + 21);
          if ( !v3 )
            goto LABEL_17;
        }
        v4 = OpenProcess(1u, 0, *(i + 17));
        v5 = v4;
        if ( v4 )
        {
          if ( !TerminateProcess(v4, 1u) )
          {
            FormatTex(&Text, L"Error terminating %s", *(i + 15));
            ErrMsgBox(&Text, ghWndNewOwner);
          }
          CloseHandle(v5);
        }
        else
        {
          FormatTex(&Text, L"Error opening %s", *(i + 15));
          v6 = ghWndNewOwner;
          v7 = GetLastError();
          if ( v7 )
          {
            FormatMessageW(0x1100u, 0, v7, 0x400u, Buffer, 0, 0);
            VLogEntry(&Dst, L"%s: %s", &Text, *Buffer);
            LocalFree(*Buffer);
          }
          else
          {
            VLogEntry(&Dst, L"%s.", &Text);
          }
          MessageBoxW(v6, &Dst, L"Process Explorer", 0x10u);
        }
      }
LABEL_17:
      ;
    }
    Sleep(0xFAu);
  }
}
// 12E96D4: using guessed type char gbConfirmKill;

//----- (01278310) --------------------------------------------------------
int __cdecl sub_1278310(int a1, int a2, wchar_t *Dst, rsize_t SizeInWords)
{
  int result; // eax
  SYSTEM_PROCESS_INFORMATION *i; // ecx

  if ( a1 == -10 )
    return tcscpy_s(Dst, SizeInWords, L"Hardware Interrupts and DPCs");
  for ( i = gpSysProcessInfo; a1 != i->UniqueProcessId || a2 && i->CreateTime.QuadPart > *a2; i = (i + i->NextEntryOffset) )
  {
    if ( !i->NextEntryOffset )
      return tcscpy_s(Dst, SizeInWords, L"<Non-existent Process>");
  }
  if ( i->ImageName.Length )
    result = wcsncpy_s(Dst, SizeInWords, i->ImageName.Buffer, i->ImageName.Length >> 1);
  else
    result = tcscpy_s(Dst, SizeInWords, L"System Idle Process");
  return result;
}

//----- (012783C0) --------------------------------------------------------
// 查询指定进程的用户信息
bool __cdecl QueryProcessUserInfo(HANDLE ProcessHandle, int dwPid, int a3, wchar_t *Buffer1, rsize_t BufferSize1, WCHAR *Buffer2, rsize_t BufferSize2, LPWSTR Name, rsize_t cchName, int a10, int a11)
{
  BOOL ret; // eax
  BOOL (__stdcall *pfnGetTokenInformation)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD); // eax
  BOOL (__stdcall *GetTokenInformation)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD); // ebx
  const wchar_t *v14; // eax
  LARGE_INTEGER nothing; // [esp+10h] [ebp-A24h]
  HANDLE InBuffer; // [esp+18h] [ebp-A1Ch]
  LPWSTR ReferencedDomainName; // [esp+1Ch] [ebp-A18h]
  void *pid; // [esp+20h] [ebp-A14h]
  void *OutBuffer; // [esp+24h] [ebp-A10h]
  DWORD dwSize; // [esp+28h] [ebp-A0Ch]
  char v22; // [esp+2Fh] [ebp-A05h]
  WCHAR v23[256]; // [esp+30h] [ebp-A04h]
  SID *Sid; // [esp+230h] [ebp-804h]

  InBuffer = ProcessHandle;
  pid = dwPid;
  nothing.QuadPart = __PAIR__(a10, a3);
  ReferencedDomainName = Buffer2;
  OutBuffer = 0;
  v22 = 0;
  tcscpy_s(Buffer1, BufferSize1, gpszTargetName);
  tcscpy_s(Buffer2, BufferSize2, gpszTargetName);
  LOBYTE(ret) = a10;
  if ( a10 )
    *nothing.HighPart = 0;
  // 获取进程的用户名
  if ( !WinStationGetProcessSid
    || (LOBYTE(ret) = nothing.LowPart, !nothing.LowPart)
    || (dwSize = 2048, LOBYTE(ret) = WinStationGetProcessSid(NULL, pid, *nothing.LowPart, &Sid, &dwSize), !ret) )
  {
LABEL_8:
    if ( !Name )
      goto LABEL_10;
    goto LABEL_9;
  }
  LOBYTE(ret) = QuerySID(&Sid, Buffer1, BufferSize1, ReferencedDomainName, BufferSize2);
  if ( !ret )
  {
    LOBYTE(ret) = tcscpy_s(Buffer1, BufferSize1, L"<unknown owner>");
    goto LABEL_8;
  }
  v22 = 1;
  if ( gdwOsType < WINDOWS_VISTA || !Name )
    return ret;
LABEL_9:
  LOBYTE(ret) = tcscpy_s(Name, cchName, gpszTargetName);
LABEL_10:
  if ( InBuffer )
  {
    // 读取自定义的驱动信息
    ret = DeviceIoControl(theDriver, 0x8335000C, &InBuffer, 4u, &OutBuffer, 4u, &nothing.LowPart, 0);
    if ( !ret )
    {
      ret = OpenProcessToken(InBuffer, TOKEN_QUERY, &OutBuffer);
      if ( !ret )
        LOBYTE(ret) = tcscpy_s(Buffer1, BufferSize1, L"<unable to open token>");
    }
    if ( OutBuffer )
    {
      pfnGetTokenInformation = ::GetTokenInformation;
      if ( gdwOsType < WINDOWS_VISTA )
        goto LABEL_37;
      if ( !Name )
      {
LABEL_29:
        if ( gdwOsType >= WINDOWS_VISTA )
        {
          if ( a11 && !pfnGetTokenInformation(OutBuffer, TokenUIAccess, a11, 4u, &dwSize) )
            *a11 = 0;
          if ( gdwOsType >= WINDOWS_VISTA )
          {
            GetTokenInformation = ::GetTokenInformation;
            if ( nothing.HighPart
              && !::GetTokenInformation(OutBuffer, TokenVirtualizationEnabled, nothing.HighPart, 4u, &dwSize) )
            {
              *nothing.HighPart = -1;
            }
            goto LABEL_38;
          }
        }
LABEL_37:
        GetTokenInformation = ::GetTokenInformation;
LABEL_38:
        if ( !v22 )
        {
          dwSize = 2048;
          if ( GetTokenInformation(OutBuffer, TokenUser, &Sid, 2048u, &dwSize) )
          {
            if ( !QuerySID(Sid, Buffer1, BufferSize1, ReferencedDomainName, BufferSize2) )
              tcscpy_s(Buffer1, BufferSize1, L"<unknown owner>");
          }
          else
          {
            tcscpy_s(Buffer1, BufferSize1, L"<unable to query owner>");
          }
        }
        LOBYTE(ret) = CloseHandle(OutBuffer);
        return ret;
      }
      pid = 0;
      dwSize = 4;
      if ( gdwOsType >= WINDOWS_8 )
      {
        if ( ::GetTokenInformation(OutBuffer, MaxTokenInfoClass, &pid, 4u, &dwSize) && pid )
        {
          wcscat_s(Name, cchName, L"AppContainer");
LABEL_28:
          pfnGetTokenInformation = ::GetTokenInformation;
          goto LABEL_29;
        }
        pfnGetTokenInformation = ::GetTokenInformation;
      }
      dwSize = 2048;
      if ( pfnGetTokenInformation(OutBuffer, TokenIntegrityLevel, &Sid, 0x800u, &dwSize) )
      {
        QuerySID(Sid, Name, cchName, v23, 0x100u);
        if ( wcsstr(Name, L" Mandatory Level") )
          *wcsstr(Name, L" Mandatory Level") = 0;
      }
      goto LABEL_28;
    }
  }
  else if ( !v22 )
  {
    v14 = L"NT AUTHORITY\\SYSTEM";
    if ( pid )
      v14 = L"<access denied>";
    LOBYTE(ret) = tcscpy_s(Buffer1, BufferSize1, v14);
  }
  return ret;
}
/* Orphan comments:
WinStationGetProcessSid(NULL, dwPid, ftStartTime, pSid, &dwSize);
*/
// 12AD238: using guessed type wchar_t aNtAuthoritySys[20];
// 12E4E54: using guessed type int gdwOsType;

//----- (01278790) --------------------------------------------------------
int sub_1278790()
{
  unsigned __int16 v0; // si
  __int16 *v1; // ebx
  signed int v2; // edi
  void (__stdcall *RtlInitUnicodeString)(); // eax
  HMODULE v4; // eax
  int RtlInitUnicodeString_1; // eax
  HMODULE v6; // eax
  int v7; // eax
  int result; // eax
  char v9; // [esp+Ch] [ebp-2E0h]
  char v10; // [esp+14h] [ebp-2D8h]
  wchar_t *v11; // [esp+1Ch] [ebp-2D0h]
  int v12; // [esp+20h] [ebp-2CCh]
  int v13; // [esp+24h] [ebp-2C8h]
  int v14; // [esp+28h] [ebp-2C4h]
  char *v15; // [esp+2Ch] [ebp-2C0h]
  int v16; // [esp+30h] [ebp-2BCh]
  int v17; // [esp+34h] [ebp-2B8h]
  int v18; // [esp+38h] [ebp-2B4h]
  int v19; // [esp+3Ch] [ebp-2B0h]
  HANDLE hObject; // [esp+40h] [ebp-2ACh]
  __int16 Dst[64]; // [esp+44h] [ebp-2A8h]
  int v22; // [esp+C4h] [ebp-228h]
  wchar_t *Src; // [esp+C8h] [ebp-224h]
  __int16 v24[260]; // [esp+CCh] [ebp-220h]
  __int16 RootPathName[10]; // [esp+2D4h] [ebp-18h]

  v19 = 0;
  v0 = 0;
  v1 = gstrDriverSymLinkName;
  v2 = 'A';
  // 扫描26个字符
  do
  {
    sub_1259D20(RootPathName, L"%c:\\", v2);
    if ( GetDriveTypeW(RootPathName) != 3 && GetDriveTypeW(RootPathName) != 2 )
      goto LABEL_17;
    sub_1259DC0(Dst, L"\\DosDevices\\%c:", v2);
    RtlInitUnicodeString = ::RtlInitUnicodeString;
    v13 = 24;
    v14 = 0;
    v16 = 64;
    if ( !::RtlInitUnicodeString )
    {
      v4 = GetModuleHandle(L"ntdll.dll");
      RtlInitUnicodeString = GetProcAddress(v4, "RtlInitUnicodeString");
      ::RtlInitUnicodeString = RtlInitUnicodeString;
    }
    RtlInitUnicodeString();
    v17 = 0;
    v15 = &v10;
    v18 = 0;
    if ( NtOpenSymbolicLinkObject(&hObject, 0x20001, &v13) )
    {
LABEL_17:
      v7 = v19;
    }
    else
    {
      HIWORD(v22) = 260;
      Src = v24;
      NtQuerySymbolicLinkObject(hObject, &v22, &v12);
      CloseHandle(hObject);
      v11 = Src;
      RtlInitUnicodeString_1 = ::RtlInitUnicodeString;
      v13 = 24;
      v14 = 0;
      v16 = 64;
      if ( !::RtlInitUnicodeString )
      {
        v6 = GetModuleHandle(L"ntdll.dll");
        RtlInitUnicodeString_1 = GetProcAddress(v6, "RtlInitUnicodeString");
        ::RtlInitUnicodeString = RtlInitUnicodeString_1;
      }
      (RtlInitUnicodeString_1)();
      v17 = 0;
      v15 = &v9;
      v18 = 0;
      if ( !NtOpenSymbolicLinkObject(&hObject, 0x20001, &v13) )
      {
        HIWORD(v22) = 260;
        Src = v24;
        NtQuerySymbolicLinkObject(hObject, &v22, &v12);
        CloseHandle(hObject);
      }
      tcscpy_s(v1 - 256, 0x100u, Src);
      *v1 = v0 + 65;
      v7 = v19 + 1;
      v1 += 257;
      ++v19;
    }
    ++v0;
    ++v2;
  }
  while ( v0 < 26u );
  result = 257 * v7;
  gszDeviceHarddi_0[result] = 0;
  return result * 2;
}
// 12E4E30: using guessed type int RtlInitUnicodeString;
// 12EF210: using guessed type int (__stdcall *NtOpenSymbolicLinkObject)(_DWORD, _DWORD, _DWORD);
// 12EF21C: using guessed type int (__stdcall *NtQuerySymbolicLinkObject)(_DWORD, _DWORD, _DWORD);

//----- (01278A20) --------------------------------------------------------
char __cdecl sub_1278A20(HANDLESANDDLLSLISTUSERPARAM *pRowInfo)
{
  char result; // al
  char v2; // dl
  int v3; // esi

  result = 0;
  v2 = pRowInfo->field_18;
  if ( v2 )
  {
    v3 = pRowInfo->field_1C;
    if ( v3 < gdwHighlightDuration )
    {
      pRowInfo->field_14 = v3;
      pRowInfo->field_10 = 2;
      return result;
    }
    if ( v2 )
    {
      result = 1;
      pRowInfo->field_18 = 0;
    }
  }
  pRowInfo->field_10 = 0;
  return result;
}
// 12E5534: using guessed type int gdwHighlightDuration;

//----- (01278A60) --------------------------------------------------------
int __cdecl ErrMsgBox(LPCTSTR lpszFormat, HWND hWnd)
{
  DWORD dwError; // eax
  WCHAR Buffer[2]; // [esp+8h] [ebp-208h]
  __int16 Text[256]; // [esp+Ch] [ebp-204h]

  dwError = GetLastError();
  if ( dwError )
  {
    FormatMessageW(0x1100u, 0, dwError, 0x400u, Buffer, 0, 0);
    VLogEntry(Text, L"%s: %s", lpszFormat, *Buffer);
    LocalFree(*Buffer);
  }
  else
  {
    VLogEntry(Text, L"%s.", lpszFormat);
  }
  return MessageBoxW(hWnd, Text, L"Process Explorer", 0x10u);
}

//----- (01278B10) --------------------------------------------------------
int __stdcall ProcStringsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  #1077 *pUserData; // esi
  HWND hListCtrl; // ebx
  CResize *v7; // eax
  LONG v8; // eax
  HWND v9; // ST14_4
  HWND hWndParent; // eax
  LRESULT v11; // ST14_4
  HWND v12; // eax
  LRESULT v13; // ST14_4
  HWND v14; // eax
  void *ProcessId; // eax
  #1077 *v16; // ecx
  HANDLE ProcessHandle; // eax
  char v18; // al
  HANDLE v19; // esi
  void (__stdcall *SendMessage)(HWND, UINT, WPARAM, LPARAM); // esi
  LRESULT v21; // ST14_4
  HWND v22; // eax
  LRESULT v23; // ST14_4
  HWND v24; // eax
  wchar_t *v25; // eax
  HWND v26; // eax
  HANDLE v27; // esi
  LRESULT nItem; // eax
  HGLOBAL hGlobal; // edi
  _WORD *pBuffer; // eax
  HGLOBAL v31; // eax
  char *v32; // esi
  rsize_t offset; // ST04_4
  LRESULT i; // esi
  HCURSOR v35; // esi
  int v36; // eax
  HCURSOR v37; // esi
  char v38; // bl
  HWND v39; // esi
  HWND v40; // eax
  HWND v41; // eax
  HWND v42; // eax
  WPARAM v43; // [esp-8h] [ebp-29Ch]
  LVITEMEXW item1; // [esp+Ch] [ebp-288h]
  LVITEMEXW lParama; // [esp+40h] [ebp-254h]
  LPCVOID lpBaseAddress; // [esp+74h] [ebp-220h]
  int dwBytesToRead; // [esp+78h] [ebp-21Ch]
  int Indent; // [esp+7Ch] [ebp-218h]
  int xxPixel; // [esp+80h] [ebp-214h]
  HANDLE dwPid; // [esp+84h] [ebp-210h]
  HANDLE hObject; // [esp+88h] [ebp-20Ch]
  #1077 *dwAllocLength; // [esp+8Ch] [ebp-208h]
  __int16 String[256]; // [esp+90h] [ebp-204h]

  hObject = hWnd;
  dwAllocLength = lParam;
  pUserData = GetWindowLongW(hWnd, GWL_USERDATA);
  lParama.mask = 0;
  memset(&lParama.iItem, 0, 0x30u);
  hListCtrl = GetDlgItem(hWnd, IDD_PROCSTRINGS_CTRL_LISTVIEW);
  Indent = 1058;
  LOWORD(xxPixel) = MulDiv(100, gLogPixelsX, 96);
  if ( uMsg > WM_INITDIALOG )
  {
    switch ( uMsg )
    {
      case WM_COMMAND:
        if ( wParam > IDS_PROCEXPLORERMENU_SAVE )
        {
          if ( wParam > 40631 )
          {
            if ( wParam == 40634 && byte_13010E0 )
            {
              v35 = SetCursor(ghArrowCursor);
              sub_1238E30(hObject, hListCtrl, &gOfnInProcStringPage, &gszStringToFind, &byte_13010E0, &word_13010E8);
              SetCursor(v35);
              ReleaseCapture();
            }
          }
          else if ( wParam == 40631 )
          {
            for ( i = 0; i < SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0); ++i )
            {
              item1.stateMask = 2;
              item1.state = 2;
              SendMessageW(hListCtrl, LVM_SETITEMSTATE, i, &item1);
            }
          }
          else
          {
            if ( wParam != 40083 )
            {
              if ( wParam - 40092 > 1 )
                return 0;
              v43 = wParam;
              goto LABEL_50;
            }
            v27 = 0;
            dwAllocLength = 0;
            nItem = SendMessageW(hListCtrl, LVM_GETNEXTITEM, lParama.iItem, LVNI_SELECTED);
            lParama.iItem = nItem;
            if ( nItem != -1 )
            {
              hGlobal = NULL;
              do
              {
                item1.iSubItem = 0;
                item1.pszText = String;
                item1.cchTextMax = 256;
                SendMessageW(hListCtrl, LVM_GETITEMTEXTW, nItem, &item1);
                dwAllocLength = (dwAllocLength + wcslen(String) + 2);
                if ( v27 )
                {
                  hGlobal = GlobalReAlloc(hGlobal, 2 * dwAllocLength + 2, 0);
                  pBuffer = GlobalLock(hGlobal);
                }
                else
                {
                  v31 = GlobalAlloc(0x2002u, 2 * dwAllocLength + 2);
                  hGlobal = v31;
                  pBuffer = GlobalLock(v31);
                  *pBuffer = 0;
                }
                v32 = dwAllocLength + 1;
                dwPid = pBuffer;
                wcscat_s(pBuffer, dwAllocLength + 1, String);
                offset = v32;
                v27 = dwPid;
                wcscat_s(dwPid, offset, L"\r\n");
                GlobalUnlock(hGlobal);
                nItem = SendMessageW(hListCtrl, LVM_GETNEXTITEM, lParama.iItem, LVNI_SELECTED);
                lParama.iItem = nItem;
              }
              while ( nItem != -1 );
              dwPid = hGlobal;
              if ( hGlobal )
              {
                if ( OpenClipboard(hObject) )
                {
                  EmptyClipboard();
                  SetClipboardData(CF_UNICODETEXT, dwPid);
                  CloseClipboard();
                }
              }
            }
          }
        }
        else if ( wParam == IDS_PROCEXPLORERMENU_SAVE )
        {
          if ( *(pUserData + 1) )
          {
            v25 = wcsrchr(*(pUserData + 86), '\\');
            SaveStringToFile(hListCtrl, (v25 + 1));
          }
          else
          {
            SaveStringToFile(hListCtrl, *(pUserData + 15));
          }
        }
        else
        {
          if ( wParam <= 1304 )
          {
            switch ( wParam )
            {
              case IDD_PROCSTRINGS_RADIO_IMAGE:
                SendMessageW(hListCtrl, WM_SETREDRAW, 0, 0);
                SendMessageW(hListCtrl, LVM_DELETEALLITEMS, 0, 0);
                if ( *(pUserData + 1) )
                  sub_12464C0(hListCtrl, *(pUserData + 86));
                else
                  sub_12464C0(hListCtrl, *(pUserData + 198));
                SendMessageW(hListCtrl, 0x101Eu, 0, 0xFFFF);
                SendMessageW(hListCtrl, WM_SETREDRAW, 1u, 0);
                v11 = SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0);
                v12 = GetDlgItem(hWnd, 40009);
                EnableWindow(v12, v11);
                v13 = SendMessageW(hListCtrl, 0x1004u, 0, 0);
                v14 = GetDlgItem(hWnd, 1210);
                EnableWindow(v14, v13);
                break;
              case IDD_MEMSCANPROGRESS_BUTTON_CANCEL:
                EndDialog(hWnd, 0);
                return 1;
              case IDD_PROCSTRINGS_BUTTON_FIND:
                tcscpy_s(&gszStringToFind, 0x2000u, &word_13010E8);
                gOfnInProcStringPage.hInstance = ghInstance;
                gOfnInProcStringPage.lStructSize = 40;
                gOfnInProcStringPage.hwndOwner = hWnd;
                gOfnInProcStringPage.lpstrFindWhat = &gszStringToFind;
                gOfnInProcStringPage.lpstrReplaceWith = 0;
                *&gOfnInProcStringPage.wFindWhatLen = 0x2000;
                gOfnInProcStringPage.lCustData = 0;
                gOfnInProcStringPage.Flags = dword_12E10E0;
                gOfnInProcStringPage.lpfnHook = 0;
                gOfnInProcStringPage.lpTemplateName = 0;
                v9 = FindTextW(&gOfnInProcStringPage);
                hWndParent = GetParent(hWnd);
                SetPropW(hWndParent, L"FindWindow", v9);
                break;
            }
            return 0;
          }
          if ( wParam != IDD_PROCSTRINGS_RADIO_MEMORY )
          {
            if ( wParam != IDS_PROCEXPLORERMENU_EXIT )
              return 0;
            v43 = 40014;
LABEL_50:
            v26 = GetParent(hWnd);
            PostMessageW(v26, WM_COMMAND, v43, 0);
            return 0;
          }
          // IDD_PROCSTRINGS_RADIO_MEMORY
          SendMessageW(hListCtrl, WM_SETREDRAW, 0, 0);
          SendMessageW(hListCtrl, LVM_DELETEALLITEMS, 0, 0);
          if ( *(pUserData + 1) )
          {
            ProcessId = *(pUserData + 0xA);
            v16 = *(pUserData + 0x56);
          }
          else
          {
            ProcessId = *(pUserData + 0x11);
            v16 = *(pUserData + 0xC6);
          }
          dwAllocLength = v16;
          dwPid = ProcessId;
          ProcessHandle = OpenProcess(0x410u, 0, ProcessId);
          hObject = ProcessHandle;
          if ( ProcessHandle )
          {
            if ( *(pUserData + 1) )
            {
              sub_1246620(hListCtrl, ProcessHandle, *(pUserData + 9), *(pUserData + 14));
              v19 = hObject;
            }
            else
            {
              v18 = sub_12603E0(ProcessHandle, dwPid, dwAllocLength, &lpBaseAddress, &dwBytesToRead);
              v19 = hObject;
              if ( v18 )
                sub_1246620(hListCtrl, hObject, lpBaseAddress, dwBytesToRead);
            }
            CloseHandle(v19);
            SendMessage = SendMessageW;
          }
          else
          {
            SendMessage = SendMessageW;
            lParama.mask = 5;
            lParama.iItem = 0x7FFFFFFF;
            lParama.pszText = L"<Error opening process>";
            lParama.lParam = 1;
            SendMessageW(hListCtrl, LVM_INSERTITEMW, 0, &lParama);
          }
          SendMessage(hListCtrl, LVM_SETCOLUMNWIDTH, 0, 0xFFFF);
          SendMessage(hListCtrl, WM_SETREDRAW, 1u, 0);
          v21 = (SendMessage)(hListCtrl, LVM_GETITEMCOUNT, 0, 0);
          v22 = GetDlgItem(hWnd, 40009);
          EnableWindow(v22, v21);
          v23 = SendMessageW(hListCtrl, LVM_GETITEMCOUNT, 0, 0);
          v24 = GetDlgItem(hWnd, IDD_PROCSTRINGS_BUTTON_FIND);
          EnableWindow(v24, v23);
        }
        return 0;
      case WM_CTLCOLOREDIT:
      case WM_CTLCOLORDLG:
      case WM_CTLCOLORSTATIC:
        return sub_1246710(hWnd, wParam);
      default:
        goto LABEL_67;
    }
  }
  if ( uMsg != WM_INITDIALOG )
  {
    switch ( uMsg )
    {
      case WM_DRAWITEM:
        FindDlg_DrawItem(dwAllocLength);
        return 0;
      case WM_MEASUREITEM:
        return HandleMeasureItem(hWnd, uMsg, wParam, dwAllocLength);
      case WM_KEYUP:
        if ( wParam == VK_F3 )
          SendMessageW(hWnd, WM_COMMAND, 40634u, 0);
        return 0;
      case WM_CHAR:
        if ( wParam == 'F' || wParam == 'f' )
        {
          if ( GetKeyState(VK_CONTROL) )
            SendMessageW(hWnd, WM_COMMAND, IDD_PROCSTRINGS_BUTTON_FIND, 0);
        }
        return 0;
      default:
        break;
    }
LABEL_67:
    if ( uMsg == gMSGCommdlg_FindReplace )
    {
      v36 = *(dwAllocLength + 3);
      if ( v36 & 0x40 )
      {
        dword_12E10E0 = gOfnInProcStringPage.Flags & 7;
      }
      else if ( v36 & 8 )
      {
        v37 = SetCursor(ghArrowCursor);
        v38 = sub_1238E30(hObject, hListCtrl, dwAllocLength, &gszStringToFind, &byte_13010E0, &word_13010E8);
        SetCursor(v37);
        ReleaseCapture();
        v39 = hObject;
        v40 = GetParent(hObject);
        v41 = GetPropW(v40, L"FindWindow");
        if ( v38 && v41 )
        {
          PostMessageW(v41, WM_COMMAND, 3u, 0);
          v42 = GetParent(v39);
          SetPropW(v42, L"FindWindow", 0);
        }
        else
        {
          SetFocus(v41);
        }
      }
    }
    return 0;
  }
  // WM_INITDIALOG
  v7 = operator new(0x40u);
  if ( v7 )
    CResize::CResize(v7, hWnd);
  GetWindowTextW(hWnd, String, 256);
  ResizeTab(hWnd);
  SetWindowLongW(hWnd, GWL_USERDATA, dwAllocLength);
  CheckRadioButton(hWnd, IDD_PROCSTRINGS_RADIO_IMAGE, IDD_PROCSTRINGS_RADIO_MEMORY, IDD_PROCSTRINGS_RADIO_IMAGE);
  v8 = GetWindowLongW(hListCtrl, GWL_STYLE);
  SetWindowLongW(hListCtrl, GWL_STYLE, v8 & 0xFFFFFFFD | 1);
  SetWindowLongW(hListCtrl, GWL_WNDPROC, PEListCtrlWndProc);
  SendMessageW(hListCtrl, WM_SETFONT, ghDefaultFont, 0);
  InitListCtrl(hListCtrl, &Indent, &xxPixel, 1);
  PostMessageW(hWnd, WM_COMMAND, IDD_PROCSTRINGS_RADIO_IMAGE, 0);
  return 1;
}
// 12C606C: using guessed type wchar_t aErrorOpeningPr_1[24];
// 12E10E0: using guessed type int dword_12E10E0;
// 12EA32C: using guessed type int gMSGCommdlg_FindReplace;
// 13010E0: using guessed type char byte_13010E0;

//----- (01279520) --------------------------------------------------------
char __usercall SearchDlls@<al>(CHAR *ImageName@<ebx>, HWND hWnd, DWORD dwProcessId, BOOL *bCancelFindInFindDlg)
{
  DWORD v4; // esi
  HWND v5; // edi
  BOOL *v6; // eax
  #1077 *pTreeListParamList; // ecx
  LVITEMUSERDATA *v8; // eax
  LVITEMUSERDATA *v9; // esi
  char v10; // al
  _DWORD *v11; // edi
  DWORD v12; // esi
  bool v13; // zf
  int v14; // ebx
  LVITEMUSERDATA *v15; // ecx
  wchar_t *v16; // eax
  wchar_t *v17; // edx
  int v18; // ecx
  HANDLE v19; // esi
  char v20; // dl
  char v21; // dh
  int v22; // eax
  _PSAPI_WORKING_SET_INFORMATION *ProcWorkingset; // esi
  LVITEMUSERDATA *pUserDataInVerifySignature; // eax
  LVITEMUSERDATA *v26; // esi
  char v27; // al
  SYSTEM_PROCESS_INFORMATION *ProcessInfo; // edi
  #1077 *pTreeListParamList1; // esi
  _RTL_DEBUG_BUFFER *dbgBuffer; // eax
  DWORD dwPid; // ecx
  void *DebugHtradHandle; // edi
  PRTL_PROCESS_MODULES ModuleInformation; // eax
  CAtlStringMgr *pStringMgr; // eax
  const WCHAR *lpszFileName; // esi
  wchar_t *pszPathName; // edi
  DWORD LongPathLength; // eax
  WCHAR *LongPathName; // esi
  signed int FindStringLength; // edi
  int v40; // eax
  const wchar_t *v41; // ebx
  int v42; // eax
  LVITEMUSERDATA *v43; // edi
  char v44; // cl
  char v45; // dl
  int v46; // eax
  char v47; // al
  char v48; // al
  char v49; // cl
  HANDLE ProcessHandle; // edi
  PIMAGE_NT_HEADERS ImgNtHeaders; // eax
  HANDLE FileHandle; // edi
  SYSTEM_PROCESS_INFORMATION *ProcInfo; // edi
  int v54; // esi
  int v55; // ecx
  LVITEMUSERDATA *v56; // eax
  char v57; // dl
  int v58; // ecx
  char v59; // al
  LVITEMUSERDATA *v60; // [esp-188h] [ebp-29A0h]
  DWORD v61; // [esp-20h] [ebp-2838h]
  _PSAPI_WORKING_SET_INFORMATION *v62; // [esp-1Ch] [ebp-2834h]
  wchar_t *v63; // [esp-18h] [ebp-2830h]
  int *v64; // [esp-14h] [ebp-282Ch]
  const void *BaseAddress; // [esp-10h] [ebp-2828h]
  char *v66; // [esp-Ch] [ebp-2824h]
  WCHAR *v67; // [esp-8h] [ebp-2820h]
  wchar_t *v68; // [esp-4h] [ebp-281Ch]
  int v69; // [esp+0h] [ebp-2818h]
  LPARAM v70; // [esp+Ch] [ebp-280Ch]
  int v71; // [esp+10h] [ebp-2808h]
  LVITEMUSERDATA *v72; // [esp+2Ch] [ebp-27ECh]
  struct _FILETIME v73; // [esp+40h] [ebp-27D8h]
  DWORD ThreadId; // [esp+48h] [ebp-27D0h]
  struct _FILETIME LastAccessTime; // [esp+4Ch] [ebp-27CCh]
  PRTL_PROCESS_MODULES v76; // [esp+54h] [ebp-27C4h]
  DWORD ExitCode; // [esp+58h] [ebp-27C0h]
  struct _FILETIME LocalFileTime; // [esp+5Ch] [ebp-27BCh]
  struct _FILETIME CreationTime; // [esp+64h] [ebp-27B4h]
  struct _FILETIME LastWriteTime; // [esp+6Ch] [ebp-27ACh]
  CHAR *v81; // [esp+74h] [ebp-27A4h]
  unsigned int v82; // [esp+78h] [ebp-27A0h]
  DWORD pdwSizeReturned; // [esp+7Ch] [ebp-279Ch]
  _RTL_DEBUG_BUFFER *DebugBuffer; // [esp+80h] [ebp-2798h]
  DWORD v85; // [esp+84h] [ebp-2794h]
  LPCWSTR pszFileName; // [esp+88h] [ebp-2790h]
  int v87; // [esp+8Ch] [ebp-278Ch]
  int v88; // [esp+90h] [ebp-2788h]
  PCHAR pSystemModuleInfo; // [esp+94h] [ebp-2784h]
  _PSAPI_WORKING_SET_INFORMATION *ProcessWorkingSet; // [esp+98h] [ebp-2780h]
  HWND hWnd1; // [esp+9Ch] [ebp-277Ch]
  SYSTEM_PROCESS_INFORMATION *pProcessInfo; // [esp+A0h] [ebp-2778h]
  DWORD ProcessId; // [esp+A4h] [ebp-2774h]
  int v94; // [esp+A8h] [ebp-2770h]
  CHAR *v95; // [esp+ACh] [ebp-276Ch]
  int ResultReturned; // [esp+B2h] [ebp-2766h]
  int v97; // [esp+C4h] [ebp-2754h]
  wchar_t *v98; // [esp+D8h] [ebp-2740h]
  wchar_t Dst; // [esp+DCh] [ebp-273Ch]
  HANDLE v100; // [esp+15Ch] [ebp-26BCh]
  int v101; // [esp+160h] [ebp-26B8h]
  int v102; // [esp+164h] [ebp-26B4h]
  wchar_t *v103; // [esp+168h] [ebp-26B0h]
  LVITEMUSERDATA UserData; // [esp+16Ch] [ebp-26ACh]
  SYSTEMTIME Date; // [esp+2F4h] [ebp-2524h]
  struct _SYSTEMTIME SystemTime; // [esp+304h] [ebp-2514h]
  char ImageBuffer[8192]; // [esp+314h] [ebp-2504h]
  wchar_t ImgName[256]; // [esp+2314h] [ebp-504h]
  __int16 szText[256]; // [esp+2514h] [ebp-304h]
  __int16 TimeStr[64]; // [esp+2714h] [ebp-104h]
  WCHAR DateStr[64]; // [esp+2794h] [ebp-84h]

  v88 = 0;
  v4 = dwProcessId;
  LOBYTE(ImageName) = 0;
  v5 = hWnd;
  v94 = 0;
  LOBYTE(ResultReturned) = 0;
  v87 = 0;
  ProcessWorkingSet = 0;
  szText[0] = 1;
  hWnd1 = hWnd;
  ProcessId = dwProcessId;
  v95 = ImageName;
  memset(&szText[1], 0, 510u);
  v6 = bCancelFindInFindDlg;
  if ( !bCancelFindInFindDlg )
  {
    if ( gdwDllsListColumnCount == bCancelFindInFindDlg || !gbShowLowerpane )
      return 0;
    ProcessWorkingSet = GetProcessWorkingSet(dwProcessId);
    v6 = 0;
  }
  if ( dwProcessId )
  {
    pTreeListParamList = gpTreeListParamList;
    v87 = gpTreeListParamList;
    if ( gpTreeListParamList )
    {
      do
      {
        if ( *(pTreeListParamList + 17) == dwProcessId )
          break;
        pTreeListParamList = *(pTreeListParamList + 364);
      }
      while ( pTreeListParamList );
      v87 = pTreeListParamList;
    }
  }
  if ( !*CreateToolhelp32Snapshot_0 )
  {
    if ( !v6 )
    {
      if ( dwProcessId != gdwProcessIdSearching )
      {
        LOBYTE(ResultReturned) = 1;
        SendMessageW(hWnd, WM_SETREDRAW, 0, 0);
        SendMessageW(hWnd, LVM_DELETEALLITEMS, 0, 0);
        SendMessageW(ghWndStatusBar, SB_GETTEXTW, gdwStatusBarCount - 1, szText);
        SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, L"Refreshing DLLs...");
        UpdateMenu(0, 5);
      }
      pUserDataInVerifySignature = gpUserDataInVerifySignature;
      if ( gpUserDataInVerifySignature )
      {
        do
        {
          v26 = pUserDataInVerifySignature->Prev;
          v72 = pUserDataInVerifySignature;
          v71 = -1;
          v27 = DeleteItemFromListCtrl(ImageName, hWnd, &v70, pUserDataInVerifySignature, &ResultReturned + 1);
          ImageName = ImageName;
          if ( v27 )
            ImageName = 1;
          if ( BYTE1(ResultReturned) )
            ++v88;
          pUserDataInVerifySignature = v26;
        }
        while ( v26 );
        v4 = ProcessId;
        v95 = ImageName;
      }
      v6 = bCancelFindInFindDlg;
    }
    ProcessInfo = gpSysProcessInfo;
    while ( 1 )
    {
      pProcessInfo = ProcessInfo;
      if ( !v6 && ProcessInfo->UniqueProcessId != v4 )
      {
        ProcWorkingset = ProcessWorkingSet;
        goto LABEL_165;
      }
      pTreeListParamList1 = gpTreeListParamList;
      LOBYTE(v81) = 0;
      if ( !gpTreeListParamList )
        goto LABEL_79;
      while ( *(pTreeListParamList1 + 17) != ProcessInfo->UniqueProcessId )
      {
        pTreeListParamList1 = *(pTreeListParamList1 + 364);
        if ( !pTreeListParamList1 )
          goto LABEL_79;
      }
      ImageName = (*(pTreeListParamList1 + 10) >> 4);
      LOBYTE(ImageName) = ImageName & 1;
      v81 = ImageName;
      if ( !ImageName )
      {
LABEL_79:
        dbgBuffer = RtlCreateQueryDebugBuffer(0, 0);
        DebugBuffer = dbgBuffer;
        if ( !dbgBuffer )
          return 0;
        dwPid = ProcessInfo->UniqueProcessId;
        LocalFileTime.dwHighDateTime = dbgBuffer;
        LocalFileTime.dwLowDateTime = dwPid;
        DebugHtradHandle = _beginthreadex(0, 0, QueryDBGInfoThreadProc, &LocalFileTime, 0, &ThreadId);
        if ( WaitForSingleObject(DebugHtradHandle, 4000u) == WAIT_TIMEOUT )
          TerminateThread(DebugHtradHandle, 1u);
        GetExitCodeThread(DebugHtradHandle, &ExitCode);
        CloseHandle(DebugHtradHandle);
        if ( !ExitCode )
        {
          v82 = 0;
          ModuleInformation = DebugBuffer->ModuleInformation;
          v76 = ModuleInformation;
          if ( ModuleInformation->ModuleCount )
          {
            ImageName = ModuleInformation->ModuleEntry[0].ImageName;
            pSystemModuleInfo = ModuleInformation->ModuleEntry[0].ImageName;
            while ( 1 )
            {
              memset(&UserData, 0, 392u);
              UserData.ImageBase = 0;
              UserData.field_24 = *(ImageName - 5);
              UserData.field_38 = *(ImageName - 4);
              LOWORD(UserData.field_3C) = *(ImageName - 2);
              if ( *ImageName == '\\' && ImageName[1] == '?' )
                strcpy_s(ImageName, 0x100u, ImageName + 4);
              pStringMgr = ATL::CAtlStringMgr::GetInstance();
              if ( !pStringMgr )
                AtlThrow(E_FAIL);
              pszFileName = ((pStringMgr->vtptr->GetNilString)(pStringMgr) + 16);
              AsciiToUNICODE(&pszFileName, ImageName);
              lpszFileName = pszFileName;
              pszPathName = _wcsdup(pszFileName);
              if ( *GetLongPathNameW )
              {
                LongPathLength = GetLongPathNameW(pszPathName, 0, 0);
                v85 = LongPathLength;
                if ( LongPathLength )
                {
                  LongPathName = malloc(2 * LongPathLength + 2);
                  GetLongPathNameW(pszPathName, LongPathName, v85 + 1);
                  free(pszPathName);
                  pszPathName = LongPathName;
                  j__free(0);
                  lpszFileName = pszFileName;
                }
              }
              UserData.szPathName = pszPathName;
              tcscpy_s(&UserData.szTargetName[65], 65u, gpszTargetName);
              if ( !bCancelFindInFindDlg )
                break;
              FindStringLength = wcslen(gszTextToFind);
              v40 = *(lpszFileName - 3);
              if ( v40 >= FindStringLength )
              {
                v85 = 0;
                if ( v40 - FindStringLength + 1 > 0 )
                {
                  v41 = lpszFileName;
                  while ( _wcsnicmp(v41, gszTextToFind, FindStringLength) )
                  {
                    ++v41;
                    v42 = *(lpszFileName - 3) - FindStringLength + 1;
                    if ( ++v85 >= v42 )
                    {
                      ImageName = pSystemModuleInfo;
                      goto LABEL_134;
                    }
                  }
                  ImageName = pSystemModuleInfo;
LABEL_117:
                  GetImageVersionInfo(
                    lpszFileName,
                    &UserData.szTargetName[65],
                    0x41u,
                    &UserData.VerInfo,
                    &UserData.ImageDesc);
                  if ( !bCancelFindInFindDlg )
                  {
                    v68 = pProcessInfo->UniqueProcessId;
                    ProcessHandle = OpenProcess(0x410u, 0, v68);
                    if ( ProcessHandle )
                    {
                      v68 = &LastWriteTime.dwHighDateTime;
                      v67 = 0x2000;
                      v66 = ImageBuffer;
                      BaseAddress = *(ImageName - 5);
                      if ( ReadProcessMemory(
                             ProcessHandle,
                             BaseAddress,
                             ImageBuffer,
                             0x2000u,
                             &LastWriteTime.dwHighDateTime) )
                      {
                        ImgNtHeaders = ImageNtHeader(ImageBuffer);
                        if ( ImgNtHeaders )
                        {
                          UserData.ImageBase = ImgNtHeaders->OptionalHeader.ImageBase;
                          if ( ImgNtHeaders->OptionalHeader.ImageBase != *(ImageName - 5) )
                            UserData.field_2C |= 1u;
                        }
                      }
                      CloseHandle(ProcessHandle);
                    }
                  }
                  tcscpy_s(UserData.szTargetName, 65u, gpszTargetName);
                  UserData.CreationTime = 0i64;
                  FileHandle = CreateFile(lpszFileName, GENERIC_READ, 7u, 0, 3u, 0, 0);
                  if ( FileHandle != -1 )
                  {
                    GetFileTime(FileHandle, &SystemTime.wHour, &v73, &CreationTime);
                    CloseHandle(FileHandle);
                    UserData.CreationTime = CreationTime;
                    FileTimeToLocalFileTime(&CreationTime, &LastAccessTime);
                    FileTimeToSystemTime(&LastAccessTime, &Date);
                    GetDateFormatW(0x400u, 1u, &Date, 0, TimeStr, 64);
                    GetTimeFormatW(0x400u, 2u, &Date, 0, DateStr, 64);
                    v68 = DateStr;
                    v67 = TimeStr;
                    FormatString(UserData.szTargetName, L"%s %s", TimeStr, DateStr, v69);
                  }
                  if ( bCancelFindInFindDlg )
                  {
                    ProcInfo = pProcessInfo;
                    wcsncpy_s(ImgName, 0x100u, pProcessInfo->ImageName.Buffer, pProcessInfo->ImageName.Length >> 1);
                    v102 = 0;
                    v98 = _wcsdup(ImgName);
                    v103 = _wcsdup(lpszFileName);
                    v100 = ProcInfo->UniqueProcessId;
                    v97 = 0;
                    v101 = *(ImageName - 5);
                    tcscpy_s(&Dst, 0x40u, L"DLL");
                    InsertRowToDllList(hWnd1, (&ResultReturned + 2));
                  }
                  else
                  {
                    sub_125C400(ProcessWorkingSet, &UserData);
                    UserData.field_14 = 0;
                    if ( gdwProcessIdSearching == ProcessId )
                    {
                      UserData.field_10 = 2;
                    }
                    else
                    {
                      LOBYTE(UserData.field_18) = 0;
                      UserData.field_10 = 0;
                    }
                    if ( OpenExeFromFile(
                           UserData.szPathName,
                           &UserData.StamptTime,
                           &UserData.FileMapping,
                           &UserData.FileMapping + 2) )
                    {
                      UserData.field_2C |= 4u;
                    }
                    qmemcpy(&v60, &UserData, 0x188u);
                    VerifySignature(hWnd1, v60);
                    lpszFileName = pszFileName;
                    LOBYTE(v95) = 1;
                  }
                  goto LABEL_134;
                }
              }
LABEL_134:
              v54 = (lpszFileName - 8);
              if ( _InterlockedDecrement((v54 + 12)) <= 0 )
              {
                v55 = *v54;
                v68 = v54;
                (*(*v55 + 4))(v54);
              }
              ImageName += 0x11C;
              ++v82;
              pSystemModuleInfo = ImageName;
              if ( v82 >= v76->ModuleCount )
                goto LABEL_160;
            }
            v43 = gpUserDataInVerifySignature;
            if ( gpUserDataInVerifySignature )
            {
              while ( 1 )
              {
                if ( v43->field_24 == *(ImageName - 5) && v43->field_38 == *(ImageName - 4) )
                {
                  v68 = lpszFileName;
                  v67 = v43->szPathName;
                  if ( !_wcsicmp(v67, lpszFileName) )
                    break;
                }
                v43 = v43->Prev;
                if ( !v43 )
                  goto LABEL_104;
              }
              v44 = v43->field_18;
              v45 = 0;
              ++v94;
              if ( v44 )
              {
                v46 = v43->field_1C;
                if ( v46 < gdwHighlightDuration )
                {
                  v43->field_10 = 2;
                  v43->field_14 = v46;
LABEL_113:
                  v48 = sub_125C400(ProcessWorkingSet, v43);
                  v49 = v95;
                  if ( v48 )
                    v49 = 1;
                  LOBYTE(v95) = v49;
                  goto LABEL_134;
                }
                if ( v44 )
                {
                  v45 = 1;
                  LOBYTE(v43->field_18) = 0;
                }
              }
              v47 = v95;
              if ( v45 )
                v47 = 1;
              v43->field_10 = 0;
              LOBYTE(v95) = v47;
              goto LABEL_113;
            }
LABEL_104:
            sub_125C400(ProcessWorkingSet, &UserData);
            goto LABEL_117;
          }
LABEL_160:
          RtlDestroyQueryDebugBuffer(DebugBuffer);
          goto LABEL_161;
        }
      }
      if ( !bCancelFindInFindDlg )
      {
        *(pTreeListParamList1 + 10) |= 0x10u;
        v56 = gpUserDataInVerifySignature;
        if ( !gpUserDataInVerifySignature )
        {
LABEL_143:
          memset(&UserData, 0, 0x188u);
          UserData.field_24 = 0;
          LOWORD(UserData.field_3C) = 0;
          UserData.field_38 = 0;
          if ( OpenExeFromFile(
                 UserData.szPathName,
                 &UserData.StamptTime,
                 &UserData.FileMapping,
                 &UserData.FileMapping + 2) )
          {
            UserData.field_2C |= 4u;
          }
          UserData.szPathName = _wcsdup(L"<Unable to query process module information>");
          tcscpy_s(&UserData.szTargetName[65], 0x41u, gpszTargetName);
          tcscpy_s(UserData.szTargetName, 0x41u, gpszTargetName);
          UserData.field_14 = 0;
          UserData.CreationTime = 0i64;
          if ( gdwProcessIdSearching == ProcessId )
          {
            UserData.field_10 = 2;
          }
          else
          {
            LOBYTE(UserData.field_18) = 0;
            UserData.field_10 = 0;
          }
          if ( OpenExeFromFile(
                 UserData.szPathName,
                 &UserData.StamptTime,
                 &UserData.FileMapping,
                 &UserData.FileMapping + 2) )
          {
            UserData.field_2C |= 4u;
          }
          qmemcpy(&v60, &UserData, 0x188u);
          VerifySignature(hWnd1, v60);
LABEL_158:
          LOBYTE(v95) = 1;
          goto LABEL_159;
        }
        while ( v56->field_24 || v56->field_38 )
        {
          v56 = v56->Prev;
          if ( !v56 )
            goto LABEL_143;
        }
        LOBYTE(ImageName) = v56->field_18;
        v57 = 0;
        ++v94;
        if ( ImageName )
        {
          v58 = v56->field_1C;
          if ( v58 < gdwHighlightDuration )
          {
            v56->field_10 = 2;
            v56->field_14 = v58;
            goto LABEL_159;
          }
          if ( ImageName )
          {
            v57 = 1;
            LOBYTE(v56->field_18) = 0;
          }
        }
        v56->field_10 = 0;
        if ( v57 )
          goto LABEL_158;
      }
LABEL_159:
      if ( !v81 )
        goto LABEL_160;
LABEL_161:
      ProcessInfo = pProcessInfo;
      wcsncpy_s(ImgName, 0x100u, pProcessInfo->ImageName.Buffer, pProcessInfo->ImageName.Length >> 1);
      ProcWorkingset = ProcessWorkingSet;
      v64 = &v94;
      v63 = ImgName;
      v62 = ProcessWorkingSet;
      v61 = ProcessInfo->UniqueProcessId;
      v59 = sub_126F870(ImageName, hWnd1, bCancelFindInFindDlg, v87, v61, ProcessWorkingSet, ImgName, &v94);
      ImageName = v95;
      if ( v59 )
        ImageName = 1;
      v95 = ImageName;
LABEL_165:
      if ( !ProcessInfo->NextEntryOffset )
      {
        v5 = hWnd1;
        goto LABEL_168;
      }
      v4 = ProcessId;
      ProcessInfo = (ProcessInfo + ProcessInfo->NextEntryOffset);
      v6 = bCancelFindInFindDlg;
    }
  }
  if ( v6 )
  {
    sub_1275140(ImageName, hWnd, v6);
    return 0;
  }
  if ( dwProcessId != gdwProcessIdSearching )
  {
    LOBYTE(ResultReturned) = 1;
    SendMessageW(hWnd, WM_SETREDRAW, 0, 0);
    SendMessageW(hWnd, LVM_DELETEALLITEMS, 0, 0);
    SendMessageW(ghWndStatusBar, SB_GETTEXTW, gdwStatusBarCount - 1, szText);
    SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, L"Refreshing DLLs...");
    UpdateMenu(0, 5);
  }
  v8 = gpUserDataInVerifySignature;
  if ( gpUserDataInVerifySignature )
  {
    do
    {
      v9 = v8->Prev;
      v72 = v8;
      v71 = -1;
      v10 = DeleteItemFromListCtrl(ImageName, hWnd, &v70, v8, &ResultReturned + 1);
      ImageName = ImageName;
      if ( v10 )
        ImageName = 1;
      if ( BYTE1(ResultReturned) )
        ++v88;
      v8 = v9;
    }
    while ( v9 );
    v4 = ProcessId;
    v95 = ImageName;
  }
  if ( v4 == 8 || v4 == 4 )
  {
    pdwSizeReturned = 1000;
    pSystemModuleInfo = malloc(0x3E8u);
    v11 = pSystemModuleInfo;
    if ( NtQuerySystemInformation(SystemModuleInformation, pSystemModuleInfo, 0x3E8u, &pdwSizeReturned) )
    {
      do
      {
        free(v11);
        pdwSizeReturned += 1000;
        v12 = pdwSizeReturned;
        v11 = malloc(pdwSizeReturned);
      }
      while ( NtQuerySystemInformation(SystemModuleInformation, v11, v12, &pdwSizeReturned) );
      pSystemModuleInfo = v11;
    }
    v13 = *v11 == 0;
    pProcessInfo = 0;
    if ( !v13 )
    {
      v14 = (v11 + 4);
      while ( 1 )
      {
        v15 = gpUserDataInVerifySignature;
        if ( gpUserDataInVerifySignature )
        {
          while ( v15->field_24 != *(v14 - 4) || v15->field_38 != *v14 )
          {
            v15 = v15->Prev;
            if ( !v15 )
              goto LABEL_32;
          }
          v20 = v15->field_18;
          v21 = 0;
          ++v94;
          if ( v20 )
          {
            v22 = v15->field_1C;
            if ( v22 < gdwHighlightDuration )
            {
              v15->field_10 = 2;
              v15->field_14 = v22;
              goto LABEL_53;
            }
            if ( v20 )
            {
              v21 = 1;
              LOBYTE(v15->field_18) = 0;
            }
          }
          v15->field_10 = 0;
          if ( v21 )
          {
            LOBYTE(v15) = 1;
LABEL_52:
            v95 = v15;
            goto LABEL_53;
          }
        }
        else
        {
LABEL_32:
          if ( *(v14 - 4) > gSystemInfo.lpMaximumApplicationAddress )
          {
            memset(&UserData, 0, 0x188u);
            v68 = sub_1259EA0(&DebugBuffer, (v14 + 16))->m_pszData;
            v16 = sub_1244280(v68);
            v17 = &DebugBuffer[-1].Reserved[4];
            UserData.szPathName = v16;
            if ( _InterlockedDecrement(&DebugBuffer[-1].Reserved[7]) <= 0 )
            {
              v18 = *v17;
              v68 = v17;
              (*(*v18 + 4))(v17);
            }
            UserData.field_24 = *(v14 - 4);
            UserData.field_38 = *v14;
            UserData.ImageBase = *(v14 - 4);
            GetImageVersionInfo(
              UserData.szPathName,
              &UserData.szTargetName[65],
              0x41u,
              &UserData.VerInfo,
              &UserData.ImageDesc);
            tcscpy_s(UserData.szTargetName, 0x41u, gpszTargetName);
            UserData.CreationTime = 0i64;
            v19 = CreateFile(UserData.szPathName, GENERIC_READ, 3u, 0, 3u, 0, 0);
            if ( v19 != -1 )
            {
              GetFileTime(v19, &CreationTime, &LastAccessTime, &LastWriteTime);
              CloseHandle(v19);
              UserData.CreationTime = LastWriteTime;
              FileTimeToLocalFileTime(&LastWriteTime, &LocalFileTime);
              FileTimeToSystemTime(&LocalFileTime, &SystemTime);
              GetDateFormatW(0x400u, 1u, &SystemTime, 0, DateStr, 64);
              GetTimeFormatW(0x400u, 2u, &SystemTime, 0, TimeStr, 64);
              v68 = TimeStr;
              v67 = DateStr;
              FormatString(UserData.szTargetName, L"%s %s", DateStr, TimeStr);
            }
            UserData.ImageBase = 0;
            UserData.field_14 = 0;
            if ( gdwProcessIdSearching == ProcessId )
            {
              UserData.field_10 = 2;
            }
            else
            {
              LOBYTE(UserData.field_18) = 0;
              UserData.field_10 = 0;
            }
            if ( OpenExeFromFile(
                   UserData.szPathName,
                   &UserData.StamptTime,
                   &UserData.FileMapping,
                   &UserData.FileMapping + 2) )
            {
              UserData.field_2C |= 4u;
            }
            if ( v87 )
            {
              v68 = UserData.szPathName;
              v67 = *(v87 + 88);
              UserData.field_15C = sub_122BB70(v67, UserData.szPathName);
            }
            qmemcpy(&v60, &UserData, 0x188u);
            VerifySignature(hWnd1, v60);
            v11 = pSystemModuleInfo;
            v15 = 1;
            goto LABEL_52;
          }
        }
LABEL_53:
        v14 += 284;
        pProcessInfo = (pProcessInfo + 1);
        if ( pProcessInfo >= *v11 )
        {
          ImageName = v95;
          break;
        }
      }
    }
    free(v11);
    v5 = hWnd1;
  }
  ProcWorkingset = ProcessWorkingSet;
  if ( !sub_126F870(ImageName, v5, 0, v87, ProcessId, ProcessWorkingSet, 0, &v94) )
  {
LABEL_168:
    if ( !ImageName && v94 == v88 || bCancelFindInFindDlg )
      goto LABEL_172;
  }
  LOBYTE(ImageName) = 1;
LABEL_172:
  gdwProcessIdSearching = ProcessId;
  if ( szText[0] != 1 )
    SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, szText);
  if ( !ImageName && ResultReturned == 1 )
    SendMessageW(v5, WM_SETREDRAW, 1u, 0);
  if ( ProcWorkingset )
    free(ProcWorkingset);
  return ImageName;
}
// 12C43D4: using guessed type wchar_t aRefreshingDlls[19];
// 12E10BC: using guessed type int gdwProcessIdSearching;
// 12E5534: using guessed type int gdwHighlightDuration;
// 12E96CD: using guessed type char gbShowLowerpane;
// 12EF25C: using guessed type int (__stdcall *RtlCreateQueryDebugBuffer)(_DWORD, _DWORD);
// 12EF264: using guessed type int (__stdcall *RtlDestroyQueryDebugBuffer)(_DWORD);
// 1305720: using guessed type int gdwStatusBarCount;

//----- (0127A540) --------------------------------------------------------
char __usercall SearchHandles@<al>(signed int a1@<ebx>, HWND a2, int a3, _BYTE *a4)
{
  HWND v5; // esi
  unsigned int v6; // edi
  int v7; // ebx
  struct _SYSTEM_HANDLE_INFORMATION *v8; // ecx
  unsigned int i; // esi
  FINDDLGLISTITEMPARAM *v10; // eax
  HWND v11; // edi
  FINDDLGLISTITEMPARAM *v12; // esi
  char v13; // al
  FINDDLGLISTITEMPARAM *v14; // edx
  int v15; // eax
  unsigned int j; // esi
  char v17; // bl
  char v18; // cl
  unsigned int v19; // kr00_4
  size_t v20; // ecx
  int v21; // edi
  wchar_t *v22; // esi
  unsigned int v23; // kr04_4
  int StructSize; // esi
  wchar_t *v25; // ecx
  int v26; // edx
  wchar_t v27; // ax
  unsigned int v28; // ecx
  unsigned int v29; // edx
  int idx; // edi
  wchar_t *v31; // eax
  int v32; // edx
  wchar_t v33; // cx
  int v34; // eax
  WCHAR *v35; // edx
  int v36; // eax
  WCHAR v37; // cx
  void *v38; // esp
  _DWORD *v39; // eax
  int v40; // eax
  char v41; // [esp-10C0h] [ebp-36A4h]
  const wchar_t *v42; // [esp-Ch] [ebp-25F0h]
  wchar_t *v43; // [esp-8h] [ebp-25ECh]
  signed int v44; // [esp-4h] [ebp-25E8h]
  LPARAM v45; // [esp+Ch] [ebp-25D8h]
  int v46; // [esp+10h] [ebp-25D4h]
  int v47; // [esp+14h] [ebp-25D0h]
  FINDDLGLISTITEMPARAM *v48; // [esp+2Ch] [ebp-25B8h]
  int a5; // [esp+40h] [ebp-25A4h]
  struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleTableEntry; // [esp+44h] [ebp-25A0h]
  WCHAR *v51; // [esp+54h] [ebp-2590h]
  int v52; // [esp+58h] [ebp-258Ch]
  PSYSTEM_HANDLE_INFORMATION SystemHandleInfo; // [esp+5Ch] [ebp-2588h]
  HWND hWnd; // [esp+60h] [ebp-2584h]
  char v55; // [esp+67h] [ebp-257Dh]
  char v56; // [esp+68h] [ebp-257Ch]
  int v57; // [esp+78h] [ebp-256Ch]
  int v58; // [esp+7Ch] [ebp-2568h]
  char v59; // [esp+80h] [ebp-2564h]
  int v60; // [esp+8Ch] [ebp-2558h]
  int v61; // [esp+90h] [ebp-2554h]
  int v62; // [esp+94h] [ebp-2550h]
  int v63; // [esp+98h] [ebp-254Ch]
  int v64; // [esp+9Ch] [ebp-2548h]
  wchar_t v65; // [esp+A0h] [ebp-2544h]
  wchar_t v66; // [esp+120h] [ebp-24C4h]
  wchar_t v67; // [esp+920h] [ebp-1CC4h]
  HANDLESANDDLLSLISTUSERPARAM RowInfo; // [esp+1128h] [ebp-14BCh]
  wchar_t Dst; // [esp+11E0h] [ebp-1404h]
  wchar_t v70; // [esp+19E0h] [ebp-C04h]
  wchar_t Src; // [esp+1BE0h] [ebp-A04h]
  LPARAM lParam; // [esp+23E0h] [ebp-204h]

  hWnd = a2;
  LOBYTE(a1) = 0;
  v52 = a1;
  LOWORD(lParam) = 1;
  v55 = 0;
  memset(&lParam + 2, 0, 0x1FEu);
  if ( !a4 && (!gdwHandlesListColumnCount || !gbShowLowerpane) )
    return 0;
  GetSystemHandlesInfo(a4 != 0);
  if ( a4 )
  {
    SystemHandleInfo = gpSystemHandleInformation;
LABEL_7:
    v5 = hWnd;
    goto LABEL_8;
  }
  SystemHandleInfo = gpSystemHandleInformation2;
  if ( a3 == dword_12E10B8 )
  {
    v10 = gpUserDataInFindDlg;
    if ( !gpUserDataInFindDlg )
      goto LABEL_7;
    v11 = hWnd;
    do
    {
      v12 = v10->Prev;
      v48 = v10;
      v46 = -1;
      v13 = DeleteItemFromListCtrl(a1, v11, &v45, v10, &HandleTableEntry.Object + 3);
      a1 = a1;
      if ( v13 )
        a1 = 1;
      v10 = v12;
    }
    while ( v12 );
    v52 = a1;
    v5 = v11;
  }
  else
  {
    v5 = hWnd;
    v55 = 1;
    SendMessageW(hWnd, WM_SETREDRAW, 0, 0);
    SendMessageW(hWnd, LVM_DELETEALLITEMS, 0, 0);
    SendMessageW(ghWndStatusBar, SB_GETTEXTW, gdwStatusBarCount - 1, &lParam);
    SendMessageW(ghWndStatusBar, SB_SETTEXTW, gdwStatusBarCount - 1, L"Refreshing handles...");
    UpdateMenu(0, 5);
  }
LABEL_8:
  v6 = 0;
  *&HandleTableEntry.ObjectTypeIndex = 0;
  if ( !sub_125D9D0(SystemHandleInfo) )
    goto LABEL_80;
  do
  {
    GetTopSystemHandleInfo(SystemHandleInfo, v6, &HandleTableEntry);
    v7 = *&HandleTableEntry.UniqueProcessId;
    if ( a4 )
      goto LABEL_46;
    if ( *(*&HandleTableEntry.UniqueProcessId + 4) != a3 )
      goto LABEL_78;
    if ( !SendMessageW(v5, LVM_GETITEMCOUNT, 0, 0) )
      goto LABEL_46;
    v8 = gpSystemHandleInformation2Copy;
    if ( gpSystemHandleInformation2Copy )
    {
      for ( i = 0; v8 && i < v8->NumberOfHandles; ++i )
      {
        GetTopSystemHandleInfo(v8, i, (&HandleTableEntry + 12));
        if ( *HandleTableEntry.GrantedAccess == *v7 && *(HandleTableEntry.GrantedAccess + 8) == *(v7 + 8) )
          goto LABEL_78;
        v8 = gpSystemHandleInformation2Copy;
      }
    }
    v14 = gpUserDataInFindDlg;
    v45 = 4;
    v47 = 0;
    if ( !gpUserDataInFindDlg )
    {
LABEL_31:
      if ( !gbShowUnnamedHandles && v8 )
      {
        for ( j = 0; v8 && j < v8->NumberOfHandles; ++j )
        {
          GetTopSystemHandleInfo(v8, j, (&HandleTableEntry + 12));
          if ( *(HandleTableEntry.GrantedAccess + 8) == *(v7 + 8) && *HandleTableEntry.GrantedAccess == *v7 )
            goto LABEL_78;
          v8 = gpSystemHandleInformation2Copy;
        }
      }
LABEL_46:
      Src = 0;
      sub_125C750(&word_12F05D8[64 * *(v7 + 18)], v7, &Src, 0x400u, &a5);
      if ( !gbShowUnnamedHandles && !Src )
        goto LABEL_78;
      tcscpy_s(&Dst, 0x400u, &Src);
      if ( _wcsicmp(&word_12F05D8[64 * *(v7 + 18)], L"Key") )
      {
        if ( !_wcsicmp(&word_12F05D8[64 * *(v7 + 18)], L"File") || !_wcsicmp(&word_12F05D8[64 * *(v7 + 18)], L"Section") )
          sub_1260DD0(&Src);
      }
      else
      {
        sub_1260EE0(&Src);
      }
      if ( !a4 )
      {
        v60 = *(v7 + 4);
        v62 = *(v7 + 8);
        v63 = *(v7 + 12);
        v61 = *v7;
        v64 = a5;
        tcscpy_s(&v65, 0x40u, &word_12F05D8[64 * *(v7 + 18)]);
        tcscpy_s(&v66, 0x400u, &Dst);
        tcscpy_s(&v67, 0x400u, &Src);
        v58 = 0;
        if ( dword_12E10B8 == a3 )
        {
          v57 = 2;
        }
        else
        {
          v59 = 0;
          v57 = 0;
        }
        v38 = alloca(4288);
        qmemcpy(&v41, &v56, 0x10C0u);
        FindDlg::AppendToListToFind(hWnd);
        v52 = 1;
        goto LABEL_76;
      }
      if ( *a4 == 1 )
        break;
      v19 = wcslen(&Src);
      v20 = wcslen(gszTextToFind);
      if ( v19 < v20 || (v21 = 0, (v19 - v20 + 1) <= 0) )
      {
LABEL_60:
        StructSize = *(v7 + 18);
        v25 = &word_12F05D8[64 * StructSize];
        v26 = (v25 + 1);
        do
        {
          v27 = *v25;
          ++v25;
        }
        while ( v27 );
        v28 = (v25 - v26) >> 1;
        v29 = wcslen(gszTextToFind);
        if ( v28 < v29 )
          goto LABEL_76;
        idx = 0;
        if ( (v28 - v29 + 1) <= 0 )
          goto LABEL_76;
        while ( 1 )
        {
          v42 = &word_12F05D8[idx + (StructSize << 6)];
          if ( !_wcsnicmp(v42, gszTextToFind, v29) )
            break;
          StructSize = *(v7 + 18);
          ++idx;
          v31 = &word_12F05D8[64 * StructSize];
          v32 = (v31 + 1);
          do
          {
            v33 = *v31;
            ++v31;
          }
          while ( v33 );
          v34 = v31 - v32;
          v35 = gszTextToFind;
          v36 = v34 >> 1;
          v51 = &gszTextToFind[1];
          do
          {
            v37 = *v35;
            ++v35;
          }
          while ( v37 );
          v29 = v35 - v51;
          if ( idx >= (v36 - v29 + 1) )
            goto LABEL_76;
        }
      }
      else
      {
        v22 = &Src;
        while ( _wcsnicmp(v22, gszTextToFind, v20) )
        {
          ++v22;
          v23 = wcslen(&Src);
          v20 = wcslen(gszTextToFind);
          v51 = ++v21;
          if ( v21 >= (v23 - v20 + 1) )
            goto LABEL_60;
        }
      }
      v44 = 256;
      v43 = &v70;
      v42 = 0;
      sub_1278310(*(v7 + 4), 0, &v70, 0x100u);
      RowInfo.ImgName = _wcsdup(&v70);
      RowInfo.szFileName = _wcsdup(&Src);
      tcscpy_s(RowInfo.szText, 0x40u, &word_12F05D8[64 * *(v7 + 18)]);
      RowInfo.ProcessId = *(v7 + 4);
      RowInfo.field_10 = 0;
      RowInfo.field_B0 = *(v7 + 8);
      InsertRowToDllList(hWnd, &RowInfo);
LABEL_76:
      if ( SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0) == 10000 )
        break;
      v6 = *&HandleTableEntry.ObjectTypeIndex;
      goto LABEL_78;
    }
    while ( 1 )
    {
      if ( v14->value2C == *(v7 + 8) )
      {
        v15 = v14->value28;
        if ( v15 == *v7 )
          break;
      }
      v14 = v14->Prev;
      if ( !v14 )
        goto LABEL_31;
    }
    v17 = v14->value18;
    v18 = 0;
    if ( v17 )
    {
      v15 = v14->value1C;
      if ( v15 < gdwHighlightDuration )
      {
        v14->value10 = 2;
        v14->value14 = v15;
        goto LABEL_78;
      }
      if ( v17 )
      {
        v18 = 1;
        LOBYTE(v14->value18) = 0;
      }
    }
    v14->value10 = 0;
    if ( v18 )
    {
      LOBYTE(v15) = 1;
      v52 = v15;
    }
LABEL_78:
    *&HandleTableEntry.ObjectTypeIndex = ++v6;
    v39 = sub_125D9D0(SystemHandleInfo);
    v5 = hWnd;
  }
  while ( v6 < v39 );
  LOBYTE(a1) = v52;
LABEL_80:
  v40 = dword_12E10B8;
  if ( !a4 )
    v40 = a3;
  dword_12E10B8 = v40;
  if ( lParam != 1 )
    SendMessageW(ghWndStatusBar, 0x40Bu, gdwStatusBarCount - 1, &lParam);
  if ( !a1 && v55 == 1 )
    SendMessageW(hWnd, 0xBu, 1u, 0);
  return a1;
}
// 12C445C: using guessed type wchar_t aRefreshingHand[22];
// 12E10B8: using guessed type int dword_12E10B8;
// 12E5534: using guessed type int gdwHighlightDuration;
// 12E96CA: using guessed type char gbShowUnnamedHandles;
// 12E96CD: using guessed type char gbShowLowerpane;
// 1305720: using guessed type int gdwStatusBarCount;

//----- (0127AD00) --------------------------------------------------------
char __usercall CTreeList::Initialize@<al>(HWND hWndTreeList, char flags)
{
  int v2; // ebp
  int v3; // edi
  int v4; // esi
  double v5; // st3
  double v6; // st4
  double v7; // st5
  double v8; // st6
  double v9; // st7
  void *v10; // esp
  signed int v11; // ecx
  SYSTEM_PROCESS_INFORMATION *pSysProcessInfoLast; // ecx
  int dwSysProcessInfoSizeLast; // edx
  __int64 v14; // kr10_8
  FILETIME NOW; // rax
  unsigned int DeltaTimeLow; // eax
  unsigned int DeltaTimeHigh; // ecx
  DWORD dwNumberOfProcessors; // edx
  signed int ProcessorIndex; // esi
  int Index; // edi
  DWORD v21; // ecx
  DWORD v22; // edx
  LONG v23; // edx
  unsigned __int64 v24; // kr28_8
  float v25; // xmm0_4
  float v26; // xmm0_4
  double v27; // xmm1_8
  float v28; // xmm0_4
  ProcessorInfo *pProcessorsInfo1; // eax
  float v30; // xmm0_4
  float v31; // xmm0_4
  double v32; // xmm1_8
  float v33; // xmm0_4
  ProcessorInfo *pProcessorsInfo2; // eax
  unsigned __int64 TOTALDeltaTimeHigh; // rax
  #1077 *pTreeListParamList1; // esi
  #1077 *prev; // edi
  int v38; // eax
  signed int v39; // edx
  __m128i v40; // xmm7
  _SYSTEM_INTERRUPT_INFORMATION *v41; // ecx
  SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION *v42; // edi
  LARGE_INTEGER *v43; // eax
  __m128i v44; // xmm6
  __m128i v45; // xmm4
  __m128i v46; // xmm3
  __m128i v47; // xmm5
  int v48; // ecx
  __m128i v49; // xmm0
  __m128i v50; // xmm2
  __m128i v51; // xmm1
  __m128i v52; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm2
  __m128i v55; // xmm0
  __m128i v56; // xmm1
  __m128i v57; // xmm0
  __m128i v58; // xmm2
  __m128i v59; // xmm0
  __m128i v60; // xmm1
  __m128i v61; // xmm5
  __m128i v62; // xmm6
  __m128i v63; // xmm3
  __m128i v64; // xmm4
  __m128i v65; // xmm5
  __m128i v66; // xmm3
  __m128i v67; // xmm4
  __m128i v68; // xmm6
  int v69; // edi
  unsigned int v70; // esi
  LARGE_INTEGER *v71; // edi
  unsigned __int64 v72; // kr30_8
  LONGLONG v73; // kr38_8
  signed __int64 v74; // kr40_8
  unsigned __int64 v75; // kr18_8
  unsigned int v76; // eax
  unsigned int v77; // eax
  int v78; // eax
  int v79; // ecx
  unsigned __int8 v80; // of
  bool v81; // dl
  char v82; // al
  bool v83; // cl
  char v84; // al
  unsigned int v85; // edi
  bool v86; // dl
  char v87; // al
  bool v88; // cl
  char v89; // al
  unsigned int v90; // edi
  float v91; // xmm0_4
  float v92; // xmm0_4
  float v93; // xmm1_4
  float v94; // xmm0_4
  float v95; // xmm0_4
  unsigned int v96; // edx
  unsigned int v97; // ecx
  int v98; // eax
  float v99; // xmm0_4
  float v100; // xmm0_4
  float v101; // xmm1_4
  ProcessorInfo *v102; // eax
  bool v103; // cl
  char v104; // al
  char v105; // al
  signed int v106; // ecx
  char v107; // al
  signed int v108; // ecx
  char v109; // al
  char v110; // cl
  char v111; // al
  int v112; // eax
  int v113; // esi
  int *v114; // edi
  char v115; // al
  int v116; // edi
  int v117; // eax
  int style; // eax
  char v119; // al
  char v120; // cl
  int v121; // edi
  SYSTEM_PROCESS_INFORMATION *v122; // esi
  DWORD v123; // eax
  DWORD v124; // edx
  LONG v125; // esi
  unsigned __int64 v126; // kr68_8
  #1077 *v127; // edi
  DWORD v128; // ecx
  LONG v129; // edx
  int v130; // eax
  signed int v131; // edx
  int v132; // ecx
  char v133; // al
  unsigned int v134; // edx
  DWORD v135; // kr00_4
  DWORD v136; // kr04_4
  unsigned __int64 v137; // kr70_8
  int v138; // ecx
  int v139; // edx
  float v140; // xmm0_4
  float v141; // xmm0_4
  float v142; // xmm1_4
  double v143; // xmm0_8
  float v144; // xmm0_4
  float v145; // xmm0_4
  float v146; // xmm0_4
  float v147; // xmm0_4
  float v148; // xmm1_4
  double v149; // xmm0_8
  __int64 v150; // xmm2_8
  __m128d v151; // xmm1
  double v152; // xmm1_8
  bool v153; // al
  char v154; // al
  double v155; // xmm0_8
  char v156; // al
  int v157; // esi
  char v158; // al
  int v159; // esi
  char v160; // al
  unsigned int v161; // eax
  int v162; // ecx
  ULONG v163; // esi
  int v164; // edx
  _DWORD *v165; // eax
  _DWORD *v166; // ecx
  _WORD *v167; // esi
  _WORD *v168; // eax
  char v169; // al
  unsigned __int8 v170; // al
  unsigned int v171; // eax
  bool v172; // cf
  unsigned __int8 v173; // al
  unsigned __int8 v174; // al
  unsigned __int8 v175; // al
  int v176; // ecx
  char v177; // al
  unsigned __int8 v178; // al
  int v179; // esi
  int v180; // eax
  char v181; // al
  int v182; // eax
  int v183; // ST54_4
  HMENU v184; // eax
  wchar_t *v185; // ecx
  bool v186; // al
  char v187; // al
  char v188; // al
  _DWORD *v189; // esi
  int v190; // eax
  char v191; // al
  int v192; // eax
  char v193; // al
  int v194; // eax
  char v195; // al
  int v196; // eax
  char v197; // al
  int v198; // eax
  char v199; // al
  int v200; // eax
  char v201; // al
  int v202; // eax
  char v203; // al
  int v204; // eax
  char v205; // al
  int v206; // eax
  char v207; // al
  unsigned int v208; // ecx
  int v209; // esi
  char v210; // al
  char v211; // al
  int v212; // edx
  int v213; // eax
  char v214; // al
  LPARAM v215; // esi
  HWND v216; // esi
  int v217; // eax
  unsigned __int8 v218; // al
  int v219; // esi
  char v220; // al
  char v221; // al
  ULONG v222; // eax
  char v223; // al
  unsigned int v224; // ecx
  int v225; // kr08_4
  unsigned int v226; // kr0C_4
  signed __int64 v227; // rax
  float v228; // xmm0_4
  unsigned int v229; // edx
  unsigned int v230; // ecx
  float v231; // xmm0_4
  __int64 dbMaxValue; // ST44_8
  double v233; // xmm0_8
  unsigned int v234; // edx
  unsigned int v235; // ecx
  char v236; // al
  char v237; // al
  unsigned __int64 v238; // kr98_8
  signed __int64 v239; // krA0_8
  signed __int64 v240; // krA8_8
  char v241; // cl
  char v242; // dl
  int v243; // eax
  char v244; // al
  WCHAR *v245; // eax
  int v246; // eax
  signed int v247; // edx
  int v248; // eax
  HANDLE v249; // eax
  DWORD v250; // ecx
  LPBYTE v251; // eax
  const WCHAR *v252; // eax
  HICON v253; // ecx
  HICON v254; // ecx
  DWORD *v255; // ecx
  int v256; // ecx
  unsigned int v257; // edx
  unsigned int *v258; // eax
  int v259; // ecx
  unsigned __int64 v260; // krB0_8
  int v261; // ecx
  ULONG v262; // eax
  int v263; // edx
  _DWORD *v264; // eax
  _DWORD *v265; // ecx
  BOOL v266; // eax
  signed int v267; // ecx
  float v268; // xmm0_4
  float v269; // xmm0_4
  float v270; // xmm1_4
  float v271; // xmm0_4
  float v272; // xmm0_4
  double v273; // xmm0_8
  wchar_t *v274; // eax
  int v275; // eax
  int v276; // eax
  void *v277; // eax
  signed int v278; // edx
  unsigned int v279; // ecx
  unsigned int v280; // edx
  wchar_t *v281; // eax
  int v282; // ecx
  int v283; // eax
  signed __int64 v284; // krC8_8
  signed __int64 v285; // krD0_8
  signed int v286; // esi
  LARGE_INTEGER *v287; // edx
  ULONG *v288; // edi
  LONGLONG v289; // krE8_8
  int v290; // eax
  LRESULT (__stdcall *v291)(HWND, UINT, WPARAM, LPARAM); // esi
  LRESULT v292; // eax
  double v293; // xmm0_8
  bool v294; // cf
  bool v295; // zf
  double v296; // xmm0_8
  unsigned int v297; // esi
  unsigned int v298; // edi
  float v299; // xmm0_4
  float v300; // xmm0_4
  bool v301; // al
  char v302; // al
  double v303; // xmm0_8
  char v304; // al
  char v305; // al
  LRESULT v306; // edi
  signed int i; // esi
  double v308; // xmm0_8
  int v309; // eax
  signed int v310; // eax
  LRESULT v311; // eax
  signed __int64 ArgList; // [esp+0h] [ebp-2758h]
  int v314; // [esp+2Ch] [ebp-272Ch]
  int v315; // [esp+30h] [ebp-2728h]
  int v316; // [esp+38h] [ebp-2720h]
  int v317; // [esp+44h] [ebp-2714h]
  int v318; // [esp+48h] [ebp-2710h]
  int v319; // [esp+6Ch] [ebp-26ECh]
  LRESULT v320; // [esp+70h] [ebp-26E8h]
  int v321; // [esp+74h] [ebp-26E4h]
  int v322; // [esp+8Ch] [ebp-26CCh]
  int v323; // [esp+A0h] [ebp-26B8h]
  double v324; // [esp+A4h] [ebp-26B4h]
  int v325; // [esp+ACh] [ebp-26ACh]
  #1077 *v326; // [esp+B4h] [ebp-26A4h]
  __int64 v327; // [esp+C4h] [ebp-2694h]
  double v328; // [esp+CCh] [ebp-268Ch]
  __int64 v329; // [esp+D4h] [ebp-2684h]
  __int64 v330; // [esp+DCh] [ebp-267Ch]
  int v331; // [esp+E8h] [ebp-2670h]
  int v332; // [esp+ECh] [ebp-266Ch]
  unsigned int v333; // [esp+F0h] [ebp-2668h]
  __int64 v334; // [esp+F4h] [ebp-2664h]
  __m128i v335; // [esp+FCh] [ebp-265Ch]
  double v336; // [esp+104h] [ebp-2654h]
  __m128i v337; // [esp+10Ch] [ebp-264Ch]
  __int64 v338; // [esp+114h] [ebp-2644h]
  int v339; // [esp+11Ch] [ebp-263Ch]
  int v340; // [esp+120h] [ebp-2638h]
  char *v341; // [esp+124h] [ebp-2634h]
  #1077 *v342; // [esp+128h] [ebp-2630h]
  #1077 *v343; // [esp+12Ch] [ebp-262Ch]
  char *v344; // [esp+130h] [ebp-2628h]
  __int64 v345; // [esp+134h] [ebp-2624h]
  float v346; // [esp+140h] [ebp-2618h]
  double v347; // [esp+144h] [ebp-2614h]
  unsigned int prev1; // [esp+14Ch] [ebp-260Ch]
  unsigned int v349; // [esp+150h] [ebp-2608h]
  LVITEMW lvItem; // [esp+154h] [ebp-2604h]
  #1077 *v351; // [esp+188h] [ebp-25D0h]
  unsigned int v352; // [esp+18Ch] [ebp-25CCh]
  #1077 *v353; // [esp+190h] [ebp-25C8h]
  __int64 v354; // [esp+194h] [ebp-25C4h]
  __int64 v355; // [esp+19Ch] [ebp-25BCh]
  HWND hWndTreeList1; // [esp+1A4h] [ebp-25B4h]
  unsigned int v357; // [esp+1A8h] [ebp-25B0h]
  int v358; // [esp+1ACh] [ebp-25ACh]
  unsigned int v359; // [esp+1B0h] [ebp-25A8h]
  double v360; // [esp+1B4h] [ebp-25A4h]
  char v361; // [esp+1C3h] [ebp-2595h]
  #1077 *pTreeListParamList2; // [esp+1C4h] [ebp-2594h]
  ULONG *v363; // [esp+1C8h] [ebp-2590h]
  unsigned int v364; // [esp+1CCh] [ebp-258Ch]
  unsigned int v365; // [esp+1D0h] [ebp-2588h]
  unsigned int v366; // [esp+1D4h] [ebp-2584h]
  char v367; // [esp+1DBh] [ebp-257Dh]
  __m128i v368; // [esp+1DCh] [ebp-257Ch]
  double nUnnamedValue; // [esp+1E4h] [ebp-2574h]
  __int64 v370; // [esp+1F4h] [ebp-2564h]
  unsigned int v371; // [esp+200h] [ebp-2558h]
  unsigned int v372; // [esp+204h] [ebp-2554h]
  unsigned int v373; // [esp+208h] [ebp-2550h]
  unsigned int v374; // [esp+20Ch] [ebp-254Ch]
  unsigned int TOTALDeltaTimeHigh1; // [esp+210h] [ebp-2548h]
  wchar_t *v376; // [esp+214h] [ebp-2544h]
  int v377; // [esp+218h] [ebp-2540h]
  unsigned int v378; // [esp+21Ch] [ebp-253Ch]
  unsigned int DeltaTimeHigh1; // [esp+220h] [ebp-2538h]
  unsigned __int8 v380; // [esp+227h] [ebp-2531h]
  unsigned int DeltaTimeLow1; // [esp+228h] [ebp-2530h]
  char v382; // [esp+22Fh] [ebp-2529h]
  char *v383; // [esp+230h] [ebp-2528h]
  int v384; // [esp+234h] [ebp-2524h]
  unsigned __int8 v385; // [esp+23Bh] [ebp-251Dh]
  SHFILEINFOW v386; // [esp+23Ch] [ebp-251Ch]
  int v387; // [esp+4F4h] [ebp-2264h]
  int v388; // [esp+504h] [ebp-2254h]
  int v389; // [esp+508h] [ebp-2250h]
  char v390; // [esp+50Ch] [ebp-224Ch]
  int v391; // [esp+51Ch] [ebp-223Ch]
  HICON v392; // [esp+528h] [ebp-2230h]
  HICON v393; // [esp+52Ch] [ebp-222Ch]
  wchar_t *v394; // [esp+530h] [ebp-2228h]
  HANDLE v395; // [esp+538h] [ebp-2220h]
  wchar_t *v396; // [esp+53Ch] [ebp-221Ch]
  HANDLE v397; // [esp+540h] [ebp-2218h]
  int v398; // [esp+544h] [ebp-2214h]
  int v399; // [esp+548h] [ebp-2210h]
  wchar_t *v400; // [esp+54Ch] [ebp-220Ch]
  ULONG v401; // [esp+550h] [ebp-2208h]
  int v402; // [esp+558h] [ebp-2200h]
  int v403; // [esp+55Ch] [ebp-21FCh]
  HWND v404; // [esp+75Ch] [ebp-1FFCh]
  bool v405; // [esp+760h] [ebp-1FF8h]
  FILETIME v406; // [esp+764h] [ebp-1FF4h]
  unsigned int v407; // [esp+770h] [ebp-1FE8h]
  int v408; // [esp+778h] [ebp-1FE0h]
  _BYTE v409[3]; // [esp+77Dh] [ebp-1FDBh]
  __int16 v410; // [esp+782h] [ebp-1FD6h]
  wchar_t *v411; // [esp+804h] [ebp-1F54h]
  const WCHAR *v412; // [esp+80Ch] [ebp-1F4Ch]
  int v413; // [esp+814h] [ebp-1F44h]
  int v414; // [esp+818h] [ebp-1F40h]
  int v415; // [esp+81Ch] [ebp-1F3Ch]
  wchar_t *v416; // [esp+824h] [ebp-1F34h]
  wchar_t *v417; // [esp+82Ch] [ebp-1F2Ch]
  int v418; // [esp+858h] [ebp-1F00h]
  int v419; // [esp+85Ch] [ebp-1EFCh]
  SIZE_T v420; // [esp+860h] [ebp-1EF8h]
  ULONG v421; // [esp+864h] [ebp-1EF4h]
  SIZE_T v422; // [esp+86Ch] [ebp-1EECh]
  SIZE_T v423; // [esp+874h] [ebp-1EE4h]
  SIZE_T v424; // [esp+878h] [ebp-1EE0h]
  SIZE_T v425; // [esp+87Ch] [ebp-1EDCh]
  int v426; // [esp+8ACh] [ebp-1EACh]
  char v427; // [esp+9F4h] [ebp-1D64h]
  void *v428; // [esp+9F8h] [ebp-1D60h]
  bool v429; // [esp+9FCh] [ebp-1D5Ch]
  double v430; // [esp+A04h] [ebp-1D54h]
  LONGLONG v431; // [esp+A1Ch] [ebp-1D3Ch]
  LARGE_INTEGER v432; // [esp+A24h] [ebp-1D34h]
  int v433; // [esp+A34h] [ebp-1D24h]
  int v434; // [esp+A38h] [ebp-1D20h]
  __int64 v435; // [esp+A44h] [ebp-1D14h]
  LONG v436; // [esp+A4Ch] [ebp-1D0Ch]
  int v437; // [esp+A54h] [ebp-1D04h]
  int v438; // [esp+A58h] [ebp-1D00h]
  int v439; // [esp+AA0h] [ebp-1CB8h]
  __int16 Buffer2[40]; // [esp+AB4h] [ebp-1CA4h]
  int v441; // [esp+B04h] [ebp-1C54h]
  __int16 v442; // [esp+1304h] [ebp-1454h]
  int v443; // [esp+1B04h] [ebp-C54h]
  int v444; // [esp+1D04h] [ebp-A54h]
  int v445; // [esp+1F04h] [ebp-854h]
  __int16 Buffer1[256]; // [esp+2104h] [ebp-654h]
  int v447; // [esp+2304h] [ebp-454h]
  int v448; // [esp+2504h] [ebp-254h]
  int v449; // [esp+2704h] [ebp-54h]
  unsigned int v450; // [esp+2748h] [ebp-10h]
  int v451; // [esp+274Ch] [ebp-Ch]
  int v452; // [esp+2750h] [ebp-8h]
  int res; // [esp+2754h] [ebp-4h]
  int retaddr; // [esp+2758h] [ebp+0h]

  v451 = v2;
  v452 = retaddr;
  v10 = alloca(10008);
  v450 = &v451 ^ __security_cookie;
  v315 = v4;
  v314 = v3;
  hWndTreeList1 = hWndTreeList;
  v385 = 0;
  v358 = 0;
  v342 = 0;
  Buffer1[0] = 0;
  v352 = 0;
  v347 = 0.0;
  v360 = 0.0;
  *&v354 = 0.0;
  v353 = 0;
  v328 = 0.0;
  v345 = 0i64;
  v338 = 0i64;
  v329 = 0i64;
  v355 = 0i64;
  v370 = 0i64;
  memset(&Buffer1[1], 0, 510u);
  v380 = 0;
  v351 = 0;
  v382 = 0;
  v331 = 0;
  v332 = 0;
  v367 = 0;
  v330 = 0i64;
  nUnnamedValue = 0.0;
  FlushTrace(&gEventTraceProperties);
  sub_126F7C0(&gDataInfo1);
  sub_126F7C0(&gDataInfo2);
  sub_126F7C0(&gDataInfo3);
  v11 = 0;
  if ( dword_12FBC28 != gbShowProcessTree )
    v11 = 1;
  dword_12FBC28 = gbShowProcessTree;
  v384 = v11;
  v442 = 0;
  memset(Buffer2, 0, 80u);
  pSysProcessInfoLast = gpSysProcessInfo1;
  dwSysProcessInfoSizeLast = gdwSysProcessInfoSize1;
  v14 = qword_12EF398;
  gpSysProcessInfo1 = gpSysProcessInfo;
  gdwSysProcessInfoSize1 = gdwSysProcessInfoSize;
  gTimeLastRefresh = gTimeLastRefresh1;
  gpSysProcessInfo = pSysProcessInfoLast;
  gdwSysProcessInfoSize = dwSysProcessInfoSizeLast;
  NOW.dwLowDateTime = LoadSystemInfo(
                        &gpSysProcessInfo,
                        &gdwSysProcessInfoSize,
                        gpSysProcessorPerfInfo,
                        gpInterruptInfo,
                        gpProcessorCycleTimeInfo,
                        &qword_12EF398,
                        &nUnnamedValue);
  gTimeLastRefresh1 = NOW;
  DeltaTimeHigh = (*&NOW - *&gTimeLastRefresh) >> 32;
  DeltaTimeLow = NOW.dwLowDateTime - gTimeLastRefresh.dwLowDateTime;
  DeltaTimeLow1 = DeltaTimeLow;
  v357 = LODWORD(nUnnamedValue) + qword_12EF398 - v14;
  dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
  DeltaTimeHigh1 = DeltaTimeHigh;
  v359 = (*&nUnnamedValue + qword_12EF398 - v14) >> 32;
  if ( gSystemInfo.dwNumberOfProcessors <= 1 || (ProcessorIndex = 0, gSystemInfo.dwNumberOfProcessors <= 0) )
  {
    nUnnamedValue = v324;
  }
  else
  {
    Index = 0;
    do
    {
      v21 = gpSysProcessorPerfInfo[Index].IdleTime.LowPart;
      v378 = gpSysProcessorPerfInfo[Index].KernelTime.LowPart;
      v371 = gpSysProcessorPerfInfo[Index].KernelTime.HighPart;
      v22 = gpSysProcessorPerfInfo[Index].UserTime.LowPart;
      v172 = v22 < v21;
      v374 = v22 - v21;
      v373 = gpSysProcessorPerfInfo[Index].UserTime.HighPart;
      v23 = gpSysProcessorPerfInfo[Index].IdleTime.HighPart;
      v373 -= v172 + v23;
      v172 = __CFADD__(v378, v374);
      v374 += v378;
      v373 += v371 + v172;
      v24 = __PAIR__(v371, v378) - __PAIR__(v23, v21);
      v371 = (__PAIR__(v371, v378) - __PAIR__(v23, v21)) >> 32;
      v378 = v24;
      if ( DeltaTimeHigh1 | DeltaTimeLow1 )
      {
        v25 = (__PAIR__(v373, v374) - *&gpProcessorsInfo[ProcessorIndex]->DeltaTime);
        nUnnamedValue = v25 * 100.0;
        v26 = __PAIR__(DeltaTimeHigh1, DeltaTimeLow1);
        v27 = nUnnamedValue / v26;
      }
      else
      {
        v27 = 0.0;
      }
      v28 = v27;
      pProcessorsInfo1 = gpProcessorsInfo[ProcessorIndex];
      pProcessorsInfo1->DeltaTime = v374;
      pProcessorsInfo1->UserTimeHigh = v373;
      nUnnamedValue = v28;
      if ( DeltaTimeHigh1 | DeltaTimeLow1 )
      {
        v30 = (__PAIR__(v371, v378) - *&gpProcessorsInfo[ProcessorIndex]->KernelTime);
        v336 = v30 * 100.0;
        v31 = __PAIR__(DeltaTimeHigh1, DeltaTimeLow1);
        v32 = v336 / v31;
      }
      else
      {
        v32 = 0.0;
      }
      v33 = v32;
      pProcessorsInfo2 = gpProcessorsInfo[ProcessorIndex];
      pProcessorsInfo2->KernelTime.dwLowDateTime = v378;
      pProcessorsInfo2->KernelTime.dwHighDateTime = v371;
      UpdateText(gpProcessorsInfo[ProcessorIndex], gTimeLastRefresh1, *&nUnnamedValue, *&v33, 0);
      dwNumberOfProcessors = gSystemInfo.dwNumberOfProcessors;
      ++ProcessorIndex;
      ++Index;
    }
    while ( ProcessorIndex < gSystemInfo.dwNumberOfProcessors );
    DeltaTimeLow = DeltaTimeLow1;
    DeltaTimeHigh = DeltaTimeHigh1;
  }
  TOTALDeltaTimeHigh = dwNumberOfProcessors * __PAIR__(DeltaTimeHigh, DeltaTimeLow);
  pTreeListParamList1 = gpTreeListParamList;
  TOTALDeltaTimeHigh1 = TOTALDeltaTimeHigh;
  v373 = HIDWORD(v338);
  DeltaTimeHigh1 = HIDWORD(TOTALDeltaTimeHigh);
  pTreeListParamList2 = gpTreeListParamList;
  v346 = 0.0;
  v371 = v338;
  if ( gpTreeListParamList )
  {
    while ( 1 )
    {
      if ( *(pTreeListParamList1 + 0x13) != -1 || !*(pTreeListParamList1 + 17) )
        *(pTreeListParamList1 + 164) = 0i64;
      v295 = *(pTreeListParamList1 + 17) == -10;
      prev = *(pTreeListParamList1 + 364);
      prev1 = *(pTreeListParamList1 + 364);
      if ( v295 )
        break;
      style = *(pTreeListParamList1 + 10);
      if ( (!(style & 2) || style & 1 && byte_12E96D6) && *(pTreeListParamList1 + 11) != -1 )
      {
        DeleteItemFromTreeList(ghWndTreeListView, pTreeListParamList1);
        lvItem.lParam = pTreeListParamList1;
        lvItem.iItem = -1;
        DeleteItemFromListCtrl(&res, hWndTreeList1, &lvItem, pTreeListParamList1, &v385);
        LOBYTE(v384) = 1;
      }
      else
      {
        lvItem.lParam = pTreeListParamList1;
        lvItem.iItem = -1;
        v119 = DeleteItemFromListCtrl(&res, hWndTreeList1, &lvItem, pTreeListParamList1, &v385);
        v120 = v384;
        if ( v119 )
          v120 = 1;
        LOBYTE(v384) = v120;
      }
      if ( !v385 )
        goto LABEL_98;
      v117 = v358;
LABEL_97:
      v358 = v117 + 1;
      *(pTreeListParamList1 + 363) = v352;
      v352 = pTreeListParamList1;
LABEL_98:
      pTreeListParamList2 = prev;
      pTreeListParamList1 = prev;
      if ( !prev )
        goto LABEL_99;
    }
    v380 = 1;
    v325 = 1;
    v326 = pTreeListParamList1;
    lvItem.iItem = SendMessageW(ghWndTreeListView, LVM_FINDITEMW, 0xFFFFFFFF, &v325);
    if ( lvItem.iItem == -1 )
    {
      v38 = *(pTreeListParamList1 + 10);
      if ( v38 & 2 )
      {
        if ( !(v38 & 1) || !byte_12E96D6 )
          sub_1237F20(ghWndTreeListView, pTreeListParamList1);
      }
    }
    v39 = 0;
    lvItem.lParam = pTreeListParamList1;
    v338 = 0i64;
    v336 = 0.0;
    v334 = 0i64;
    nUnnamedValue = 0.0;
    if ( gSystemInfo.dwNumberOfProcessors <= 0 )
    {
      v69 = HIDWORD(v334);
      v365 = HIDWORD(nUnnamedValue);
      v383 = LODWORD(nUnnamedValue);
      v364 = HIDWORD(v338);
      v378 = v338;
      v372 = HIDWORD(v336);
      v366 = LODWORD(v336);
      v77 = v334;
      DeltaTimeLow1 = v334;
    }
    else
    {
      if ( gSystemInfo.dwNumberOfProcessors < 4 )
      {
        v69 = HIDWORD(v334);
        v365 = HIDWORD(nUnnamedValue);
        v383 = LODWORD(nUnnamedValue);
        v364 = HIDWORD(v338);
        v378 = v338;
        v372 = HIDWORD(v336);
        v366 = LODWORD(v336);
        DeltaTimeLow1 = v334;
      }
      else
      {
        v40 = 0i64;
        v377 = gSystemInfo.dwNumberOfProcessors - gSystemInfo.dwNumberOfProcessors % 4;
        v41 = gpInterruptInfo;
        v42 = gpProcessorCycleTimeInfo + 2;
        v43 = &gpSysProcessorPerfInfo->DpcTime;
        _mm_store_si128(&v335, 0i64);
        v44 = 0i64;
        _mm_store_si128(&v337, 0i64);
        v45 = 0i64;
        _mm_store_si128(&v368, 0i64);
        v46 = 0i64;
        v47 = 0i64;
        v48 = &v41[1].DpcCount;
        do
        {
          v49 = _mm_cvtsi32_si128(v43[8].LowPart);
          v42 += 4;
          v50 = _mm_cvtsi32_si128(v43[2].LowPart);
          v48 += 96;
          v43 += 24;
          v39 += 4;
          *v51.m128i_i8 = v43[-23];
          v51.m128i_i64[1] = v43[-17].QuadPart;
          v52 = _mm_unpacklo_epi32(
                  _mm_add_epi32(
                    _mm_unpacklo_epi32(v50, v49),
                    _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v48 - 120)), _mm_cvtsi32_si128(*(v48 - 96)))),
                  0i64);
          *v49.m128i_i8 = v43[-24];
          v49.m128i_i64[1] = v43[-18].QuadPart;
          v53 = _mm_add_epi64(v51, v49);
          v54 = _mm_add_epi64(v52, v368);
          v55 = v53;
          v56 = _mm_add_epi64(v53, v337);
          _mm_store_si128(&v335, _mm_add_epi64(v55, v335));
          *v55.m128i_i8 = v42[-6];
          v55.m128i_i64[1] = v42[-5].CycleTime;
          v40 = _mm_add_epi64(v40, v55);
          v57 = _mm_cvtsi32_si128(v43[-4].LowPart);
          _mm_store_si128(&v368, v54);
          v58 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v43[-10].LowPart), v57);
          v59 = _mm_cvtsi32_si128(*(v48 - 48));
          _mm_store_si128(&v337, v56);
          *v56.m128i_i8 = v43[-11];
          v56.m128i_i64[1] = v43[-5].QuadPart;
          v47 = _mm_add_epi64(
                  v47,
                  _mm_unpacklo_epi32(_mm_add_epi32(v58, _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(v48 - 72)), v59)), 0i64));
          *v59.m128i_i8 = v43[-12];
          v59.m128i_i64[1] = v43[-6].QuadPart;
          v60 = _mm_add_epi64(v56, v59);
          *v59.m128i_i8 = v42[-4];
          v45 = _mm_add_epi64(v45, v60);
          v59.m128i_i64[1] = v42[-3].CycleTime;
          v46 = _mm_add_epi64(v46, v60);
          v44 = _mm_add_epi64(v44, v59);
        }
        while ( v39 < v377 );
        v61 = _mm_add_epi64(v47, v368);
        v62 = _mm_add_epi64(v44, v40);
        v63 = _mm_add_epi64(v46, v337);
        v64 = _mm_add_epi64(v45, v335);
        v65 = _mm_add_epi64(v61, _mm_srli_si128(v61, 8));
        v66 = _mm_add_epi64(v63, _mm_srli_si128(v63, 8));
        DeltaTimeLow1 = _mm_cvtsi128_si32(v65);
        v366 = _mm_cvtsi128_si32(v66);
        v67 = _mm_add_epi64(v64, _mm_srli_si128(v64, 8));
        v378 = _mm_cvtsi128_si32(v67);
        v68 = _mm_add_epi64(v62, _mm_srli_si128(v62, 8));
        v383 = _mm_cvtsi128_si32(v68);
        v69 = _mm_cvtsi128_si32(_mm_srli_si128(v65, 4));
        v372 = _mm_cvtsi128_si32(_mm_srli_si128(v66, 4));
        v364 = _mm_cvtsi128_si32(_mm_srli_si128(v67, 4));
        v365 = _mm_cvtsi128_si32(_mm_srli_si128(v68, 4));
      }
      v374 = v69;
      if ( v39 < gSystemInfo.dwNumberOfProcessors )
      {
        v70 = v374;
        v71 = &gpSysProcessorPerfInfo[v39].InterruptTime;
        v363 = &gpInterruptInfo[v39].DpcCount;
        do
        {
          v72 = __PAIR__(v70, *v363 + v71[1].LowPart) + DeltaTimeLow1;
          v70 = (__PAIR__(v70, *v363 + v71[1].LowPart) + DeltaTimeLow1) >> 32;
          DeltaTimeLow1 = v72;
          v73 = *v71 + v71[-1].QuadPart;
          v71 += 6;
          v74 = v73 + __PAIR__(v364, v378);
          v364 = (v73 + __PAIR__(v364, v378)) >> 32;
          v378 = v74;
          v75 = v73 + __PAIR__(v372, v366);
          v372 = v75 >> 32;
          v366 = v75;
          v76 = (gpProcessorCycleTimeInfo[v39].CycleTime + __PAIR__(v365, v383)) >> 32;
          v383 += LODWORD(gpProcessorCycleTimeInfo[v39++].CycleTime);
          v363 += 6;
          v365 = v76;
        }
        while ( v39 < gSystemInfo.dwNumberOfProcessors );
        v374 = v70;
        pTreeListParamList1 = pTreeListParamList2;
        v69 = v374;
      }
      v77 = DeltaTimeLow1;
    }
    v80 = __OFSUB__(v69, (v77 < *(pTreeListParamList1 + 336)) + *(pTreeListParamList1 + 337));
    v79 = (__PAIR__(v69, v77) - *(pTreeListParamList1 + 168)) >> 32;
    v78 = v77 - *(pTreeListParamList1 + 336);
    if ( v79 < 0 || ((v79 < 0) ^ v80) | (v79 == 0) && !v78 )
    {
      nUnnamedValue = 0.0;
      v79 = 0;
      v78 = 0;
    }
    v81 = v78 != *(pTreeListParamList1 + 334) || v79 != *(pTreeListParamList1 + 335);
    *(pTreeListParamList1 + 334) = v78;
    *(pTreeListParamList1 + 335) = v79;
    v82 = ColumnIDIsIllegal(v81, ghWndTreeListView, 1092, lvItem.iItem);
    LOBYTE(v384) = v82 | v384;
    v83 = DeltaTimeLow1 != *(pTreeListParamList1 + 336) || v69 != *(pTreeListParamList1 + 337);
    *(pTreeListParamList1 + 336) = DeltaTimeLow1;
    *(pTreeListParamList1 + 337) = v69;
    v84 = ColumnIDIsIllegal(v83, ghWndTreeListView, 1091, lvItem.iItem);
    LOBYTE(v384) = v84 | v384;
    v85 = v365;
    v86 = __PAIR__(v365, v383) - *(pTreeListParamList1 + 170) != *(pTreeListParamList1 + 169);
    *(pTreeListParamList1 + 169) = __PAIR__(v365, v383) - *(pTreeListParamList1 + 170);
    v87 = ColumnIDIsIllegal(v86, ghWndTreeListView, 1200, lvItem.iItem);
    LOBYTE(v384) = v87 | v384;
    v88 = v383 != *(pTreeListParamList1 + 340) || v85 != *(pTreeListParamList1 + 341);
    *(pTreeListParamList1 + 340) = v383;
    *(pTreeListParamList1 + 341) = v85;
    v89 = ColumnIDIsIllegal(v88, ghWndTreeListView, 1195, lvItem.iItem);
    LOBYTE(v384) = v89 | v384;
    v90 = v364;
    if ( GetProcessorSystemCycleTime )
    {
      if ( v359 | v357 )
      {
        v91 = *(pTreeListParamList1 + 169);
        *&v377 = v91 * 100.0;
        v92 = __PAIR__(v359, v357);
        v93 = *&v377 / v92;
LABEL_59:
        nUnnamedValue = v93;
        if ( v93 > 100.0 )
          nUnnamedValue = gdbMaxValue;
        v97 = v372;
        v96 = (__PAIR__(v372, v366) - *(pTreeListParamList1 + 166)) >> 32;
        v377 = v366 - *(pTreeListParamList1 + 332);
        v172 = __CFADD__(v366, v371);
        v371 += v366;
        *(pTreeListParamList1 + 332) = v366;
        v373 += v97 + v172;
        v98 = DeltaTimeHigh1 | TOTALDeltaTimeHigh1;
        *(pTreeListParamList1 + 333) = v97;
        if ( v98 )
        {
          v99 = __PAIR__(v96, v377);
          *&v377 = v99 * 100.0;
          v100 = __PAIR__(DeltaTimeHigh1, TOTALDeltaTimeHigh1);
          v101 = *&v377 / v100;
        }
        else
        {
          v101 = 0.0;
        }
        UpdateText(*(pTreeListParamList1 + 343), gTimeLastRefresh1, *&nUnnamedValue, *&v101, 0);
        UpdateText(*(pTreeListParamList1 + 227), gTimeLastRefresh1, 0i64, 0i64 >> 63, 0);
        v102 = *(pTreeListParamList1 + 266);
        if ( v102 )
          UpdateText(v102, gTimeLastRefresh1, 0i64, 0i64 >> 63, 0);
        if ( *(pTreeListParamList1 + 40) & 0x40 )
          v360 = nUnnamedValue + v360;
        if ( *(pTreeListParamList1 + 17) )
          v347 = nUnnamedValue + v347;
        if ( nUnnamedValue > *&v354 )
        {
          *&v354 = nUnnamedValue;
          v353 = pTreeListParamList1;
        }
        v103 = v378 != *(pTreeListParamList1 + 330) || v90 != *(pTreeListParamList1 + 331);
        *(pTreeListParamList1 + 330) = v378;
        *(pTreeListParamList1 + 331) = v90;
        v104 = ColumnIDIsIllegal(v103, ghWndTreeListView, 1087, lvItem.iItem);
        LOBYTE(v384) = v104 | v384;
        lvItem.lParam->field_10 = 0;
        v105 = ColumnIDIsIllegal(1, ghWndTreeListView, 1191, lvItem.iItem);
        v106 = v384;
        if ( v105 )
          v106 = 1;
        v377 = v106;
        v107 = ColumnIDIsIllegal(1, ghWndTreeListView, 1193, lvItem.iItem);
        v108 = v377;
        if ( v107 )
          v108 = 1;
        v377 = v108;
        v109 = ColumnIDIsIllegal(1, ghWndTreeListView, 1330, lvItem.iItem);
        v110 = v377;
        if ( v109 )
          v110 = 1;
        v295 = nUnnamedValue == *(pTreeListParamList1 + 162);
        LOBYTE(v384) = v110;
        *(pTreeListParamList1 + 162) = nUnnamedValue;
        ColumnIDIsIllegal(v295 == 0, ghWndTreeListView, 1055, lvItem.iItem);
        *(pTreeListParamList1 + 164) = nUnnamedValue + *(pTreeListParamList1 + 164);
        v111 = ColumnIDIsIllegal(1, ghWndTreeListView, 1637, lvItem.iItem);
        LOBYTE(v384) = v111 | v384;
        v377 = pTreeListParamList1 + 84;
        v112 = *(pTreeListParamList1 + 21);
        if ( v112 )
        {
          v113 = v377;
          v114 = v377;
          do
          {
            *(v112 + 1312) = nUnnamedValue;
            v115 = ColumnIDIsIllegal(1, ghWndTreeListView, 1637, *(*v113 + 44));
            v116 = *v114;
            LOBYTE(v384) = v115 | v384;
            v114 = (v116 + 84);
            v112 = *v114;
          }
          while ( *v114 );
          pTreeListParamList1 = pTreeListParamList2;
        }
        prev = prev1;
        v117 = v358 - 1;
        --lvItem.iItem;
        v385 = 1;
        goto LABEL_97;
      }
    }
    else if ( DeltaTimeHigh1 | TOTALDeltaTimeHigh1 )
    {
      v94 = (__PAIR__(v364, v378) - *(pTreeListParamList1 + 165));
      *&v377 = v94 * 100.0;
      v95 = __PAIR__(DeltaTimeHigh1, TOTALDeltaTimeHigh1);
      v93 = *&v377 / v95;
      goto LABEL_59;
    }
    v93 = 0.0;
    goto LABEL_59;
  }
LABEL_99:
  v121 = HIDWORD(v345);
  v122 = gpSysProcessInfo;
  v333 = v345;
  v377 = HIDWORD(v329);
  prev1 = v329;
  v366 = HIDWORD(v355);
  v364 = v355;
  v365 = HIDWORD(v370);
  v378 = v370;
  v374 = HIDWORD(v330);
  v340 = HIDWORD(v345);
  v363 = v330;
  while ( 1 )
  {
    ++*&Buffer2[24];
    *&Buffer2[28] += v122->NumberOfThreads;
    *&Buffer2[32] += v122->HandleCount;
    v123 = v122->UniqueProcessId;
    DeltaTimeLow1 = v122;
    v376 = v123;
    if ( v123 )
    {
      v124 = v122->KernelTime.LowPart;
      v125 = v122->KernelTime.HighPart;
      v126 = __PAIR__(v125, v124) + *(DeltaTimeLow1 + 40) + __PAIR__(v121, v333);
      v333 += v124 + *(DeltaTimeLow1 + 40);
      v172 = __CFADD__(v124, v371);
      v371 += v124;
      v123 = v376;
      v373 += v125 + v172;
      v122 = DeltaTimeLow1;
      v340 = HIDWORD(v126);
    }
    v127 = gpTreeListParamList;
    v343 = gpTreeListParamList;
    if ( !gpTreeListParamList )
    {
LABEL_108:
      HIDWORD(v355) = v123;
      v383 = OpenProcess(0x410u, 0, v123);
      v341 = v383;
      if ( !v383 )
      {
        if ( GetLastError() == 5 )
          DeviceIoControl(theDriver, 0x8335003C, &v355 + 4, 4u, &v341, 4u, &v336 + 1, 0);
        v383 = v341;
        if ( !v341 )
        {
          HIDWORD(v345) = v122->UniqueProcessId;
          v383 = OpenProcess(0x1000u, 0, HIDWORD(v345));
          v344 = v383;
          if ( !v383 )
          {
            if ( GetLastError() == 5 )
              DeviceIoControl(theDriver, 0x8335003C, &v345 + 4, 4u, &v344, 4u, &v338 + 1, 0);
            v383 = v344;
          }
        }
      }
      memset(&v387, 0, 0x5C0u);
      v395 = v122->UniqueProcessId;
      if ( v122->ImageName.Length )
        wcsncpy_s(&v443, 0x100u, v122->ImageName.Buffer, v122->ImageName.Length >> 1);
      else
        tcscpy_s(&v443, 0x100u, L"System Idle Process");
      QueryProcessUserInfo(
        v383,
        v122->UniqueProcessId,
        &v122->CreateTime,
        &v445,
        0x100u,
        &v444,
        0x100u,
        Buffer1,
        0x100u,
        &v331,
        &v332);
      if ( !v444 || (v245 = L"\\", !v445) )
        v245 = gpszTargetName;
      FormatTex(&v441, L"%s%s%s", &v444, v245, &v445, v314, v315);
      v416 = _wcsdup(Buffer1);
      v246 = v391;
      if ( v331 )
      {
        v246 = v391 | 0x200;
        v391 |= 0x200u;
      }
      if ( v332 )
        v391 = v246 | 0x2000;
      NtQueryInformationProcess(v383, 61, v409, 1u, &v323);
      if ( IsImmersiveProcess && IsImmersiveProcess(v383) )
      {
        if ( GetPackageFullName )
        {
          v339 = 0;
          if ( GetPackageFullName(v383, &v339, 0) == 122 )
          {
            v376 = malloc(2 * v339);
            if ( !GetPackageFullName(v383, &v339, v376) )
              v417 = _wcsdup(v376);
            free(v376);
          }
        }
        v391 |= 0x1000u;
      }
      v419 = -1;
      v426 = -1;
      sub_126DF20(
        v247,
        v122,
        v383,
        TOTALDeltaTimeHigh1,
        DeltaTimeHigh1,
        gTimeLastRefresh1.dwLowDateTime,
        gTimeLastRefresh1.dwHighDateTime,
        &v387,
        0xFFFFFFFF);
      v248 = v122->InheritedFromUniqueProcessId;
      if ( v248 )
      {
        sub_1278310(v248, &v122->CreateTime, &v447, 0x100u);
        sub_1259D80(&v449, L"(%d)", v122->InheritedFromUniqueProcessId);
        wcscat_s(&v447, 0x100u, &v449);
      }
      else
      {
        VLogEntry(&v447, L"<None>");
      }
      sub_12602C0(v383, v122->UniqueProcessId, &v413, &v414, &v415, &v361);
      if ( v361 )
        v391 |= 0x400u;
      HIDWORD(v370) = v122->UniqueProcessId;
      tcscpy_s(&v448, 0x100u, gpszTargetName);
      ghWndFound = 0;
      if ( HIDWORD(v370) == GetCurrentProcessId() )
      {
        ghWndFound = ghWndNewOwner;
        GetWindowTextW(ghWndNewOwner, gszWindowNameFound, 256);
      }
      else
      {
        gbWindowFound = 0;
        gszWindowNameFound = &v448;
        gdwWindowNameFoundSize = 256;
        EnumWindows(EnumWindowsCallback, SHIDWORD(v370));
      }
      v404 = ghWndFound;
      if ( ghWndFound )
        v405 = IsHungAppWindow(ghWndFound);
      if ( !v367 )
      {
        GetAllServicesName();
        v367 = 1;
      }
      v249 = v122->UniqueProcessId;
      HIDWORD(v370) = v122->UniqueProcessId;
      if ( *EnumServicesStatusExW && v249 && (v250 = 0, gdwServiceNameBufferRealSize) )
      {
        v251 = gstrServiceNameBuffer + 36;
        while ( 1 )
        {
          v122 = DeltaTimeLow1;
          if ( *v251 == HIDWORD(v370) )
            break;
          ++v250;
          v251 += 44;
          if ( v250 >= gdwServiceNameBufferRealSize )
            goto LABEL_297;
        }
        v391 |= 0x20u;
      }
      else
      {
LABEL_297:
        v391 &= 0xFFFFFFDF;
      }
      tcscpy_s(&v410, 0x41u, gpszTargetName);
      v394 = _wcsdup(&v443);
      if ( !sub_125D0C0(v383, &v387) )
      {
        v252 = v412;
        v253 = 0;
        v386.hIcon = 0;
        if ( v412 )
        {
          SHGetFileInfoW(v412, 0, &v386, 0x2B4u, 0x101u);
          v252 = v412;
          v253 = v386.hIcon;
        }
        v392 = v253;
        v254 = 0;
        v386.hIcon = 0;
        if ( v252 )
        {
          SHGetFileInfoW(v252, 0, &v386, 0x2B4u, 0x100u);
          v254 = v386.hIcon;
        }
        v393 = v254;
      }
      v255 = &v122->CreateTime.LowPart;
      v436 = v122->BasePriority;
      if ( !v122->InheritedFromUniqueProcessId && v395 )
      {
        gdwProcessId = v395;
        gProcessorCreateTime.dwLowDateTime = *v255;
        gProcessorCreateTime.dwHighDateTime = v122->CreateTime.HighPart;
        v122->InheritedFromUniqueProcessId = -1;
      }
      v397 = v122->InheritedFromUniqueProcessId;
      v399 = 0;
      v401 = v122->HandleCount;
      v406.dwLowDateTime = *v255;
      v406.dwHighDateTime = v122->CreateTime.HighPart;
      nUnnamedValue = 0.0;
      v385 = 0;
      if ( GetVersion() <= 4u )
      {
        v385 = 1;
        v256 = &v122->ReadOperationCount;
      }
      else
      {
        v256 = v122->Threads;
      }
      v376 = v122->NumberOfThreads;
      if ( !v376 )
        goto LABEL_455;
      v257 = LODWORD(nUnnamedValue);
      v258 = (v256 + 48);
      v259 = HIDWORD(nUnnamedValue);
      do
      {
        v260 = *v258 + __PAIR__(v259, v257);
        v259 = v260 >> 32;
        v257 = v260;
        v258 += 16;
        v376 = (v376 - 1);
      }
      while ( v376 );
      if ( v259 >= 0 && (v259 > 0 || v260) )
      {
        v433 = v260;
        v434 = v259;
      }
      else
      {
LABEL_455:
        *&v433 = 0i64;
      }
      v439 = 0;
      v385 = 0;
      if ( GetVersion() <= 4u )
      {
        v385 = 1;
        v261 = &v122->ReadOperationCount;
      }
      else
      {
        v261 = v122->Threads;
      }
      v262 = v122->NumberOfThreads;
      v263 = 0;
      if ( v262 )
      {
        v264 = (v261 + 56);
        v376 = v122->NumberOfThreads;
        v265 = (v261 + 52);
        v127 = v343;
        do
        {
          if ( *v265 == 5 && *v264 == 5 )
            ++v263;
          v265 += 16;
          v264 += 16;
          v376 = (v376 - 1);
        }
        while ( v376 );
        v262 = v122->NumberOfThreads;
      }
      if ( v262 == v263 )
        v391 |= 0x80u;
      if ( sub_126DA70(v383, v395, 0, 0) )
        v391 |= 0x800u;
      else
        v391 &= 0xFFFFF7FF;
      v407 = sub_125BEF0(&v387, v383);
      v398 = 0;
      v431 = v122->KernelTime.QuadPart + v122->UserTime.QuadPart;
      v432 = v122->KernelTime;
      v402 = 0;
      v421 = v122->PageFaultCount;
      v422 = v122->PagefileUsage;
      v420 = v122->VirtualSize;
      v423 = v122->PeakPagefileUsage;
      v424 = v122->WorkingSetSize;
      v425 = v122->PeakWorkingSetSize;
      if ( !_wcsicmp(v394, L"wmiprvse.exe") )
        sub_1283A00(v395, &v418);
      v408 = -1;
      if ( GetProcessDpiAwareness )
        GetProcessDpiAwareness(v383, &v408);
      if ( v374 <= 0 && v122->PagefileUsage > v363 )
      {
        v363 = v122->PagefileUsage;
        v374 = 0;
      }
      if ( *ProcessIdToSessionId )
      {
        v266 = ProcessIdToSessionId(v122->UniqueProcessId, &v402);
        v267 = v402;
        if ( !v266 )
          v267 = -1;
        v402 = v267;
      }
      if ( dword_12E10C8 )
      {
        v430 = 0.0;
        nUnnamedValue = 0.0;
LABEL_360:
        v396 = _wcsdup(&v447);
        v274 = _wcsdup(&v441);
        v391 |= 4u;
        v400 = v274;
        v295 = _wcsicmp(v274, &gszMainTitle) == 0;
        v275 = v391;
        if ( v295 )
        {
          v275 = v391 | 0x40;
          v391 |= 0x40u;
        }
        if ( gbShowAllUsers || v391 & 0x40 )
          v276 = v275 | 2;
        else
          v276 = v275 & 0xFFFFFFFD;
        v391 = v276;
        tcscpy_s(&v403, 0x100u, &v448);
        if ( dword_12E10C8 )
        {
          v388 = 0;
        }
        else
        {
          if ( *&gTimeLastRefresh <= *&v406 )
          {
            v388 = 2;
          }
          else
          {
            v388 = 0;
            v430 = 0.0;
          }
          v389 = 0;
          v390 = 0;
        }
        v427 = 0;
        v428 = sub_124B9D0(v395);
        v429 = sub_1230960(&v387);
        v277 = v428;
        if ( v428 )
        {
          if ( !v382 )
          {
            sub_124C500();
            v277 = v428;
            v382 = 1;
          }
          if ( v277 )
            ++*&Buffer2[36];
        }
        sub_124C540(&v387, 0xFFFFFFFF);
        v438 = 0;
        v437 = 0;
        v389 = 0;
        v372 = SendMessageW(ghWndNewOwner, PTM_MSG_7EE, g_dwProcessId == v122->UniqueProcessId, &v387);
        sub_126DF20(
          v278,
          v122,
          v383,
          TOTALDeltaTimeHigh1,
          DeltaTimeHigh1,
          gTimeLastRefresh1.dwLowDateTime,
          gTimeLastRefresh1.dwHighDateTime,
          v372,
          0xFFFFFFFF);
        v279 = v372;
        v280 = v352;
        v352 = v372;
        LOBYTE(v384) = 1;
        *(v352 + 1336) = *(v352 + 1344);
        *(v279 + 1340) = *(v279 + 1348);
        *(v279 + 1352) = *(v279 + 1360);
        *(v279 + 1356) = *(v279 + 1364);
        *(v279 + 1452) = v280;
        if ( v412 && *v412 != 91 )
        {
          if ( gbVerifySignatures )
          {
            InterlockedIncrement((v279 + 36));
            _beginthread(VerifySignatureThreadProc, 0, v372);
            v279 = v372;
          }
          v281 = sub_122BB70(*(v279 + 88), *(v279 + 792));
          v282 = v372;
          *(v372 + 828) = v281;
          v283 = 2;
          if ( gbVirusTotalCheck )
            v283 = 0;
          sub_1281C30(v282, 1, v283);
          v279 = v372;
        }
        if ( *(v279 + 68) && nUnnamedValue > *&v354 )
        {
          *&v354 = nUnnamedValue;
          v353 = v279;
        }
        if ( v391 & 0x40 )
        {
          v284 = __PAIR__(v366, v122->PagefileUsage) + v364;
          v366 = (__PAIR__(v366, v122->PagefileUsage) + v364) >> 32;
          v364 = v284;
          v285 = __PAIR__(v365, v122->WorkingSetSize) + v378;
          v365 = (__PAIR__(v365, v122->WorkingSetSize) + v378) >> 32;
          v378 = v285;
          ++*&Buffer2[26];
          *&Buffer2[30] += v122->NumberOfThreads;
          *&Buffer2[34] += v122->HandleCount;
          if ( v428 )
            ++*&Buffer2[38];
        }
        goto LABEL_259;
      }
      if ( GetProcessorSystemCycleTime && gdwOsType >= 2 )
      {
        if ( v359 | v357 )
        {
          v268 = v122->CycleTime;
          *(&v370 + 1) = v268 * 100.0;
          v269 = __PAIR__(v359, v357);
          v270 = *(&v370 + 1) / v269;
LABEL_354:
          v273 = v270;
          nUnnamedValue = v270;
          if ( v270 > 100.0 )
          {
            v273 = gdbMaxValue;
            nUnnamedValue = gdbMaxValue;
          }
          v430 = v273;
          if ( v391 & 0x40 )
          {
            v360 = v273 + v360;
            v273 = nUnnamedValue;
          }
          if ( v395 )
            v347 = v273 + v347;
          goto LABEL_360;
        }
      }
      else if ( DeltaTimeHigh1 | TOTALDeltaTimeHigh1 )
      {
        v271 = (v122->KernelTime.QuadPart + v122->UserTime.QuadPart);
        *(&v370 + 1) = v271 * 100.0;
        v272 = __PAIR__(DeltaTimeHigh1, TOTALDeltaTimeHigh1);
        v270 = *(&v370 + 1) / v272;
        goto LABEL_354;
      }
      v270 = 0.0;
      goto LABEL_354;
    }
    v128 = v122->CreateTime.LowPart;
    v129 = v122->CreateTime.HighPart;
    while ( *(v127 + 156) != v128 || *(v127 + 157) != v129 || *(v127 + 17) != v123 )
    {
      v127 = *(v127 + 364);
      v343 = v127;
      if ( !v127 )
        goto LABEL_108;
    }
    HIDWORD(v330) = v123;
    v383 = OpenProcess(0x2000000u, 0, v123);
    pTreeListParamList2 = v383;
    if ( !v383 )
    {
      if ( GetLastError() == 5 )
        DeviceIoControl(theDriver, 0x8335003C, &v330 + 4, 4u, &pTreeListParamList2, 4u, &v334 + 1, 0);
      v383 = pTreeListParamList2;
    }
    if ( (v325 = 1,
          v326 = v127,
          v130 = SendMessageW(hWndTreeList1, 0x1053u, 0xFFFFFFFF, &v325),
          lvItem.iItem = v130,
          v132 = *(v127 + 10),
          !(v132 & 2))
      || v132 & 1 && byte_12E96D6
      || v130 != -1 )
    {
      *(v127 + 11) = v130;
    }
    else
    {
      sub_1237F20(ghWndTreeListView, v127);
    }
    v133 = sub_126DF20(
             v131,
             v122,
             v383,
             TOTALDeltaTimeHigh1,
             DeltaTimeHigh1,
             gTimeLastRefresh1.dwLowDateTime,
             gTimeLastRefresh1.dwHighDateTime,
             v127,
             lvItem.iItem);
    LOBYTE(v384) = v133 | v384;
    v135 = v122->KernelTime.LowPart;
    v136 = v122->UserTime.LowPart;
    v134 = v122->UserTime.LowPart + v122->KernelTime.LowPart;
    v349 = v122->KernelTime.HighPart;
    v137 = __PAIR__(v349, v136) + __PAIR__(v122->UserTime.HighPart, v135);
    v172 = v134 < *(v127 + 330);
    v138 = v134 - *(v127 + 330);
    HIDWORD(v355) = v136 + v135;
    v139 = HIDWORD(v137) - (v172 + *(v127 + 331));
    v376 = HIDWORD(v137);
    if ( GetProcessorSystemCycleTime )
    {
      if ( !(v359 | v357) )
        goto LABEL_135;
      v140 = *(v127 + 169);
      *(&v370 + 1) = v140 * 100.0;
      v141 = __PAIR__(v359, v357);
      v142 = *(&v370 + 1) / v141;
    }
    else
    {
      if ( !*(v127 + 17) )
      {
        v143 = nUnnamedValue;
        v351 = v127;
        goto LABEL_137;
      }
      if ( !(DeltaTimeHigh1 | TOTALDeltaTimeHigh1) )
      {
LABEL_135:
        v142 = 0.0;
        goto LABEL_136;
      }
      v144 = __PAIR__(v139, v138);
      *(&v370 + 1) = v144 * 100.0;
      v145 = __PAIR__(DeltaTimeHigh1, TOTALDeltaTimeHigh1);
      v142 = *(&v370 + 1) / v145;
    }
LABEL_136:
    v143 = v142;
    nUnnamedValue = v142;
LABEL_137:
    if ( v143 > 100.0 )
      nUnnamedValue = gdbMaxValue;
    if ( DeltaTimeHigh1 | TOTALDeltaTimeHigh1 )
    {
      v146 = (__PAIR__(v349, v122->KernelTime.LowPart) - *(v127 + 166));
      *(&v370 + 1) = v146 * 100.0;
      v147 = __PAIR__(DeltaTimeHigh1, TOTALDeltaTimeHigh1);
      v148 = *(&v370 + 1) / v147;
    }
    else
    {
      v148 = 0.0;
    }
    v149 = *(v127 + 173);
    v172 = v149 < v328;
    v295 = v149 == v328;
    *(v127 + 332) = v122->KernelTime.LowPart;
    *(v127 + 333) = v349;
    *&v150 = v148;
    if ( !v172 && !v295 )
    {
      v342 = v127;
      v328 = v149;
    }
    if ( *(v127 + 40) & 0x40 )
      v360 = nUnnamedValue + v360;
    v151 = _mm_unpckl_pd(*&nUnnamedValue, *&nUnnamedValue);
    if ( *(v127 + 17) )
    {
      if ( v122->UserTime.QuadPart )
        UpdateText(*(v127 + 343), gTimeLastRefresh1, *&v151.m128d_f64[0], v150, 0);
      else
        UpdateText(*(v127 + 343), gTimeLastRefresh1, *&v151.m128d_f64[0], *&v151.m128d_f64[1], 0);
      v152 = nUnnamedValue;
      v347 = nUnnamedValue + v347;
      if ( nUnnamedValue > *&v354 )
      {
        *&v354 = nUnnamedValue;
        v353 = v127;
      }
    }
    else
    {
      UpdateText(*(v127 + 343), gTimeLastRefresh1, 0i64, *&v151.m128d_f64[0], 0);
      v152 = nUnnamedValue;
    }
    v153 = v152 != *(v127 + 162);
    *(v127 + 162) = v152;
    v154 = ColumnIDIsIllegal(v153, ghWndTreeListView, 1055, lvItem.iItem);
    v155 = *(v127 + 164) + nUnnamedValue;
    LOBYTE(v384) = v154 | v384;
    v385 = 1;
    if ( v155 == *(v127 + 164) )
      v385 = 0;
    *(v127 + 164) = v155;
    v156 = ColumnIDIsIllegal(1, ghWndTreeListView, 1637, lvItem.iItem);
    LOBYTE(v384) = v156 | v384;
    v295 = *(v127 + 21) == 0;
    HIDWORD(v370) = v127 + 84;
    if ( !v295 )
    {
      v157 = v127 + 84;
      do
      {
        *(*v157 + 1312) = *(*v157 + 1312) + nUnnamedValue;
        v158 = ColumnIDIsIllegal(1, ghWndTreeListView, 1637, *(*v157 + 44));
        v159 = *v157;
        LOBYTE(v384) = v158 | v384;
        v157 = v159 + 84;
      }
      while ( *v157 );
      v122 = DeltaTimeLow1;
    }
    v160 = ColumnIDIsIllegal(v385, ghWndTreeListView, 1191, lvItem.iItem);
    LOBYTE(v384) = v160 | v384;
    --v358;
    if ( sub_125D0C0(v383, v127) )
    {
      PostMessageW(ghWndNewOwner, 0x7EBu, lvItem.iItem, -1);
      RedrawTreeList();
    }
    v161 = (*(v127 + 10) >> 7) & 0xFFFFFF01;
    v385 = 0;
    v349 = v161;
    if ( GetVersion() <= 4u )
    {
      v385 = 1;
      v162 = &v122->ReadOperationCount;
    }
    else
    {
      v162 = v122->Threads;
    }
    v163 = v122->NumberOfThreads;
    v164 = 0;
    HIDWORD(v370) = v163;
    if ( v163 )
    {
      v165 = (v162 + 56);
      v166 = (v162 + 52);
      do
      {
        if ( *v166 == 5 && *v165 == 5 )
          ++v164;
        v166 += 16;
        v165 += 16;
        --v163;
      }
      while ( v163 );
      v163 = HIDWORD(v370);
    }
    if ( v163 == v164 )
      *(v127 + 10) |= 0x80u;
    else
      *(v127 + 10) &= 0xFFFFFF7F;
    if ( ((*(v127 + 10) >> 7) & 1) != v349 )
    {
      PostMessageW(ghWndNewOwner, 0x7EBu, lvItem.iItem, -1);
      RedrawTreeList();
    }
    v167 = *(v127 + 200);
    if ( (!v167 || !*v167) && *(v127 + 653) < 2u )
    {
      sub_12602C0(v383, *(v127 + 17), v127 + 800, v127 + 804, v127 + 808, 0);
      free(v167);
      ++*(v127 + 653);
      v168 = *(v127 + 200);
      if ( v168 )
      {
        if ( *v168 )
        {
          v169 = ColumnIDIsIllegal(1, ghWndTreeListView, 1032, lvItem.iItem);
          LOBYTE(v384) = v169 | v384;
        }
      }
    }
    v170 = *(v127 + 652);
    if ( v170 < 2u )
    {
      if ( !flags )
        *(v127 + 652) = v170 + 1;
    }
    else if ( !flags )
    {
      goto LABEL_190;
    }
    if ( sub_126DA70(v383, *(v127 + 17), 0, 0) )
      *(v127 + 10) |= 0x800u;
    else
      *(v127 + 10) &= 0xFFFFF7FF;
LABEL_190:
    if ( v383 )
    {
      HIDWORD(v370) = *(v127 + 159);
      v171 = sub_125BEF0(v127, v383);
      *(v127 + 159) = v171;
      if ( v171 != HIDWORD(v370)
        && ((v172 = v171 < BYTE4(v370), v171 != BYTE4(v370))
         || (v173 = *(v127 + 637), v172 = v173 < BYTE5(v370), v173 != BYTE5(v370))
         || (v174 = *(v127 + 638), v172 = v174 < BYTE6(v370), v174 != BYTE6(v370))
         || (v175 = *(v127 + 639), v172 = v175 < HIBYTE(v370), v175 != HIBYTE(v370))) )
      {
        v176 = -v172 | 1;
      }
      else
      {
        v176 = 0;
      }
      v177 = ColumnIDIsIllegal(v176 == 0, ghWndTreeListView, 1199, lvItem.iItem);
      LOBYTE(v384) = v177 | v384;
    }
    if ( *(v127 + 321) )
    {
LABEL_210:
      ++*&Buffer2[36];
      goto LABEL_211;
    }
    v178 = *(v127 + 1280);
    if ( v178 < 2u )
    {
      if ( !flags )
        *(v127 + 1280) = v178 + 1;
    }
    else if ( !flags )
    {
      goto LABEL_209;
    }
    *(v127 + 321) = sub_124B9D0(*(v127 + 17));
    *(v127 + 1288) = sub_1230960(v127);
    if ( !*(v127 + 321) )
      goto LABEL_211;
    if ( !v382 )
    {
      sub_124C500();
      v382 = 1;
    }
    PostMessageW(ghWndNewOwner, 0x7EBu, lvItem.iItem, -1);
    RedrawTreeList();
LABEL_209:
    if ( *(v127 + 321) )
      goto LABEL_210;
LABEL_211:
    v179 = *(v127 + 342);
    v180 = *(DeltaTimeLow1 + 64);
    *(v127 + 342) = v180;
    v181 = ColumnIDIsIllegal(v180 != v179, ghWndTreeListView, 5, lvItem.iItem);
    LOBYTE(v384) = v181 | v384;
    if ( *(v127 + 342) != v179 )
    {
      v182 = *&lvItem.lParam[7].szText[20];
      if ( v182 == 4 && !lvItem.lParam[5].field_20 )
        v182 = 0;
      v183 = v182;
      v184 = GetMenu(ghWndNewOwner);
      sub_127EF00(v184, v183);
    }
    v185 = v376;
    v186 = HIDWORD(v355) != *(v127 + 330) || v376 != *(v127 + 331);
    *(v127 + 330) = HIDWORD(v355);
    *(v127 + 331) = v185;
    v187 = ColumnIDIsIllegal(v186, ghWndTreeListView, 1087, lvItem.iItem);
    LOBYTE(v384) = v187 | v384;
    if ( GetProcessDpiAwareness )
    {
      GetProcessDpiAwareness(v383, &v329 + 4);
      v295 = HIDWORD(v329) == *(v127 + 161);
      *(v127 + 161) = HIDWORD(v329);
      v188 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1667, lvItem.iItem);
      LOBYTE(v384) = v188 | v384;
    }
    v189 = DeltaTimeLow1;
    v190 = *(DeltaTimeLow1 + 76);
    v295 = v190 == *(v127 + 23);
    *(v127 + 23) = v190;
    v191 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 18, lvItem.iItem);
    LOBYTE(v384) = v191 | v384;
    v192 = v189[24] - *(v127 + 220);
    v295 = v192 == *(v127 + 221);
    *(v127 + 221) = v192;
    v193 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1179, lvItem.iItem);
    LOBYTE(v384) = v193 | v384;
    v194 = v189[24];
    v295 = v194 == *(v127 + 220);
    *(v127 + 220) = v194;
    v195 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1059, lvItem.iItem);
    LOBYTE(v384) = v195 | v384;
    v196 = v189[26];
    v295 = v196 == *(v127 + 225);
    *(v127 + 225) = v196;
    v197 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1063, lvItem.iItem);
    LOBYTE(v384) = v197 | v384;
    v198 = v189[25];
    v295 = v198 == *(v127 + 226);
    *(v127 + 226) = v198;
    v199 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1064, lvItem.iItem);
    LOBYTE(v384) = v199 | v384;
    v200 = v189[28];
    v295 = v200 == *(v127 + 230);
    *(v127 + 230) = v200;
    v201 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 9, lvItem.iItem);
    LOBYTE(v384) = v201 | v384;
    v202 = v189[30];
    v295 = v202 == *(v127 + 231);
    *(v127 + 231) = v202;
    v203 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 10, lvItem.iItem);
    LOBYTE(v384) = v203 | v384;
    v204 = v189[32];
    v295 = v204 == *(v127 + 224);
    *(v127 + 224) = v204;
    v205 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1062, lvItem.iItem);
    LOBYTE(v384) = v205 | v384;
    v206 = v189[31] - *(v127 + 222);
    v295 = v206 == *(v127 + 223);
    *(v127 + 223) = v206;
    v207 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1192, lvItem.iItem);
    LOBYTE(v384) = v207 | v384;
    v208 = v189[31];
    if ( v374 <= 0 && v208 > v363 )
    {
      v363 = v189[31];
      v374 = 0;
    }
    v295 = v208 == *(v127 + 222);
    *(v127 + 222) = v208;
    v209 = !v295;
    v210 = ColumnIDIsIllegal(v209, ghWndTreeListView, 1060, lvItem.iItem);
    LOBYTE(v384) = v210 | v384;
    v211 = ColumnIDIsIllegal(v209, ghWndTreeListView, 1193, lvItem.iItem);
    LOBYTE(v384) = v211 | v384;
    v212 = *(v127 + 227);
    if ( v212 && (*(v127 + 224) >> 10) + *&dword_12BD110[2 * (*(v127 + 224) >> 41)] >= *(v212 + 40) )
      *(v212 + 40) = (((*(v127 + 224) >> 10) + *&dword_12BD110[2 * (*(v127 + 224) >> 41)]) * 1.2);
    UpdateText(*(v127 + 227), gTimeLastRefresh1, COERCE__INT64(*(v127 + 222) * 0.0009765625), 0i64, 0);
    v122 = DeltaTimeLow1;
    v213 = *(DeltaTimeLow1 + 92);
    v295 = v213 == *(v127 + 219);
    *(v127 + 219) = v213;
    v214 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1114, lvItem.iItem);
    LOBYTE(v384) = v214 | v384;
    if ( IsIllegalID(ghWndTreeListView, 35) || IsIllegalID(ghWndTreeListView, 1196) )
    {
      v215 = v122->UniqueProcessId;
      tcscpy_s(&v448, 0x100u, gpszTargetName);
      ghWndFound = 0;
      if ( v215 == GetCurrentProcessId() )
      {
        ghWndFound = ghWndNewOwner;
        GetWindowTextW(ghWndNewOwner, gszWindowNameFound, 256);
      }
      else
      {
        gbWindowFound = 0;
        gszWindowNameFound = &v448;
        gdwWindowNameFoundSize = 256;
        EnumWindows(EnumWindowsCallback, v215);
      }
      v216 = ghWndFound;
      v385 = *(v127 + 620);
      if ( IsIllegalID(ghWndTreeListView, 1196) && v216 )
        v385 = IsHungAppWindow(v216);
      v217 = wcscmp(&v448, v127 + 52);
      if ( v217 )
        v217 = -(v217 < 0) | 1;
      v295 = v217 == 0;
      v218 = v385;
      if ( !v295 || (v385 = 0, v218 != *(v127 + 620)) )
        v385 = 1;
      *(v127 + 620) = v218;
      tcscpy_s(v127 + 52, 0x100u, &v448);
      *(v127 + 154) = v216;
      v219 = v385;
      v220 = ColumnIDIsIllegal(v385, ghWndTreeListView, 35, lvItem.iItem);
      LOBYTE(v384) = v220 | v384;
      v221 = ColumnIDIsIllegal(v219, ghWndTreeListView, 1196, lvItem.iItem);
      v122 = DeltaTimeLow1;
      LOBYTE(v384) = v221 | v384;
    }
    v222 = v122->NumberOfThreads;
    v295 = v222 == *(v127 + 24);
    *(v127 + 24) = v222;
    v223 = ColumnIDIsIllegal(!v295, ghWndTreeListView, 1065, lvItem.iItem);
    LOBYTE(v384) = v223 | v384;
    if ( *(v127 + 266) )
    {
      v224 = (*(v127 + 127) + *(v127 + 131)) >> 32;
      v225 = *(v127 + 254) + *(v127 + 262);
      v226 = *(v127 + 246);
      HIDWORD(v370) = *(v127 + 246) + v225;
      LODWORD(v227) = v226 + v225;
      HIDWORD(v355) = (__PAIR__(v224, v226) + __PAIR__(*(v127 + 247), v225)) >> 32;
      HIDWORD(v227) = HIDWORD(v355);
      if ( v227 >= *(*(v127 + 266) + 40) )
      {
        v228 = __PAIR__(HIDWORD(v355), HIDWORD(v370));
        *(*(v127 + 266) + 40) = (v228 * 1.2);
        *(*(v127 + 266) + 64) = *(*(v127 + 266) + 40);
      }
    }
    v229 = *(v127 + 247);
    v230 = *(v127 + 246);
    v231 = *(v127 + 127);
    *(&v355 + 1) = v231;
    *&dbMaxValue = v231;
    v233 = __PAIR__(v229, v230);
    v234 = *(v127 + 263);
    v235 = *(v127 + 262);
    *&v233 = v233;
    *(&v355 + 1) = *&v233 + *(&v355 + 1);
    *&v233 = __PAIR__(v234, v235);
    UpdateText(*(v127 + 266), gTimeLastRefresh1, COERCE__INT64(*(&v355 + 1) + *&v233), dbMaxValue, 0);
    CDataInfo::Init(v127, (v127 + 960));
    CDataInfo::Init(v127, (v127 + 1072));
    CDataInfo::Init(v127, (v127 + 1176));
    v236 = ColumnIDIsIllegal(1, ghWndTreeListView, 1330, lvItem.iItem);
    LOBYTE(v384) = v236 | v384;
    if ( *(v127 + 321) && !v382 )
    {
      sub_124C500();
      v382 = 1;
    }
    v237 = sub_124C540(v127, lvItem.iItem);
    LOBYTE(v384) = v237 | v384;
    if ( *(v127 + 40) & 0x40 )
    {
      v238 = v122->KernelTime.QuadPart + v122->UserTime.QuadPart + __PAIR__(v377, prev1);
      v377 = v238 >> 32;
      prev1 = v238;
      v239 = __PAIR__(v366, v122->PagefileUsage) + v364;
      v366 = (__PAIR__(v366, v122->PagefileUsage) + v364) >> 32;
      v364 = v239;
      v240 = __PAIR__(v365, v122->WorkingSetSize) + v378;
      v365 = (__PAIR__(v365, v122->WorkingSetSize) + v378) >> 32;
      v378 = v240;
      ++*&Buffer2[26];
      *&Buffer2[30] += v122->NumberOfThreads;
      *&Buffer2[34] += v122->HandleCount;
      if ( *(v127 + 321) )
        ++*&Buffer2[38];
    }
    ColumnIDIsIllegal(1, ghWndTreeListView, 1193, lvItem.iItem);
    ColumnIDIsIllegal(1, ghWndTreeListView, 1330, lvItem.iItem);
    ColumnIDIsIllegal(1, ghWndTreeListView, 1191, lvItem.iItem);
    v241 = *(v127 + 24);
    v242 = 0;
    if ( v241 )
    {
      v243 = *(v127 + 7);
      if ( v243 < gdwHighlightDuration )
      {
        *(v127 + 4) = 2;
        *(v127 + 5) = v243;
        goto LABEL_259;
      }
      if ( v241 )
      {
        v242 = 1;
        *(v127 + 24) = 0;
      }
    }
    v244 = v384;
    if ( v242 )
      v244 = 1;
    *(v127 + 4) = 0;
    LOBYTE(v384) = v244;
LABEL_259:
    if ( v383 )
      CloseHandle(v383);
    if ( !v122->NextEntryOffset )
      break;
    v121 = v340;
    v122 = (v122 + v122->NextEntryOffset);
  }
  if ( v380 || !gbShowAllUsers )
  {
    v291 = SendMessageW;
  }
  else
  {
    memset(&v387, 0, 0x5C0u);
    v391 |= 6u;
    v286 = 0;
    LOBYTE(v407) = -1;
    v428 = 0;
    v426 = -1;
    v419 = -1;
    v439 = 0;
    v388 = 0;
    v395 = -10;
    if ( gSystemInfo.dwNumberOfProcessors > 0 )
    {
      v287 = &gpSysProcessorPerfInfo->InterruptTime;
      v288 = &gpInterruptInfo->DpcCount;
      do
      {
        v288 += 6;
        *&v433 += *(v288 - 6) + v287[1].LowPart;
        v431 += *v287 + v287[-1].QuadPart;
        v289 = *v287 + v287[-1].QuadPart;
        v287 += 6;
        v432.QuadPart += v289;
        v290 = (gpProcessorCycleTimeInfo[v286].CycleTime + v435) >> 32;
        LODWORD(v435) = LODWORD(gpProcessorCycleTimeInfo[v286++].CycleTime) + v435;
        HIDWORD(v435) = v290;
      }
      while ( v286 < gSystemInfo.dwNumberOfProcessors );
      v127 = v343;
    }
    v411 = _wcsdup(L"Hardware Interrupts and DPCs");
    v394 = _wcsdup(L"Interrupts");
    v406 = gProcessorCreateTime;
    v397 = gdwProcessId;
    v291 = SendMessageW;
    v396 = _wcsdup(L"System");
    v292 = SendMessageW(ghWndNewOwner, PTM_MSG_7EE, g_dwProcessId == 0, &v387);
    *(v292 + 1452) = v352;
  }
  if ( !dword_12FBC28
    && gdwProcessListSortColumnCount != 1000
    && !v384
    && gdwIDMapProcesListForSelectColumn[gdwProcessListSortColumnCount] == 1055 )
  {
    lvItem.mask = 4;
    lvItem.iItem = 1;
    lvItem.iSubItem = 0;
    if ( v291(hWndTreeList1, LVM_GETITEMW, WM_NULL, &lvItem) )
    {
      while ( 1 )
      {
        if ( gbProcessSortDirection )
        {
          v293 = *(v127 + 162);
          v294 = v293 < *&lvItem.lParam[7].field_8;
          v295 = v293 == *&lvItem.lParam[7].field_8;
        }
        else
        {
          v296 = *&lvItem.lParam[7].field_8;
          v294 = v296 < *(v127 + 162);
          v295 = v296 == *(v127 + 162);
        }
        if ( !v294 && !v295 )
          break;
        ++lvItem.iItem;
        v127 = lvItem.lParam;
        if ( !v291(hWndTreeList1, LVM_GETITEMW, WM_NULL, &lvItem) )
          goto LABEL_410;
      }
      LOBYTE(v384) = 1;
    }
  }
LABEL_410:
  v297 = TOTALDeltaTimeHigh1;
  v298 = DeltaTimeHigh1;
  if ( DeltaTimeHigh1 | TOTALDeltaTimeHigh1 )
  {
    v299 = (__PAIR__(v373, v371) - qword_12FBC30);
    v346 = v299 * 100.0;
    v300 = __PAIR__(DeltaTimeHigh1, TOTALDeltaTimeHigh1);
    v346 = v346 / v300;
  }
  LODWORD(qword_12FBC30) = v371;
  HIDWORD(qword_12FBC30) = v373;
  *&Buffer2[4] = v360;
  LODWORD(ArgList) = v364;
  sub_1277400(ArgList, 0, &v327, &v360);
  *&Buffer2[12] = v9;
  LODWORD(qword_12FBA40) = v363;
  HIDWORD(qword_12FBA40) = v374;
  *&Buffer2[20] = (__PAIR__(v365, v378) / 1024) / v360 * 100.0;
  if ( v351 )
  {
    v360 = 100.0 - v347;
    if ( 100.0 - v347 < 0.0 )
      v360 = 0.0;
    v326 = v351;
    v325 = 1;
    lvItem.iItem = SendMessageW(hWndTreeList1, LVM_FINDITEMW, 0xFFFFFFFF, &v325);
    v301 = v360 != *(v351 + 162);
    *(v351 + 162) = v360;
    v302 = ColumnIDIsIllegal(v301, ghWndTreeListView, 1055, lvItem.iItem);
    LOBYTE(v384) = v302 | v384;
    v380 = 1;
    v303 = *(v351 + 164) + v360;
    if ( v303 == *(v351 + 164) )
      v380 = 0;
    *(v351 + 164) = v303;
    v304 = ColumnIDIsIllegal(1, ghWndTreeListView, 1637, lvItem.iItem);
    LOBYTE(v384) = v304 | v384;
    v305 = ColumnIDIsIllegal(v380, ghWndTreeListView, 1191, lvItem.iItem);
    LOBYTE(v384) = v305 | v384;
    UpdateText(*(v351 + 343), gTimeLastRefresh1, 0i64, *&v360, 0);
  }
  if ( !v384 && v358 )
  {
    v306 = SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, WM_NULL, 0);
    for ( i = 0; i < v306; ++i )
      PostMessageW(ghWndNewOwner, 0x7EBu, i, -1);
    v298 = DeltaTimeHigh1;
    v297 = TOTALDeltaTimeHigh1;
  }
  v308 = gdbMaxValue;
  if ( v347 <= 100.0 )
    v308 = v347;
  *Buffer2 = v308;
  UpdateStatusBar(v9, v8, v7, v6, v5, ghWndStatusBar, Buffer2, &v324, &v327);
  if ( v353 )
  {
    v309 = *(v353 + 17);
    if ( gbShowCpuFractions )
    {
      if ( v309 <= 0 )
        FormatTex(&v442, L"%02.02f%% %s", v354, *(v353 + 15));
      else
        FormatTex(&v442, L"%02.02f%% %s:%d", v354, *(v353 + 15), *(v353 + 17));
    }
    else if ( v309 <= 0 )
    {
      FormatTex(&v442, L"%02.0f%% %s", v354, *(v353 + 15));
    }
    else
    {
      FormatTex(&v442, L"%02.0f%% %s:%d", v354, *(v353 + 15), *(v353 + 17));
    }
  }
  UpdateText(gpGraphClassData[1], gTimeLastRefresh1, *Buffer2, *&v346, &v442);
  if ( gdwAdapterRuntingTime )
  {
    sub_12338F0(
      gTimeLastRefresh1.dwLowDateTime,
      gTimeLastRefresh1.dwHighDateTime,
      __PAIR__(v298, v297) / gSystemInfo.dwNumberOfProcessors,
      gpGraphClassData[2],
      v342,
      dword_12FBA1C,
      gpGraphClassData[3],
      gpGraphClassData[4]);
    *(&v345 + 1) = v9;
    sub_127FD50(gpGraphClassData[2], *(&v345 + 1), v342, v328);
  }
  if ( gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
    sub_12344A0(&gptrIOGraphData__3UCSimpleGraphData__A, &gDataInfo1);
  if ( gptrNetGraphData.GraphData )
    sub_12344A0(&gptrNetGraphData, &gDataInfo2);
  if ( gptrDiskGraphData.GraphData )
    sub_12344A0(&gptrDiskGraphData, &gDataInfo3);
  ColumnIDIsIllegal(1, ghWndTreeListView, 1055, 0xFFFFFFFE);
  ColumnIDIsIllegal(1, ghWndTreeListView, 1060, 0xFFFFFFFE);
  ColumnIDIsIllegal(1, ghWndTreeListView, 1063, 0xFFFFFFFE);
  ColumnIDIsIllegal(1, ghWndTreeListView, 1650, 0xFFFFFFFE);
  sub_127FD50(gpGraphClassData[1], *Buffer2, v353, *&v354);
  sub_127FCA0(gpGraphClassData[0], *&v324);
  sub_1280360(gpGraphClassData[5], v327);
  v310 = v384;
  if ( flags )
    v310 = 1;
  HIDWORD(v345) = v310;
  if ( dword_12E10C8 )
  {
    if ( dword_12DE100 == -1 )
    {
      v318 = 3;
      v317 = 3;
      SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, WM_NULL, &v316);
    }
    else
    {
      v320 = 0;
      v319 = 4;
      v321 = 0;
      if ( SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, WM_NULL, 0) > 0 )
      {
        while ( 1 )
        {
          SendMessageW(ghWndTreeListView, LVM_GETITEMW, WM_NULL, &v319);
          if ( *(v322 + 68) == dword_12DE100 )
            break;
          ++v320;
          v319 = 4;
          v321 = 0;
          v311 = SendMessageW(ghWndTreeListView, LVM_GETITEMCOUNT, WM_NULL, 0);
          if ( v320 >= v311 )
            goto LABEL_451;
        }
        v318 = 3;
        v317 = 3;
        SendMessageW(ghWndTreeListView, LVM_SETITEMSTATE, v320, &v316);
      }
    }
LABEL_451:
    LOBYTE(v310) = BYTE4(v345);
    dword_12E10C8 = 0;
  }
  return v310;
}
// 127AD00: could not find valid save-restore pair for ebp
// 127AD00: could not find valid save-restore pair for edi
// 127AD00: could not find valid save-restore pair for esi
// 128C710: using guessed type int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD);
// 12BCDC0: using guessed type double gdbMaxValue;
// 12C44C8: using guessed type wchar_t a0202fS[13];
// 12DE100: using guessed type int dword_12DE100;
// 12E10C8: using guessed type int dword_12E10C8;
// 12E4E54: using guessed type int gdwOsType;
// 12E5534: using guessed type int gdwHighlightDuration;
// 12E5742: using guessed type char gbShowProcessTree;
// 12E598C: using guessed type char gbProcessSortDirection;
// 12E96C9: using guessed type char gbShowCpuFractions;
// 12E96D0: using guessed type char gbShowAllUsers;
// 12E96D6: using guessed type char byte_12E96D6;
// 12E96D7: using guessed type char gbVerifySignatures;
// 12E96E0: using guessed type char gbVirusTotalCheck;
// 12EB1BC: using guessed type int gdwProcessId;
// 12EB1C0: using guessed type FILETIME gProcessorCreateTime;
// 12EF368: using guessed type int (__stdcall *GetPackageFullName)(_DWORD, _DWORD, _DWORD);
// 12EF36C: using guessed type int (__stdcall *GetProcessDpiAwareness)(_DWORD, _DWORD);
// 12EF374: using guessed type int gdwSysProcessInfoSize1;
// 12EF398: using guessed type __int64 qword_12EF398;
// 12FBA1C: using guessed type int dword_12FBA1C;
// 12FBA40: using guessed type __int64 qword_12FBA40;
// 12FBA4C: using guessed type int (__stdcall *IsImmersiveProcess)(_DWORD);
// 12FBA50: using guessed type int (__stdcall *SHGetStockIconInfo)(_DWORD, _DWORD, _DWORD);
// 12FBA5C: using guessed type char gbWindowFound;
// 12FBC28: using guessed type int dword_12FBC28;
// 12FBC30: using guessed type __int64 qword_12FBC30;

//----- (0127E3B0) --------------------------------------------------------
HCURSOR __cdecl sub_127E3B0(int a1)
{
  DWORD v1; // ebx
  HWND v2; // eax
  HCURSOR result; // eax
  HCURSOR v4; // eax
  HCURSOR v5; // eax
  signed int v6; // ebx
  LRESULT (__stdcall *SendMessageW_1)(HWND, UINT, WPARAM, LPARAM); // edi
  signed int v8; // ecx
  __m128i v9; // xmm1
  char *v10; // edx
  unsigned int v11; // eax
  __m128i v12; // xmm0
  signed int v13; // esi
  const wchar_t *v14; // eax
  signed int v15; // esi
  signed int i; // edi
  int j; // esi
  const wchar_t *v18; // eax
  signed int v19; // esi
  signed int v20; // ecx
  __m128i v21; // xmm1
  char *v22; // edx
  unsigned int v23; // eax
  __m128i v24; // xmm0
  signed int k; // edi
  const wchar_t *v26; // eax
  void (__stdcall *SendMessageW)(HWND, UINT, WPARAM, LPARAM); // edi
  signed int v28; // ebx
  signed int l; // edi
  const wchar_t *v30; // eax
  LPARAM v31; // [esp+4h] [ebp-2684h]
  int v32; // [esp+Ch] [ebp-267Ch]
  CHAR *v33; // [esp+18h] [ebp-2670h]
  int v34; // [esp+1Ch] [ebp-266Ch]
  LPARAM v35; // [esp+38h] [ebp-2650h]
  int v36; // [esp+3Ch] [ebp-264Ch]
  int v37; // [esp+40h] [ebp-2648h]
  int v38; // [esp+58h] [ebp-2630h]
  struct tagOFNW ofn; // [esp+6Ch] [ebp-261Ch]
  LPARAM v40; // [esp+C4h] [ebp-25C4h]
  CHAR *v41; // [esp+D0h] [ebp-25B8h]
  int v42[4]; // [esp+D4h] [ebp-25B4h]
  LRESULT v43; // [esp+E4h] [ebp-25A4h]
  HCURSOR hCursor; // [esp+E8h] [ebp-25A0h]
  int v45; // [esp+ECh] [ebp-259Ch]
  LRESULT v46; // [esp+F0h] [ebp-2598h]
  HWND hWnd; // [esp+F4h] [ebp-2594h]
  FILE *File; // [esp+F8h] [ebp-2590h]
  int lParam[4]; // [esp+FCh] [ebp-258Ch]
  char v50[368]; // [esp+10Ch] [ebp-257Ch]
  CHAR szFormat[8190]; // [esp+27Ch] [ebp-240Ch]
  __int16 v52; // [esp+227Ah] [ebp-40Eh]
  wchar_t v53[256]; // [esp+227Ch] [ebp-40Ch]
  wchar_t Dst; // [esp+247Ch] [ebp-20Ch]
  char v55[518]; // [esp+247Eh] [ebp-20Ah]

  Dst = 0;
  memset(v55, 0, 0x206u);
  v1 = g_dwProcessId;
  v46 = g_dwProcessId;
  sub_1278310(g_dwProcessId, 0, v53, 0x100u);
  v2 = ghWndHandlesListCtrl;
  if ( gbShowDllView )
    v2 = ghWndDllsListCtrl;
  hWnd = v2;
  if ( !a1 && dword_13054FC )
  {
    tcscpy_s(&Dst, 0x104u, word_1305500);
LABEL_12:
    if ( v1 != g_dwProcessId )
      return MessageBoxW(ghWndNewOwner, L"The process has exited", L"Process Explorer", 0x10u);
    if ( _wfopen_s(&File, &Dst, L"w, ccs=UTF-8") )
    {
      LogEntry(szFormat, L"Error saving %s", &Dst);
      result = ErrMsgBox(szFormat, ghWndNewOwner);
    }
    else
    {
      v4 = ghWaitCursor;
      if ( !ghWaitCursor )
      {
        v4 = LoadCursorW(ghWaitCursor, IDC_WAIT);
        ghWaitCursor = v4;
      }
      v5 = SetCursor(v4);
      v6 = gdwProcessListColumnCount;
      SendMessageW_1 = ::SendMessageW;
      hCursor = v5;
      v41 = szFormat;
      v40 = 4;
      v42[0] = 4096;
      if ( !::SendMessageW(ghWndTreeListView, 0x103Bu, gdwProcessListColumnCount, lParam) )
      {
        v8 = 0;
        if ( v6 > 0 )
        {
          if ( v6 >= 8 )
          {
            v9 = _mm_load_si128(&xmmword_12BEA50);
            v10 = v50;
            do
            {
              v11 = v8 + 4;
              v10 += 32;
              v12 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v8), 0), v9);
              v8 += 8;
              _mm_storeu_si128(v10 - 3, v12);
              _mm_storeu_si128(v10 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0), v9));
            }
            while ( v8 < v6 - v6 % 8 );
          }
          for ( ; v8 < v6; ++v8 )
            lParam[v8] = v8;
        }
      }
      v13 = 0;
      if ( v6 > 0 )
      {
        do
        {
          ::SendMessageW(ghWndTreeListView, LVM_GETCOLUMNW, lParam[v13], &v40);
          v14 = L"\t";
          if ( v13 == v6 - 1 )
            v14 = L"\n";
          fwprintf(File, L"%s%s", v41, v14);
          ++v13;
        }
        while ( v13 < v6 );
        SendMessageW_1 = ::SendMessageW;
      }
      v15 = 0;
      v43 = SendMessageW_1(ghWndTreeListView, LVM_GETITEMCOUNT, 0, 0);
      v45 = 0;
      if ( v43 > 0 )
      {
        do
        {
          v35 = 4;
          *szFormat = 0;
          v37 = 0;
          v36 = v15;
          SendMessageW_1(ghWndTreeListView, LVM_GETITEMW, 0, &v35);
          for ( i = 0; i < v6; ++i )
          {
            v34 = 4096;
            *szFormat = 0;
            v32 = lParam[i];
            v33 = szFormat;
            ::SendMessageW(ghWndTreeListView, LVM_GETITEMTEXTW, v15, &v31);
            v52 = 0;
            if ( !i && gbShowProcessTree )
            {
              for ( j = 0; j < *(v38 + 80); ++j )
                fwprintf(File, L" ");
              v15 = v45;
            }
            v18 = L"\t";
            if ( i == v6 - 1 )
              v18 = L"\n";
            fwprintf(File, L"%s%s", szFormat, v18);
          }
          SendMessageW_1 = ::SendMessageW;
          v45 = ++v15;
        }
        while ( v15 < v43 );
      }
      fwprintf(File, L"\n");
      if ( v46 == g_dwProcessId )
      {
        if ( gbShowLowerpane && (g_dwProcessId & 0x80000000) == 0 )
        {
          fwprintf(File, L"Process: %s Pid: %d\n\n", v53, g_dwProcessId);
          v19 = gdwHandlesListColumnCount;
          if ( gbShowDllView )
            v19 = gdwDllsListColumnCount;
          if ( !SendMessageW_1(hWnd, LVM_GETCOLUMNORDERARRAY, v19, lParam) )
          {
            v20 = 0;
            if ( v19 > 0 )
            {
              if ( v19 >= 8 )
              {
                v21 = _mm_load_si128(&xmmword_12BEA50);
                v22 = v50;
                do
                {
                  v23 = v20 + 4;
                  v22 += 32;
                  v24 = _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v20), 0), v21);
                  v20 += 8;
                  _mm_storeu_si128(v22 - 3, v24);
                  _mm_storeu_si128(v22 - 2, _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v23), 0), v21));
                }
                while ( v20 < v19 - v19 % 8 );
              }
              for ( ; v20 < v19; ++v20 )
                lParam[v20] = v20;
            }
          }
          for ( k = 0; k < v19; ++k )
          {
            ::SendMessageW(hWnd, LVM_GETCOLUMNW, lParam[k], &v40);
            v26 = L"\t";
            if ( k == v19 - 1 )
              v26 = L"\n";
            fwprintf(File, L"%s%s", v41, v26);
          }
          SendMessageW = ::SendMessageW;
          v28 = 0;
          v46 = ::SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
          if ( v46 > 0 )
          {
            do
            {
              v35 = 4;
              *szFormat = 0;
              v37 = 0;
              v36 = v28;
              SendMessageW(hWnd, LVM_GETITEMW, 0, &v35);
              for ( l = 0; l < v19; ++l )
              {
                v34 = 4096;
                *szFormat = 0;
                v32 = lParam[l];
                v33 = szFormat;
                ::SendMessageW(hWnd, LVM_GETITEMTEXTW, v28, &v31);
                v52 = 0;
                v30 = L"\t";
                if ( l == v19 - 1 )
                  v30 = L"\n";
                fwprintf(File, L"%s%s", szFormat, v30);
              }
              SendMessageW = ::SendMessageW;
              ++v28;
            }
            while ( v28 < v46 );
          }
        }
      }
      else
      {
        MessageBoxW(ghWndNewOwner, L"The process has exited", L"Process Explorer", 0x10u);
      }
      fclose(File);
      tcscpy_s(word_1305500, _MAX_PATH, &Dst);
      dword_13054FC = 1;
      result = SetCursor(hCursor);
    }
    return result;
  }
  if ( v53[0] == 60 )
    tcscpy_s(v53, 0x100u, L"Procexp");
  if ( word_1305500[0] )
    tcscpy_s(&Dst, _MAX_PATH, word_1305500);
  else
    stprintf(&Dst, L"%s.txt", v53);
  ofn.hwndOwner = ghWndNewOwner;
  ofn.hInstance = ghInstance;
  ofn.lpstrFile = &Dst;
  *&ofn.nFileOffset = 0;
  ofn.lpfnHook = 0;
  ofn.lStructSize = 76;
  ofn.lpstrCustomFilter = 0;
  ofn.nMaxCustFilter = 0;
  ofn.nFilterIndex = 1;
  ofn.nMaxFile = 256;
  ofn.lpstrFileTitle = 0;
  ofn.nMaxFileTitle = 0;
  ofn.lpstrInitialDir = 0;
  ofn.Flags = 0x200004;
  ofn.lpstrTitle = L"Save Process Explorer Data...";
  ofn.lpstrDefExt = L"*.txt";
  ofn.lpstrFilter = L"Process Explorer Data (*.TXT)";
  result = GetSaveFileNameW(&ofn);
  if ( result )
    goto LABEL_12;
  return result;
}
// 12BEA50: using guessed type __int128 xmmword_12BEA50;
// 12C6A18: using guessed type wchar_t aSaveProcessExp[30];
// 12C6A54: using guessed type wchar_t aTxt[6];
// 12C6A60: using guessed type wchar_t aProcessExplore_11[30];
// 12E5742: using guessed type char gbShowProcessTree;
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;
// 13054FC: using guessed type int dword_13054FC;
// 127E3B0: using guessed type LPARAM lParam[4];

//----- (0127EB40) --------------------------------------------------------
HCURSOR __cdecl SaveStringToFile(HWND hWnd, int ArgList)
{
  HCURSOR result; // eax
  HCURSOR v3; // eax
  LRESULT v4; // ebx
  signed int i; // esi
  LPARAM v6; // [esp+8h] [ebp-22D8h]
  int v7; // [esp+10h] [ebp-22D0h]
  wchar_t *v8; // [esp+1Ch] [ebp-22C4h]
  int v9; // [esp+20h] [ebp-22C0h]
  LPARAM lParam; // [esp+3Ch] [ebp-22A4h]
  int v11; // [esp+40h] [ebp-22A0h]
  int v12; // [esp+44h] [ebp-229Ch]
  struct tagOFNW ofn; // [esp+70h] [ebp-2270h]
  HWND v14; // [esp+C8h] [ebp-2218h]
  HCURSOR hCursor; // [esp+CCh] [ebp-2214h]
  FILE *File; // [esp+D0h] [ebp-2210h]
  wchar_t Dst; // [esp+D4h] [ebp-220Ch]
  __int16 v18; // [esp+20D2h] [ebp-20Eh]
  __int16 szFileName[260]; // [esp+20D4h] [ebp-20Ch]

  szFileName[0] = 0;
  v14 = hWnd;
  memset(&szFileName[1], 0, 0x206u);
  stprintf(szFileName, L"%s.txt", ArgList);
  ofn.hwndOwner = ghWndNewOwner;
  ofn.hInstance = ghInstance;
  ofn.lpstrFile = szFileName;
  *&ofn.nFileOffset = 0;
  ofn.lpfnHook = 0;
  ofn.lStructSize = 76;
  ofn.lpstrCustomFilter = 0;
  ofn.nMaxCustFilter = 0;
  ofn.nFilterIndex = 1;
  ofn.nMaxFile = 256;
  ofn.lpstrFileTitle = 0;
  ofn.nMaxFileTitle = 0;
  ofn.lpstrInitialDir = 0;
  ofn.Flags = 2097156;
  ofn.lpstrTitle = L"Save Process Explorer Strings...";
  ofn.lpstrDefExt = L"*.txt";
  ofn.lpstrFilter = L"Process Explorer Strings (*.TXT)";
  result = GetSaveFileNameW(&ofn);
  if ( result )
  {
    if ( _wfopen_s(&File, szFileName, L"w, ccs=UTF-8") )
    {
      LogEntry(&Dst, L"Error saving %s", szFileName);
      result = ErrMsgBox(&Dst, ghWndNewOwner);
    }
    else
    {
      v3 = ghCursorWait;
      if ( !ghCursorWait )
      {
        v3 = LoadCursorW(ghCursorWait, IDC_WAIT);
        ghCursorWait = v3;
      }
      hCursor = SetCursor(v3);
      v4 = SendMessageW(hWnd, LVM_GETITEMCOUNT, 0, 0);
      for ( i = 0; i < v4; ++i )
      {
        lParam = 4;
        Dst = 0;
        v12 = 0;
        v11 = i;
        SendMessageW(ghWndTreeListView, 0x104Bu, 0, &lParam);
        v9 = 4096;
        Dst = 0;
        v7 = 0;
        v8 = &Dst;
        SendMessageW(v14, 0x1073u, i, &v6);
        v18 = 0;
        fwprintf(File, L"%s\n", &Dst);
      }
      fclose(File);
      result = SetCursor(hCursor);
    }
  }
  return result;
}
// 12C6A54: using guessed type wchar_t aTxt[6];
// 12C6B60: using guessed type wchar_t aSaveProcessExp_0[33];
// 12C6BA8: using guessed type wchar_t aProcessExplore_12[33];

//----- (0127EDC0) --------------------------------------------------------
BOOL __stdcall CpuAffinityDlgProc(HWND hDlg, UINT ProcessAffinityMask, WPARAM SystemAffinityMask, LPARAM hProcess)
{
  unsigned int v5; // edi
  signed int v6; // esi
  unsigned int idx; // edi
  signed int v8; // esi
  DWORD v9; // esi
  HWND v10; // eax

  if ( ProcessAffinityMask == 272 )
  {
    ghProcessToCheckCPUAffinity = hProcess;
    if ( GetProcessAffinityMask(hProcess, &ProcessAffinityMask, &SystemAffinityMask) )
    {
      idx = 0;
      v8 = 1;
      do
      {
        if ( v8 & ProcessAffinityMask )
          CheckDlgButton(hDlg, idx + 2000, 1u);
        ++idx;
        v8 = __ROL4__(v8, 1);
      }
      while ( idx < 0x3F );
      v9 = 63;
      if ( gSystemInfo.dwNumberOfProcessors <= 0x3F )
      {
        do
        {
          v10 = GetDlgItem(hDlg, v9 + 2000);
          EnableWindow(v10, 0);
          --v9;
        }
        while ( v9 >= gSystemInfo.dwNumberOfProcessors );
      }
      return 1;
    }
    ErrMsgBox(L"Error retrieving process affinity", hDlg);
    EndDialog(hDlg, 0);
    return 0;
  }
  if ( ProcessAffinityMask != 273 )
    return 0;
  if ( SystemAffinityMask == 1 )
  {
    v5 = 0;
    ProcessAffinityMask = 0;
    v6 = 1;
    do
    {
      if ( IsDlgButtonChecked(hDlg, v5 + 2000) == 1 )
        ProcessAffinityMask |= v6;
      ++v5;
      v6 = __ROL4__(v6, 1);
    }
    while ( v5 < 0x1F );
    if ( !SetProcessAffinityMask(ghProcessToCheckCPUAffinity, ProcessAffinityMask) )
      ErrMsgBox(L"Error setting affinity", hDlg);
  }
  else if ( SystemAffinityMask != 2 )
  {
    return 0;
  }
  EndDialog(hDlg, 0);
  return 1;
}

//----- (0127EF00) --------------------------------------------------------
int __cdecl sub_127EF00(HMENU hmenu, int a2)
{
  int result; // eax

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBCu, 0);
      break;
    case 1:
    case 2:
    case 3:
    case 4:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBBu, 0);
      break;
    case 5:
    case 6:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBDu, 0);
      break;
    case 7:
    case 8:
    case 9:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBEu, 0);
      break;
    case 10:
    case 11:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CBFu, 0);
      break;
    case 12:
    case 13:
    case 14:
    case 15:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CC0u, 0);
      break;
    case 24:
      result = CheckMenuRadioItem(hmenu, 0x9CBBu, 0x9CC1u, 0x9CC1u, 0);
      break;
    default:
      return result;
  }
  return result;
}

//----- (0127EFB0) --------------------------------------------------------
int __cdecl sub_127EFB0(unsigned int a1)
{
  signed int v1; // ebx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  signed int v5; // ecx
  int v6; // edi
  int v7; // edx
  signed int v8; // ecx
  int v9; // edi
  int v10; // edx

  v1 = dword_12EAFB0;
  if ( a1 > dword_12EAFB0 )
  {
    sub_1246750(&dword_12EAFA8, 0, &dword_12EAFB0, &dword_12EAFAC);
    v1 = dword_12EAFB0;
    if ( a1 > dword_12EAFB0 )
      return 0;
  }
  if ( gdwOsType < 2 )
    v3 = dword_12EAFAC + 12 * (a1 - 1);
  else
    v3 = dword_12EAFAC + 16 * a1 - 16;
  v4 = *(v3 + 4);
  if ( v4 <= a1 )
  {
    if ( v4 < a1 )
    {
      v8 = a1 - 1;
      if ( (a1 - 1) < v1 )
      {
        v9 = dword_12EAFAC + 12 * v8;
        v10 = dword_12EAFAC + 16 * v8;
        do
        {
          v3 = v9;
          if ( gdwOsType >= 2 )
            v3 = v10;
          if ( *(v3 + 4) == a1 )
            break;
          ++v8;
          v10 += 16;
          v9 += 12;
        }
        while ( v8 < v1 );
      }
    }
  }
  else
  {
    v5 = a1 - 1;
    if ( (a1 - 1) > 0 )
    {
      v6 = dword_12EAFAC + 12 * v5;
      v7 = dword_12EAFAC + 16 * v5;
      while ( 1 )
      {
        v3 = v6;
        if ( gdwOsType >= 2 )
          v3 = v7;
        if ( *(v3 + 4) == a1 )
          break;
        --v5;
        v7 -= 16;
        v6 -= 12;
        if ( v5 <= 0 )
          return *(v3 + 8);
      }
    }
  }
  return *(v3 + 8);
}
// 12E4E54: using guessed type int gdwOsType;
// 12EAFA8: using guessed type int dword_12EAFA8;
// 12EAFAC: using guessed type int dword_12EAFAC;
// 12EAFB0: using guessed type int dword_12EAFB0;

//----- (0127F0A0) --------------------------------------------------------
_DWORD *__cdecl sub_127F0A0(unsigned __int8 a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // edi
  int i; // esi
  signed int v5; // eax
  _SYSTEM_PROCESS_INFORMATION *v6; // eax
  int v7; // eax
  _SYSTEM_PROCESS_INFORMATION *ppBuffer; // [esp+Ch] [ebp-4h]

  *a3 = 0;
  ppBuffer = 0;
  GetAllProcesses(&ppBuffer, 0);
  v3 = a3;
  for ( i = 0; ; ++i )
  {
    v5 = NtSuspendProcess ? 1 : a1 + 1;
    if ( i >= v5 )
      break;
    v3 = 87;
    v6 = ppBuffer;
    if ( ppBuffer->UniqueProcessId == a2 )
    {
LABEL_9:
      v7 = sub_12706C0(a1, v6, i);
      v3 = v7;
      if ( !v7 || !i && v7 == 1904 )
      {
        *a3 = 1;
        goto LABEL_17;
      }
    }
    else
    {
      while ( v6->NextEntryOffset )
      {
        v6 = (v6 + v6->NextEntryOffset);
        if ( v6->UniqueProcessId == a2 )
          goto LABEL_9;
      }
    }
    if ( !*a3 )
      break;
LABEL_17:
    if ( a1 )
      Sleep(0x64u);
  }
  free(ppBuffer);
  if ( *a3 )
    v3 = 0;
  return v3;
}
// 12EF24C: using guessed type int (__stdcall *NtSuspendProcess)(_DWORD);

//----- (0127F170) --------------------------------------------------------
bool __cdecl LoadDbgHelp(LPCTSTR lpLibFileName)
{
  HMODULE hModule; // esi
  int (__stdcall *pfnSymLoadModule64_1)(HANDLE, HANDLE, PCSTR, PCSTR, DWORD64, DWORD); // eax
  int (__stdcall *pfnSymLoadModule64_2)(HANDLE, HANDLE, PCSTR, PCSTR, DWORD64, DWORD); // ecx
  int v4; // eax
  bool LoadedFailed; // zf

  hModule = LoadLibraryW(lpLibFileName);
  *SymInitialize = GetProcAddress(hModule, "SymInitialize");
  *EnumerateLoadedModulesW64 = GetProcAddress(hModule, "EnumerateLoadedModulesW64");
  *SymRegisterCallback64 = GetProcAddress(hModule, "SymRegisterCallback64");
  *SymGetModuleInfoW64 = GetProcAddress(hModule, "SymGetModuleInfoW64");
  *SymCleanup = GetProcAddress(hModule, "SymCleanup");
  *SymFromAddrW = GetProcAddress(hModule, "SymFromAddrW");
  *SymGetSymFromName = GetProcAddress(hModule, "SymGetSymFromName");
  *MiniDumpWriteDump = GetProcAddress(hModule, "MiniDumpWriteDump");
  *SymSetOptions = GetProcAddress(hModule, "SymSetOptions");
  *SymGetOptions = GetProcAddress(hModule, "SymGetOptions");
  *SymLoadModuleExW = GetProcAddress(hModule, "SymLoadModuleExW");
  if ( *SymLoadModuleExW )
  {
    Hook_SymLoadModuleExW = Real_SymLoadModuleExW;
  }
  else
  {
    pfnSymLoadModule64_1 = GetProcAddress(hModule, "SymLoadModule64");
    pfnSymLoadModule64_2 = 0;
    pfnSymLoadModule64 = pfnSymLoadModule64_1;
    if ( pfnSymLoadModule64_1 )
      pfnSymLoadModule64_2 = Proxy_SymLoadModule64;
    Hook_SymLoadModuleExW = pfnSymLoadModule64_2;
  }
  *SymUnloadModule64 = GetProcAddress(hModule, "SymUnloadModule64");
  *ImageNtHeader = GetProcAddress(hModule, "ImageNtHeader");
  *StackWalk64 = GetProcAddress(hModule, "StackWalk64");
  *SymGetModuleBase64 = GetProcAddress(hModule, "SymGetModuleBase64");
  *SymFunctionTableAccess64 = GetProcAddress(hModule, "SymFunctionTableAccess64");
  if ( gbSymbolWarningShown )
    goto LABEL_9;
  v4 = *SymInitialize;
  LoadedFailed = *SymInitialize == NULL;
  if ( *SymInitialize )
  {
    if ( !gszSymbolPath[0] )
    {
LABEL_10:
      LoadedFailed = v4 == 0;
      return !LoadedFailed;
    }
LABEL_9:
    SetEnvironmentVariableW(L"_NT_SYMBOL_PATH", gszSymbolPath);
    v4 = *SymInitialize;
    goto LABEL_10;
  }
  return !LoadedFailed;
}
// 12E98FC: using guessed type char gbSymbolWarningShown;

//----- (0127F2C0) --------------------------------------------------------
BOOL __stdcall SysInfoPropWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax
  LRESULT v5; // ST14_4
  HWND v6; // eax
  int nShowCmd; // eax
  HWND hTab; // eax
  CResize *v9; // eax
  CResize *v10; // esi
  HWND v11; // eax
  char bAdministrator1; // al
  const wchar_t *pszName; // ecx
  const wchar_t *pszName2; // eax
  bool bAdministrator; // zf
  const wchar_t *pszName4; // ecx
  const wchar_t *pszName3; // eax
  HWND hTabCtrl; // eax
  HWND hTab1; // ebx
  LONG dwExStyle; // eax
  LONG dwStyle; // eax
  HWND hWndParent; // edi
  void (__stdcall *SendMessage)(HWND, UINT, WPARAM, LPARAM); // ecx
  const WCHAR **ppszTemplateName; // ebx
  WPARAM nTab; // edx
  LPARAM v26; // eax
  const WCHAR *pszTemplateName; // esi
  SysInfoPageFuncItem *pszText; // eax
  HWND hWndPage; // edi
  HWND hWndTab; // ebx
  HWND v32; // eax
  signed int idx; // esi
  HWND v34; // eax
  HWND v35; // eax
  LRESULT v36; // esi
  HWND v37; // eax
  LRESULT v38; // edi
  HWND v39; // eax
  HWND v40; // eax
  HWND v41; // eax
  NMHDR nmhdr; // [esp+Ch] [ebp-98h]
  HWND hTab2; // [esp+18h] [ebp-8Ch]
  TCITEMW tcitemm; // [esp+1Ch] [ebp-88h]
  WPARAM iTab; // [esp+38h] [ebp-6Ch]
  HWND hWnda; // [esp+3Ch] [ebp-68h]
  LPARAM nCount; // [esp+40h] [ebp-64h]
  struct tagRECT Rect; // [esp+44h] [ebp-60h]
  struct tagRECT rcTab; // [esp+54h] [ebp-50h]
  SysInfoPageFuncItem SummaryPageFuncItem; // [esp+64h] [ebp-40h]
  SysInfoPageFuncItem CPUPageFuncItem; // [esp+70h] [ebp-34h]
  SysInfoPageFuncItem MemoryPageFuncItem; // [esp+7Ch] [ebp-28h]
  SysInfoPageFuncItem IOPageFuncItem; // [esp+88h] [ebp-1Ch]
  SysInfoPageFuncItem GPUPageFuncItem; // [esp+94h] [ebp-10h]

  nCount = lParam;
  hWnda = hWnd;
  if ( message > WM_INITDIALOG )
  {
    if ( message == WM_COMMAND )
    {
      if ( wParam > IDS_PROCEXPLORERMENU_REFRESH_NOW )
      {
        switch ( wParam )
        {
          case IDS_PROCEXPLORERMENU_PAUSED_SPACE:
          case IDS_PROCEXPLORERMENU_TWO_SECONDS:
          case IDS_PROCEXPLORERMENU_FIVE_SECONDS:
          case IDS_PROCEXPLORERMENU_ONE_SECONDS:
          case IDS_PROCEXPLORERMENU_TEN_SECONDS:
          case IDS_PROCEXPLORERMENU_HALF_SECONDS:
            PostMessageW(ghWndNewOwner, WM_COMMAND, wParam, lParam);
            break;
          case IDS_PROCEXPLORERMENU_PROCESS_WINDOW_BRING_TO_FRONT|0x8:
          case IDS_PROCEXPLORERMENU_SHOW_COLUMN_HEATMAPS|0x4:
            v35 = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
            v36 = SendMessageW(v35, TCM_GETITEMCOUNT, 0, 0);
            v37 = GetDlgItem(hWnda, IDD_PROCPROPSHEET_CTRL_TABCTRL);
            v38 = SendMessageW(v37, TCM_GETCURSEL, 0, 0);
            v39 = GetDlgItem(hWnda, IDD_PROCPROPSHEET_CTRL_TABCTRL);
            SendMessageW(v39, TCM_SETCURSEL, (v36 + v38 + 2 * (wParam == 40092) - 1) % v36, 0);
            tcitemm.mask = TCIF_PARAM;
            tcitemm.lParam = 0;
            v40 = GetDlgItem(hWnda, IDD_PROCPROPSHEET_CTRL_TABCTRL);
            SendMessageW(v40, TCM_GETITEMW, v38, &tcitemm);
            ShowWindow(tcitemm.lParam, SW_HIDE);
            v41 = GetDlgItem(hWnda, IDD_PROCPROPSHEET_CTRL_TABCTRL);
            SendMessageW(v41, TCM_GETITEMW, (v36 + v38 + 2 * (wParam == 40092) - 1) % v36, &tcitemm);
            ShowWindow(tcitemm.lParam, SW_SHOW);
            break;
          default:
            return 0;
        }
      }
      else if ( wParam == IDS_PROCEXPLORERMENU_REFRESH_NOW )
      {
        SetEvent(ghEventRefreshSearchResult);
      }
      else if ( wParam > 0 && (wParam <= IDCANCEL || wParam == IDS_PROCEXPLORERMENU_EXIT) )
      {
        SendMessageW(hWnd, WM_CLOSE, 0, 0);
      }
    }
    else if ( message == WM_TIMER )
    {
      v32 = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
      idx = 0;
      nCount = SendMessageW(v32, TCM_GETITEMCOUNT, 0, 0);
      if ( nCount > 0 )
      {
        do
        {
          tcitemm.mask = TCIF_PARAM;
          tcitemm.lParam = 0;
          v34 = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
          SendMessageW(v34, TCM_GETITEMW, idx, &tcitemm);
          SendMessageW(tcitemm.lParam, WM_TIMER, 0, 0);
          ++idx;
        }
        while ( idx < nCount );
      }
    }
    return 0;
  }
  if ( message != WM_INITDIALOG )
  {
    if ( message == WM_DESTROY )
    {
      GetWindowPlacement(hWnd, &gWindowPlacement[4]);
      hTab = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
      gdwDefaultSysInfoPage = SendMessageW(hTab, TCM_GETCURSEL, 0, 0);
      EnterCriticalSection(&gLockForSysInfoProperties);
      ghSysinfoPropSheetDlg = 0;
      LeaveCriticalSection(&gLockForSysInfoProperties);
      _endthread();
    }
    if ( message == WM_CLOSE )
    {
      DestroyWindow(hWnd);
    }
    else if ( message == WM_NOTIFY && (*(lParam + 8) + 552) <= 1 )
    {
      v4 = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
      tcitemm.mask = 8;
      v5 = SendMessageW(v4, TCM_GETCURSEL, 0, 0);
      tcitemm.lParam = 0;
      v6 = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
      SendMessageW(v6, TCM_GETITEMW, v5, &tcitemm);
      nShowCmd = SW_HIDE;
      if ( *(nCount + 8) == -0x227u )
        nShowCmd = SW_SHOW;
      ShowWindow(tcitemm.lParam, nShowCmd);
    }
    return 0;
  }
  // WM_INITDIALOG
  v9 = operator new(0x40u);
  if ( v9 )
    CResize::CResize(v9, hWnd);
  v10 = operator new(0x40u);
  if ( v10 )
  {
    v11 = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
    CResize::CResize(v10, v11);
  }
  SummaryPageFuncItem.Name = L"Summary";
  SummaryPageFuncItem.WndProc = SysInfoSummaryPageWndProc;
  bAdministrator1 = IsBuiltinAndAnministrative();
  CPUPageFuncItem.Name = L"CPU";
  CPUPageFuncItem.WndProc = SysInfoCPUPageWndProc;
  pszName = L"SYSTEMINFOSUMETW";
  CPUPageFuncItem.DlgTemplateName = L"SYSTEMINFOCPU";
  if ( !bAdministrator1 )
    pszName = L"SYSTEMINFOSUM";
  MemoryPageFuncItem.Name = L"Memory";
  pszName2 = L"SYSTEMINFOMEM";
  SummaryPageFuncItem.DlgTemplateName = pszName;
  if ( gdwOsType < WINDOWS_VISTA )
    pszName2 = L"SYSTEMINFOMEMXP";
  MemoryPageFuncItem.WndProc = SysInfoMemoryPageWndProc;
  MemoryPageFuncItem.DlgTemplateName = pszName2;
  IOPageFuncItem.Name = L"I/O";
  IOPageFuncItem.WndProc = SysInfoIOPageWndProc;
  bAdministrator = IsBuiltinAndAnministrative() == 0;
  GPUPageFuncItem.Name = L"GPU";
  GPUPageFuncItem.WndProc = SysInfoGPUPageWndProc;
  pszName4 = L"SYSTEMINFOIOETW";
  pszName3 = L"SYSTEMINFOGPU";
  if ( bAdministrator )
    pszName4 = L"SYSTEMINFOIO";
  IOPageFuncItem.DlgTemplateName = pszName4;
  if ( gdwAdapterRuntingTime <= 0 )
    pszName3 = NULL;
  GPUPageFuncItem.DlgTemplateName = pszName3;
  hTabCtrl = GetDlgItem(hWnd, IDD_PROCPROPSHEET_CTRL_TABCTRL);
  hTab1 = hTabCtrl;
  hTab2 = hTabCtrl;
  dwExStyle = GetWindowLongW(hTabCtrl, GWL_EXSTYLE);
  SetWindowLongW(hTab1, GWL_EXSTYLE, dwExStyle | WS_EX_CONTROLPARENT);
  dwStyle = GetWindowLongW(hTab1, GWL_STYLE);
  hWndParent = hTab1;
  SetWindowLongW(hTab1, GWL_STYLE, dwStyle | WS_CLIPCHILDREN);
  SendMessage = SendMessageW;
  ppszTemplateName = &SummaryPageFuncItem.DlgTemplateName;
  nTab = 0;
  v26 = 5;
  iTab = 0;
  nCount = 5;
  do
  {
    pszTemplateName = *ppszTemplateName;
    if ( *ppszTemplateName )
    {
      pszText = *(ppszTemplateName - 2);        // pPageFuncItem->Name
      _mm_storeu_si128(&tcitemm.dwState, 0i64);
      tcitemm.pszText = pszText;
      *&tcitemm.iImage = 0i64;
      tcitemm.mask = TCIF_TEXT;
      // 增加一个TAB项
      SendMessage(hWndParent, TCM_INSERTITEMW, nTab, &tcitemm);
      GetClientRect(hWndParent, &rcTab);
      SendMessageW(hWndParent, TCM_ADJUSTRECT, 0, &rcTab);
      // pszTemplateName = pPageFuncItem->szTemplateName
      // DlgProc = pPageFuncItem->WndProc
      hWndPage = CreateDialogParamW(ghInstance, pszTemplateName, hWndParent, *(ppszTemplateName - 1), 0);
      MoveWindow(hWndPage, rcTab.left, rcTab.top, rcTab.right - rcTab.left, rcTab.bottom - rcTab.top, 1);
      ShowWindow(hWndPage, SW_HIDE);
      // 将Page的HWND句柄作为TCITEM的lParam数据保存
      tcitemm.lParam = hWndPage;
      hWndParent = hTab2;
      tcitemm.mask = TCIF_PARAM;
      SendMessageW(hTab2, TCM_SETITEMW, iTab, &tcitemm);
      v26 = nCount;
      nTab = iTab + 1;
      SendMessage = SendMessageW;
      ++iTab;
    }
    ppszTemplateName += 3;
    nCount = --v26;
  }
  while ( v26 );
  SendMessage(hWndParent, TCM_SETCURSEL, gdwDefaultSysInfoPage, 0);
  hWndTab = hWnda;
  nmhdr.idFrom = IDD_PROCPROPSHEET_CTRL_TABCTRL;
  nmhdr.code = -0x227u;
  SendMessageW(hWnda, WM_NOTIFY, 0, &nmhdr);
  if ( gWindowPlacement[4].rcNormalPosition.right )
    _mm_storeu_si128(&Rect, _mm_loadu_si128(&gWindowPlacement[4].rcNormalPosition));
  else
    GetWindowRect(hWndTab, &Rect);
  gWindowPlacement[4].showCmd = SW_SHOW;
  SetWindowPlacement(hWndTab, &gWindowPlacement[4]);
  if ( gbAlwaysOntop )
    SetWindowPos(hWndTab, HWND_MESSAGE|0x2, 0, 0, 0, 0, 3u);
  return 1;
}
// 128A009: using guessed type int _endthread(void);
// 12C67DC: using guessed type wchar_t aSummary[8];
// 12C67EC: using guessed type wchar_t aSysteminfosume[17];
// 12C6810: using guessed type wchar_t aSysteminfosum[14];
// 12C682C: using guessed type wchar_t aCpu_0[4];
// 12C6834: using guessed type wchar_t aSysteminfocpu[14];
// 12C6850: using guessed type wchar_t aMemory[7];
// 12C6860: using guessed type wchar_t aSysteminfomem[14];
// 12C687C: using guessed type wchar_t aSysteminfomemx[16];
// 12C689C: using guessed type wchar_t aIO_0[4];
// 12C68A4: using guessed type wchar_t aSysteminfoioet[16];
// 12C68C4: using guessed type wchar_t aSysteminfoio[13];
// 12C68E0: using guessed type wchar_t aGpu_0[4];
// 12C68E8: using guessed type wchar_t aSysteminfogpu[14];
// 12E4E54: using guessed type int gdwOsType;
// 12E96D2: using guessed type char gbAlwaysOntop;

//----- (0127F8F0) --------------------------------------------------------
bool __cdecl sub_127F8F0(double a1, double *a2)
{
  bool result; // al

  result = a1 != *a2;
  *a2 = a1;
  return result;
}

//----- (0127F920) --------------------------------------------------------
char __cdecl sub_127F920(int a1, int a2, _DWORD *a3)
{
  char result; // al

  if ( a1 != *a3 || a2 != a3[1] )
  {
    *a3 = a1;
    a3[1] = a2;
    result = 1;
  }
  else
  {
    *a3 = a1;
    a3[1] = a2;
    result = 0;
  }
  return result;
}

//----- (0127F950) --------------------------------------------------------
void __cdecl VerifySignatureThreadProc(#1077 *lpAddend)
{
  VerifySignatureOK(lpAddend, 1);
  if ( *(lpAddend + 1) )
    sub_1238600(lpAddend);
  else
    DestroyTreeListItemData(lpAddend);
}

//----- (0127F980) --------------------------------------------------------
int __thiscall ATL::CComCriticalSection::Init(LPCRITICAL_SECTION lpCriticalSection)
{
  int result; // eax

  if ( InitializeCriticalSectionAndSpinCount(lpCriticalSection, 0) )
    return 0;
  result = GetLastError();
  if ( result > 0 )
    result = result | 0x80070000;
  return result;
}

//----- (0127F9B0) --------------------------------------------------------
int sub_127F9B0(wchar_t *DstBuf, size_t MaxCount, wchar_t *Format, ...)
{
  va_list ArgList; // [esp+14h] [ebp+14h]

  va_start(ArgList, Format);
  return _vsnwprintf_s(DstBuf, 0x100u, MaxCount, Format, ArgList);
}

//----- (0127F9D0) --------------------------------------------------------
LRESULT __cdecl InitStatusBar(HWND hWnd)
{
  HWND hWndSB; // edx
  WPARAM iPart; // ecx
  signed int number; // edi
  signed int flags; // esi
  int count; // eax
  int sbParts[32]; // [esp+10h] [ebp-84h]

  hWndSB = hWnd;
  iPart = 0;
  number = 32;
  gdwStatusBarCount = 0;
  flags = 1;
  do
  {
    if ( flags & gdwStatusBarColumns )
    {
      sbParts[iPart] = 10 * (iPart + 1);
      SendMessageW(hWndSB, SB_SETTEXTW, iPart, gszStatusBarText);
      hWndSB = hWnd;
      iPart = gdwStatusBarCount++ + 1;
    }
    flags = __ROL4__(flags, 1);
    --number;
  }
  while ( number );
  SendMessageW(hWndSB, SB_SETTEXTW, iPart, gszStatusBarText);
  count = gdwStatusBarCount;
  sbParts[gdwStatusBarCount] = -1;
  gdwStatusBarCount = count + 1;
  return SendMessageW(ghWndStatusBar, SB_SETPARTS, count + 1, sbParts);
}
// 12E5990: using guessed type int gdwStatusBarColumns;
// 1305720: using guessed type int gdwStatusBarCount;
// 127F9D0: using guessed type LPARAM sbParts[32];

//----- (0127FA90) --------------------------------------------------------
int __cdecl OnTooltipGetDipsInfoW(int a1, int a2)
{
  unsigned int v2; // eax
  WCHAR Buffer; // [esp+4h] [ebp-804h]

  v2 = *(a2 + 4);
  if ( v2 <= 0x9EC3 )
  {
    if ( v2 == 40643 )
    {
      LoadStringW(ghInstance, IDS_PROPERTIES, &Buffer, 1024);
    }
    else
    {
      switch ( v2 )
      {
        case IDS_PROCEXPLORERMENU_REFRESH_NOW:
          LoadStringW(ghInstance, IDS_REFRESHNOW, &Buffer, 1024);
          break;
        case IDS_PROCEXPLORERMENU_SHOW_UNNAMED_HANDLES_AND_MAPPINGS:
          LoadStringW(ghInstance, IDS_SHOWUNNAMEDOBJECTS, &Buffer, 1024);
          break;
        case IDS_PROCEXPLORERMENU_SAVE:
          LoadStringW(ghInstance, IDS_SAVE, &Buffer, 1024);
          break;
        case IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS:
          LoadStringW(ghInstance, IDS_KILLPROCESS, &Buffer, 1024);
          break;
        case IDM_OTHER_VIEW_HANDLES:
          if ( gbShowDllView )
            LoadStringW(ghInstance, IDS_VIEWHANDLES, &Buffer, 1024);
          else
            LoadStringW(ghInstance, IDS_VIEWDLLS, &Buffer, 1024);
          break;
        case IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE:
          LoadStringW(ghInstance, IDS_SHOWPROCESSTREE, &Buffer, 1024);
          break;
        case IDS_PROCEXPLORERMENU_SHOW_LOWER_PANE:
          if ( gbShowLowerpane )
            LoadStringW(ghInstance, IDS_HIDELOWERPANE, &Buffer, 1024);
          else
            LoadStringW(ghInstance, IDS_SHOWLOWERPANE, &Buffer, 1024);
          break;
        case IDS_TRAYMENU_SYSTEM_INFORMATION:
          LoadStringW(ghInstance, IDS_SYSTEMINFORMATION, &Buffer, 1024);
          break;
        case IDS_PROCEXPLORERMENU_FIND_HANDLE_OR_DLL:
          LoadStringW(ghInstance, IDS_FINDHANDLE, &Buffer, 1024);
          break;
        case IDM_OTHER_FIND_DLLS_OR_HANDLES:
          LoadStringW(ghInstance, IDS_FINDHANDLEORDLL, &Buffer, 1024);
          break;
        case IDM_OTHER_FIND_WINDOW_PROCESS:
          LoadStringW(ghInstance, IDS_DRAGFINDWINDOW, &Buffer, 1024);
          break;
        default:
          break;
      }
    }
  }
  *(a2 + 12) = &Buffer;
  return 0;
}
// 12E96CC: using guessed type char gbShowDllView;
// 12E96CD: using guessed type char gbShowLowerpane;

//----- (0127FCA0) --------------------------------------------------------
void __cdecl sub_127FCA0(int a1, __int64 a2)
{
  bool v2; // zf
  HICON v3; // esi
  int nValue128[4]; // [esp+Ch] [ebp-21Ch]
  wchar_t Src; // [esp+1Ch] [ebp-20Ch]

  v2 = guIdOfCommitTrayIcon == 0;
  _mm_storeu_si128(nValue128, _mm_load_si128(&xmmword_12C7010));
  if ( !v2 )
  {
    sub_1232410(&Src, 0x104u, L"Current Commit: ", a2);
    v3 = PEDrawIcon(a1, 0, nValue128, gColorGraphBackground, 0, 0.0);
    UpdateTrayIcon(ghWndNewOwner, guIdOfCommitTrayIcon, v3, &Src);
    DestroyIcon(v3);
  }
}
// 12C6CEC: using guessed type wchar_t aCurrentCommit[17];
// 12C7010: using guessed type __int128 xmmword_12C7010;

//----- (0127FD50) --------------------------------------------------------
char __cdecl sub_127FD50(CGraphData *a1, double a2, int a3, double a4)
{
  int nOffset; // eax
  CGraphData *pGraphData; // edi
  bool v6; // zf
  double v7; // xmm0_8
  signed int v8; // ebx
  HICON hIcon1; // eax
  unsigned int v10; // esi
  unsigned int v11; // eax
  HICON v12; // esi
  ICONINFO piconinfo; // [esp+14h] [ebp-234h]
  CGraphData *v15; // [esp+28h] [ebp-220h]
  int a3a[4]; // [esp+2Ch] [ebp-21Ch]
  __int16 szBuffer[260]; // [esp+3Ch] [ebp-20Ch]

  LOBYTE(nOffset) = dword_1305738;
  pGraphData = a1;
  v15 = a1;
  if ( !(dword_1305738 & 1) )
  {
    dword_1305728 = 0;
    dword_1305738 |= 1u;
    dword_130572C = 0;
    hdc = 0;
    ghBitmapColor = 0;
    LOBYTE(nOffset) = atexit(sub_12AADC0);
  }
  v6 = byte_130573C == 0;
  _mm_storeu_si128(a3a, _mm_load_si128(&xmmword_12C7010));
  if ( v6 )
  {
    byte_130573C = 1;
    LOBYTE(nOffset) = sub_1230CA0(&ghBitmapColor, 16, 16);
  }
  if ( guIdOfCpuTrayIcon || guIdOfGpuTrayIcon )
  {
    v7 = a2;
    if ( a2 > 100.0 )
    {
      v7 = gdbMaxValue;
      a2 = gdbMaxValue;
    }
    if ( a1->Index )
      nOffset = stprintf(szBuffer, L"GPU Usage: %.0f%%", LODWORD(v7), HIDWORD(v7));
    else
      nOffset = stprintf(szBuffer, L"CPU Usage: %.0f%%", LODWORD(v7), HIDWORD(v7));
    if ( a3 && a4 > 0.5 )
      LOBYTE(nOffset) = swprintf_s(&szBuffer[nOffset], 260 - nOffset, L"%c%s: %.0f%%", 10, *(a3 + 60), a4);
    v8 = (a2 / 100.0 * 16.0);
    if ( gbTrayCPUHistory )
    {
      hIcon1 = PEDrawIcon(a1, 0, a3a, 0xFFFFFFFF, 0, 0.0);
    }
    else
    {
      if ( a2 == -1.0 )
      {
        v8 = dword_1305740;
      }
      else if ( v8 == dword_1305740 )
      {
        return nOffset;
      }
      v10 = dword_1305728 * dword_130572C;
      if ( dword_1305734 && v10 )
      {
        memset32(
          dword_1305734,
          (gColorGraphBackground & 0xFF00) | (gColorGraphBackground << 16) | (gColorGraphBackground >> 16) & 0xFF,
          v10);
        pGraphData = v15;
      }
      a3a[1] = 16 - v8;
      if ( a2 <= 90.0 )
      {
        v11 = 4652870;
        if ( a2 > 70.0 )
          v11 = 0xA0FFFF;
      }
      else
      {
        v11 = 4605695;
      }
      sub_1230D60(&ghBitmapColor, a3a, v11);
      piconinfo.hbmColor = ghBitmapColor;
      piconinfo.hbmMask = ghBitmapColor;
      piconinfo.fIcon = 1;
      piconinfo.xHotspot = 0;
      piconinfo.yHotspot = 0;
      hIcon1 = CreateIconIndirect(&piconinfo);
    }
    v12 = hIcon1;
    if ( pGraphData->Index )
      UpdateTrayIcon(ghWndNewOwner, guIdOfGpuTrayIcon, hIcon1, szBuffer);
    else
      UpdateTrayIcon(ghWndNewOwner, guIdOfCpuTrayIcon, hIcon1, szBuffer);
    LOBYTE(nOffset) = DestroyIcon(v12);
    dword_1305740 = v8;
  }
  return nOffset;
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12C6C80: using guessed type wchar_t aCpuUsage0f[18];
// 12C7010: using guessed type __int128 xmmword_12C7010;
// 12E96C2: using guessed type char gbTrayCPUHistory;
// 12EA3BC: using guessed type int guIdOfCpuTrayIcon;
// 1305728: using guessed type int dword_1305728;
// 130572C: using guessed type int dword_130572C;
// 1305734: using guessed type int dword_1305734;
// 1305738: using guessed type int dword_1305738;
// 130573C: using guessed type char byte_130573C;
// 1305740: using guessed type int dword_1305740;
// 127FD50: using guessed type wchar_t szBuffer[260];

//----- (01280010) --------------------------------------------------------
BOOL __cdecl sub_1280010(int a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v5; // zf
  BOOL result; // eax
  int v7; // ebx
  HICON v8; // esi
  int nValue128[4]; // [esp+28h] [ebp-21Ch]
  __int16 Dst[260]; // [esp+38h] [ebp-20Ch]

  v5 = guIdOfDiskTrayIcon == 0;
  result = a1;
  _mm_storeu_si128(nValue128, _mm_load_si128(&xmmword_12C7010));
  if ( !v5 )
  {
    v7 = stprintf(Dst, L"Disk\n");
    if ( a2 )
    {
      sub_1232200(1, &Dst[v7], 260 - v7, a4, a3, a5);
      if ( v7 >= 0 )
        swprintf_s(&Dst[v7], 260 - v7, L"\n%s", *(a2 + 60));
    }
    v8 = PEDrawIcon(a1, 0, nValue128, gColorGraphBackground, 0, 0.0);
    UpdateTrayIcon(ghWndNewOwner, guIdOfDiskTrayIcon, v8, Dst);
    result = DestroyIcon(v8);
  }
  return result;
}
// 12C7010: using guessed type __int128 xmmword_12C7010;
// 1280010: using guessed type wchar_t Dst[260];

//----- (01280130) --------------------------------------------------------
ProcessorInfo *__cdecl sub_1280130(ProcessorInfo *pProcessorInfo, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool bShowTrayIcon; // zf
  ProcessorInfo *result; // eax
  int length; // eax
  int nLength; // esi
  HICON v9; // esi
  __m128i nValue128; // [esp+28h] [ebp-21Ch]
  TCHAR szText[260]; // [esp+38h] [ebp-20Ch]

  bShowTrayIcon = guIdOfIoTrayIcon == 0;
  result = pProcessorInfo;
  _mm_storeu_si128(&nValue128, _mm_load_si128(&xmmword_12C7010));
  if ( !bShowTrayIcon )
  {
    length = stprintf(szText, L"I/O\n");
    if ( a2 )
    {
      nLength = sub_1232200(1, &szText[2 * length], 260 - length, a4, a3, a5) + length;
      if ( nLength >= 0 )
        swprintf_s(&szText[2 * nLength], 260 - nLength, L"\n%s", *(a2 + 60));
    }
    v9 = PEDrawIcon(pProcessorInfo, 0, nValue128.m128i_i32, gColorGraphBackground, 0, 0.0);
    UpdateTrayIcon(ghWndNewOwner, guIdOfIoTrayIcon, v9, szText);
    result = DestroyIcon(v9);
  }
  return result;
}
// 12C7010: using guessed type __int128 xmmword_12C7010;

//----- (01280250) --------------------------------------------------------
BOOL __cdecl sub_1280250(int a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v5; // zf
  BOOL result; // eax
  int v7; // eax
  wchar_t *v8; // esi
  size_t v9; // edi
  HICON v10; // esi
  int nValue128[4]; // [esp+28h] [ebp-21Ch]
  __int16 Dst[260]; // [esp+38h] [ebp-20Ch]

  v5 = guIdOfNetTrayIcon == 0;
  result = a1;
  _mm_storeu_si128(nValue128, _mm_load_si128(&xmmword_12C7010));
  if ( !v5 )
  {
    v7 = stprintf(Dst, L"Network\n");
    if ( a2 )
    {
      v8 = &Dst[v7];
      v9 = 260 - v7;
      sub_1232200(1, &Dst[v7], 260 - v7, a4, a3, a5);
      swprintf_s(v8, v9, L"\n%s", *(a2 + 60));
    }
    v10 = PEDrawIcon(a1, 0, nValue128, gColorGraphBackground, 0, 0.0);
    UpdateTrayIcon(ghWndNewOwner, guIdOfNetTrayIcon, v10, Dst);
    result = DestroyIcon(v10);
  }
  return result;
}
// 12C7010: using guessed type __int128 xmmword_12C7010;
// 1280250: using guessed type wchar_t Dst[260];

//----- (01280360) --------------------------------------------------------
void __cdecl sub_1280360(int a1, __int64 a2)
{
  bool v2; // zf
  HICON v3; // esi
  int nValue128[4]; // [esp+Ch] [ebp-21Ch]
  wchar_t Src; // [esp+1Ch] [ebp-20Ch]

  v2 = guIdOfPhysTrayIcon == 0;
  _mm_storeu_si128(nValue128, _mm_load_si128(&xmmword_12C7010));
  if ( !v2 )
  {
    sub_1232410(&Src, 0x104u, L"Physical Usage: ", a2);
    v3 = PEDrawIcon(a1, 0, nValue128, gColorGraphBackground, 0, 0.0);
    UpdateTrayIcon(ghWndNewOwner, guIdOfPhysTrayIcon, v3, &Src);
    DestroyIcon(v3);
  }
}
// 12C6D10: using guessed type wchar_t aPhysicalUsage[17];
// 12C7010: using guessed type __int128 xmmword_12C7010;

//----- (01280410) --------------------------------------------------------
double *__usercall UpdateStatusBar@<eax>(double a1@<st0>, double st6_0@<st1>, double st5_0@<st2>, double st4_0@<st3>, double st3_0@<st4>, HWND a2, int a3, double *a4, __int64 *a5)
{
  double *result; // eax
  WPARAM v10; // edi
  HDC v11; // esi
  void *v12; // eax
  signed int v13; // esi
  signed int v14; // edx
  unsigned int v15; // eax
  double v16; // xmm0_8
  char v17; // al
  double v18; // xmm0_8
  int v19; // esi
  HDC v20; // ST04_4
  int v21; // eax
  int v22; // ecx
  HDC v23; // ebx
  struct _FILETIME LocalFileTime; // [esp+14h] [ebp-2CCh]
  double v25; // [esp+1Ch] [ebp-2C4h]
  HGDIOBJ h; // [esp+24h] [ebp-2BCh]
  int v27; // [esp+28h] [ebp-2B8h]
  int v28; // [esp+2Ch] [ebp-2B4h]
  HWND hWnd; // [esp+30h] [ebp-2B0h]
  HDC hdc; // [esp+34h] [ebp-2ACh]
  char v31; // [esp+3Bh] [ebp-2A5h]
  struct _SYSTEMTIME SystemTime; // [esp+3Ch] [ebp-2A4h]
  struct tagRECT rc; // [esp+4Ch] [ebp-294h]
  int lParam[32]; // [esp+5Ch] [ebp-284h]
  __int16 chText[256]; // [esp+DCh] [ebp-204h]

  result = a4;
  v10 = 0;
  hWnd = a2;
  v31 = 0;
  if ( !a2 )
  {
    dword_12E10E8 = -1;
    dword_12E10EC = -1;
    dword_12E10F0 = -1;
    dword_12E10F4 = -1;
    dword_12E10F8 = -1;
    dword_12E10FC = -1;
    dword_12E1100 = -1;
    dword_12E1104 = -1;
    *&dbl_12E1110 = dbl_12BCDD8;
    *&dbl_12E1108 = dbl_12BCDD8;
    *&dbl_12E1118 = dbl_12BCDD8;
    return result;
  }
  sub_1277400(0i64, a4, a5, &v25);
  *(a3 + 16) = st3_0;
  *(a3 + 32) = *a5 / v25 * 100.0;
  v11 = GetDC(ghWndStatusBar);
  hdc = v11;
  v12 = SendMessageW(hWnd, WM_GETFONT, 0, 0);
  h = SelectObject(v11, v12);
  SendMessageW(ghWndStatusBar, SB_GETPARTS, 0x20u, lParam);
  v13 = 1;
  v14 = 32;
  v27 = 1;
  v28 = 32;
  do
  {
    v15 = gdwStatusBarColumns & v13;
    if ( gdwStatusBarColumns & v13 )
    {
      if ( v15 > 0x80 )
      {
        if ( v15 > 0x800 )
        {
          switch ( v15 )
          {
            case 0x1000u:
              v19 = sub_127F9B0(chText, 0xFFFFFFFF, L"Refresh: ");
              FileTimeToLocalFileTime(&gTimeLastRefresh1, &LocalFileTime);
              FileTimeToSystemTime(&LocalFileTime, &SystemTime);
              GetTimeFormatW(0x400u, 0, &SystemTime, 0, &chText[v19], 256 - v19);
              v13 = v27;
              break;
            case 0x2000u:
              if ( *(a3 + 32) == dbl_12E1128 )
              {
                v17 = v31;
                if ( !v31 )
                {
                  ++v10;
                  goto LABEL_86;
                }
              }
              VLogEntry(chText, L"Physical Usage: %02.2f%%", *(a3 + 32));
              dbl_12E1128 = *(a3 + 32);
              break;
            case 0x4000u:
              if ( *(a3 + 40) == dbl_12E1130 )
              {
                v17 = v31;
                if ( !v31 )
                {
                  ++v10;
                  goto LABEL_86;
                }
              }
              VLogEntry(chText, L"Own Physical Usage: %02.2f%%", *(a3 + 40));
              dbl_12E1130 = *(a3 + 40);
              break;
          }
        }
        else
        {
          switch ( v15 )
          {
            case 0x800u:
              if ( *(a3 + 68) == dword_12E10FC )
              {
                v17 = v31;
                if ( !v31 )
                {
                  ++v10;
                  goto LABEL_86;
                }
              }
              VLogEntry(chText, L"Own Handles: %d", *(a3 + 68));
              dword_12E10FC = *(a3 + 68);
              break;
            case 0x100u:
              if ( *(a3 + 56) == dword_12E10F0 )
              {
                v17 = v31;
                if ( !v31 )
                {
                  ++v10;
                  goto LABEL_86;
                }
              }
              VLogEntry(chText, L"Threads: %d", *(a3 + 56));
              dword_12E10F0 = *(a3 + 56);
              break;
            case 0x200u:
              if ( *(a3 + 60) == dword_12E10F4 )
              {
                v17 = v31;
                if ( !v31 )
                {
                  ++v10;
                  goto LABEL_86;
                }
              }
              VLogEntry(chText, L"Own Threads: %d", *(a3 + 60));
              dword_12E10F4 = *(a3 + 60);
              break;
            case 0x400u:
              if ( *(a3 + 64) == dword_12E10F8 )
              {
                v17 = v31;
                if ( !v31 )
                {
                  ++v10;
                  goto LABEL_86;
                }
              }
              VLogEntry(chText, L"Handles: %d", *(a3 + 64));
              dword_12E10F8 = *(a3 + 64);
              break;
          }
        }
      }
      else if ( v15 == 128 )
      {
        if ( *(a3 + 76) == dword_12E1104 )
        {
          v17 = v31;
          if ( !v31 )
          {
            ++v10;
            goto LABEL_86;
          }
        }
        VLogEntry(chText, L"Own .NET Processes: %d", *(a3 + 76));
        dword_12E1104 = *(a3 + 76);
      }
      else
      {
        switch ( v15 )
        {
          case 1u:
            v16 = *a3;
            if ( *a3 == dbl_12E1110 )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            if ( gbShowCpuFractions )
              VLogEntry(chText, L"CPU Usage: %02.2f%%", LODWORD(v16), HIDWORD(v16));
            else
              VLogEntry(chText, L"CPU Usage: %0.0f%%", LODWORD(v16), HIDWORD(v16));
            dbl_12E1110 = *a3;
            break;
          case 2u:
            v18 = *(a3 + 8);
            if ( v18 == dbl_12E1108 )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            if ( gbShowCpuFractions )
              VLogEntry(chText, L"Own CPU Usage: %02.2f%%", LODWORD(v18), HIDWORD(v18));
            else
              VLogEntry(chText, L"Own CPU Usage: %0.0f%%", LODWORD(v18), HIDWORD(v18));
            dbl_12E1108 = *(a3 + 8);
            break;
          case 4u:
            if ( *(a3 + 16) == dbl_12E1118 )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            VLogEntry(chText, L"Commit Charge: %02.2f%%", *(a3 + 16));
            dbl_12E1118 = *(a3 + 16);
            break;
          case 8u:
            if ( *(a3 + 24) == dbl_12E1120 )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            VLogEntry(chText, L"Own Commit Charge: %02.2f%%", *(a3 + 24));
            dbl_12E1120 = *(a3 + 24);
            break;
          case 0x10u:
            if ( *(a3 + 48) == dword_12E10E8 )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            VLogEntry(chText, L"Processes: %d", *(a3 + 48));
            dword_12E10E8 = *(a3 + 48);
            break;
          case 0x20u:
            if ( *(a3 + 52) == dword_12E10EC )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            VLogEntry(chText, L"Own Processes: %d", *(a3 + 52));
            dword_12E10EC = *(a3 + 52);
            break;
          case 0x40u:
            if ( *(a3 + 72) == dword_12E1100 )
            {
              v17 = v31;
              if ( !v31 )
              {
                ++v10;
                goto LABEL_86;
              }
            }
            VLogEntry(chText, L".NET Processes: %d", *(a3 + 72));
            dword_12E1100 = *(a3 + 72);
            break;
          default:
            break;
        }
      }
      v20 = hdc;
      _mm_storeu_si128(&rc, 0i64);
      DrawTextW(v20, chText, -1, &rc, 0xD20u);
      v21 = rc.right + 10;
      rc.right += 10;
      if ( v10 )
        v22 = lParam[v10] - *(&rc.bottom + v10);
      else
        v22 = lParam[0];
      if ( v22 < v21 )
      {
        v31 = 1;
        lParam[v10] += v21 - v22;
      }
      SendMessageW(hWnd, SB_SETTEXTW, v10, chText);
      v14 = v28;
      ++v10;
    }
    v17 = v31;
LABEL_86:
    v13 = __ROL4__(v13, 1);
    --v14;
    v27 = v13;
    v28 = v14;
  }
  while ( v14 );
  if ( v17 )
  {
    lParam[v10] = -1;
    SendMessageW(ghWndStatusBar, SB_SETPARTS, v10 + 1, lParam);
  }
  v23 = hdc;
  SelectObject(hdc, h);
  return ReleaseDC(ghWndStatusBar, v23);
}
// 12BCDC0: using guessed type double gdbMaxValue;
// 12C6D34: using guessed type wchar_t aCpuUsage022f[20];
// 12C6D84: using guessed type wchar_t aOwnCpuUsage022[24];
// 12E10E8: using guessed type int dword_12E10E8;
// 12E10EC: using guessed type int dword_12E10EC;
// 12E10F0: using guessed type int dword_12E10F0;
// 12E10F4: using guessed type int dword_12E10F4;
// 12E10F8: using guessed type int dword_12E10F8;
// 12E10FC: using guessed type int dword_12E10FC;
// 12E1100: using guessed type int dword_12E1100;
// 12E1104: using guessed type int dword_12E1104;
// 12E1108: using guessed type double dbl_12E1108;
// 12E1110: using guessed type double dbl_12E1110;
// 12E1118: using guessed type double dbl_12E1118;
// 12E1120: using guessed type double dbl_12E1120;
// 12E1128: using guessed type double dbl_12E1128;
// 12E1130: using guessed type double dbl_12E1130;
// 12E5990: using guessed type int gdwStatusBarColumns;
// 12E96C9: using guessed type char gbShowCpuFractions;
// 1280410: using guessed type LPARAM lParam[32];
// 1280410: using guessed type WCHAR chText[256];

//----- (01280BB0) --------------------------------------------------------
HWND __cdecl CreateRebar(HWND hWndParent, UINT uId)
{
  unsigned int nToolbarHeight; // edi
  WPARAM nItem; // edi
  unsigned int idx; // esi
  LRESULT nIndex; // eax
  bool v7; // zf
  REBARINFO rbInfo; // [esp+0h] [ebp-1B0h]
  INITCOMMONCONTROLSEX picce; // [esp+Ch] [ebp-1A4h]
  REBARBANDINFOW rbbi; // [esp+14h] [ebp-19Ch]
  RECT rcSrc1; // [esp+64h] [ebp-14Ch]
  RECT rcSrc2; // [esp+74h] [ebp-13Ch]
  struct tagRECT rcDst; // [esp+84h] [ebp-12Ch]
  TBBUTTON tbBtns[14]; // [esp+94h] [ebp-11Ch]

  tbBtns[0].iBitmap = 3;
  tbBtns[0].idCommand = IDS_PROCEXPLORERMENU_SAVE;
  *&tbBtns[0].fsState = TBSTATE_ENABLED;
  *&tbBtns[0].dwData = 0i64;
  tbBtns[1].iBitmap = 0;
  tbBtns[1].idCommand = 0;
  *&tbBtns[1].fsState = 0x104;
  *&tbBtns[1].dwData = 0i64;
  tbBtns[2].iBitmap = 7;
  tbBtns[2].idCommand = 40002;
  *&tbBtns[2].fsState = TBSTATE_ENABLED;
  *&tbBtns[2].dwData = 0i64;
  tbBtns[3].iBitmap = 0;
  tbBtns[3].idCommand = 0;
  *&tbBtns[3].fsState = 0x104;
  *&tbBtns[3].dwData = 0i64;
  tbBtns[4].iBitmap = 13;
  tbBtns[4].idCommand = 40060;
  *&tbBtns[4].fsState = 4;
  *&tbBtns[4].dwData = 0i64;
  tbBtns[5].iBitmap = 8;
  tbBtns[5].idCommand = IDS_PROCEXPLORERMENU_SHOW_PROCESS_TREE;
  *&tbBtns[5].fsState = TBSTATE_ENABLED;
  *&tbBtns[5].dwData = 0i64;
  tbBtns[6].iBitmap = 9;
  tbBtns[6].idCommand = IDS_PROCEXPLORERMENU_SHOW_LOWER_PANE;
  *&tbBtns[6].fsState = TBSTATE_ENABLED;
  *&tbBtns[6].dwData = 0i64;
  tbBtns[7].iBitmap = 4;
  tbBtns[7].idCommand = 0x9C5E;
  *&tbBtns[7].fsState = TBSTATE_ENABLED;
  *&tbBtns[7].dwData = 0i64;
  tbBtns[8].iBitmap = 0;
  tbBtns[8].idCommand = 0;
  *&tbBtns[8].fsState = 0x104;
  *&tbBtns[8].dwData = 0i64;
  tbBtns[9].iBitmap = 6;
  tbBtns[9].idCommand = IDM_OTHER_VIEW_PROCESS_PROPERTIES;
  *&tbBtns[9].fsState = TBSTATE_ENABLED;
  *&tbBtns[9].dwData = 0i64;
  tbBtns[10].iBitmap = 5;
  tbBtns[10].idCommand = IDS_PROCEXPLORERMENU_PROCESS_KILL_PROCESS;
  *&tbBtns[10].fsState = TBSTATE_ENABLED;
  *&tbBtns[10].dwData = 0i64;
  tbBtns[11].iBitmap = 0;
  tbBtns[11].idCommand = 0;
  *&tbBtns[11].fsState = 0x104;
  *&tbBtns[11].dwData = 0i64;
  tbBtns[12].iBitmap = 2;
  tbBtns[12].idCommand = IDM_OTHER_FIND_DLLS_OR_HANDLES;
  *&tbBtns[12].fsState = TBSTATE_ENABLED;
  *&tbBtns[12].dwData = 0i64;
  tbBtns[13].iBitmap = 12;
  tbBtns[13].idCommand = IDM_OTHER_FIND_WINDOW_PROCESS;
  *&tbBtns[13].fsState = TBSTATE_ENABLED;
  *&tbBtns[13].dwData = 0i64;
  picce.dwSize = 8;
  picce.dwICC = 0x604;
  InitCommonControlsEx(&picce);
  ghWndRebar = CreateWindowExW(
                 WS_EX_TOOLWINDOW,
                 L"ReBarWindow32",
                 0,
                 // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBS_BANDBORDERS|CCS_NODIVIDER|CCS_NOPARENTALIGN
                 0x56800448u,
                 0,
                 0,
                 400,
                 275,
                 hWndParent,
                 0,
                 ghInstance,
                 0);
  rbInfo.cbSize = 12;
  rbInfo.fMask = 0;
  if ( !SendMessageW(ghWndRebar, RB_SETBARINFO, 0, &rbInfo) )
    return 0;
  ghWndToolbar = CreateToolbarEx(
                   ghWndRebar,
                   // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|TBSTYLE_TOOLTIPS|TBSTYLE_FLAT|BTNS_SHOWTEXT|TBSTYLE_GROUP
                   0x56000944u,
                   uId,
                   12,                          // idBitmap
                   ghInstance,
                   IDW_TOOLBAR,
                   tbBtns,
                   14,
                   NULL,
                   0,
                   0,
                   0,
                   20u);                        // structsize
  if ( !ghWndToolbar )
    return 0;
  nToolbarHeight = GetToolbarButtonHeight();
  SendMessageW(ghWndToolbar, TB_GETRECT, IDS_PROCEXPLORERMENU_SAVE, &rcSrc1);
  SendMessageW(ghWndToolbar, TB_GETRECT, IDM_OTHER_FIND_WINDOW_PROCESS, &rcSrc2);
  UnionRect(&rcDst, &rcSrc1, &rcSrc2);
  memset(&rbbi, 0, 0x50u);
  rbbi.cbSize = 80;
  // RBBIM_ID|RBBIM_CHILD|RBBIM_CHILDSIZE|RBBIM_SIZE|RBBIM_STYLE|RBBIM_COLORS
  rbbi.fMask = 0x173;
  rbbi.fStyle = RBBS_GRIPPERALWAYS;
  rbbi.hwndChild = ghWndToolbar;
  rbbi.cxMinChild = 0;
  rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
  rbbi.clrBack = GetSysColor(COLOR_BTNFACE);
  rbbi.cx = rcDst.right - rcDst.left;
  rbbi.cxMinChild = rcDst.right - rcDst.left;
  rbbi.cyMinChild = nToolbarHeight >> 16;
  rbbi.wID = 0;
  SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  ghWndGraphCPUUsage = CreateWindowExW(
                         0,
                         L"CpuGraphClassGraph",
                         gpszTargetName,
                         // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                         0x56010004u,
                         0,
                         0,
                         0,
                         0,
                         ghWndRebar,
                         IDW_GRAPHCTRL,
                         ghInstance,
                         gpGraphClassData[1]);
  rbbi.hwndChild = ghWndGraphCPUUsage;
  rbbi.cx = MulDiv(75, gLogPixelsX, 96);
  rbbi.cxMinChild = 0;
  rbbi.wID = 1;
  SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  ghWndGraphMemory = CreateWindowExW(
                       0,
                       L"CpuGraphClassGraph",
                       gpszTargetName,
                       // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                       0x56010004u,
                       0,
                       0,
                       0,
                       0,
                       ghWndRebar,
                       IDW_GRAPHCTRL,
                       ghInstance,
                       gpGraphClassData[0]);
  rbbi.hwndChild = ghWndGraphMemory;
  rbbi.cx = MulDiv(75, gLogPixelsX, 96);
  rbbi.cxMinChild = 0;
  rbbi.wID = 2;
  SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  ghWndGraphPhysicalMemory = CreateWindowExW(
                               0,
                               L"CpuGraphClassGraph",
                               gpszTargetName,
                               // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                               0x56010004u,
                               0,
                               0,
                               0,
                               0,
                               ghWndRebar,
                               IDW_GRAPHCTRL,
                               ghInstance,
                               gpGraphClassData[5]);
  rbbi.hwndChild = ghWndGraphPhysicalMemory;
  rbbi.cx = MulDiv(75, gLogPixelsX, 96);
  rbbi.cxMinChild = 0;
  rbbi.wID = 3;
  SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  if ( gptrIOGraphData__3UCSimpleGraphData__A.GraphData )
  {
    ghWndIOGraphCtrl = CreateWindowExW(
                         0,
                         L"CpuGraphClassGraph",
                         gpszTargetName,
                         // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                         0x56010004u,
                         0,
                         0,
                         0,
                         0,
                         ghWndRebar,
                         IDW_GRAPHCTRL,
                         ghInstance,
                         gptrIOGraphData__3UCSimpleGraphData__A.GraphData);
    rbbi.hwndChild = ghWndIOGraphCtrl;
    rbbi.cx = MulDiv(75, gLogPixelsX, 96);
    rbbi.cxMinChild = 0;
    rbbi.wID = 4;
    SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  }
  if ( IsBuiltinAndAnministrative() && gptrNetGraphData.GraphData )
  {
    ghWndNetworkGraphCtrl = CreateWindowExW(
                              0,
                              L"CpuGraphClassGraph",
                              gpszTargetName,
                              // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                              0x56010004u,
                              0,
                              0,
                              0,
                              0,
                              ghWndRebar,
                              IDW_GRAPHCTRL,
                              ghInstance,
                              gptrNetGraphData.GraphData);
    rbbi.hwndChild = ghWndNetworkGraphCtrl;
    rbbi.cx = MulDiv(75, gLogPixelsX, 96);
    rbbi.cxMinChild = 0;
    rbbi.wID = 5;
    SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  }
  if ( IsBuiltinAndAnministrative() && gptrDiskGraphData.GraphData )
  {
    ghWndDiskGraphCtrl = CreateWindowExW(
                           0,
                           L"CpuGraphClassGraph",
                           gpszTargetName,
                           // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                           0x56010004u,
                           0,
                           0,
                           0,
                           0,
                           ghWndRebar,
                           IDW_GRAPHCTRL,
                           ghInstance,
                           gptrDiskGraphData.GraphData);
    rbbi.hwndChild = ghWndDiskGraphCtrl;
    rbbi.cx = MulDiv(75, gLogPixelsX, 96);
    rbbi.cxMinChild = 0;
    rbbi.wID = 6;
    SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  }
  if ( gdwAdapterRuntingTime )
  {
    ghWndGPUGraphCtrl = CreateWindowExW(
                          0,
                          L"CpuGraphClassGraph",
                          gpszTargetName,
                          // WS_VISIBLE|WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|RBBS_CHILDEDGE
                          0x56010004u,
                          0,
                          0,
                          0,
                          0,
                          ghWndRebar,
                          IDW_GRAPHCTRL,
                          ghInstance,
                          gpGraphClassData[2]);
    rbbi.hwndChild = ghWndGPUGraphCtrl;
    rbbi.cx = MulDiv(75, gLogPixelsX, 96);
    rbbi.cxMinChild = 0;
    rbbi.wID = 7;
    SendMessageW(ghWndRebar, RB_INSERTBANDW, 0xFFFFFFFF, &rbbi);
  }
  if ( gdwToolbarBands[0] != -1 )
  {
    nItem = 0;
    idx = 0;
    do
    {
      nIndex = SendMessageW(ghWndRebar, RB_IDTOINDEX, gGraphReBarCtrlIds[idx], 0);
      SendMessageW(ghWndRebar, RB_MOVEBAND, nIndex, nItem);
      SendMessageW(ghWndRebar, RB_GETBANDINFOW, nItem, &rbbi);
      v7 = LOBYTE(gdwSortableColumnVector[idx]) == 0;
      // RBBIM_ID|||RBBIM_SIZE|RBBIM_STYLE|
      rbbi.fMask = 0x141;
      if ( v7 )
        rbbi.fStyle &= -RBBS_FIXEDSIZE;
      else
        rbbi.fStyle |= RBBS_BREAK;
      rbbi.cx = MulDiv(gdwToolbarBands[idx], gLogPixelsX, 96);
      rbbi.wID = gGraphReBarCtrlIds[idx];
      SendMessageW(ghWndRebar, RB_SETBANDINFOW, nItem, &rbbi);
      idx += 3;
      ++nItem;
    }
    while ( idx < 24 );
  }
  return ghWndToolbar;
}
// 12E9B38: using guessed type int gdwToolbarBands[];
// 12E9B3C: using guessed type int gGraphReBarCtrlIds[];

//----- (012813B0) --------------------------------------------------------
LPARAM GetToolbarButtonHeight()
{
  int hight; // edi
  WORD width; // ax
  int ButtonSize; // esi

  hight = GetSystemMetrics(SM_CYSMICON) << 16;
  width = GetSystemMetrics(SM_CXSMICON);
  SendMessageW(ghWndToolbar, TB_SETBITMAPSIZE, 0, hight | width);
  ButtonSize = SendMessageW(ghWndToolbar, TB_GETBUTTONSIZE, 0, 0);
  SendMessageW(ghWndToolbar, TB_SETBITMAPSIZE, 0, 0xF0010);
  SendMessageW(ghWndToolbar, TB_SETBUTTONSIZE, 0, ButtonSize);
  return ButtonSize;
}

//----- (01281420) --------------------------------------------------------
_DWORD *__stdcall sub_1281420(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = sub_1282A70(a1, a2);
  if ( result != -8 )
    result[2] = *a3;
  return result;
}

//----- (01281440) --------------------------------------------------------
_DWORD *__thiscall sub_1281440(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int *a5, int a6)
{
  _DWORD *v6; // edi
  CSysProcItem *v7; // eax
  CSysProcItem *v8; // ebx
  int v9; // eax
  CSysProcItem *v10; // eax
  CSysProcItem *v11; // ecx
  CSysProcItem *v12; // esi
  CSysProcItem *v13; // edx
  CSysProcItem *v14; // edx
  CSysProcItem **v15; // ecx
  CSysProcItem *v16; // edx
  CSysProcItem *v17; // esi
  CSysProcItem *v18; // ecx
  CSysProcItem *v19; // ecx
  CSysProcItem *v20; // edx
  CSysProcItem *v21; // ecx
  CSysProcItem *v22; // ecx
  CSysProcItem *v23; // ecx
  _DWORD *result; // eax

  v6 = this;
  if ( this[1] >= 0xAAAAAA9u )
    std::_Xlength_error("map/set<T> too long");
  v7 = sub_1211310(this, a5);
  ++v6[1];
  v8 = v7;
  v7->_Parent = a4;
  if ( a4 == *v6 )
  {
    *(*v6 + 4) = v7;
    **v6 = v7;
    v9 = *v6;
LABEL_8:
    *(v9 + 8) = v8;
    goto LABEL_9;
  }
  if ( !a3 )
  {
    a4[2] = v7;
    v9 = *v6;
    if ( a4 != *(*v6 + 8) )
      goto LABEL_9;
    goto LABEL_8;
  }
  *a4 = v7;
  if ( a4 == **v6 )
    **v6 = v7;
LABEL_9:
  v10 = v8;
  while ( !v10->_Parent->_Color )
  {
    v11 = v10->_Parent;
    v12 = v11->_Parent;
    v13 = v12->_Left;
    if ( v11 == v12->_Left )
    {
      v13 = v12->_Right;
      if ( v13->_Color )
      {
        if ( v10 == v11->_Right )
        {
          v10 = v10->_Parent;
          v14 = v11->_Right;
          v11->_Right = v14->_Left;
          if ( !v14->_Left->_Isnil )
            v14->_Left->_Parent = v11;
          v14->_Parent = v11->_Parent;
          if ( v11 == *(*v6 + 4) )
          {
            *(*v6 + 4) = v14;
          }
          else
          {
            v15 = &v11->_Parent->_Left;
            if ( v10 == *v15 )
              *v15 = v14;
            else
              v15[2] = v14;
          }
          v14->_Left = v10;
          v10->_Parent = v14;
        }
        v10->_Parent->_Color = 1;
        v10->_Parent->_Parent->_Color = 0;
        v16 = v10->_Parent->_Parent;
        v17 = v16->_Left;
        v16->_Left = v16->_Left->_Right;
        v18 = v17->_Right;
        if ( !v18->_Isnil )
          v18->_Parent = v16;
        v17->_Parent = v16->_Parent;
        if ( v16 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v17;
          v17->_Right = v16;
        }
        else
        {
          v19 = v16->_Parent;
          if ( v16 == v19->_Right )
            v19->_Right = v17;
          else
            v19->_Left = v17;
          v17->_Right = v16;
        }
LABEL_48:
        v16->_Parent = v17;
        continue;
      }
    }
    else if ( v13->_Color )
    {
      if ( v10 == v11->_Left )
      {
        v10 = v10->_Parent;
        v20 = v11->_Left;
        v11->_Left = v11->_Left->_Right;
        v21 = v20->_Right;
        if ( !v21->_Isnil )
          v21->_Parent = v10;
        v20->_Parent = v10->_Parent;
        if ( v10 == *(*v6 + 4) )
        {
          *(*v6 + 4) = v20;
        }
        else
        {
          v22 = v10->_Parent;
          if ( v10 == v22->_Right )
            v22->_Right = v20;
          else
            v22->_Left = v20;
        }
        v20->_Right = v10;
        v10->_Parent = v20;
      }
      v10->_Parent->_Color = 1;
      v10->_Parent->_Parent->_Color = 0;
      v16 = v10->_Parent->_Parent;
      v17 = v16->_Right;
      v16->_Right = v17->_Left;
      if ( !v17->_Left->_Isnil )
        v17->_Left->_Parent = v16;
      v17->_Parent = v16->_Parent;
      if ( v16 == *(*v6 + 4) )
      {
        *(*v6 + 4) = v17;
      }
      else
      {
        v23 = v16->_Parent;
        if ( v16 == v23->_Left )
          v23->_Left = v17;
        else
          v23->_Right = v17;
      }
      v17->_Left = v16;
      goto LABEL_48;
    }
    v11->_Color = 1;
    v13->_Color = 1;
    v10->_Parent->_Parent->_Color = 0;
    v10 = v10->_Parent->_Parent;
  }
  *(*(*v6 + 4) + 12) = 1;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (01281650) --------------------------------------------------------
int __thiscall sub_1281650(_DWORD *this, int a2, _DWORD *a3, int *a4, int a5)
{
  _DWORD *v5; // edx
  _DWORD *v6; // ecx
  bool v7; // al
  int *v8; // ebx
  _DWORD *v9; // esi
  volatile LONG *v10; // ecx
  volatile LONG *v11; // ecx
  _DWORD *v12; // esi
  int *v13; // eax
  int v14; // ecx
  int result; // eax
  volatile LONG *v16; // ecx
  volatile LONG *v17; // [esp-8h] [ebp-34h]
  volatile LONG *v18; // [esp-8h] [ebp-34h]
  volatile LONG *v19; // [esp-8h] [ebp-34h]
  void *v20; // [esp-4h] [ebp-30h]
  volatile LONG *v21; // [esp-4h] [ebp-30h]
  volatile LONG *v22; // [esp-4h] [ebp-30h]
  int v23; // [esp+0h] [ebp-2Ch]
  _DWORD *v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  _DWORD *v26; // [esp+18h] [ebp-14h]
  int *v27; // [esp+1Ch] [ebp-10h]
  int v28; // [esp+28h] [ebp-4h]

  v27 = &v23;
  v5 = this;
  v24 = this;
  v6 = *this;
  v7 = 1;
  v8 = a4;
  v28 = 0;
  v9 = v6[1];
  v26 = v6;
  LOBYTE(v25) = 1;
  if ( !*(v9 + 13) )
  {
    do
    {
      v26 = v9;
      if ( a3 )
      {
        v20 = *v8;
        if ( *v8 )
          InterlockedIncrement((*v8 + 8));
        v10 = v9[4];
        v17 = v10;
        if ( v10 )
          InterlockedIncrement(v10 + 2);
        v7 = sub_12114B0(v17, v20) == 0;
      }
      else
      {
        v11 = v9[4];
        v21 = v11;
        if ( v11 )
          InterlockedIncrement(v11 + 2);
        v18 = *v8;
        if ( *v8 )
          InterlockedIncrement(v18 + 2);
        v7 = sub_12114B0(v18, v21);
      }
      LOBYTE(v25) = v7;
      if ( v7 )
        v9 = *v9;
      else
        v9 = v9[2];
    }
    while ( !*(v9 + 13) );
    v6 = v26;
    v5 = v24;
  }
  v12 = v6;
  a3 = v6;
  if ( v7 )
  {
    if ( v6 == **v5 )
    {
      v13 = sub_1281440(v5, &a3, 1, v6, v8, a5);
LABEL_21:
      v14 = *v13;
      result = a2;
      *a2 = v14;
      *(a2 + 4) = 1;
      return result;
    }
    sub_1211450(&a3);
    v12 = a3;
  }
  v22 = *v8;
  if ( *v8 )
    InterlockedIncrement(v22 + 2);
  v16 = v12[4];
  v19 = v16;
  if ( v16 )
    InterlockedIncrement(v16 + 2);
  if ( sub_12114B0(v19, v22) )
  {
    v13 = sub_1281440(v24, &a4, v25, v26, v8, a5);
    goto LABEL_21;
  }
  result = a2;
  *a2 = v12;
  *(a2 + 4) = 0;
  return result;
}

//----- (012817E0) --------------------------------------------------------
char sub_12817E0()
{
  char result; // al

  result = CHttp::CHttp(ghWndNewOwner, L"Process Explorer", 0, 0, szDescription);
  byte_1305774 = result;
  if ( result )
  {
    CHttp::Initialize();
    result = byte_1305774;
  }
  return result;
}
// 1305774: using guessed type char byte_1305774;

//----- (01281820) --------------------------------------------------------
char __cdecl sub_1281820(ResizeInfo *a1)
{
  char result; // al

  result = 0;
  if ( a1 && (a1->d1.top == 1 || a1->d1.top == 4) )
    result = 1;
  return result;
}

//----- (01281840) --------------------------------------------------------
BOOL __cdecl sub_1281840(LPCWSTR lpFileName, wchar_t *Dest, int a3)
{
  wchar_t *v3; // edi
  BOOL v4; // ebx
  HANDLE v5; // eax
  void *v6; // esi
  DWORD v7; // eax
  DWORD v8; // ecx
  DWORD v9; // edx
  SIZE_T v10; // esi
  const BYTE *v11; // eax
  bool v12; // zf
  HCRYPTHASH v13; // ST08_4
  DWORD v14; // esi
  HANDLE v16; // [esp+Ch] [ebp-48h]
  const BYTE *dwFileOffsetHigh_4; // [esp+14h] [ebp-40h]
  DWORD v18; // [esp+18h] [ebp-3Ch]
  DWORD v19; // [esp+1Ch] [ebp-38h]
  LPFILETIME lpCreationTime; // [esp+20h] [ebp-34h]
  HCRYPTPROV phProv; // [esp+24h] [ebp-30h]
  HCRYPTHASH phHash; // [esp+28h] [ebp-2Ch]
  DWORD pdwDataLen; // [esp+2Ch] [ebp-28h]
  BYTE pbData; // [esp+30h] [ebp-24h]
  __int128 v25; // [esp+31h] [ebp-23h]
  __int64 v26; // [esp+41h] [ebp-13h]
  int v27; // [esp+49h] [ebp-Bh]
  __int16 v28; // [esp+4Dh] [ebp-7h]
  char v29; // [esp+4Fh] [ebp-5h]

  v3 = Dest;
  v4 = 0;
  phProv = 0;
  phHash = 0;
  v5 = CreateFile(lpFileName, 0x80000000, 7u, 0, 3u, 0, 0);
  v6 = v5;
  v16 = v5;
  if ( v5 == -1 )
    return v4 != 0;
  GetFileTime(v5, a3, 0, 0);
  v4 = CryptAcquireContextW(&phProv, 0, 0, 0x18u, 0xF0000000);
  if ( !v4 )
  {
    v4 = CryptAcquireContextW(&phProv, 0, 0, 1u, 0xF0000000);
    if ( !v4 )
      goto LABEL_24;
  }
  if ( !CryptCreateHash(phProv, 0x8004u, 0, 0, &phHash) )
    goto LABEL_23;
  lpCreationTime = CreateFileMappingW(v6, 0, 2u, 0, 0, 0);
  if ( !lpCreationTime )
  {
    v4 = 0;
    goto LABEL_22;
  }
  v7 = GetFileSize(v6, 0);
  v19 = v7;
  v4 = 1;
  if ( !v7 )
    goto LABEL_16;
  v8 = 0;
  v9 = 0;
  v18 = 0;
  pdwDataLen = 0;
  while ( 1 )
  {
    v10 = v7;
    if ( v7 > 0x100000 )
      v10 = 0x100000;
    v11 = MapViewOfFile(lpCreationTime, 4u, v8, v9, v10);
    dwFileOffsetHigh_4 = v11;
    if ( !v11 )
      goto LABEL_13;
    if ( !CryptHashData(phHash, v11, v10, 0) )
      break;
    v11 = dwFileOffsetHigh_4;
LABEL_13:
    UnmapViewOfFile(v11);
    v8 = (v10 + __PAIR__(v18, pdwDataLen)) >> 32;
    v9 = v10 + pdwDataLen;
    pdwDataLen += v10;
    v7 = v19 - v10;
    v12 = v19 == v10;
    v18 = v8;
    v19 -= v10;
    if ( v12 )
      goto LABEL_16;
  }
  v4 = 0;
LABEL_16:
  CloseHandle(lpCreationTime);
  if ( v4 )
  {
    pbData = 0;
    v27 = 0;
    v13 = phHash;
    v28 = 0;
    _mm_storeu_si128(&v25, 0i64);
    v29 = 0;
    v26 = 0i64;
    pdwDataLen = 32;
    if ( CryptGetHashParam(v13, 2u, &pbData, &pdwDataLen, 0) )
    {
      v14 = 0;
      if ( pdwDataLen )
      {
        do
        {
          _swprintf(v3, L"%02X", *(&pbData + v14++));
          v3 += 2;
        }
        while ( v14 < pdwDataLen );
      }
    }
  }
LABEL_22:
  CryptDestroyHash(phHash);
  v6 = v16;
LABEL_23:
  CryptReleaseContext(phProv, 0);
LABEL_24:
  CloseHandle(v6);
  return v4 != 0;
}

//----- (01281A50) --------------------------------------------------------
int __cdecl sub_1281A50(int a1, wchar_t *Dest)
{
  int result; // eax
  const wchar_t *v3; // edx
  const wchar_t *v4; // edx
  const wchar_t *v5; // edx
  char **v6; // edx
  char *v7; // edx
  char *v8; // ecx
  _DWORD *v9; // eax

  result = 0;
  *Dest = 0;
  if ( a1 )
  {
    result = *(a1 + 4) - 1;
    switch ( *(a1 + 4) )
    {
      case 1:
      case 6:
        v9 = *(a1 + 40);
        if ( v9 )
          result = _swprintf(Dest, L"%s", *v9);
        else
          result = _swprintf(Dest, L"%s", 0);
        break;
      case 2:
        v3 = L"Hash submitted...";
        do
        {
          result = *v3;
          ++v3;
          *(v3 + Dest - L"Hash submitted..." - 2) = result;
        }
        while ( result );
        break;
      case 3:
        v5 = L"File submitted...";
        do
        {
          result = *v5;
          ++v5;
          *(v5 + Dest - L"File submitted..." - 2) = result;
        }
        while ( result );
        break;
      case 4:
        v4 = L"Scanning file...";
        do
        {
          result = *v4;
          ++v4;
          *(v4 + Dest - L"Scanning file..." - 2) = result;
        }
        while ( result );
        break;
      case 5:
        v6 = *(a1 + 32);
        if ( v6 )
          v7 = *v6;
        else
          v7 = 0;
        v8 = (Dest - v7);
        do
        {
          result = *v7;
          v7 += 2;
          *&v7[v8 - 2] = result;
        }
        while ( result );
        break;
      default:
        return result;
    }
  }
  return result;
}
// 12B2BBC: using guessed type wchar_t aHashSubmitted[18];
// 12B2BE0: using guessed type wchar_t aScanningFile[17];
// 12B2C04: using guessed type wchar_t aFileSubmitted[18];

//----- (01281B40) --------------------------------------------------------
void CHttp::Initialize()
{
  if ( !gbHttpInited )
  {
    CHttp::Open(&gHttp, ghWndNewOwner, L"Process Explorer", 0, 0, 0);
    InitializeCriticalSection(&gItem.Lock);
    gItem.hEvent1 = CreateEventW(0, 0, 0, 0);
    gItem.hEvent2 = CreateEventW(0, 0, 0, 0);
    gItem.hThread1 = _beginthreadex(0, 0, sub_1282230, 0, 0, 0);
    gItem.hEvent3 = CreateEventW(0, 0, 0, 0);
    gItem.hThread2 = _beginthreadex(0, 0, sub_1281EC0, 0, 0, 0);
    gItem.hThread3 = _beginthreadex(0, 0, sub_1282970, 0, 0, 0);
    gbHttpInited = 1;
  }
}
// 1282970: using guessed type int __stdcall sub_1282970(int);
// 13057B4: using guessed type char gbHttpInited;

//----- (01281C10) --------------------------------------------------------
char __cdecl sub_1281C10(CString *a1)
{
  char result; // al
  CStringData *v2; // ecx

  result = 0;
  if ( !a1 || (v2 = a1[1].m_pszData, v2 == 1) || &v2[-1].nAllocLength + 3 <= 1 )
    result = 1;
  return result;
}

//----- (01281C30) --------------------------------------------------------
void __cdecl sub_1281C30(int a1, char a2, int a3)
{
  int v3; // ebx
  _DWORD *v4; // edi
  OLECHAR *v5; // ST0C_4
  int *v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  void (__stdcall *v10)(volatile LONG *); // ecx
  _DWORD *v11; // eax
  CComBSTR *v12; // esi
  WCHAR *v13; // eax
  int v14; // eax
  BSTR v15; // eax
  volatile LONG *v16; // eax
  CComBSTR *ppComBSTR; // [esp+10h] [ebp-28h]
  CComBSTR *ppv; // [esp+14h] [ebp-24h]
  char v19; // [esp+18h] [ebp-20h]
  OLECHAR *psz; // [esp+1Ch] [ebp-1Ch]
  int v21; // [esp+20h] [ebp-18h]
  _DWORD *v22; // [esp+24h] [ebp-14h]
  CComBSTR v23; // [esp+28h] [ebp-10h]
  int v24; // [esp+34h] [ebp-4h]

  if ( byte_1305774 )
  {
    EnterCriticalSection(&gItem.Lock);
    v3 = 0;
    v4 = 0;
    v21 = 0;
    v22 = 0;
    v23.bstr = 0;
    v24 = 0;
    if ( *(a1 + 4) )
    {
      v5 = *(a1 + 344);
      v21 = a1;
      bstr_t::Assign(&v23, v5);
      psz = *(a1 + 348);
    }
    else
    {
      v3 = a1;
      bstr_t::Assign(&v23, *(a1 + 792));
      psz = *(a1 + 828);
    }
    v6 = *sub_1282F90(&theStringMAP, &ppv, &v23);
    if ( v6 == theStringMAP
      || ((v7 = v6[5], !v3) ? (*(v21 + 364) = v7) : (*(v3 + 844) = v7),
          (v4 = v6[5], v22 = v4, v8 = v4[1], v8 == 6) || v8 == 5) )
    {
      v9 = a3;
      if ( a3 != 2 )
      {
        v10 = InterlockedIncrement;
        if ( !v4 )
        {
          v11 = operator new(0x2Cu);
          if ( v11 )
            v4 = sub_1211350(v11);
          else
            v4 = 0;
          v12 = v23.bstr;
          *v4 = a2;
          v22 = v4;
          if ( v4 + 5 != &v23 )
          {
            bstr_t::Data_t::Free((v4 + 5));
            v4[5] = v12;
            if ( v12 )
              InterlockedIncrement(&v12->Length);
          }
          v13 = gpszTargetName;
          if ( psz )
            v13 = psz;
          psz = bstr_t::EqualAssign(&ppv, v13);
          if ( v4 + 2 != psz )
          {
            bstr_t::Data_t::Free((v4 + 2));
            v14 = *psz;
            v4[2] = *psz;
            if ( v14 )
              InterlockedIncrement((v14 + 8));
          }
          bstr_t::Data_t::Free(&ppv);
          ppv = bstr_t::EqualAssign(&psz, gpszTargetName);
          if ( v4 + 3 != ppv )
          {
            bstr_t::Data_t::Free(v4 + 1);
            v15 = ppv->bstr;
            v4[3] = ppv->bstr;
            if ( v15 )
              InterlockedIncrement(v15 + 2);
          }
          bstr_t::Data_t::Free(&psz);
          ppComBSTR = v12;
          if ( v12 )
            InterlockedIncrement(&v12->Length);
          ppv = v4;
          LOBYTE(v24) = 1;
          sub_1281650(&theStringMAP, &v19, 0, &ppComBSTR, byte_1305775);
          LOBYTE(v24) = 0;
          bstr_t::Data_t::Free(&ppComBSTR);
          v10 = InterlockedIncrement;
          v9 = a3;
        }
        v4[1] = 3 - (v9 != 1);
        if ( v3 )
        {
          *(v3 + 844) = v4;
          v16 = (v3 + 36);
        }
        else
        {
          v16 = v21;
          *(v21 + 364) = v4;
        }
        v10(v16);
        if ( v9 == 1 )
        {
          sub_1219380(&theLIST2, &v22);
          SetEvent(gItem.hEvent3);
        }
        else
        {
          sub_12117F0(&theLIST1, &v22);
          SetEvent(gItem.hEvent2);
        }
      }
    }
    LeaveCriticalSection(&gItem.Lock);
    bstr_t::Data_t::Free(&v23);
  }
}
// 1305774: using guessed type char byte_1305774;
// 1305775: using guessed type char byte_1305775;

//----- (01281EC0) --------------------------------------------------------
int __stdcall sub_1281EC0(int a1)
{
  void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION); // ebx
  void (__stdcall *EnterCriticalSection_1)(LPCRITICAL_SECTION); // esi
  CNode *v3; // ST0C_4
  CNode **v4; // ecx
  CComBSTR *v5; // edi
  CNode *v6; // eax
  CComBSTR *pComBSTR; // eax
  CComBSTR *pComBSTR1; // esi
  BSTR bstr; // eax
  BSTR *v10; // ecx
  int v11; // eax
  bool v12; // bl
  const wchar_t **v13; // eax
  const wchar_t *v14; // eax
  CNode *v15; // ebx
  _DWORD *v16; // eax
  void (__stdcall *v17)(HWND, UINT, WPARAM, LPARAM); // ebx
  HKEY v18; // eax
  const wchar_t *v19; // eax
  _DWORD *v20; // ebx
  _DWORD *v21; // eax
  int v22; // esi
  HANDLE hEvent3; // [esp+10h] [ebp-24h]
  HANDLE hEvent1; // [esp+14h] [ebp-20h]
  void *v26; // [esp+18h] [ebp-1Ch]
  OLECHAR psz[2]; // [esp+1Ch] [ebp-18h]
  CComBSTR *v28; // [esp+20h] [ebp-14h]
  char v29; // [esp+27h] [ebp-Dh]
  int v30; // [esp+30h] [ebp-4h]

  hEvent3 = gItem.hEvent3;
  hEvent1 = gItem.hEvent1;
  *psz = 0;
  v30 = 0;
  if ( WaitForMultipleObjects(2u, &hEvent3, 0, 0xFFFFFFFF) != 1 )
  {
    EnterCriticalSection = ::EnterCriticalSection;
    EnterCriticalSection_1 = LeaveCriticalSection;
    while ( 1 )
    {
      EnterCriticalSection(&gItem.Lock);
      if ( theLIST2.Prev )
        break;
LABEL_42:
      EnterCriticalSection_1(&gItem.Lock);
      if ( WaitForMultipleObjects(2u, &hEvent3, 0, 0xFFFFFFFF) == 1 )
        goto LABEL_43;
    }
    while ( 1 )
    {
      v3 = theLIST2.Next->Next;
      v4 = theLIST2.Next->Next->Prev;
      v6 = theLIST2.Next->Next->Next;
      v28 = theLIST2.Next->Next[1].Next;
      v5 = v28;
      *v4 = v6;
      v3->Next->Prev = v3->Prev;
      --theLIST2.Prev;
      j__free(v3);
      EnterCriticalSection_1(&gItem.Lock);
      CHttp::Requery(&gHttp, &v5->Length, psz);
      EnterCriticalSection(&gItem.Lock);
      v29 = 0;
      pComBSTR = operator new(0xCu);
      pComBSTR1 = pComBSTR;
      v26 = pComBSTR;
      LOBYTE(v30) = 1;
      if ( pComBSTR )
      {
        pComBSTR->hKey = 0;
        pComBSTR->Length = 1;
        bstr = SysAllocString(gpszTargetName);
        pComBSTR1->bstr = bstr;
        if ( !bstr )
          goto LABEL_6;
      }
      else
      {
        pComBSTR1 = 0;
      }
      LOBYTE(v30) = 0;
      if ( !pComBSTR1 )
LABEL_6:
        com_error::throw(E_OUTOFMEMORY);
      v10 = v5[2].Length;
      if ( v10 == pComBSTR1 )
        break;
      if ( v10 )
      {
        v11 = sub_11F4730(v10, &pComBSTR1->bstr);
      }
      else
      {
        if ( !pComBSTR1->bstr || !SysStringLen(pComBSTR1->bstr) )
          break;
        v11 = -1;
      }
LABEL_16:
      v12 = v11 != 0;
      if ( !InterlockedDecrement(&pComBSTR1->Length) )
      {
        if ( pComBSTR1->bstr )
        {
          SysFreeString(pComBSTR1->bstr);
          pComBSTR1->bstr = 0;
        }
        if ( pComBSTR1->hKey )
        {
          j_j__free(pComBSTR1->hKey);
          pComBSTR1->hKey = 0;
        }
        j__free(pComBSTR1);
      }
      if ( !v12 )
      {
        v18 = v5[3].hKey;
        if ( v18 )
          v19 = *v18;
        else
          v19 = 0;
        if ( _wcsicmp(v19, L"Submitted") )
        {
          v5->hKey = 1;
        }
        else
        {
          v20 = theLIST;
          v21 = sub_1281420(theLIST, *(theLIST + 1), &v28);
          if ( (357913940 - *(&theLIST + 1)) < 1 )
LABEL_52:
            std::_Xlength_error("list<T> too long");
          *(&theLIST + 1) = *(&theLIST + 1) + 1;
          v20[1] = v21;
          *v21[1] = v21;
          v5->hKey = 4;
        }
        v29 = 1;
        goto LABEL_38;
      }
      v13 = v5[2].Length;
      if ( v13 )
        v14 = *v13;
      else
        v14 = 0;
      if ( wcsstr(v14, L"throttle") )
      {
        v15 = theLIST2.Next->Next;
        v16 = sub_1281420(&theLIST2.Next->Next->Next, theLIST2.Next->Next->Prev, &v28);
        if ( (357913940 - theLIST2.Prev) < 1 )
          goto LABEL_52;
        ++theLIST2.Prev;
        v15->Prev = v16;
        *v16[1] = v16;
        SetEvent(gItem.hEvent3);
LABEL_38:
        v17 = PostMessageW;
        goto LABEL_39;
      }
      v17 = PostMessageW;
      v5->hKey = 5;
      v29 = 1;
      PostMessageW(ghWndNewOwner, 0x7F9u, 0, v5);
LABEL_39:
      EnterCriticalSection_1 = LeaveCriticalSection;
      LeaveCriticalSection(&gItem.Lock);
      if ( v29 )
        v17(ghWndNewOwner, 0x7F9u, 0, v5);
      EnterCriticalSection = ::EnterCriticalSection;
      ::EnterCriticalSection(&gItem.Lock);
      if ( !theLIST2.Prev )
        goto LABEL_42;
    }
    v11 = 0;
    goto LABEL_16;
  }
LABEL_43:
  v22 = *psz;
  if ( *psz && !InterlockedDecrement((*psz + 8)) && v22 )
  {
    if ( *v22 )
    {
      SysFreeString(*v22);
      *v22 = 0;
    }
    if ( *(v22 + 4) )
    {
      j_j__free(*(v22 + 4));
      *(v22 + 4) = 0;
    }
    j__free(v22);
  }
  return 0;
}

//----- (01282230) --------------------------------------------------------
int __stdcall sub_1282230(int a1)
{
  int v1; // edi
  _DWORD *v2; // ebx
  void (__stdcall *v3)(LPCRITICAL_SECTION); // esi
  _DWORD *v4; // ST514_4
  _DWORD *v5; // ecx
  _bstr_t *v6; // ebx
  int v7; // eax
  OLECHAR **v8; // eax
  OLECHAR *v9; // eax
  Data_t *v10; // ecx
  const WCHAR *v11; // ecx
  OLECHAR **v12; // eax
  OLECHAR *v13; // eax
  _DWORD *v14; // esi
  _DWORD *v15; // eax
  _DWORD *v16; // ecx
  DWORD v17; // eax
  _bstr_t *v18; // edi
  Data_t *v19; // esi
  void *v20; // esi
  _DWORD *v21; // esi
  LPARAM v22; // ebx
  BSTR *v23; // eax
  BSTR *v24; // edi
  BSTR v25; // eax
  BSTR *v26; // ecx
  int v27; // eax
  const wchar_t **v28; // eax
  const wchar_t *v29; // eax
  _DWORD *v30; // eax
  OLECHAR **v31; // eax
  OLECHAR *v32; // eax
  const wchar_t **v33; // eax
  const wchar_t *v34; // eax
  _DWORD *v35; // eax
  _DWORD *v36; // eax
  _DWORD *v37; // eax
  _DWORD *v38; // esi
  _DWORD *v39; // eax
  _DWORD *v40; // esi
  HANDLE Handles; // [esp+10h] [ebp-B4h]
  HANDLE v43; // [esp+14h] [ebp-B0h]
  int v44; // [esp+18h] [ebp-ACh]
  _DWORD **v45; // [esp+1Ch] [ebp-A8h]
  int v46; // [esp+20h] [ebp-A4h]
  void *v47; // [esp+24h] [ebp-A0h]
  _bstr_t *v48; // [esp+28h] [ebp-9Ch]
  void *v49; // [esp+2Ch] [ebp-98h]
  bool v50; // [esp+32h] [ebp-92h]
  char v51; // [esp+33h] [ebp-91h]
  OLECHAR psz; // [esp+34h] [ebp-90h]
  int v53; // [esp+C0h] [ebp-4h]

  v1 = 0;
  Handles = gItem.hEvent2;
  v43 = gItem.hEvent1;
  v46 = 0;
  v2 = sub_1282A70(0, 0);
  v45 = v2;
  v53 = 0;
  v44 = 0;
  while ( WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF) != 1 )
  {
    v3 = LeaveCriticalSection;
    Sleep(0x1388u);
    EnterCriticalSection(&gItem.Lock);
    if ( *(&theLIST1 + 1) )
    {
      do
      {
        v4 = *theLIST1;
        v5 = *(*theLIST1 + 4);
        v7 = **theLIST1;
        v48 = *(*theLIST1 + 8);
        v6 = v48;
        *v5 = v7;
        *(*v4 + 4) = v4[1];
        *(&theLIST1 + 1) = *(&theLIST1 + 1) - 1;
        j__free(v4);
        v3(&gItem.Lock);
        v8 = &v6[4].m_Data->m_wstr;
        if ( !v8 || (v9 = *v8) == 0 || !SysStringLen(v9) )
        {
          v10 = v6[5].m_Data;
          v11 = v10 ? v10->m_wstr : 0;
          if ( sub_1281840(v11, &psz, &v6[6]) )
            bstr_t::Assign(v6 + 4, &psz);
        }
        v12 = &v6[4].m_Data->m_wstr;
        if ( v12 && (v13 = *v12) != 0 && SysStringLen(v13) )
        {
          ++v44;
          v14 = *v45;
          v15 = sub_1281420(*v45, (*v45)[1], &v48);
          if ( (0x15555554 - v1) < 1 )
LABEL_89:
            std::_Xlength_error("list<T> too long");
          v14[1] = v15;
          ++v1;
          v16 = v15[1];
          v46 = v1;
          *v16 = v15;
          sub_1225160(&gHttp, v6 + 8);
        }
        else
        {
          v17 = GetLastError();
          sub_1224320(&v47, v17);
          v18 = v6 + 8;
          if ( &v6[8] != &v47 )
          {
            v19 = v18->m_Data;
            if ( v18->m_Data )
            {
              if ( !InterlockedDecrement(&v19->m_RefCount) && v19 )
              {
                if ( v19->m_wstr )
                {
                  SysFreeString(v19->m_wstr);
                  v19->m_wstr = 0;
                }
                if ( v19->m_str )
                {
                  j_j__free(v19->m_str);
                  v19->m_str = 0;
                }
                j__free(v19);
              }
              v18->m_Data = 0;
            }
            v18->m_Data = v47;
            if ( v47 )
              InterlockedIncrement(v47 + 2);
          }
          v6[1].m_Data = 5;
          v20 = v47;
          if ( v47 )
          {
            if ( !InterlockedDecrement(v47 + 2) && v20 )
            {
              if ( *v20 )
              {
                SysFreeString(*v20);
                *v20 = 0;
              }
              if ( *(v20 + 1) )
              {
                j_j__free(*(v20 + 1));
                *(v20 + 1) = 0;
              }
              j__free(v20);
            }
            v47 = 0;
          }
          v1 = v46;
        }
        EnterCriticalSection(&gItem.Lock);
        v3 = LeaveCriticalSection;
      }
      while ( *(&theLIST1 + 1) );
      v2 = v45;
    }
    v3(&gItem.Lock);
    sub_1221FC0(&gHttp);
    v21 = *v2;
    if ( *v2 != v2 )
    {
      while ( 1 )
      {
        EnterCriticalSection(&gItem.Lock);
        v22 = v21[2];
        v51 = 0;
        v48 = v22;
        v23 = operator new(0xCu);
        v24 = v23;
        v49 = v23;
        LOBYTE(v53) = 1;
        if ( v23 )
        {
          v23[1] = 0;
          v23[2] = 1;
          v25 = SysAllocString(gpszTargetName);
          *v24 = v25;
          if ( !v25 )
            goto LABEL_44;
        }
        else
        {
          v24 = 0;
        }
        LOBYTE(v53) = 0;
        if ( !v24 )
LABEL_44:
          com_error::throw(-2147024882);
        v26 = *(v22 + 32);
        if ( v26 == v24 )
          break;
        if ( v26 )
        {
          v27 = sub_11F4730(v26, v24);
        }
        else
        {
          if ( !*v24 || !SysStringLen(*v24) )
            break;
          v27 = -1;
        }
LABEL_54:
        v50 = v27 != 0;
        if ( !InterlockedDecrement(v24 + 2) )
        {
          if ( *v24 )
          {
            SysFreeString(*v24);
            *v24 = 0;
          }
          if ( v24[1] )
          {
            j_j__free(v24[1]);
            v24[1] = 0;
          }
          j__free(v24);
        }
        if ( v50 )
        {
          v28 = *(v22 + 32);
          if ( v28 )
            v29 = *v28;
          else
            v29 = 0;
          if ( wcsstr(v29, L"Throttle") )
          {
            v49 = *theLIST1;
            v30 = sub_1281420(v49, *(v49 + 1), &v48);
            if ( (357913940 - *(&theLIST1 + 1)) < 1 )
              goto LABEL_89;
            *(&theLIST1 + 1) = *(&theLIST1 + 1) + 1;
            *(v49 + 1) = v30;
            *v30[1] = v30;
            SetEvent(gItem.hEvent2);
            goto LABEL_83;
          }
          *(v22 + 4) = 5;
        }
        else
        {
          v31 = *(v22 + 36);
          if ( v31 && (v32 = *v31) != 0 && SysStringLen(v32) )
          {
            v33 = *(v22 + 40);
            if ( v33 )
              v34 = *v33;
            else
              v34 = 0;
            if ( _wcsicmp(v34, L"Submitted") )
            {
              *(v22 + 4) = 1;
            }
            else
            {
              v49 = *theLIST1;
              v35 = sub_1281420(v49, *(v49 + 1), &v48);
              if ( (357913940 - *(&theLIST1 + 1)) < 1 )
                goto LABEL_89;
              *(&theLIST1 + 1) = *(&theLIST1 + 1) + 1;
              *(v49 + 1) = v35;
              *v35[1] = v35;
              SetEvent(gItem.hEvent2);
            }
          }
          else
          {
            *(v22 + 4) = 6;
            if ( gbVirusTotalSubmitUnknown && *v22 )
            {
              *(v22 + 4) = 3;
              v49 = theLIST2.Next;
              v36 = sub_1281420(&theLIST2.Next->Next, theLIST2.Next->Prev, &v48);
              if ( (357913940 - theLIST2.Prev) < 1 )
                goto LABEL_89;
              ++theLIST2.Prev;
              *(v49 + 1) = v36;
              *v36[1] = v36;
              SetEvent(gItem.hEvent3);
            }
          }
        }
        v51 = 1;
LABEL_83:
        LeaveCriticalSection(&gItem.Lock);
        if ( v51 )
          PostMessageW(ghWndNewOwner, 0x7F9u, 0, v22);
        v21 = *v21;
        v2 = v45;
        if ( v21 == v45 )
          goto LABEL_86;
      }
      v27 = 0;
      goto LABEL_54;
    }
LABEL_86:
    v37 = *v2;
    v1 = 0;
    *v2 = v2;
    v2[1] = v2;
    v46 = 0;
    if ( v37 != v2 )
    {
      do
      {
        v38 = *v37;
        j__free(v37);
        v37 = v38;
      }
      while ( v38 != v2 );
    }
  }
  v39 = *v2;
  *v2 = v2;
  v2[1] = v2;
  if ( v39 != v2 )
  {
    do
    {
      v40 = *v39;
      j__free(v39);
      v39 = v40;
    }
    while ( v40 != v2 );
  }
  j__free(v2);
  return 0;
}
// 12E96E1: using guessed type char gbVirusTotalSubmitUnknown;

//----- (01282860) --------------------------------------------------------
LRESULT __stdcall pfnSubclass(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  HWND v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  wchar_t **v9; // eax
  wchar_t *v10; // eax
  int v12; // eax
  HCURSOR v13; // eax

  v6 = GetParent(hWnd);
  v7 = GetWindowLongW(v6, -21);
  if ( v7[1] )
    v8 = v7[91];
  else
    v8 = v7[211];
  if ( uMsg != 512 )
  {
    if ( uMsg == 514 && v8 && (*(v8 + 4) == 1 || *(v8 + 4) == 4) )
    {
      v9 = *(v8 + 36);
      if ( v9 )
        v10 = *v9;
      else
        v10 = 0;
      sub_1245750(hWnd, 0, v10);
    }
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  if ( !v8 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  v12 = *(v8 + 4) - 1;
  if ( v12 )
  {
    if ( v12 != 3 )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  v13 = LoadCursorW(ghInstance, L"HAND");
  SetCursor(v13);
  return 1;
}

//----- (01282910) --------------------------------------------------------
char __cdecl sub_1282910(int a1)
{
  wchar_t **v1; // eax
  wchar_t *v2; // eax
  char result; // al
  int v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  v4 = 0;
  if ( *(a1 + 4) != 1 )
    return 0;
  v1 = *(a1 + 40);
  if ( v1 )
    v2 = *v1;
  else
    v2 = 0;
  vscan_fn(v2, L"%d/%d", &v5);
  result = 0;
  if ( v5 )
    result = 1;
  return result;
}
// 12B2BB0: using guessed type wchar_t aDD[6];

//----- (01282970) --------------------------------------------------------
int __stdcall sub_1282970(int a1)
{
  DWORD (__stdcall *v1)(HANDLE, DWORD); // edi
  _DWORD *v2; // esi
  int v3; // edi
  const wchar_t **v4; // eax
  const wchar_t *v5; // eax
  _DWORD **v6; // eax

  v1 = WaitForSingleObject;
  while ( v1(gItem.hEvent1, 0x2710u) == 258 )
  {
    if ( !sub_12237E0(&gHttp) )
    {
      v2 = *theLIST;
      if ( *theLIST != theLIST )
      {
        do
        {
          EnterCriticalSection(&gItem.Lock);
          v3 = v2[2];
          v4 = *(v3 + 40);
          if ( v4 )
            v5 = *v4;
          else
            v5 = 0;
          if ( _wcsicmp(v5, L"Submitted") )
          {
            v6 = v2;
            *(v3 + 4) = 1;
            v2 = *v2;
            *v6[1] = *v6;
            (*v6)[1] = v6[1];
            *(&theLIST + 1) = *(&theLIST + 1) - 1;
            j__free(v6);
          }
          else
          {
            v2 = *v2;
          }
          LeaveCriticalSection(&gItem.Lock);
        }
        while ( v2 != theLIST );
        v1 = WaitForSingleObject;
      }
      PostMessageW(ghWndNewOwner, 0x7F9u, 0, 0);
    }
  }
  return 0;
}
// 1282970: using guessed type int __stdcall sub_1282970(int);

//----- (01282A70) --------------------------------------------------------
_DWORD *__stdcall sub_1282A70(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx

  result = operator new(0xCu);
  if ( !result )
    std::bad_alloc::bad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
  }
  else
  {
    v3 = result;
    v4 = result;
  }
  *result = v3;
  if ( result != -4 )
    result[1] = v4;
  return result;
}

//----- (01282AB0) --------------------------------------------------------
void __stdcall sub_1282AB0(void *a1)
{
  _DWORD *v1; // edi
  void *i; // ebx
  int v3; // esi

  v1 = a1;
  for ( i = a1; !*(i + 13); v1 = i )
  {
    sub_1282AB0(*(i + 2));
    v3 = v1[4];
    i = *i;
    if ( v3 )
    {
      if ( !InterlockedDecrement((v3 + 8)) && v3 )
      {
        if ( *v3 )
        {
          SysFreeString(*v3);
          *v3 = 0;
        }
        if ( *(v3 + 4) )
        {
          j_j__free(*(v3 + 4));
          *(v3 + 4) = 0;
        }
        j__free(v3);
      }
      v1[4] = 0;
    }
    j__free(v1);
  }
}

//----- (01282B40) --------------------------------------------------------
int *__thiscall sub_1282B40(void *this, int a2)
{
  int *v2; // edi
  int *v3; // esi
  volatile LONG *v4; // ecx
  volatile LONG *v6; // [esp-8h] [ebp-1Ch]
  volatile LONG *v7; // [esp-4h] [ebp-18h]

  v2 = *this;
  v3 = *(*this + 4);
  while ( !*(v3 + 13) )
  {
    v7 = *a2;
    if ( *a2 )
      InterlockedIncrement(v7 + 2);
    v4 = v3[4];
    v6 = v4;
    if ( v4 )
      InterlockedIncrement(v4 + 2);
    if ( sub_12114B0(v6, v7) )
    {
      v3 = v3[2];
    }
    else
    {
      v2 = v3;
      v3 = *v3;
    }
  }
  return v2;
}

//----- (01282BB0) --------------------------------------------------------
_DWORD *__thiscall sub_1282BB0(void *this, _DWORD *a2)
{
  int v2; // esi
  int v3; // eax
  _DWORD *result; // eax

  v2 = *a2;
  *a2 = *(*a2 + 8);
  v3 = *(v2 + 8);
  if ( !*(v3 + 13) )
    *(v3 + 4) = a2;
  *(v2 + 4) = a2[1];
  result = *this;
  if ( a2 == *(*this + 4) )
  {
    result[1] = v2;
    *(v2 + 8) = a2;
    a2[1] = v2;
  }
  else
  {
    result = a2[1];
    if ( a2 == result[2] )
      result[2] = v2;
    else
      *result = v2;
    *(v2 + 8) = a2;
    a2[1] = v2;
  }
  return result;
}

//----- (01282C10) --------------------------------------------------------
int __stdcall sub_1282C10(int a1, int a2, int a3)
{
  int **v3; // ecx
  int v4; // eax
  int **v5; // esi
  int *v6; // ecx
  int *v7; // eax
  int v8; // ecx
  int result; // eax
  _DWORD *v10; // ecx
  int i; // edx
  int j; // eax
  char v13; // [esp+4h] [ebp-4h]

  v4 = a2;
  v5 = v3;
  v6 = *v3;
  if ( a2 != *v6 || a3 != v6 )
  {
    for ( ; a2 != a3; v4 = a2 )
    {
      v10 = v4;
      if ( !*(v4 + 13) )
      {
        i = *(v4 + 8);
        if ( *(i + 13) )
        {
          for ( i = *(v4 + 4); !*(i + 13); i = *(i + 4) )
          {
            if ( v4 != *(i + 8) )
              break;
            v4 = i;
          }
        }
        else
        {
          for ( j = *i; !*(j + 13); j = *j )
            i = j;
        }
        a2 = i;
      }
      sub_1282CD0(v5, &v13, v10);
    }
    *a1 = v4;
    result = a1;
  }
  else
  {
    sub_1282AB0(v6[1]);
    (*v5)[1] = *v5;
    **v5 = *v5;
    (*v5)[2] = *v5;
    v7 = *v5;
    v5[1] = 0;
    v8 = *v7;
    result = a1;
    *a1 = v8;
  }
  return result;
}

//----- (01282CD0) --------------------------------------------------------
_DWORD *__thiscall sub_1282CD0(int **this, _DWORD *a2, _DWORD *a3)
{
  CMapNode *v3; // ebx
  CMapNode *v4; // edx
  CMapNode *v5; // edi
  CMapNode *v6; // ecx
  CMapNode *v7; // esi
  CMapNode *v8; // eax
  CMapNode *v9; // ecx
  CMapNode *v10; // eax
  CMapNode *v11; // eax
  CMapNode *i; // ecx
  CMapNode *v13; // eax
  char v14; // cl
  CMapNode *v15; // ecx
  DWORD v16; // esi
  CMapNode *v17; // eax
  _DWORD *v18; // ecx
  _DWORD *result; // eax
  _DWORD *v20; // [esp+Ch] [ebp-8h]
  CMapNode *v21; // [esp+10h] [ebp-4h]

  v3 = this;
  v21 = a3;
  sub_1214CE0(&a3);
  v4 = v21;
  if ( v21->_Left->_isnil )
  {
    v5 = v21->_Right;
  }
  else if ( v21->_Right->_isnil )
  {
    v5 = v21->_Left;
  }
  else
  {
    v6 = a3;
    v20 = a3;
    v5 = a3[2];
    if ( a3 != v21 )
    {
      v21->_Left->_Parent = a3;
      v6->_Left = v21->_Left;
      if ( v6 == v21->_Right )
      {
        v7 = v6;
      }
      else
      {
        v7 = v6->_Parent;
        if ( !v5->_isnil )
          v5->_Parent = v7;
        v7->_Left = v5;
        v6->_Right = v21->_Right;
        v21->_Right->_Parent = v6;
      }
      if ( v3->_Left->_Parent == v21 )
      {
        v3->_Left->_Parent = v6;
      }
      else
      {
        v13 = v21->_Parent;
        if ( v13->_Left == v21 )
          v13->_Left = v6;
        else
          v13->_Right = v6;
      }
      v6->_Parent = v21->_Parent;
      v14 = v6->_Color;
      *(v20 + 12) = v21->_Color;
      v4 = v21;
      v21->_Color = v14;
      goto LABEL_37;
    }
  }
  v7 = v21->_Parent;
  if ( !v5->_isnil )
    v5->_Parent = v7;
  if ( v3->_Left->_Parent == v21 )
  {
    v3->_Left->_Parent = v5;
  }
  else if ( v7->_Left == v21 )
  {
    v7->_Left = v5;
  }
  else
  {
    v7->_Right = v5;
  }
  v8 = v3->_Left;
  if ( v3->_Left->_Left == v21 )
  {
    if ( v5->_isnil )
    {
      v9 = v7;
    }
    else
    {
      v10 = v5->_Left;
      v9 = v5;
      if ( !v5->_Left->_isnil )
      {
        do
        {
          v9 = v10;
          v10 = v10->_Left;
        }
        while ( !v10->_isnil );
      }
      v8 = v3->_Left;
    }
    v8->_Left = v9;
  }
  if ( v3->_Left->_Right == v21 )
  {
    if ( v5->_isnil )
    {
      v3->_Left->_Right = v7;
    }
    else
    {
      v11 = v5->_Right;
      for ( i = v5; !v11->_isnil; v11 = v11->_Right )
        i = v11;
      v3->_Left->_Right = i;
    }
  }
LABEL_37:
  if ( v4->_Color != 1 )
    goto LABEL_62;
  if ( v5 == v3->_Left->_Parent )
    goto LABEL_61;
  while ( v5->_Color == 1 )
  {
    v15 = v7->_Left;
    if ( v5 == v7->_Left )
    {
      v15 = v7->_Right;
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_12754B0(v3, v7);
        v15 = v7->_Right;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Left->_Color != 1 || v15->_Right->_Color != 1 )
      {
        if ( v15->_Right->_Color == 1 )
        {
          v15->_Left->_Color = 1;
          v15->_Color = 0;
          sub_1282BB0(v3, v15);
          v15 = v7->_Right;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Right->_Color = 1;
        sub_12754B0(v3, v7);
        break;
      }
    }
    else
    {
      if ( !v15->_Color )
      {
        v15->_Color = 1;
        v7->_Color = 0;
        sub_1282BB0(v3, v7);
        v15 = v7->_Left;
      }
      if ( v15->_isnil )
        goto LABEL_55;
      if ( v15->_Right->_Color != 1 || v15->_Left->_Color != 1 )
      {
        if ( v15->_Left->_Color == 1 )
        {
          v15->_Right->_Color = 1;
          v15->_Color = 0;
          sub_12754B0(v3, v15);
          v15 = v7->_Left;
        }
        v15->_Color = v7->_Color;
        v7->_Color = 1;
        v15->_Left->_Color = 1;
        sub_1282BB0(v3, v7);
        break;
      }
    }
    v15->_Color = 0;
LABEL_55:
    v5 = v7;
    v7 = v7->_Parent;
    if ( v5 == v3->_Left->_Parent )
      break;
  }
  v4 = v21;
LABEL_61:
  v5->_Color = 1;
LABEL_62:
  v16 = v4->_KeyValue.Key;
  if ( v16 )
  {
    if ( !InterlockedDecrement((v16 + 8)) && v16 )
    {
      if ( *v16 )
      {
        SysFreeString(*v16);
        *v16 = 0;
      }
      if ( *(v16 + 4) )
      {
        j_j__free(*(v16 + 4));
        *(v16 + 4) = 0;
      }
      j__free(v16);
    }
    v4 = v21;
    v21->_KeyValue.Key = 0;
  }
  j__free(v4);
  v17 = v3->_Parent;
  v18 = a3;
  if ( v17 )
    v3->_Parent = (v17 - 1);
  result = a2;
  *a2 = v18;
  return result;
}

//----- (01282F90) --------------------------------------------------------
int **__thiscall sub_1282F90(int **this, int **a2, volatile LONG **a3)
{
  int **v3; // edi
  int *v4; // eax
  int *v5; // esi
  volatile LONG *v6; // ecx
  int **result; // eax
  volatile LONG *v8; // [esp-8h] [ebp-14h]
  volatile LONG *v9; // [esp-4h] [ebp-10h]

  v3 = this;
  v4 = sub_1282B40(this, a3);
  v5 = v4;
  if ( v4 == *v3 )
    goto LABEL_11;
  v6 = v4[4];
  v9 = v6;
  if ( v6 )
    InterlockedIncrement(v6 + 2);
  v8 = *a3;
  if ( *a3 )
    InterlockedIncrement(v8 + 2);
  if ( sub_12114B0(v8, v9) )
  {
LABEL_11:
    result = a2;
    *a2 = *v3;
  }
  else
  {
    result = a2;
    *a2 = v5;
  }
  return result;
}

//----- (01283010) --------------------------------------------------------
HANDLE DumpProcessThreadProc()
{
  HANDLE v0; // eax
  HANDLE hProcexp32bitServerEvent; // ebx
  HANDLE result; // eax
  HANDLE hMapping; // eax
  MapInfo *pMapping; // esi
  DWORD (__stdcall *GetLastError)(); // ebx
  const WCHAR *pszFileName; // ecx
  HANDLE hFile; // edi
  HANDLE hProcess; // ebx
  HANDLE hHandle; // [esp+8h] [ebp-8h]
  HANDLE hProcexp32bitClientEvent; // [esp+Ch] [ebp-4h]

  LoadDbgHelp(L"Dbghelp.dll");
  v0 = CreateEventW(0, 0, 0, L"Procexp32bitServerEvent");
  hProcexp32bitServerEvent = v0;
  hHandle = v0;
  result = CreateEventW(0, 0, 0, L"Procexp32bitClientEvent");
  hProcexp32bitClientEvent = result;
  if ( result )
  {
    if ( hProcexp32bitServerEvent )
    {
      hMapping = CreateFileMappingW(
                   INVALID_HANDLE_VALUE,
                   0,
                   // PAGE_READWRITE | PAGE_REVERT_TO_FILE_MAP
                   0x8000004u,
                   0,
                   gSystemInfo.dwPageSize,
                   L"Procexp32bitSection");
      pMapping = MapViewOfFile(hMapping, 6u, 0, 0, gSystemInfo.dwPageSize);
      result = WaitForSingleObject(hProcexp32bitServerEvent, 0xFFFFFFFF);
      if ( !result )
      {
        GetLastError = ::GetLastError;
        pszFileName = pMapping->szFileName;
        do
        {
          // FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
          hFile = CreateFile(pszFileName, GENERIC_WRITE, 7u, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
          if ( hFile == INVALID_HANDLE_VALUE )
          {
            pMapping->dwError = GetLastError();
          }
          else
          {
            // PROCESS_TRACE_MODE_EVENT_RECORD 
            // 目前还不知道啥意思，具体用途不明
            hProcess = OpenProcess(PROCESS_TRACE_MODE_EVENT_RECORD, 0, pMapping->dwPid);
            if ( hProcess )
            {
              if ( !DumpProcessToFile(hFile, hProcess, pMapping->bDumpMemory) )
                pMapping->dwError = ::GetLastError();
              CloseHandle(hProcess);
              GetLastError = ::GetLastError;
            }
            else
            {
              GetLastError = ::GetLastError;
              pMapping->dwError = ::GetLastError();
            }
            CloseHandle(hFile);
          }
          SetEvent(hProcexp32bitClientEvent);
          result = WaitForSingleObject(hHandle, 0xFFFFFFFF);
          pszFileName = pMapping->szFileName;
        }
        while ( !result );
      }
    }
  }
  return result;
}

//----- (01283150) --------------------------------------------------------
signed int Usage()
{
  if ( GetVersion() < 6u )
    MessageBoxW(
      0,
      L"Usage: Process Explorer [/t] [/p:[r|h|l]] [/s:<PID>]\n"
       "\n"
       "/t\tStart minimized in the tray\n"
       "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
       "/s\tSelect the specified process\n",
      L"Process Explorer",
      0x40u);
  else
    MessageBoxW(
      0,
      L"Usage: Process Explorer [/e] [/t] [/p:[r|h|l]] [/s:<PID>]\n"
       "\n"
       "/e\tRequest UAC elevation\n"
       "/t\tStart minimized in the tray\n"
       "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
       "/s\tSelect the specified process\n",
      L"Process Explorer",
      0x40u);
  return -1;
}

//----- (01283190) --------------------------------------------------------
int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
  HMODULE hKernel; // eax
  void (__stdcall *GetNativeSystemInfo)(); // eax
  int result; // eax
  ULONGLONG gdwOsVersion; // rax
  int dwMinorVersion; // eax
  HANDLE v9; // eax
  int arg; // esi
  WCHAR *chCmd; // edx
  unsigned int off; // eax
  int idx; // ecx
  unsigned int v14; // ecx
  WCHAR *v15; // eax
  WCHAR *v16; // eax
  int nCmd; // esi
  WCHAR *ppcmdlinenow; // ecx
  int v19; // edi
  WCHAR chcmd; // ax
  WCHAR *strCmd; // ecx
  int chCmd_1; // eax
  HANDLE v23; // eax
  DWORD ret; // eax
  HACCEL hAccel; // ebx
  HWND hWndThreadStack; // eax
  DWORD v27; // [esp-8h] [ebp-C0h]
  struct tagMSG msg; // [esp+8h] [ebp-B0h]
  HINSTANCE hInst; // [esp+24h] [ebp-94h]
  const WCHAR *lpCommandLine; // [esp+28h] [ebp-90h]
  int nArgc; // [esp+2Ch] [ebp-8Ch]
  WCHAR *ppCmdLine[33]; // [esp+30h] [ebp-88h]

  hInst = hInstance;
  lpCommandLine = lpCmdLine;
  LOBYTE(ppCmdLine[0]) = 0;
  hKernel = LoadLibraryW(L"kernel32.dll");
  GetNativeSystemInfo = GetProcAddress(hKernel, "GetNativeSystemInfo");
  if ( GetNativeSystemInfo )
    GetNativeSystemInfo();
  else
    GetSystemInfo(&gSystemInfo);
  // 如果是64位系统的Win32系统则进入
  if ( IsX64() )
  {
    _beginthread(DumpProcessThreadProc, 0, hInstance);
    if ( StartProcExp64(1, nShowCmd) )
      return 0;
    MessageBoxW(
      0,
      L"Unable to extract 64-bit image. Run Process Explorer from a writeable directory.",
      L"Process Explorer",
      MB_ICONERROR);
    return 1;
  }
  // 进入32位系统
  gdwSomeFunctionVA = 0xF60;
  LOWORD(gdwOsVersion) = GetVersion();
  if ( gdwOsVersion >= 5u )
  {
    gdwOsType = 0;
    if ( gdwOsVersion < 10u )
    {
      if ( gdwOsVersion >= 6u )
      {
        dwMinorVersion = BYTE1(gdwOsVersion);
        if ( dwMinorVersion )
        {
          if ( dwMinorVersion == 1 )
            gdwOsType = WINDOWS_7;
          else
            gdwOsType = WINDOWS_8;
        }
        else
        {
          gdwOsType = WINDOWS_VISTA;
        }
      }
    }
    else
    {
      gdwOsType = WINDOWS_10;
    }
  }
  v9 = GetCurrentProcess();
  SetPriorityClass(v9, HIGH_PRIORITY_CLASS);
  arg = 0;
  gpszCommandLine = lpCmdLine;
  nArgc = 0;
  ppCmdLine[1] = lpCmdLine;
  if ( *lpCmdLine )
  {
    do
    {
      chCmd = ppCmdLine[arg + 1];
      off = 0;
      if ( *chCmd )
      {
        idx = 0;
        do
        {
          if ( chCmd[idx] == ' ' )
            break;
          idx = ++off;
        }
        while ( chCmd[off] );
        if ( off )
          nArgc = ++arg;
      }
      v14 = off;
      v15 = ppCmdLine[arg];
      if ( !v15[v14] )
        break;
      v15[v14] = 0;
      arg = nArgc;
      v16 = &ppCmdLine[nArgc][v14 + 1];
      ppCmdLine[nArgc + 1] = v16;
      if ( arg == ' ' )
        break;
    }
    while ( *v16 );
  }
  // 处理版权
  if ( !sub_1226F60(L"Process Explorer", &nArgc, &ppCmdLine[1]) )
    return 1;
  nCmd = 0;
  if ( nArgc <= 0 )
  {
__CreateMainWnd:
    if ( !CreateMainWindow(hInst, nShowCmd) )
      return 0;
    hAccel = LoadAcceleratorsW(hInst, L"PROCEXPLORER");
    if ( !GetMessageW(&msg, 0, 0, 0) )
      return 0;
    while ( 1 )                                 // 消息循环
    {
      hWndThreadStack = ghWndThreadStack;
      if ( ghWndThreadStack )
      {
        // 处理加速键
        if ( TranslateAcceleratorW(ghWndThreadStack, hAccel, &msg) )
          goto __NextMsg;
        hWndThreadStack = ghWndThreadStack;
      }
      if ( !ghDlgFindDialog )
        goto __MsgTranslate;
      if ( !IsDialogMessageW(ghDlgFindDialog, &msg) )
      {
        hWndThreadStack = ghWndThreadStack;
__MsgTranslate:
        if ( (!hWndThreadStack || !IsDialogMessageW(hWndThreadStack, &msg))
          && !TranslateAcceleratorW(ghWndNewOwner, hAccel, &msg) )
        {
          TranslateMessage(&msg);
          DispatchMessageW(&msg);
        }
      }
__NextMsg:
      if ( !GetMessageW(&msg, 0, 0, 0) )
        return 0;
    }
  }
  while ( 2 )
  {
    ppcmdlinenow = ppCmdLine[nCmd + 1];
    v19 = (ppcmdlinenow + 1);
    do
    {
      chcmd = *ppcmdlinenow;
      ++ppcmdlinenow;
    }
    while ( chcmd );
    _wcsupr_s(ppCmdLine[nCmd + 1], ((ppcmdlinenow - v19) >> 1) + 1);
    strCmd = ppCmdLine[nCmd + 1];
    chCmd_1 = *strCmd;
    if ( chCmd_1 != '/' && chCmd_1 != '-' )
    {
      if ( !wcsstr(strCmd, L"TASKMGR") )
        return Usage();
LABEL_48:
      if ( HIBYTE(ppCmdLine[0]) && !IsBuiltinAndAnministrative() )
      {
        ret = ExecuteProcess(lpCommandLine, nShowCmd, 0);
        if ( ret )
        {
          if ( ret != ERROR_CANCELLED )
            ErrMsgBox(L"Error elevating", ghWndNewOwner);
          return 1;
        }
        return 0;
      }
      goto __CreateMainWnd;
    }
    switch ( strCmd[1] )
    {
      case 'E':
        if ( GetVersion() < 6u )
          return Usage();
        HIBYTE(ppCmdLine[0]) = 1;
        goto LABEL_45;
      case 'P':
        if ( strCmd[2] == 58 )
        {
          switch ( strCmd[3] )
          {
            case 'H':
              goto LABEL_45;
            case 'L':
              v27 = 0x40;
              goto LABEL_44;
            case 'N':
              v27 = 32;
              goto LABEL_44;
            case 'R':
              v27 = 256;
LABEL_44:
              v23 = GetCurrentProcess();
              SetPriorityClass(v23, v27);
              goto LABEL_45;
            default:
              return Usage();
          }
        }
        return Usage();
      case 'R':
        if ( strCmd[2] != 84 )
          return Usage();
        sub_1251F10(0);
        return 0;
      case 'S':
        if ( strCmd[2] != 58 )
          return Usage();
        dword_12DE100 = _wtoi(strCmd + 3);
        goto LABEL_45;
      case 'T':
        gbHide1 = 1;
LABEL_45:
        if ( ++nCmd >= nArgc )
          goto LABEL_48;
        continue;
      default:
        if ( GetVersion() < 6u )
          MessageBoxW(
            0,
            L"Usage: Process Explorer [/t] [/p:[r|h|l]] [/s:<PID>]\n"
             "\n"
             "/t\tStart minimized in the tray\n"
             "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
             "/s\tSelect the specified process\n",
            L"Process Explorer",
            0x40u);
        else
          MessageBoxW(
            0,
            L"Usage: Process Explorer [/e] [/t] [/p:[r|h|l]] [/s:<PID>]\n"
             "\n"
             "/e\tRequest UAC elevation\n"
             "/t\tStart minimized in the tray\n"
             "/p\tRun at priority: realtime (r), high (h), normal (n) or low (l)\n"
             "/s\tSelect the specified process\n",
            L"Process Explorer",
            0x40u);
        result = -1;
        break;
    }
    return result;
  }
}
// 12DE100: using guessed type int dword_12DE100;
// 12E4E54: using guessed type int gdwOsType;
// 12EA388: using guessed type char gbHide1;
// 12EB1CC: using guessed type int gdwSomeFunctionVA;

//----- (012836C0) --------------------------------------------------------
wchar_t *__cdecl sub_12836C0(wchar_t *Src)
{
  size_t v2; // eax
  rsize_t v3; // ebx
  wchar_t *v4; // eax
  wchar_t *v5; // esi

  if ( !Src )
    return 0;
  v2 = wcsnlen(Src, 0xFFu);
  v3 = v2 + 1;
  v4 = malloc(2 * (v2 + 1));
  v5 = v4;
  if ( !v4 || !tcscpy_s(v4, v3, Src) )
    return v5;
  free(v5);
  return 0;
}

//----- (01283720) --------------------------------------------------------
int __cdecl sub_1283720(int a1, int a2, wchar_t *a3, int a4, int a5)
{
  int *v5; // edi
  void *v6; // esi
  int v8; // edi

  v5 = a1;
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    return -2147024809;
  v6 = malloc(0x190u);
  if ( !v6 )
    return -2147024882;
  a1 = 0;
  v8 = sub_12837B0(v5, a2, v6, &a1);
  if ( !v8 )
    v8 = sub_12838A0(a3, v6, a1, a4, a5);
  free(v6);
  return v8;
}

//----- (012837B0) --------------------------------------------------------
int __cdecl sub_12837B0(int *a1, int a2, int a3, _DWORD *a4)
{
  int *v4; // ecx
  int v5; // edi
  _DWORD *v6; // esi
  int v7; // eax
  int result; // eax
  int *v9; // ecx
  int v10; // ebx
  int v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v4 = a1;
  if ( !a1 )
    return -2147024809;
  if ( !a2 )
    return -2147024809;
  v5 = a3;
  if ( !a3 )
    return -2147024809;
  v6 = a4;
  if ( !a4 )
    return -2147024809;
  v7 = *a1;
  a1 = 0;
  v12 = 0;
  v11 = 0;
  result = (*(v7 + 80))(v4, L"WQL", a2, 48, 0, &a1);
  if ( result >= 0 )
  {
    v9 = a1;
    if ( a1 )
    {
      while ( 1 )
      {
        v10 = (*(*v9 + 16))(v9, -1, 1, &v12, &v11);
        if ( v10 < 0 )
        {
          if ( a1 )
            (*(*a1 + 8))(a1);
          return v10;
        }
        if ( !v11 )
          break;
        *(v5 + 4 * (*v6)++) = v12;
        if ( *v6 >= 0x64u )
        {
          (*(*v12 + 8))(v12);
          break;
        }
        v9 = a1;
        if ( !a1 )
          goto LABEL_11;
      }
      if ( !a1 )
        goto LABEL_11;
      (*(*a1 + 8))(a1);
      result = 0;
    }
    else
    {
LABEL_11:
      result = 0;
    }
  }
  return result;
}

//----- (012838A0) --------------------------------------------------------
int __cdecl sub_12838A0(wchar_t *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // edi
  int v6; // esi
  VARIANTARG pvarg; // [esp+4h] [ebp-18h]
  unsigned int v9; // [esp+14h] [ebp-8h]
  int Value; // [esp+18h] [ebp-4h]

  if ( !a1 || !a2 || !a4 || !a5 )
    return -2147024809;
  VariantInit(&pvarg);
  v5 = 0;
  if ( !a3 )
    return 0;
  do
  {
    v6 = *(a2 + 4 * v5);
    *(a2 + 4 * v5) = 0;
    if ( (*(*v6 + 16))(v6, L"hostprocessidentifier", 0, &pvarg, 0, 0)
      || pvarg.vt != 3
      || !pvarg.lVal
      || (Value = 0, _set_errno(0), v9 = wcstoul(a1, 0, 10), _get_errno(&Value), v9 == -1)
      || Value
      || pvarg.lVal != v9 )
    {
      (*(*v6 + 8))(v6);
    }
    else
    {
      *(a4 + 4 * (*a5)++) = v6;
      if ( *a5 >= 0x64u )
      {
        (*(*v6 + 8))(v6);
        return 0;
      }
    }
    ++v5;
  }
  while ( v5 < a3 );
  return 0;
}
// 12C7564: using guessed type wchar_t aHostprocesside[22];

//----- (012839A0) --------------------------------------------------------
signed int __cdecl sub_12839A0(int *a1)
{
  int v2; // edi
  void **v3; // esi

  if ( !a1 )
    return 0x80070057;
  v2 = *a1;
  while ( v2 )
  {
    v3 = v2;
    v2 = *(v2 + 12);
    free(*v3);
    free(v3[1]);
    free(v3[2]);
    free(v3);
  }
  *a1 = 0;
  return 0;
}

//----- (01283A00) --------------------------------------------------------
int __cdecl sub_1283A00(int ArgList, int a2)
{
  signed int v2; // ebx
  _DWORD *v3; // esi
  HRESULT v4; // eax
  int v5; // eax
  HRESULT v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // edi
  int v10; // esi
  int v11; // ebx
  __m128i *v12; // eax
  __int64 v14; // [esp+8h] [ebp-2A0h]
  int v15; // [esp+10h] [ebp-298h]
  _DWORD *v16; // [esp+14h] [ebp-294h]
  int v17; // [esp+18h] [ebp-290h]
  LPVOID ppv; // [esp+1Ch] [ebp-28Ch]
  IUnknown *pProxy; // [esp+20h] [ebp-288h]
  wchar_t Dst; // [esp+24h] [ebp-284h]
  char v21; // [esp+9Ch] [ebp-20Ch]
  wchar_t Src; // [esp+224h] [ebp-84h]

  sub_1259DC0(&Src, L"%d", ArgList);
  if ( !a2 )
    return -2147024809;
  ppv = 0;
  v2 = 0;
  pProxy = 0;
  v3 = 0;
  v4 = CoCreateInstance(&stru_12C7A7C, 0, 1u, &stru_12C79AC, &ppv);
  if ( v4 < 0 )
  {
    v2 = v4;
    goto LABEL_24;
  }
  v5 = (*(*ppv + 12))(ppv, L"root/cimv2", 0, 0, 0, 0, 0, 0, &pProxy);
  if ( v5 < 0 )
  {
    v2 = v5;
    goto LABEL_24;
  }
  v6 = CoSetProxyBlanket(pProxy, 0xAu, 0, 0, 3u, 3u, 0, 0);
  if ( v6 < 0 )
  {
    v2 = v6;
    goto LABEL_24;
  }
  qmemcpy(&Dst, L"select * from msft_providers where HostProcessIdentifier = ", 0x78u);
  memset(&v21, 0, 0x186u);
  if ( wcscat_s(&Dst, 0xFFu, &Src) )
  {
    v2 = -2147418113;
    v3 = 0;
    goto LABEL_24;
  }
  v7 = malloc(0x190u);
  v3 = v7;
  v16 = v7;
  if ( !v7 )
  {
    v2 = -2147024882;
    goto LABEL_24;
  }
  v17 = 0;
  if ( sub_12837B0(pProxy, &Dst, v7, &v17) )
  {
    v8 = sub_1283720(pProxy, L"select * from msft_providers", &Src, v3, &v17);
    if ( v8 )
    {
      v2 = v8;
      goto LABEL_24;
    }
  }
  v9 = 0;
  if ( v17 > 0 )
  {
    while ( 1 )
    {
      v10 = v3[v9];
      v14 = 0i64;
      v15 = 0;
      if ( !sub_1283CB0(v10, ppv, &v14) )
      {
        v11 = v15;
        if ( v15 )
        {
          if ( v14 && HIDWORD(v14) )
          {
            v12 = malloc(0x10u);
            if ( !v12 )
            {
              (*(*v10 + 8))(v10);
              v3 = v16;
              v2 = -2147024882;
              break;
            }
            _mm_storel_epi64(v12, _mm_loadl_epi64(&v14));
            v12->m128i_i32[2] = v11;
            v12->m128i_i32[3] = *a2;
            *a2 = v12;
          }
        }
      }
      (*(*v10 + 8))(v10);
      v3 = v16;
      if ( ++v9 >= v17 )
      {
        v2 = 0;
        break;
      }
    }
  }
LABEL_24:
  if ( pProxy )
    pProxy->lpVtbl->Release(pProxy);
  if ( ppv )
    (*(*ppv + 8))(ppv);
  if ( v3 )
    free(v3);
  return v2;
}
// 12C7494: using guessed type wchar_t aRootCimv2[11];
// 12C74B0: using guessed type wchar_t aSelectFromMsft[60];
// 12C7528: using guessed type wchar_t aSelectFromMsft_0[29];

//----- (01283CB0) --------------------------------------------------------
signed int __cdecl sub_1283CB0(int a1, int a2, void **a3)
{
  void **v3; // edi
  signed int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  const wchar_t *v11; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // eax
  wchar_t *v14; // eax
  VARIANTARG v16; // [esp+8h] [ebp-654h]
  VARIANTARG pvarg; // [esp+18h] [ebp-644h]
  VARIANTARG v18; // [esp+28h] [ebp-634h]
  DWORD cbData; // [esp+38h] [ebp-624h]
  int v20; // [esp+3Ch] [ebp-620h]
  int v21; // [esp+40h] [ebp-61Ch]
  HKEY phkResult; // [esp+44h] [ebp-618h]
  int v23; // [esp+48h] [ebp-614h]
  int v24; // [esp+4Ch] [ebp-610h]
  int v25; // [esp+50h] [ebp-60Ch]
  void **v26; // [esp+54h] [ebp-608h]
  wchar_t Data[256]; // [esp+58h] [ebp-604h]
  wchar_t Dst; // [esp+258h] [ebp-404h]
  char v29; // [esp+2B2h] [ebp-3AAh]
  WCHAR SubKey[8]; // [esp+458h] [ebp-204h]
  __int128 v31; // [esp+468h] [ebp-1F4h]
  __int128 v32; // [esp+478h] [ebp-1E4h]
  char v33; // [esp+488h] [ebp-1D4h]

  v20 = a2;
  v3 = a3;
  v26 = a3;
  if ( !a1 || !a2 || !a3 )
    return -2147024809;
  v23 = 0;
  v24 = 0;
  v4 = 0;
  v21 = 0;
  v25 = 0;
  VariantInit(&pvarg);
  VariantInit(&v18);
  v5 = (*(*a1 + 16))(a1, L"namespace", 0, &pvarg, 0, 0);
  if ( !v5 )
  {
    v6 = (*(*a1 + 16))(a1, L"provider", 0, &v18, 0, 0);
    if ( v6 )
    {
      v4 = v6;
      goto LABEL_38;
    }
    if ( v18.vt != 8 || pvarg.vt != 8 || !v18.lVal || !pvarg.lVal )
    {
      v4 = -2147418113;
      goto LABEL_38;
    }
    v7 = (*(*v20 + 12))(v20, pvarg.lVal, 0, 0, 0, 0, 0, 0, &v25);
    if ( v7 < 0 )
    {
      v4 = v7;
      goto LABEL_38;
    }
    qmemcpy(&Dst, L"select * from __win32provider where Name = '", 0x5Au);
    memset(&v29, 0, 0x1A4u);
    if ( !wcscat_s(&Dst, 0xFFu, v18.bstrVal) && !wcscat_s(&Dst, 0xFFu, L"'") )
    {
      v8 = (*(*v25 + 80))(v25, L"WQL", &Dst, 48, 0, &v23);
      if ( v8 )
      {
        v4 = v8;
LABEL_37:
        v3 = v26;
        goto LABEL_38;
      }
      v9 = (*(*v23 + 16))(v23, -1, 1, &v24, &v21);
      if ( v9 )
      {
        v4 = v9;
        goto LABEL_37;
      }
      VariantInit(&v16);
      v10 = (*(*v24 + 16))(v24, L"clsid", 0, &v16, 0, 0);
      if ( v10 )
      {
        v4 = v10;
        goto LABEL_37;
      }
      if ( v16.vt != 8 )
        goto LABEL_37;
      v11 = v16.bstrVal;
      if ( !v16.lVal )
        goto LABEL_37;
      _mm_storeu_si128(SubKey, _mm_loadu_si128(&xmmword_12C7624));
      _mm_storeu_si128(&v31, _mm_loadu_si128(&xmmword_12C7634));
      _mm_storeu_si128(&v32, _mm_loadu_si128(&xmmword_12C7644));
      memset(&v33, 0, 0x1CEu);
      if ( !wcscat_s(SubKey, 0xFFu, v11)
        && !wcscat_s(SubKey, 0xFFu, L"\\InprocServer32")
        && !RegOpenKeyExW(HKEY_LOCAL_MACHINE, SubKey, 0, 0x20119u, &phkResult) )
      {
        memset(Data, 0, 0x1FEu);
        cbData = 510;
        if ( !RegQueryValueExW(phkResult, gpszTargetName, 0, 0, Data, &cbData) )
        {
          v12 = sub_12836C0(v18.bstrVal);
          v3 = v26;
          *v26 = v12;
          if ( v12 )
          {
            v13 = sub_12836C0(pvarg.bstrVal);
            v3[1] = v13;
            if ( v13 )
            {
              v14 = sub_12836C0(Data);
              v3[2] = v14;
              if ( v14 )
                RegCloseKey(phkResult);
              else
                v4 = -2147024882;
            }
            else
            {
              v4 = -2147024882;
            }
          }
          else
          {
            v4 = -2147024882;
          }
          goto LABEL_38;
        }
      }
    }
    v4 = -2147418113;
    goto LABEL_37;
  }
  v4 = v5;
LABEL_38:
  if ( v24 )
    (*(*v24 + 8))(v24);
  if ( v23 )
    (*(*v23 + 8))(v23);
  if ( v25 )
    (*(*v25 + 8))(v25);
  VariantClear(&pvarg);
  VariantClear(&v18);
  if ( v4 )
  {
    if ( *v3 )
      free(*v3);
    if ( v3[1] )
      free(v3[1]);
    if ( v3[2] )
      free(v3[2]);
  }
  return v4;
}
// 12C7590: using guessed type wchar_t aNamespace_0[10];
// 12C75A4: using guessed type wchar_t aProvider[9];
// 12C75B8: using guessed type wchar_t aSelectFromWin3[45];
// 12C7618: using guessed type wchar_t aClsid_0[6];
// 12C7624: using guessed type __int128 xmmword_12C7624;
// 12C7634: using guessed type __int128 xmmword_12C7634;
// 12C7644: using guessed type __int128 xmmword_12C7644;

//----- (01284170) --------------------------------------------------------
void __stdcall __noreturn com_error::throw(int a1)
{
  off_12E138C(a1, 0);
}
// 12E138C: using guessed type int (__cdecl *off_12E138C)(_DWORD, _DWORD);

//----- (01284190) --------------------------------------------------------
_DWORD *__thiscall sub_1284190(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // ecx

  v2 = this;
  *this = &std::_com_error::`vftable';
  this[1] = *(a2 + 4);
  v3 = *(a2 + 8);
  v2[2] = v3;
  v2[3] = 0;
  if ( v3 )
    (*(*v3 + 4))(v3);
  return v2;
}
// 12C7BCC: using guessed type int (__thiscall *std::_com_error::`vftable')(void *, char);

//----- (012841D0) --------------------------------------------------------
HLOCAL __thiscall sub_12841D0(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  HLOCAL result; // eax

  v1 = this;
  v2 = this[2];
  *v1 = &std::_com_error::`vftable';
  if ( v2 )
    (*(*v2 + 8))(v2);
  result = v1[3];
  if ( result )
    result = LocalFree(v1[3]);
  return result;
}
// 12C7BCC: using guessed type int (__thiscall *std::_com_error::`vftable')(void *, char);

//----- (01284200) --------------------------------------------------------
HLOCAL *__thiscall sub_1284200(void *this, char a2)
{
  HLOCAL *v2; // esi
  int v3; // ecx

  v2 = this;
  v3 = *(this + 2);
  *v2 = &std::_com_error::`vftable';
  if ( v3 )
    (*(*v3 + 8))(v3);
  if ( v2[3] )
    LocalFree(v2[3]);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12C7BCC: using guessed type int (__thiscall *std::_com_error::`vftable')(void *, char);

//----- (01284240) --------------------------------------------------------
void __cdecl __noreturn sub_1284240(int a1, int a2)
{
  int (__thiscall **v2)(void *, char); // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v3 = a1;
  v4 = a2;
  v2 = &std::_com_error::`vftable';
  v5 = 0;
  _CxxThrowException(&v2, &_TI1_AV_com_error__);
}
// 12881AA: using guessed type void __stdcall __noreturn _CxxThrowException(_DWORD, _DWORD);
// 12C7BCC: using guessed type int (__thiscall *std::_com_error::`vftable')(void *, char);
// 12D5BFC: using guessed type int _TI1_AV_com_error__;

//----- (01284270) --------------------------------------------------------
CHAR *__stdcall UTFToAscii(LPCWSTR lpWideCharStr)
{
  unsigned int v2; // kr00_4
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  CHAR *v6; // eax
  CHAR *v7; // esi
  int v8; // eax
  int v9; // [esp+0h] [ebp-20h]
  int *v10; // [esp+10h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-4h]

  v10 = &v9;
  if ( !lpWideCharStr )
    return 0;
  v2 = wcslen(lpWideCharStr);
  v3 = WideCharToMultiByte(0, 0, lpWideCharStr, v2 + 1, 0, 0, 0, 0);
  v4 = v3;
  if ( !v3 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      v5 = v5 | 0x80070000;
    com_error::throw(v5);
  }
  v11 = 0;
  v6 = operator new(v3);
  v7 = v6;
  v11 = -1;
  if ( !v6 )
    com_error::throw(-2147024882);
  if ( !WideCharToMultiByte(0, 0, lpWideCharStr, v2 + 1, v6, v4, 0, 0) )
  {
    j__free(v7);
    v8 = GetLastError();
    if ( v8 > 0 )
      v8 = v8 | 0x80070000;
    com_error::throw(v8);
  }
  return v7;
}

//----- (01284390) --------------------------------------------------------
BSTR __stdcall AsciiToUTF(LPCSTR lpString)
{
  int v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  void *v7; // esp
  int *v8; // esi
  int v9; // eax
  BSTR v10; // ebx
  int v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+10h] [ebp-28h]
  int *v13; // [esp+14h] [ebp-24h]
  int cbMultiByte; // [esp+18h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !lpString )
    return 0;
  v2 = lstrlenA(lpString);
  cbMultiByte = v2 + 1;
  v3 = MultiByteToWideChar(0, 0, lpString, v2 + 1, 0, 0);
  v4 = v3;
  v12 = v3;
  if ( !v3 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      v5 = v5 | 0x80070000;
    com_error::throw(v5);
  }
  ms_exc.registration.TryLevel = 0;
  v6 = 2 * v3;
  if ( v4 >= 4096 )
  {
    v8 = malloc(2 * v4);
    v13 = v8;
  }
  else
  {
    v7 = alloca(v6);
    ms_exc.old_esp = &v11;
    v8 = &v11;
    v13 = &v11;
  }
  ms_exc.registration.TryLevel = -2;
  if ( !v8 )
    com_error::throw(E_OUTOFMEMORY);
  if ( !MultiByteToWideChar(0, 0, lpString, cbMultiByte, v8, v4) )
  {
    if ( v4 >= 4096 )
      free(v8);
    v9 = GetLastError();
    if ( v9 > 0 )
      v9 = v9 | 0x80070000;
    com_error::throw(v9);
  }
  v10 = SysAllocString(v8);
  if ( v4 >= 4096 )
    free(v8);
  if ( !v10 )
    com_error::throw(E_OUTOFMEMORY);
  return v10;
}

//----- (01284501) --------------------------------------------------------
std::exception *__thiscall sub_1284501(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::bad_alloc::`vftable';
  return v2;
}
// 12C7BD4: using guessed type void *std::bad_alloc::`vftable';

//----- (0128451C) --------------------------------------------------------
std::exception *__thiscall sub_128451C(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::length_error::`vftable';
  return v2;
}
// 12C7BFC: using guessed type void *std::length_error::`vftable';

//----- (01284537) --------------------------------------------------------
std::exception *__thiscall sub_1284537(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::logic_error::`vftable';
  return v2;
}
// 12C7BF0: using guessed type void *std::logic_error::`vftable';

//----- (01284552) --------------------------------------------------------
std::exception *__thiscall sub_1284552(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::out_of_range::`vftable';
  return v2;
}
// 12C7C08: using guessed type void *std::out_of_range::`vftable';

//----- (0128456D) --------------------------------------------------------
void __thiscall sub_128456D(std::exception *this)
{
  *this = &std::bad_alloc::`vftable';
  sub_1289D91(this);
}
// 12C7BD4: using guessed type void *std::bad_alloc::`vftable';

//----- (01284585) --------------------------------------------------------
void *__thiscall sub_1284585(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::bad_alloc::`vftable';
  sub_1289D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12C7BD4: using guessed type void *std::bad_alloc::`vftable';

//----- (012845AA) --------------------------------------------------------
void *__thiscall sub_12845AA(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_1289D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0128465F) --------------------------------------------------------
int __cdecl sub_128465F(int a1)
{
  _DWORD *v1; // eax

  v1 = &unk_12C7E68;
  if ( !"address family not supported" )
    return 0;
  while ( *v1 != a1 )
  {
    v1 += 2;
    if ( !v1[1] )
      return 0;
  }
  return v1[1];
}

//----- (01284689) --------------------------------------------------------
int __cdecl sub_1284689(int a1)
{
  _DWORD *v1; // eax

  v1 = &unk_12C7C10;
  if ( !"permission denied" )
    return 0;
  while ( *v1 != a1 )
  {
    v1 += 2;
    if ( !v1[1] )
      return 0;
  }
  return v1[1];
}

//----- (01284C4A) --------------------------------------------------------
int sub_1284C4A()
{
  return *&dword_1305844;
}

//----- (01284F3E) --------------------------------------------------------
void __cdecl sub_1284F3E(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (01284F4C) --------------------------------------------------------
void __cdecl sub_1284F4C(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (01284FDB) --------------------------------------------------------
_DWORD *__thiscall ATL::CAtlBaseModule::CAtlBaseModule(_DWORD *this)
{
  _DWORD *v1; // esi

  v1 = this;
  ATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(this);
  *v1 = 56;
  v1[2] = 18808832;
  v1[1] = 18808832;
  v1[3] = _ATL_VER10;
  v1[4] = &GUID_ATLVer110;
  if ( ATL::CComCriticalSection::Init((v1 + 5)) < 0 )
  {
    if ( IsDebuggerPresent() )
      OutputDebugStringW(L"ERROR : Unable to initialize critical section in CAtlBaseModule\n");
    ATL::CAtlBaseModule::m_bInitFailed = 1;
  }
  return v1;
}
// 12C8AF0: using guessed type GUID GUID_ATLVer110;
// 1305714: using guessed type char ATL::CAtlBaseModule::m_bInitFailed;

//----- (0128502E) --------------------------------------------------------
_DWORD *__thiscall ATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *result; // eax

  v1 = this;
  memset(this + 5, 0, 0x18u);
  v1[11] = 0;
  v1[12] = 0;
  result = v1;
  v1[13] = 0;
  return result;
}

//----- (01285051) --------------------------------------------------------
void __thiscall ATL::CAtlBaseModule::~CAtlBaseModule(ATL::CAtlBaseModule *this)
{
  ATL::CAtlBaseModule *v1; // esi

  v1 = this;
  DeleteCriticalSection((this + 20));
  ATL::_ATL_BASE_MODULE70::~_ATL_BASE_MODULE70(v1 + 11);
}

//----- (01285067) --------------------------------------------------------
char *__thiscall sub_1285067(CSimpleArray *this, int a2)
{
  if ( a2 < 0 || a2 >= this->m_nSize )
  {
    RaiseException(0xC000008C, 1u, 0, 0);
    JUMPOUT(loc_1285090);
  }
  return this->m_aT + 4 * a2;
}

//----- (01285091) --------------------------------------------------------
HINSTANCE __thiscall CAtlBaseModule::GetHInstanceAt(_ATL_BASE_MODULE70 *this, int a2)
{
  _ATL_BASE_MODULE70 *v2; // esi
  struct _RTL_CRITICAL_SECTION *v3; // edi
  HINSTANCE v4; // esi

  v2 = this;
  v3 = &this->m_csResource.m_sec;
  EnterCriticalSection(&this->m_csResource.m_sec);
  if ( a2 > v2->m_rgResourceInstance.m_nSize || a2 < 0 )
  {
    v4 = 0;
  }
  else if ( a2 == v2->m_rgResourceInstance.m_nSize )
  {
    v4 = v2->m_hInstResource;
  }
  else
  {
    v4 = *sub_1285067(&v2->m_rgResourceInstance, a2);
  }
  LeaveCriticalSection(v3);
  return v4;
}

//----- (012850D6) --------------------------------------------------------
void __thiscall ATL::_ATL_BASE_MODULE70::~_ATL_BASE_MODULE70(void **this)
{
  void **v1; // esi

  v1 = this;
  if ( *this )
  {
    free(*this);
    *v1 = 0;
  }
  v1[1] = 0;
  v1[2] = 0;
}

//----- (01287B15) --------------------------------------------------------
void **sub_1287B15()
{
  return &off_12E1568;
}
// 12E1568: using guessed type void *off_12E1568;

//----- (012889CE) --------------------------------------------------------
int __thiscall sub_12889CE(_DWORD *this)
{
  *this = &type_info::`vftable';
  return unknown_libname_8(this);
}
// 1295348: using guessed type _DWORD __cdecl unknown_libname_8(_DWORD);
// 12C8BE8: using guessed type void *type_info::`vftable';

//----- (012889FA) --------------------------------------------------------
void *__thiscall sub_12889FA(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  sub_12889CE(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}

//----- (0128918B) --------------------------------------------------------
int sub_128918B()
{
  return flsall(1);
}
// 12891ED: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (01289CF7) --------------------------------------------------------
std::exception *__thiscall sub_1289CF7(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::bad_cast::`vftable';
  return v2;
}
// 12C8FEC: using guessed type void *std::bad_cast::`vftable';

//----- (01289D12) --------------------------------------------------------
std::exception *__thiscall sub_1289D12(std::exception *this, char *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, &a2);
  *v2 = &std::bad_cast::`vftable';
  return v2;
}
// 12C8FEC: using guessed type void *std::bad_cast::`vftable';

//----- (01289D91) --------------------------------------------------------
void __thiscall sub_1289D91(std::exception *this)
{
  *this = &std::exception::`vftable';
  std::exception::_Tidy(this);
}
// 12C8FCC: using guessed type void *std::exception::`vftable';

//----- (01289DCF) --------------------------------------------------------
void *__thiscall sub_1289DCF(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::exception::`vftable';
  std::exception::_Tidy(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12C8FCC: using guessed type void *std::exception::`vftable';

//----- (0128B822) --------------------------------------------------------
std::exception *__thiscall sub_128B822(std::exception *this, struct exception *a2)
{
  std::exception *v2; // esi

  v2 = this;
  std::exception::exception(this, a2);
  *v2 = &std::bad_exception::`vftable';
  return v2;
}
// 12C8FFC: using guessed type void *std::bad_exception::`vftable';

//----- (0128B83D) --------------------------------------------------------
void __thiscall sub_128B83D(std::exception *this)
{
  *this = &std::bad_exception::`vftable';
  sub_1289D91(this);
}
// 12C8FFC: using guessed type void *std::bad_exception::`vftable';

//----- (0128B848) --------------------------------------------------------
void *__thiscall sub_128B848(void *this, char a2)
{
  void *v2; // esi

  v2 = this;
  *this = &std::bad_exception::`vftable';
  sub_1289D91(this);
  if ( a2 & 1 )
    j__free(v2);
  return v2;
}
// 12C8FFC: using guessed type void *std::bad_exception::`vftable';

//----- (0128D342) --------------------------------------------------------
void __cdecl sub_128D342(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (0128F821) --------------------------------------------------------
void *__cdecl sub_128F821(void *a1)
{
  void *result; // eax

  result = a1;
  dword_1305EBC = a1;
  return result;
}

//----- (0128F8CF) --------------------------------------------------------
void *__cdecl sub_128F8CF(void *a1)
{
  void *result; // eax

  result = a1;
  dword_1305EC4 = a1;
  return result;
}

//----- (0128FAF6) --------------------------------------------------------
DWORD sub_128FAF6()
{
  return dwTlsIndex;
}

//----- (0129007A) --------------------------------------------------------
void sub_129007A()
{
  dword_13069AC = 0;
}
// 13069AC: using guessed type int dword_13069AC;

//----- (0129533B) --------------------------------------------------------
void *__cdecl sub_129533B(void *a1)
{
  void *result; // eax

  result = a1;
  dword_1306628 = a1;
  return result;
}

//----- (01297C9C) --------------------------------------------------------
void sub_1297C9C()
{
  void (**i)(void); // esi

  for ( i = &unk_12CF88C; i < &unk_12CF88C; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (01297CBC) --------------------------------------------------------
void __cdecl sub_1297CBC()
{
  void (**i)(void); // esi

  for ( i = &unk_12CF894; i < &unk_12CF894; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (01297CDC) --------------------------------------------------------
PVOID sub_1297CDC()
{
  return DecodePointer(dword_130663C);
}

//----- (01297EFA) --------------------------------------------------------
int __cdecl sub_1297EFA(int a1)
{
  int result; // eax

  result = a1;
  dword_1306648 = a1;
  return result;
}
// 1306648: using guessed type int dword_1306648;

//----- (01298B73) --------------------------------------------------------
HANDLE sub_1298B73()
{
  HANDLE result; // eax

  result = hObject;
  if ( hObject != -1 && hObject != -2 )
    result = CloseHandle(hObject);
  return result;
}

//----- (01299F90) --------------------------------------------------------
int sub_1299F90()
{
  __crtSetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (0129A2BD) --------------------------------------------------------
int __cdecl sub_129A2BD(int a1)
{
  int result; // eax

  result = a1;
  dword_1305EC8 = a1;
  return result;
}
// 1305EC8: using guessed type int dword_1305EC8;

//----- (0129B1A0) --------------------------------------------------------
int *sub_129B1A0()
{
  return &dword_12E2434;
}
// 12E2434: using guessed type int dword_12E2434;

//----- (0129B1A6) --------------------------------------------------------
int *sub_129B1A6()
{
  return &dword_12E2438;
}
// 12E2438: using guessed type int dword_12E2438;

//----- (0129B1AC) --------------------------------------------------------
int *sub_129B1AC()
{
  return &dword_12E2430;
}
// 12E2430: using guessed type int dword_12E2430;

//----- (0129B1B2) --------------------------------------------------------
void **sub_129B1B2()
{
  return &off_12E24C0;
}
// 12E24C0: using guessed type void *off_12E24C0;

//----- (0129B1B8) --------------------------------------------------------
signed int __cdecl sub_129B1B8(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_12E2434;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 128F859: using guessed type int _invalid_parameter_noinfo(void);
// 12E2434: using guessed type int dword_12E2434;

//----- (0129B1E2) --------------------------------------------------------
signed int __cdecl sub_129B1E2(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_12E2438;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 128F859: using guessed type int _invalid_parameter_noinfo(void);
// 12E2438: using guessed type int dword_12E2438;

//----- (0129B20C) --------------------------------------------------------
signed int __cdecl sub_129B20C(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_12E2430;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 128F859: using guessed type int _invalid_parameter_noinfo(void);
// 12E2430: using guessed type int dword_12E2430;

//----- (0129B5FC) --------------------------------------------------------
int __cdecl sub_129B5FC(const WCHAR *a1, int a2, int a3)
{
  int v3; // esi
  PVOID v4; // edi
  HMODULE v5; // edi
  FARPROC v6; // eax
  FARPROC v7; // eax
  FARPROC v8; // eax
  FARPROC v9; // eax
  FARPROC v10; // eax
  PVOID v12; // eax
  int v13; // eax
  int v14; // edi
  int (*v15)(void); // eax
  int (__stdcall *v16)(int); // eax
  int (__stdcall *v17)(int, LPCWSTR, int, int); // eax
  char v19; // [esp+Ch] [ebp-24h]
  int v20; // [esp+10h] [ebp-20h]
  LPCWSTR lpOutputString; // [esp+14h] [ebp-1Ch]
  int (__stdcall *v22)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // [esp+18h] [ebp-18h]
  int (*v23)(void); // [esp+1Ch] [ebp-14h]
  char v24; // [esp+20h] [ebp-10h]
  char v25; // [esp+28h] [ebp-8h]

  lpOutputString = a1;
  v3 = 0;
  v20 = a2;
  v4 = EncodePointer(0);
  v22 = v4;
  v23 = __crtIsPackagedApp();
  if ( !dword_130694C )
  {
    v5 = LoadLibraryExW(L"USER32.DLL", 0, 0x800u);
    if ( !v5 )
    {
      if ( GetLastError() != 87 )
        return 0;
      v5 = LoadLibraryExW(L"USER32.DLL", 0, 0);
      if ( !v5 )
        return 0;
    }
    v6 = GetProcAddress(v5, "MessageBoxW");
    if ( !v6 )
      return 0;
    dword_130694C = EncodePointer(v6);
    v7 = GetProcAddress(v5, "GetActiveWindow");
    dword_1306950 = EncodePointer(v7);
    v8 = GetProcAddress(v5, "GetLastActivePopup");
    dword_1306954 = EncodePointer(v8);
    v9 = GetProcAddress(v5, "GetUserObjectInformationW");
    dword_130695C = EncodePointer(v9);
    if ( dword_130695C )
    {
      v10 = GetProcAddress(v5, "GetProcessWindowStation");
      dword_1306958 = EncodePointer(v10);
    }
    v4 = v22;
  }
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringW(lpOutputString);
    if ( v23 )
      return 4;
  }
  else if ( v23 )
  {
    DecodePointer(dword_130694C);
    return 3;
  }
  if ( dword_1306958 == v4
    || dword_130695C == v4
    || (v23 = DecodePointer(dword_1306958), v12 = DecodePointer(dword_130695C), v22 = v12, !v23)
    || !v12
    || (v13 = v23()) != 0 && v22(v13, 1, &v24, 12, &v19) && v25 & 1 )
  {
    if ( dword_1306950 != v4 )
    {
      v15 = DecodePointer(dword_1306950);
      if ( v15 )
      {
        v3 = v15();
        if ( v3 )
        {
          if ( dword_1306954 != v4 )
          {
            v16 = DecodePointer(dword_1306954);
            if ( v16 )
              v3 = v16(v3);
          }
        }
      }
    }
    v14 = a3;
  }
  else
  {
    v14 = a3 | 0x200000;
  }
  v17 = DecodePointer(dword_130694C);
  if ( v17 )
    return v17(v3, lpOutputString, v20, v14);
  return 0;
}
// 128D069: using guessed type int __crtIsPackagedApp(void);

//----- (0129F550) --------------------------------------------------------
int OnTreeListNotify7D1()
{
  return 0;
}

//----- (0129FE30) --------------------------------------------------------
signed int __cdecl sub_129FE30(unsigned __int16 *a1, int *a2)
{
  signed int v2; // ebx
  int *v3; // edi
  int v4; // edx
  int v5; // esi
  int v6; // eax
  int v7; // edx
  char v8; // cl
  bool i; // zf
  int v10; // edx
  unsigned int v11; // eax
  bool v12; // cf
  unsigned int v13; // eax
  signed int v14; // ecx
  int j; // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // ecx
  int v19; // eax
  unsigned int v20; // edx
  int *v21; // edx
  int v22; // eax
  signed int v23; // ecx
  int v24; // edx
  int v25; // ecx
  char v26; // cl
  bool k; // zf
  int v28; // edx
  unsigned int v29; // eax
  signed int v30; // ecx
  unsigned int v31; // eax
  int l; // edx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  unsigned int v38; // edx
  int *v39; // edx
  signed int v40; // ecx
  int v41; // ecx
  int v42; // edi
  unsigned int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int *v46; // edx
  signed int v47; // ecx
  int v48; // ecx
  signed int v49; // esi
  unsigned int v50; // edx
  int *v51; // edx
  signed int v52; // ecx
  int v53; // esi
  int v54; // eax
  int v56; // [esp+Ch] [ebp-44h]
  int v57; // [esp+14h] [ebp-3Ch]
  int v58; // [esp+14h] [ebp-3Ch]
  unsigned int v59; // [esp+18h] [ebp-38h]
  int v60; // [esp+18h] [ebp-38h]
  int v61; // [esp+18h] [ebp-38h]
  int v62; // [esp+1Ch] [ebp-34h]
  int v63; // [esp+1Ch] [ebp-34h]
  int v64; // [esp+1Ch] [ebp-34h]
  int v65; // [esp+20h] [ebp-30h]
  char v66; // [esp+20h] [ebp-30h]
  signed int v67; // [esp+24h] [ebp-2Ch]
  int v68; // [esp+28h] [ebp-28h]
  char v69; // [esp+28h] [ebp-28h]
  int v70; // [esp+28h] [ebp-28h]
  int v71; // [esp+2Ch] [ebp-24h]
  unsigned int v72; // [esp+2Ch] [ebp-24h]
  int v73; // [esp+30h] [ebp-20h]
  int v74; // [esp+30h] [ebp-20h]
  int v75; // [esp+30h] [ebp-20h]
  int v76; // [esp+30h] [ebp-20h]
  int v77; // [esp+30h] [ebp-20h]
  int v78; // [esp+34h] [ebp-1Ch]
  int v79; // [esp+38h] [ebp-18h]
  int v80; // [esp+3Ch] [ebp-14h]
  int v81; // [esp+40h] [ebp-10h]
  int v82; // [esp+44h] [ebp-Ch]
  int v83; // [esp+48h] [ebp-8h]

  v2 = 0;
  v3 = a2;
  v56 = a1[5] & 0x8000;
  v4 = (a1[5] & 0x7FFF) - 0x3FFF;
  v81 = *(a1 + 3);
  v82 = *(a1 + 1);
  v73 = v4;
  v83 = *a1 << 16;
  if ( v4 == -16383 )
  {
    v5 = 0;
    v6 = 0;
    while ( !*(&v81 + v6) )
    {
      if ( ++v6 >= 3 )
        goto LABEL_84;
    }
    v81 = 0;
    v82 = 0;
    v83 = 0;
  }
  else
  {
    v71 = v4;
    v78 = v81;
    v62 = dword_12E2570 - 1;
    v67 = 0;
    v79 = v82;
    v80 = v83;
    v7 = dword_12E2570 / 32;
    v57 = dword_12E2570 / 32;
    v65 = 31 - dword_12E2570 % 32;
    v8 = v65;
    if ( (1 << v65) & *(&v81 + dword_12E2570 / 32) )
    {
      for ( i = (~(-1 << v65) & *(&v81 + v7)) == 0; i; i = *(&v81 + v7) == 0 )
      {
        if ( ++v7 >= 3 )
          goto LABEL_24;
      }
      v10 = v62 / 32;
      v67 = 0;
      v59 = 1 << (31 - v62 % 32);
      v11 = *(&v81 + v62 / 32);
      v12 = v11 + v59 < v11;
      v13 = v11 + v59;
      v14 = 0;
      if ( v12 || v13 < v59 )
      {
        v14 = 1;
        v67 = 1;
      }
      *(&v81 + v10) = v13;
      for ( j = v10 - 1; j >= 0; *(&v81 + j--) = v17 )
      {
        if ( !v14 )
          break;
        v16 = *(&v81 + j);
        v14 = 0;
        v67 = 0;
        v12 = v16 + 1 < v16;
        v17 = v16 + 1;
        if ( v12 || v17 < 1 )
        {
          v14 = 1;
          v67 = 1;
        }
      }
      v8 = v65;
LABEL_24:
      v7 = v57;
    }
    *(&v81 + v7) &= -1 << v8;
    if ( v7 + 1 < 3 )
      memset(&v81 + v7 + 1, 0, 4 * (3 - (v7 + 1)));
    v18 = v73;
    if ( v67 )
      v18 = v73 + 1;
    if ( v18 >= dword_12E256C - dword_12E2570 )
    {
      if ( v18 > dword_12E256C )
      {
        if ( v18 < dword_12E2568 )
        {
          v81 &= 0x7FFFFFFFu;
          v61 = v18 + dword_12E257C;
          v70 = dword_12E2574 / 32;
          v48 = dword_12E2574 % 32;
          v77 = 0;
          v49 = 0;
          do
          {
            v50 = *(&v81 + v49);
            *(&v81 + v49++) = v77 | (v50 >> v48);
            v77 = (~(-1 << v48) & v50) << (32 - v48);
          }
          while ( v49 < 3 );
          v5 = v61;
          v51 = &v83 - v70;
          v2 = 0;
          v52 = 2;
          do
          {
            if ( v52 < v70 )
              *(&v81 + v52) = 0;
            else
              *(&v81 + v52) = *v51;
            --v51;
            --v52;
          }
          while ( v52 >= 0 );
        }
        else
        {
          v82 = 0;
          v83 = 0;
          v81 = 2147483648;
          v64 = dword_12E2574 / 32;
          v41 = dword_12E2574 % 32;
          v60 = dword_12E2574 % 32;
          v76 = 0;
          v42 = ~(-1 << dword_12E2574 % 32);
          v69 = 32 - dword_12E2574 % 32;
          do
          {
            v43 = *(&v81 + v2);
            v44 = v43;
            v45 = v76 | (v43 >> v41);
            LOBYTE(v41) = v60;
            *(&v81 + v2++) = v45;
            v76 = (v42 & v44) << v69;
          }
          while ( v2 < 3 );
          v46 = &v83 - v64;
          v47 = 2;
          do
          {
            if ( v47 < v64 )
              *(&v81 + v47) = 0;
            else
              *(&v81 + v47) = *v46;
            --v46;
            --v47;
          }
          while ( v47 >= 0 );
          v5 = dword_12E2568 + dword_12E257C;
          v2 = 1;
        }
        goto LABEL_83;
      }
      v81 = v78;
      v82 = v79;
      v58 = (dword_12E256C - v71) / 32;
      v83 = v80;
      v19 = (dword_12E256C - v71) % 32;
      v74 = 0;
      do
      {
        v20 = *(&v81 + v2);
        *(&v81 + v2++) = v74 | (v20 >> v19);
        v74 = (~(-1 << v19) & v20) << (32 - v19);
      }
      while ( v2 < 3 );
      v21 = &v83 - v58;
      v22 = v58;
      v23 = 2;
      do
      {
        if ( v23 < v22 )
        {
          *(&v81 + v23) = 0;
        }
        else
        {
          *(&v81 + v23) = *v21;
          v22 = v58;
        }
        --v21;
        --v23;
      }
      while ( v23 >= 0 );
      v24 = (v62 + 1) / 32;
      v25 = (v62 + 1) % 32;
      v66 = 31 - v25;
      v26 = 31 - v25;
      if ( (1 << v26) & *(&v81 + v24) )
      {
        for ( k = (~(-1 << v26) & *(&v81 + v24)) == 0; k; k = *(&v81 + v24) == 0 )
        {
          if ( ++v24 >= 3 )
            goto LABEL_56;
        }
        v28 = v62 / 32;
        v29 = *(&v81 + v62 / 32);
        v30 = 0;
        v72 = 1 << (31 - v62 % 32);
        v12 = v29 + v72 < v29;
        v31 = v29 + v72;
        if ( v12 || v31 < v72 )
          v30 = 1;
        *(&v81 + v28) = v31;
        for ( l = v28 - 1; l >= 0; *(&v81 + l--) = v34 )
        {
          if ( !v30 )
            break;
          v33 = *(&v81 + l);
          v30 = 0;
          v12 = v33 + 1 < v33;
          v34 = v33 + 1;
          if ( v12 || v34 < 1 )
            v30 = 1;
        }
        v26 = v66;
LABEL_56:
        v24 = (v62 + 1) / 32;
      }
      *(&v81 + v24) &= -1 << v26;
      v35 = v24 + 1;
      if ( v35 < 3 )
        memset(&v81 + v35, 0, 4 * (3 - v35));
      v68 = (dword_12E2574 + 1) / 32;
      v36 = (dword_12E2574 + 1) % 32;
      v37 = 0;
      v75 = 0;
      v63 = 0;
      do
      {
        v38 = *(&v81 + v37);
        *(&v81 + v63) = v75 | (v38 >> v36);
        v75 = (~(-1 << v36) & v38) << (32 - v36);
        v37 = v63 + 1;
        v63 = v37;
      }
      while ( v37 < 3 );
      v39 = &v83 - v68;
      v40 = 2;
      do
      {
        if ( v40 < v68 )
          *(&v81 + v40) = 0;
        else
          *(&v81 + v40) = *v39;
        --v39;
        --v40;
      }
      while ( v40 >= 0 );
    }
    else
    {
      v81 = 0;
      v82 = 0;
      v83 = 0;
    }
    v5 = 0;
  }
  v2 = 2;
LABEL_83:
  v3 = a2;
LABEL_84:
  v53 = v81 | (v56 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_12E2574));
  if ( dword_12E2578 == 64 )
  {
    v54 = v82;
    v3[1] = v53;
    *v3 = v54;
  }
  else if ( dword_12E2578 == 32 )
  {
    *v3 = v53;
  }
  return v2;
}
// 12E2568: using guessed type int dword_12E2568;
// 12E256C: using guessed type int dword_12E256C;
// 12E2570: using guessed type int dword_12E2570;
// 12E2574: using guessed type int dword_12E2574;
// 12E2578: using guessed type int dword_12E2578;
// 12E257C: using guessed type int dword_12E257C;

//----- (012A03A2) --------------------------------------------------------
signed int __cdecl sub_12A03A2(unsigned __int16 *a1, int *a2)
{
  signed int v2; // ebx
  int *v3; // edi
  int v4; // edx
  int v5; // esi
  int v6; // eax
  int v7; // edx
  char v8; // cl
  bool i; // zf
  int v10; // edx
  unsigned int v11; // eax
  bool v12; // cf
  unsigned int v13; // eax
  signed int v14; // ecx
  int j; // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // ecx
  int v19; // eax
  unsigned int v20; // edx
  int *v21; // edx
  int v22; // eax
  signed int v23; // ecx
  int v24; // edx
  int v25; // ecx
  char v26; // cl
  bool k; // zf
  int v28; // edx
  unsigned int v29; // eax
  signed int v30; // ecx
  unsigned int v31; // eax
  int l; // edx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  unsigned int v38; // edx
  int *v39; // edx
  signed int v40; // ecx
  int v41; // ecx
  int v42; // edi
  unsigned int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int *v46; // edx
  signed int v47; // ecx
  int v48; // ecx
  signed int v49; // esi
  unsigned int v50; // edx
  int *v51; // edx
  signed int v52; // ecx
  int v53; // esi
  int v54; // eax
  int v56; // [esp+Ch] [ebp-44h]
  int v57; // [esp+14h] [ebp-3Ch]
  int v58; // [esp+14h] [ebp-3Ch]
  unsigned int v59; // [esp+18h] [ebp-38h]
  int v60; // [esp+18h] [ebp-38h]
  int v61; // [esp+18h] [ebp-38h]
  int v62; // [esp+1Ch] [ebp-34h]
  int v63; // [esp+1Ch] [ebp-34h]
  int v64; // [esp+1Ch] [ebp-34h]
  int v65; // [esp+20h] [ebp-30h]
  char v66; // [esp+20h] [ebp-30h]
  signed int v67; // [esp+24h] [ebp-2Ch]
  int v68; // [esp+28h] [ebp-28h]
  char v69; // [esp+28h] [ebp-28h]
  int v70; // [esp+28h] [ebp-28h]
  int v71; // [esp+2Ch] [ebp-24h]
  unsigned int v72; // [esp+2Ch] [ebp-24h]
  int v73; // [esp+30h] [ebp-20h]
  int v74; // [esp+30h] [ebp-20h]
  int v75; // [esp+30h] [ebp-20h]
  int v76; // [esp+30h] [ebp-20h]
  int v77; // [esp+30h] [ebp-20h]
  int v78; // [esp+34h] [ebp-1Ch]
  int v79; // [esp+38h] [ebp-18h]
  int v80; // [esp+3Ch] [ebp-14h]
  int v81; // [esp+40h] [ebp-10h]
  int v82; // [esp+44h] [ebp-Ch]
  int v83; // [esp+48h] [ebp-8h]

  v2 = 0;
  v3 = a2;
  v56 = a1[5] & 0x8000;
  v4 = (a1[5] & 0x7FFF) - 0x3FFF;
  v81 = *(a1 + 3);
  v82 = *(a1 + 1);
  v73 = v4;
  v83 = *a1 << 16;
  if ( v4 == -16383 )
  {
    v5 = 0;
    v6 = 0;
    while ( !*(&v81 + v6) )
    {
      if ( ++v6 >= 3 )
        goto LABEL_84;
    }
    v81 = 0;
    v82 = 0;
    v83 = 0;
  }
  else
  {
    v71 = v4;
    v78 = v81;
    v62 = dword_12E2588 - 1;
    v67 = 0;
    v79 = v82;
    v80 = v83;
    v7 = dword_12E2588 / 32;
    v57 = dword_12E2588 / 32;
    v65 = 31 - dword_12E2588 % 32;
    v8 = v65;
    if ( (1 << v65) & *(&v81 + dword_12E2588 / 32) )
    {
      for ( i = (~(-1 << v65) & *(&v81 + v7)) == 0; i; i = *(&v81 + v7) == 0 )
      {
        if ( ++v7 >= 3 )
          goto LABEL_24;
      }
      v10 = v62 / 32;
      v67 = 0;
      v59 = 1 << (31 - v62 % 32);
      v11 = *(&v81 + v62 / 32);
      v12 = v11 + v59 < v11;
      v13 = v11 + v59;
      v14 = 0;
      if ( v12 || v13 < v59 )
      {
        v14 = 1;
        v67 = 1;
      }
      *(&v81 + v10) = v13;
      for ( j = v10 - 1; j >= 0; *(&v81 + j--) = v17 )
      {
        if ( !v14 )
          break;
        v16 = *(&v81 + j);
        v14 = 0;
        v67 = 0;
        v12 = v16 + 1 < v16;
        v17 = v16 + 1;
        if ( v12 || v17 < 1 )
        {
          v14 = 1;
          v67 = 1;
        }
      }
      v8 = v65;
LABEL_24:
      v7 = v57;
    }
    *(&v81 + v7) &= -1 << v8;
    if ( v7 + 1 < 3 )
      memset(&v81 + v7 + 1, 0, 4 * (3 - (v7 + 1)));
    v18 = v73;
    if ( v67 )
      v18 = v73 + 1;
    if ( v18 >= dword_12E2584 - dword_12E2588 )
    {
      if ( v18 > dword_12E2584 )
      {
        if ( v18 < dword_12E2580 )
        {
          v81 &= 0x7FFFFFFFu;
          v61 = v18 + dword_12E2594;
          v70 = dword_12E258C / 32;
          v48 = dword_12E258C % 32;
          v77 = 0;
          v49 = 0;
          do
          {
            v50 = *(&v81 + v49);
            *(&v81 + v49++) = v77 | (v50 >> v48);
            v77 = (~(-1 << v48) & v50) << (32 - v48);
          }
          while ( v49 < 3 );
          v5 = v61;
          v51 = &v83 - v70;
          v2 = 0;
          v52 = 2;
          do
          {
            if ( v52 < v70 )
              *(&v81 + v52) = 0;
            else
              *(&v81 + v52) = *v51;
            --v51;
            --v52;
          }
          while ( v52 >= 0 );
        }
        else
        {
          v82 = 0;
          v83 = 0;
          v81 = 2147483648;
          v64 = dword_12E258C / 32;
          v41 = dword_12E258C % 32;
          v60 = dword_12E258C % 32;
          v76 = 0;
          v42 = ~(-1 << dword_12E258C % 32);
          v69 = 32 - dword_12E258C % 32;
          do
          {
            v43 = *(&v81 + v2);
            v44 = v43;
            v45 = v76 | (v43 >> v41);
            LOBYTE(v41) = v60;
            *(&v81 + v2++) = v45;
            v76 = (v42 & v44) << v69;
          }
          while ( v2 < 3 );
          v46 = &v83 - v64;
          v47 = 2;
          do
          {
            if ( v47 < v64 )
              *(&v81 + v47) = 0;
            else
              *(&v81 + v47) = *v46;
            --v46;
            --v47;
          }
          while ( v47 >= 0 );
          v5 = dword_12E2580 + dword_12E2594;
          v2 = 1;
        }
        goto LABEL_83;
      }
      v81 = v78;
      v82 = v79;
      v58 = (dword_12E2584 - v71) / 32;
      v83 = v80;
      v19 = (dword_12E2584 - v71) % 32;
      v74 = 0;
      do
      {
        v20 = *(&v81 + v2);
        *(&v81 + v2++) = v74 | (v20 >> v19);
        v74 = (~(-1 << v19) & v20) << (32 - v19);
      }
      while ( v2 < 3 );
      v21 = &v83 - v58;
      v22 = v58;
      v23 = 2;
      do
      {
        if ( v23 < v22 )
        {
          *(&v81 + v23) = 0;
        }
        else
        {
          *(&v81 + v23) = *v21;
          v22 = v58;
        }
        --v21;
        --v23;
      }
      while ( v23 >= 0 );
      v24 = (v62 + 1) / 32;
      v25 = (v62 + 1) % 32;
      v66 = 31 - v25;
      v26 = 31 - v25;
      if ( (1 << v26) & *(&v81 + v24) )
      {
        for ( k = (~(-1 << v26) & *(&v81 + v24)) == 0; k; k = *(&v81 + v24) == 0 )
        {
          if ( ++v24 >= 3 )
            goto LABEL_56;
        }
        v28 = v62 / 32;
        v29 = *(&v81 + v62 / 32);
        v30 = 0;
        v72 = 1 << (31 - v62 % 32);
        v12 = v29 + v72 < v29;
        v31 = v29 + v72;
        if ( v12 || v31 < v72 )
          v30 = 1;
        *(&v81 + v28) = v31;
        for ( l = v28 - 1; l >= 0; *(&v81 + l--) = v34 )
        {
          if ( !v30 )
            break;
          v33 = *(&v81 + l);
          v30 = 0;
          v12 = v33 + 1 < v33;
          v34 = v33 + 1;
          if ( v12 || v34 < 1 )
            v30 = 1;
        }
        v26 = v66;
LABEL_56:
        v24 = (v62 + 1) / 32;
      }
      *(&v81 + v24) &= -1 << v26;
      v35 = v24 + 1;
      if ( v35 < 3 )
        memset(&v81 + v35, 0, 4 * (3 - v35));
      v68 = (dword_12E258C + 1) / 32;
      v36 = (dword_12E258C + 1) % 32;
      v37 = 0;
      v75 = 0;
      v63 = 0;
      do
      {
        v38 = *(&v81 + v37);
        *(&v81 + v63) = v75 | (v38 >> v36);
        v75 = (~(-1 << v36) & v38) << (32 - v36);
        v37 = v63 + 1;
        v63 = v37;
      }
      while ( v37 < 3 );
      v39 = &v83 - v68;
      v40 = 2;
      do
      {
        if ( v40 < v68 )
          *(&v81 + v40) = 0;
        else
          *(&v81 + v40) = *v39;
        --v39;
        --v40;
      }
      while ( v40 >= 0 );
    }
    else
    {
      v81 = 0;
      v82 = 0;
      v83 = 0;
    }
    v5 = 0;
  }
  v2 = 2;
LABEL_83:
  v3 = a2;
LABEL_84:
  v53 = v81 | (v56 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_12E258C));
  if ( dword_12E2590 == 64 )
  {
    v54 = v82;
    v3[1] = v53;
    *v3 = v54;
  }
  else if ( dword_12E2590 == 32 )
  {
    *v3 = v53;
  }
  return v2;
}
// 12E2580: using guessed type int dword_12E2580;
// 12E2584: using guessed type int dword_12E2584;
// 12E2588: using guessed type int dword_12E2588;
// 12E258C: using guessed type int dword_12E258C;
// 12E2590: using guessed type int dword_12E2590;
// 12E2594: using guessed type int dword_12E2594;

//----- (012A1B17) --------------------------------------------------------
signed int __cdecl sub_12A1B17(_DWORD *a1)
{
  signed int result; // eax

  if ( a1 )
  {
    *a1 = dword_13069A4;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 22;
  }
  return result;
}
// 128F859: using guessed type int _invalid_parameter_noinfo(void);
// 13069A4: using guessed type int dword_13069A4;

//----- (012A1C0E) --------------------------------------------------------
HANDLE sub_12A1C0E()
{
  HANDLE result; // eax

  result = hConsoleOutput;
  if ( hConsoleOutput != -1 && hConsoleOutput != -2 )
    result = CloseHandle(hConsoleOutput);
  return result;
}

//----- (012A3624) --------------------------------------------------------
int __cdecl SEH_402480(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A37AA) --------------------------------------------------------
int __cdecl SEH_402D60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A37E9) --------------------------------------------------------
int __cdecl SEH_403440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3810) --------------------------------------------------------
int __cdecl SEH_4035A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3830) --------------------------------------------------------
int __cdecl SEH_4038F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3869) --------------------------------------------------------
int __cdecl SEH_4314F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3898) --------------------------------------------------------
int __cdecl SEH_403D40(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A38CB) --------------------------------------------------------
int __cdecl SEH_404130(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3910) --------------------------------------------------------
int __cdecl SEH_404890(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3950) --------------------------------------------------------
int __cdecl SEH_404AC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3978) --------------------------------------------------------
int __cdecl SEH_404F20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A39C1) --------------------------------------------------------
int __cdecl SEH_404FB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3A00) --------------------------------------------------------
int __cdecl SEH_4052B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3A30) --------------------------------------------------------
int __cdecl SEH_405520(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3A79) --------------------------------------------------------
int __cdecl SEH_405C70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3AAB) --------------------------------------------------------
int __cdecl SEH_406440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3AF0) --------------------------------------------------------
int __cdecl SEH_406090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3B50) --------------------------------------------------------
int __cdecl SEH_4067A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3B78) --------------------------------------------------------
int __cdecl SEH_406CC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3BB8) --------------------------------------------------------
int __cdecl SEH_406DD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3C38) --------------------------------------------------------
int __cdecl SEH_4070E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3C81) --------------------------------------------------------
int __cdecl SEH_407CC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3CD1) --------------------------------------------------------
int __cdecl SEH_4085A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A3E47) --------------------------------------------------------
int __cdecl SEH_4087A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A403E) --------------------------------------------------------
int __cdecl SEH_409270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A420F) --------------------------------------------------------
int __cdecl SEH_409B70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4238) --------------------------------------------------------
int __cdecl SEH_425730(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A43B3) --------------------------------------------------------
int __cdecl SEH_40AB10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4910) --------------------------------------------------------
int __cdecl SEH_40B220(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A49A0) --------------------------------------------------------
int __cdecl SEH_40F2D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A49D8) --------------------------------------------------------
int __cdecl SEH_40F610(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4A00) --------------------------------------------------------
int __cdecl SEH_40F9D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4A20) --------------------------------------------------------
int __cdecl SEH_40FD00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4A40) --------------------------------------------------------
int __cdecl SEH_40FDF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4A92) --------------------------------------------------------
int __cdecl SEH_410460(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4C1A) --------------------------------------------------------
int __cdecl SEH_410790(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4C48) --------------------------------------------------------
int __cdecl SEH_411150(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A4E28) --------------------------------------------------------
int __cdecl SEH_411610(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5006) --------------------------------------------------------
int __cdecl SEH_412090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5187) --------------------------------------------------------
int __cdecl SEH_413160(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5307) --------------------------------------------------------
int __cdecl SEH_413A80(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5509) --------------------------------------------------------
int __cdecl SEH_414200(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A580D) --------------------------------------------------------
int __cdecl SEH_414FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5A24) --------------------------------------------------------
int __cdecl SEH_415FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5AE0) --------------------------------------------------------
int __cdecl SEH_416A10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5B20) --------------------------------------------------------
int __cdecl SEH_416E10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5C9F) --------------------------------------------------------
int __cdecl SEH_417000(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5E4B) --------------------------------------------------------
int __cdecl SEH_4177C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A5E78) --------------------------------------------------------
int __cdecl SEH_417FE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6013) --------------------------------------------------------
int __cdecl SEH_418050(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6048) --------------------------------------------------------
int __cdecl SEH_418A90(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A61C7) --------------------------------------------------------
int __cdecl SEH_418C20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A61F8) --------------------------------------------------------
int __cdecl SEH_4193C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6399) --------------------------------------------------------
int __cdecl SEH_419580(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6533) --------------------------------------------------------
int __cdecl SEH_41A120(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6568) --------------------------------------------------------
int __cdecl SEH_41AD20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A659B) --------------------------------------------------------
int __cdecl SEH_45ED60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6802) --------------------------------------------------------
int __cdecl SEH_41B1A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A699B) --------------------------------------------------------
int __cdecl SEH_41D790(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6BBC) --------------------------------------------------------
int __cdecl SEH_41E3A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6BF8) --------------------------------------------------------
int __cdecl SEH_41EFE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6C38) --------------------------------------------------------
int __cdecl SEH_41F0E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A6F3B) --------------------------------------------------------
int __cdecl SEH_41F260(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A704E) --------------------------------------------------------
int __cdecl SEH_420760(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A70E8) --------------------------------------------------------
int __cdecl SEH_420EA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7120) --------------------------------------------------------
int __cdecl SEH_4211B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A714A) --------------------------------------------------------
int __cdecl SEH_4013A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7178) --------------------------------------------------------
int __cdecl SEH_421590(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A72D4) --------------------------------------------------------
int __cdecl SEH_421860(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7308) --------------------------------------------------------
int __cdecl SEH_422060(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A747C) --------------------------------------------------------
int __cdecl SEH_422110(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A764A) --------------------------------------------------------
int __cdecl SEH_4227D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A782A) --------------------------------------------------------
int __cdecl SEH_423190(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7860) --------------------------------------------------------
int __cdecl SEH_424040(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7880) --------------------------------------------------------
int __cdecl SEH_424270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A78A0) --------------------------------------------------------
int __cdecl SEH_4244A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A78C0) --------------------------------------------------------
int __cdecl SEH_4245C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A78FE) --------------------------------------------------------
int __cdecl SEH_424740(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7938) --------------------------------------------------------
int __cdecl SEH_424920(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7998) --------------------------------------------------------
int __cdecl SEH_424FE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A79D0) --------------------------------------------------------
int __cdecl SEH_425120(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A79F8) --------------------------------------------------------
int __cdecl SEH_425350(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7A28) --------------------------------------------------------
int __cdecl SEH_425440(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7A58) --------------------------------------------------------
int __cdecl SEH_425850(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7A99) --------------------------------------------------------
int __cdecl SEH_425940(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7AC8) --------------------------------------------------------
int __cdecl SEH_425AB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7BBA) --------------------------------------------------------
int __cdecl SEH_425D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7BF8) --------------------------------------------------------
int __cdecl SEH_426830(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7C28) --------------------------------------------------------
int __cdecl SEH_4269A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7C50) --------------------------------------------------------
int __cdecl SEH_426BB0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7C78) --------------------------------------------------------
int __cdecl SEH_427AC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7CAB) --------------------------------------------------------
int __cdecl SEH_45E760(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7CE6) --------------------------------------------------------
int __cdecl SEH_428730(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7D45) --------------------------------------------------------
int __cdecl SEH_428970(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7D80) --------------------------------------------------------
int __cdecl SEH_429580(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7DA8) --------------------------------------------------------
int __cdecl SEH_42A1F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7DDB) --------------------------------------------------------
int __cdecl SEH_42FAF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7E10) --------------------------------------------------------
int __cdecl SEH_431240(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7E60) --------------------------------------------------------
int __cdecl SEH_431560(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7EDE) --------------------------------------------------------
int __cdecl SEH_4318A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A7F83) --------------------------------------------------------
int __cdecl SEH_431BC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8191) --------------------------------------------------------
int __cdecl SEH_431FC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A825C) --------------------------------------------------------
int __cdecl SEH_4337E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A82B1) --------------------------------------------------------
int __cdecl SEH_434530(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A82E9) --------------------------------------------------------
int __cdecl SEH_434810(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8320) --------------------------------------------------------
int __cdecl SEH_434AA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8358) --------------------------------------------------------
int __cdecl SEH_434F00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A85A0) --------------------------------------------------------
int __cdecl SEH_4355A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A85D0) --------------------------------------------------------
int __cdecl SEH_437DF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A85F8) --------------------------------------------------------
int __cdecl SEH_438150(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A866A) --------------------------------------------------------
int __cdecl SEH_438360(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8698) --------------------------------------------------------
int __cdecl SEH_438570(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A86C8) --------------------------------------------------------
int __cdecl SEH_438630(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8735) --------------------------------------------------------
int __cdecl SEH_438CE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A876B) --------------------------------------------------------
int __cdecl SEH_439090(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A87A0) --------------------------------------------------------
int __cdecl SEH_4391F0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A87D0) --------------------------------------------------------
int __cdecl SEH_4392D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A87F8) --------------------------------------------------------
int __cdecl SEH_439D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8828) --------------------------------------------------------
int __cdecl SEH_439E70(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8850) --------------------------------------------------------
int __cdecl SEH_43B100(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8889) --------------------------------------------------------
int __cdecl SEH_43B460(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A88D0) --------------------------------------------------------
int __cdecl SEH_43B780(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A894F) --------------------------------------------------------
int __cdecl SEH_43BF00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A89A4) --------------------------------------------------------
int __cdecl SEH_43D080(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A89C8) --------------------------------------------------------
int __cdecl SEH_43D1D0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8A19) --------------------------------------------------------
int __cdecl SEH_43D3B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8A5E) --------------------------------------------------------
int __cdecl SEH_43D590(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8AD5) --------------------------------------------------------
int __cdecl SEH_43D670(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8B03) --------------------------------------------------------
int __cdecl SEH_43DF10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8B3E) --------------------------------------------------------
int __cdecl SEH_43E1A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8B7B) --------------------------------------------------------
int __cdecl SEH_43EAD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8BAB) --------------------------------------------------------
int __cdecl SEH_43EBA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8BE0) --------------------------------------------------------
int __cdecl SEH_43EEA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8C75) --------------------------------------------------------
int __cdecl SEH_43F0A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8CA8) --------------------------------------------------------
int __cdecl SEH_43FFF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8CD8) --------------------------------------------------------
int __cdecl SEH_469E00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8D16) --------------------------------------------------------
int __cdecl SEH_445F60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8EBE) --------------------------------------------------------
int __cdecl SEH_446270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A8FC9) --------------------------------------------------------
int __cdecl SEH_451E50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A902D) --------------------------------------------------------
int __cdecl SEH_4526B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9081) --------------------------------------------------------
int __cdecl SEH_457640(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A90B1) --------------------------------------------------------
int __cdecl SEH_457740(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A90F6) --------------------------------------------------------
int __cdecl SEH_4577E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9138) --------------------------------------------------------
int __cdecl SEH_457DD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A91C3) --------------------------------------------------------
int __cdecl SEH_4580C0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A91F0) --------------------------------------------------------
int __cdecl SEH_458AE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9218) --------------------------------------------------------
int __cdecl SEH_458C80(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9248) --------------------------------------------------------
int __cdecl SEH_458D10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A92D3) --------------------------------------------------------
int __cdecl SEH_458E20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A930B) --------------------------------------------------------
int __cdecl SEH_459500(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A93FF) --------------------------------------------------------
int __cdecl SEH_459C50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9452) --------------------------------------------------------
int __cdecl SEH_45A570(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9504) --------------------------------------------------------
int __cdecl SEH_45B0A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A954B) --------------------------------------------------------
int __cdecl SEH_45B680(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9580) --------------------------------------------------------
int __cdecl SEH_45B8A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A95A0) --------------------------------------------------------
int __cdecl SEH_45C840(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A95CB) --------------------------------------------------------
int __cdecl SEH_45EE00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A964C) --------------------------------------------------------
int __cdecl SEH_45D510(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A96B2) --------------------------------------------------------
int __cdecl SEH_45DCE0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A96F9) --------------------------------------------------------
int __cdecl SEH_45E4E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A972B) --------------------------------------------------------
int __cdecl SEH_45E8B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9758) --------------------------------------------------------
int __cdecl SEH_466900(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9780) --------------------------------------------------------
int __cdecl SEH_469AF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A97A0) --------------------------------------------------------
int __cdecl SEH_469C10(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A97C8) --------------------------------------------------------
int __cdecl SEH_469EA0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A97FE) --------------------------------------------------------
int __cdecl SEH_46A670(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A983E) --------------------------------------------------------
int __cdecl SEH_46ADD0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A987B) --------------------------------------------------------
int __cdecl SEH_46B930(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A98D1) --------------------------------------------------------
int __cdecl SEH_46BC50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9908) --------------------------------------------------------
int __cdecl SEH_46C350(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9938) --------------------------------------------------------
int __cdecl SEH_46DAF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9976) --------------------------------------------------------
int __cdecl SEH_46DD60(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A99B3) --------------------------------------------------------
int __cdecl SEH_46EC30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9A01) --------------------------------------------------------
int __cdecl SEH_4703E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9A3B) --------------------------------------------------------
int __cdecl SEH_4723A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9A6E) --------------------------------------------------------
int __cdecl SEH_472810(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9B48) --------------------------------------------------------
int __cdecl SEH_472C20(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9B7E) --------------------------------------------------------
int __cdecl SEH_473C50(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9BBB) --------------------------------------------------------
int __cdecl SEH_474990(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9BEE) --------------------------------------------------------
int __cdecl SEH_4766A0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9C2E) --------------------------------------------------------
int __cdecl SEH_477710(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9C6E) --------------------------------------------------------
int __cdecl SEH_478E00(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9CAB) --------------------------------------------------------
int __cdecl SEH_479A30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9CEE) --------------------------------------------------------
int __cdecl SEH_47ACF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9D2B) --------------------------------------------------------
int __cdecl SEH_47D5B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9D70) --------------------------------------------------------
int __cdecl SEH_4808E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9D9E) --------------------------------------------------------
int __cdecl SEH_4809B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9DDE) --------------------------------------------------------
int __cdecl SEH_4818B0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9E1E) --------------------------------------------------------
int __cdecl SEH_482010(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9E5E) --------------------------------------------------------
int __cdecl SEH_4825E0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9E9B) --------------------------------------------------------
int __cdecl SEH_483260(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9ECE) --------------------------------------------------------
int __cdecl SEH_483AF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9F3D) --------------------------------------------------------
int __cdecl SEH_483FC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9F70) --------------------------------------------------------
int __cdecl SEH_491650(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9F9A) --------------------------------------------------------
int __cdecl SEH_401FF0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012A9FD0) --------------------------------------------------------
int __cdecl SEH_491C30(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012AA003) --------------------------------------------------------
int __cdecl SEH_491EC0(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012AA039) --------------------------------------------------------
int __cdecl SEH_492230(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012AA070) --------------------------------------------------------
int __cdecl SEH_494270(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012AA093) --------------------------------------------------------
int __cdecl sub_12AA093(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012AA0AE) --------------------------------------------------------
int __cdecl sub_12AA0AE(EXCEPTION_RECORD *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4)
{
  return __CxxFrameHandler3(a1, a2, a3, a4);
}
// 1285CD1: using guessed type _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, struct _CONTEXT *, void *);

//----- (012AA0D0) --------------------------------------------------------
void __cdecl sub_12AA0D0()
{
  `eh vector destructor iterator'(dword_12E4900, 0x28u, 20, sub_11F3850);
}
// 12E4900: using guessed type int dword_12E4900[200];

//----- (012AA0F0) --------------------------------------------------------
void __thiscall sub_12AA0F0(void *this)
{
  void *v1; // [esp-2h] [ebp-4h]

  v1 = this;
  if ( dword_12E4C20 )
  {
    nullsub_1(dword_12E4C20, dword_12E4C24);
    ATL::CAtlStringMgr::Clone(&v1 + 3);
    j__free(dword_12E4C20);
    dword_12E4C20 = 0;
    dword_12E4C24 = 0;
    dword_12E4C28 = 0;
  }
}
// 11FFB30: using guessed type _DWORD __stdcall nullsub_1(_DWORD, _DWORD);
// 12E4C24: using guessed type int dword_12E4C24;
// 12E4C28: using guessed type int dword_12E4C28;

//----- (012AA150) --------------------------------------------------------
void __cdecl sub_12AA150()
{
  free(gpszAutorunsDesc);
}

//----- (012AA160) --------------------------------------------------------
void __cdecl sub_12AA160()
{
  void *v0; // esi

  v0 = dword_12E48F8;
  if ( dword_12E48F8 )
  {
    if ( !InterlockedDecrement(dword_12E48F8 + 2) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 1) )
      {
        j_j__free(*(v0 + 1));
        *(v0 + 1) = 0;
      }
      j__free(v0);
    }
    dword_12E48F8 = 0;
  }
}

//----- (012AA1C0) --------------------------------------------------------
void __cdecl sub_12AA1C0()
{
  void *v0; // esi

  v0 = dword_12E48F4;
  if ( dword_12E48F4 )
  {
    if ( !InterlockedDecrement(dword_12E48F4 + 2) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 1) )
      {
        j_j__free(*(v0 + 1));
        *(v0 + 1) = 0;
      }
      j__free(v0);
    }
    dword_12E48F4 = 0;
  }
}

//----- (012AA220) --------------------------------------------------------
void __cdecl sub_12AA220()
{
  free(dword_12E48E4);
}

//----- (012AA230) --------------------------------------------------------
void __cdecl sub_12AA230()
{
  free(gEnvPathName);
}

//----- (012AA240) --------------------------------------------------------
void __cdecl sub_12AA240()
{
  free(dword_12E48FC);
}

//----- (012AA250) --------------------------------------------------------
void __cdecl sub_12AA250()
{
  char *v0; // esi
  int v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1200050(&dword_12E4C30, &v1, *dword_12E4C30, dword_12E4C30);
  v0 = dword_12E4C30;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AA2D0) --------------------------------------------------------
void __cdecl sub_12AA2D0()
{
  free(dword_12E48F0);
}

//----- (012AA2E0) --------------------------------------------------------
void __cdecl sub_12AA2E0()
{
  free(dword_12E4C44);
}

//----- (012AA2F0) --------------------------------------------------------
void __cdecl sub_12AA2F0()
{
  free(dword_12E4C54);
}

//----- (012AA300) --------------------------------------------------------
void __cdecl sub_12AA300()
{
  free(dword_12E4C50);
}

//----- (012AA310) --------------------------------------------------------
void __cdecl sub_12AA310()
{
  sub_12113D0(&dword_12E4CD0);
}
// 12E4CD0: using guessed type int dword_12E4CD0;

//----- (012AA320) --------------------------------------------------------
void __cdecl sub_12AA320()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *dword_12E4CFC;
  *dword_12E4CFC = dword_12E4CFC;
  *(dword_12E4CFC + 1) = dword_12E4CFC;
  v1 = dword_12E4CFC;
  dword_12E4D00 = 0;
  if ( v0 != dword_12E4CFC )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = dword_12E4CFC;
      v0 = v2;
    }
    while ( v2 != dword_12E4CFC );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 12E4D00: using guessed type int dword_12E4D00;

//----- (012AA3F0) --------------------------------------------------------
void __cdecl sub_12AA3F0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *dword_12E4CF4;
  *dword_12E4CF4 = dword_12E4CF4;
  *(dword_12E4CF4 + 1) = dword_12E4CF4;
  v1 = dword_12E4CF4;
  dword_12E4CF8 = 0;
  if ( v0 != dword_12E4CF4 )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = dword_12E4CF4;
      v0 = v2;
    }
    while ( v2 != dword_12E4CF4 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 12E4CF8: using guessed type int dword_12E4CF8;

//----- (012AA4C0) --------------------------------------------------------
void __cdecl sub_12AA4C0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *dword_12E4D04;
  *dword_12E4D04 = dword_12E4D04;
  *(dword_12E4D04 + 1) = dword_12E4D04;
  v1 = dword_12E4D04;
  dword_12E4D08 = 0;
  if ( v0 != dword_12E4D04 )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = dword_12E4D04;
      v0 = v2;
    }
    while ( v2 != dword_12E4D04 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 12E4D08: using guessed type int dword_12E4D08;

//----- (012AA590) --------------------------------------------------------
void __cdecl sub_12AA590()
{
  char *v0; // esi
  int v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1282C10(&v1, *stru_12E4CEC, stru_12E4CEC);
  v0 = stru_12E4CEC;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AA610) --------------------------------------------------------
void __cdecl sub_12AA610()
{
  off_12DAA3C[0] = &std::error_category::`vftable';
}
// 12B2D74: using guessed type void *std::error_category::`vftable';
// 12DAA3C: using guessed type int (__thiscall **off_12DAA3C[3])(void *, char);

//----- (012AA620) --------------------------------------------------------
void __cdecl sub_12AA620()
{
  off_12DAA40[0] = &std::error_category::`vftable';
}
// 12B2D74: using guessed type void *std::error_category::`vftable';
// 12DAA40: using guessed type int (__thiscall **off_12DAA40[2])(void *, char);

//----- (012AA630) --------------------------------------------------------
void __cdecl sub_12AA630()
{
  off_12DAA44 = &std::error_category::`vftable';
}
// 12B2D74: using guessed type void *std::error_category::`vftable';
// 12DAA44: using guessed type int (__thiscall **off_12DAA44)(void *, char);

//----- (012AA640) --------------------------------------------------------
void __cdecl sub_12AA640()
{
  free(dword_12E4D30);
  free(dword_12E4D2C);
}

//----- (012AA660) --------------------------------------------------------
void __cdecl sub_12AA660()
{
  free(dword_12E4D24);
  free(dword_12E4D20);
}

//----- (012AA680) --------------------------------------------------------
void __cdecl sub_12AA680()
{
  char *v0; // esi
  char v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1217560(&dword_12E4D14, &v1, *dword_12E4D14, dword_12E4D14);
  v0 = dword_12E4D14;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AA700) --------------------------------------------------------
void __cdecl sub_12AA700()
{
  if ( ghuxthemeModule )
    FreeLibrary(ghuxthemeModule);
}

//----- (012AA720) --------------------------------------------------------
void __cdecl sub_12AA720()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *gList;
  *gList = gList;
  *(gList + 1) = gList;
  v1 = gList;
  dword_12E4DF0 = 0;
  if ( v0 != gList )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gList;
      v0 = v2;
    }
    while ( v2 != gList );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 12E4DF0: using guessed type int dword_12E4DF0;

//----- (012AA7F0) --------------------------------------------------------
void __cdecl sub_12AA7F0()
{
  gWin32Heap.vtptr = &ATL::CWin32Heap::`vftable';
  if ( LOBYTE(gWin32Heap.m_bOwnHeap) )
  {
    if ( gWin32Heap.m_hHeap )
      HeapDestroy(gWin32Heap.m_hHeap);
  }
}
// 12BC4F8: using guessed type void *ATL::CWin32Heap::`vftable';

//----- (012AA820) --------------------------------------------------------
void __cdecl sub_12AA820()
{
  `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr.vtptr = &ATL::CAtlStringMgr::`vftable';
  byte_12E4DF4 = 0;
}
// 12BC510: using guessed type void *ATL::CAtlStringMgr::`vftable';
// 12E4DF4: using guessed type char byte_12E4DF4;

//----- (012AA840) --------------------------------------------------------
void __cdecl sub_12AA840()
{
  CList *v0; // edi
  CList *v1; // ebx
  CList *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = gAdapterList->Prev;
  gAdapterList->Prev = gAdapterList;
  gAdapterList->Next = gAdapterList;
  v1 = gAdapterList;
  *(&gAdapterList + 1) = 0;
  if ( v0 != gAdapterList )
  {
    do
    {
      v2 = v0->Prev;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(&v0->Next);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(&v0->field_8);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = gAdapterList;
      v0 = v2;
    }
    while ( v2 != gAdapterList );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(&v1->Next);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AA910) --------------------------------------------------------
void __cdecl sub_12AA910()
{
  CComBSTR *v0; // esi

  v0 = gppComBSTR2;
  if ( gppComBSTR2 )
  {
    if ( !InterlockedDecrement(&gppComBSTR2->Length) && v0 )
    {
      if ( v0->bstr )
      {
        SysFreeString(v0->bstr);
        v0->bstr = 0;
      }
      if ( v0->hKey )
      {
        j_j__free(v0->hKey);
        v0->hKey = 0;
      }
      j__free(v0);
    }
    gppComBSTR2 = 0;
  }
}

//----- (012AA970) --------------------------------------------------------
void __cdecl sub_12AA970()
{
  CComBSTR *v0; // esi

  v0 = gppComBSTR;
  if ( gppComBSTR )
  {
    if ( !InterlockedDecrement(&gppComBSTR->Length) && v0 )
    {
      if ( v0->bstr )
      {
        SysFreeString(v0->bstr);
        v0->bstr = 0;
      }
      if ( v0->hKey )
      {
        j_j__free(v0->hKey);
        v0->hKey = 0;
      }
      j__free(v0);
    }
    gppComBSTR = 0;
  }
}

//----- (012AA9D0) --------------------------------------------------------
void __cdecl sub_12AA9D0()
{
  sub_1259F70(&dword_12EA0C4);
}
// 12EA0C4: using guessed type int dword_12EA0C4;

//----- (012AA9E0) --------------------------------------------------------
void __cdecl sub_12AA9E0()
{
  sub_1232C80(&Data);
}

//----- (012AA9F0) --------------------------------------------------------
void __cdecl sub_12AA9F0()
{
  CComBSTR *v0; // esi

  v0 = ppComBSTR2;
  if ( ppComBSTR2 )
  {
    if ( !InterlockedDecrement(&ppComBSTR2->Length) && v0 )
    {
      if ( v0->bstr )
      {
        SysFreeString(v0->bstr);
        v0->bstr = 0;
      }
      if ( v0->hKey )
      {
        j_j__free(v0->hKey);
        v0->hKey = 0;
      }
      j__free(v0);
    }
    ppComBSTR2 = 0;
  }
}

//----- (012AAA50) --------------------------------------------------------
void __cdecl sub_12AAA50()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *dword_12EA0EC;
  *dword_12EA0EC = dword_12EA0EC;
  *(dword_12EA0EC + 1) = dword_12EA0EC;
  v1 = dword_12EA0EC;
  dword_12EA0F0 = 0;
  if ( v0 != dword_12EA0EC )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = dword_12EA0EC;
      v0 = v2;
    }
    while ( v2 != dword_12EA0EC );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);
// 12EA0F0: using guessed type int dword_12EA0F0;

//----- (012AAB20) --------------------------------------------------------
void __cdecl sub_12AAB20()
{
  CSysProcItem *v0; // esi
  CSysProcItem *a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1275510(&Right, &a2, Right._Left->_Left, Right._Left);
  v0 = Right._Left;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AABA0) --------------------------------------------------------
void __cdecl sub_12AABA0()
{
  int v0; // esi

  v0 = gptrDiskGraphData.Name;
  if ( gptrDiskGraphData.Name )
  {
    if ( !InterlockedDecrement((gptrDiskGraphData.Name + 8)) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 4) )
      {
        j_j__free(*(v0 + 4));
        *(v0 + 4) = 0;
      }
      j__free(v0);
    }
    gptrDiskGraphData.Name = 0;
  }
}

//----- (012AAC00) --------------------------------------------------------
void __cdecl sub_12AAC00()
{
  int v0; // esi

  v0 = gptrIOGraphData__3UCSimpleGraphData__A.Name;
  if ( gptrIOGraphData__3UCSimpleGraphData__A.Name )
  {
    if ( !InterlockedDecrement((gptrIOGraphData__3UCSimpleGraphData__A.Name + 8)) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 4) )
      {
        j_j__free(*(v0 + 4));
        *(v0 + 4) = 0;
      }
      j__free(v0);
    }
    gptrIOGraphData__3UCSimpleGraphData__A.Name = 0;
  }
}

//----- (012AAC60) --------------------------------------------------------
void __cdecl sub_12AAC60()
{
  int v0; // esi

  v0 = gptrNetGraphData.Name;
  if ( gptrNetGraphData.Name )
  {
    if ( !InterlockedDecrement((gptrNetGraphData.Name + 8)) && v0 )
    {
      if ( *v0 )
      {
        SysFreeString(*v0);
        *v0 = 0;
      }
      if ( *(v0 + 4) )
      {
        j_j__free(*(v0 + 4));
        *(v0 + 4) = 0;
      }
      j__free(v0);
    }
    gptrNetGraphData.Name = 0;
  }
}

//----- (012AACC0) --------------------------------------------------------
void __cdecl sub_12AACC0()
{
  CSysProcItem *v0; // esi
  CSysProcItem *a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1275510(&dword_12FBA78, &a2, dword_12FBA78._Left->_Left, dword_12FBA78._Left);
  v0 = dword_12FBA78._Left;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AAD40) --------------------------------------------------------
void __cdecl sub_12AAD40()
{
  CSysProcItem *v0; // esi
  CSysProcItem *a2; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1275510(&dword_12FBA70, &a2, dword_12FBA70._Left->_Left, dword_12FBA70._Left);
  v0 = dword_12FBA70._Left;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Parent);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(&v0->_Right);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AADC0) --------------------------------------------------------
void __cdecl sub_12AADC0()
{
  if ( hdc )
    DeleteDC(hdc);
  if ( ghBitmapColor )
    DeleteObject(ghBitmapColor);
}

//----- (012AADF0) --------------------------------------------------------
void __cdecl sub_12AADF0()
{
  sub_12113D0(&gHttp);
}

//----- (012AAE00) --------------------------------------------------------
void __cdecl sub_12AAE00()
{
  CNode *v0; // edi
  CNode *v1; // ebx
  CNode *v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = theLIST2.Next->Next;
  theLIST2.Next->Next = theLIST2.Next;
  theLIST2.Next->Prev = theLIST2.Next;
  v1 = theLIST2.Next;
  theLIST2.Prev = 0;
  if ( v0 != theLIST2.Next )
  {
    do
    {
      v2 = v0->Next;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(&v0->Prev);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(&v0[1]);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = theLIST2.Next;
      v0 = v2;
    }
    while ( v2 != theLIST2.Next );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(&v1->Prev);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AAED0) --------------------------------------------------------
void __cdecl sub_12AAED0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *theLIST1;
  *theLIST1 = theLIST1;
  *(theLIST1 + 1) = theLIST1;
  v1 = theLIST1;
  *(&theLIST1 + 1) = 0;
  if ( v0 != theLIST1 )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = theLIST1;
      v0 = v2;
    }
    while ( v2 != theLIST1 );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AAFA0) --------------------------------------------------------
void __cdecl sub_12AAFA0()
{
  void **v0; // edi
  char *v1; // ebx
  void **v2; // esi
  char v3; // [esp+8h] [ebp-4h]
  char v4; // [esp+9h] [ebp-3h]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = *theLIST;
  *theLIST = theLIST;
  *(theLIST + 1) = theLIST;
  v1 = theLIST;
  *(&theLIST + 1) = 0;
  if ( v0 != theLIST )
  {
    do
    {
      v2 = *v0;
      ATL::CAtlStringMgr::Clone(&v6);
      nullsub_2(v0);
      ATL::CAtlStringMgr::Clone(&v5);
      nullsub_2(v0 + 1);
      ATL::CAtlStringMgr::Clone(&v4);
      nullsub_2(v0 + 2);
      ATL::CAtlStringMgr::Clone(&v3);
      j__free(v0);
      v1 = theLIST;
      v0 = v2;
    }
    while ( v2 != theLIST );
  }
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1);
  ATL::CAtlStringMgr::Clone(&v4);
  nullsub_2(v1 + 4);
  ATL::CAtlStringMgr::Clone(&v3);
  j__free(v1);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AB070) --------------------------------------------------------
void __cdecl sub_12AB070()
{
  char *v0; // esi
  int v1; // [esp+4h] [ebp-8h]
  char v2; // [esp+Bh] [ebp-1h]

  sub_1282C10(&v1, *theStringMAP, theStringMAP);
  v0 = theStringMAP;
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 4);
  ATL::CAtlStringMgr::Clone(&v2);
  nullsub_2(v0 + 8);
  ATL::CAtlStringMgr::Clone(&v2);
  j__free(v0);
}
// 1217A90: using guessed type _DWORD __stdcall nullsub_2(_DWORD);

//----- (012AB0F0) --------------------------------------------------------
void __cdecl sub_12AB0F0()
{
  VariantClear(&pvarg);
}

//----- (012AB0FC) --------------------------------------------------------
void __cdecl sub_12AB0FC()
{
  unknown_libname_5(&dword_13057D8);
}
// 1284714: using guessed type int __thiscall unknown_libname_5(_DWORD);
// 13057D8: using guessed type int dword_13057D8;

//----- (012AB106) --------------------------------------------------------
void __cdecl sub_12AB106()
{
  sub_1284B60(&dword_130585A);
}
// 130585A: using guessed type int dword_130585A;

//----- (012AB110) --------------------------------------------------------
void __cdecl sub_12AB110()
{
  sub_1228940(&dword_1305864);
}
// 1305864: using guessed type int dword_1305864;

//----- (012AB11A) --------------------------------------------------------
void __cdecl sub_12AB11A()
{
  sub_1284F5A(&unk_13058F3);
}

//----- (012AB124) --------------------------------------------------------
void __cdecl sub_12AB124()
{
  unknown_libname_5(&word_13058F0);
}
// 1284714: using guessed type int __thiscall unknown_libname_5(_DWORD);
// 13058F0: using guessed type __int16 word_13058F0;

//----- (012AB12E) --------------------------------------------------------
void __cdecl ATL::_dynamic_atexit_destructor_for___AtlBaseModule__()
{
  ATL::CAtlBaseModule::~CAtlBaseModule(&ATL::_AtlBaseModule);
}

#error "There were 1 decompilation failure(s) on 1650 function(s)"
